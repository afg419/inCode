\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Auto: A Todo GUI application with Auto (on GHCJS, etc.) \% Justin Le \% April
23, 2015

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html}{in
Code}}.}

Continuing along with
\href{http://blog.jle.im/entries/series/+all-about-auto}{All About Auto}, let's
look at another exciting and useful application of the
\emph{\href{http://hackage.haskell.org/package/auto}{auto}} library: GUI's.
We're going to look at the canonical "hello world" of GUI apps these days
-\/-\/- the todo app. We're going to be using the specs of
\href{http://todomvc.com/}{todoMVC} to build a todoMVC "candidate" that follows
the specs...and along the way see what \emph{auto} offers in its tools of
managing isolated state components and modeling GUI logic. We're really going to
be focusing on application logic -\/-\/- "control" and "model" -\/-\/- and not
looking too close on "views", which \emph{auto} doesn't quite try to offer and
where you can really pick your own view rendering system, making this adaptable
to really any platform -\/-\/- javascript/web, desktop, command line, etc.

A live version of our end-product
\href{https://mstksg.github.com/auto-examples/todo}{is hosted and online}.

This post does assume \emph{some} concepts from the
\href{https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md}{tutorial}...if
not all, then at least those in the
\href{http://blog.jle.im/entry/introducing-the-auto-library}{introductory post}
or the \href{https://github.com/mstksg/auto/blob/master/README.md}{README}. If
you ever find yourself thinking that these concepts are completely new and
crazy, you might want to try looking through the
\href{https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md}{tutorial}
or \href{http://hackage.haskell.org/package/auto}{docs} to refresh your mind. As
always, comments are welcome, and I'm also usually on \emph{\#haskell-auto} as
\emph{jle`}, and also on \href{https://twitter.com/mstk}{twitter}

(Fair warning...this is not quite a "ghcjs tutorial", if that's what you're
looking for; it's an auto tutorial that uses some rudimentary ghcjs. Hopefully
you can learn from that too!)

\section{Overall Layout}

At the highest level, \emph{auto} is a library that provides us tools to build
and work with stream transformers on streams of values. Transform a stream of
input values to a stream of output values. So, let's try to phrase our Todo app
problem in that perspective. What are our inputs, and what are our outputs?

For a Todo app, the outputs are probably going to be a \emph{todo list} itself.
If we're building a GUI, then having the todo list itself is going to be enough
to build our front-end display. The stream of \emph{inputs} is a little less
obvious, but, well, what does an app really take as inputs? Commands! Our stream
of inputs will be commands sent by a GUI or by whatever front-end we choose. Our
todo app then is a transformer of a stream of commands to a stream of todo
lists...where the todo list we get changes as we process more commands.

So the "overall loop" will be:

\begin{enumerate}
\tightlist
\item
  A front-end rendered by \emph{ghcjs-dom} (or whatever) with event handlers
  that drop commands into a concurrent \texttt{Chan} queue. This just handles
  rendering.
\item
  Our \texttt{Auto} launched with \texttt{runOnChan}, which waits on the
  \texttt{Chan} queue, runs the inputs through the \texttt{Auto}, and renders
  the result. This handles all of the logic.
\end{enumerate}

We like types in Haskell, so let's begin by laying out our types!

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs\#L19-L46
import Control.Auto import Control.Auto.Collection import Control.Monad.Fix
import Data.IntMap (IntMap) import Data.Serialize import GHC.Generics import
Prelude hiding ((.), id) import qualified Data.IntMap as IM

data TodoInp = IAdd String -\/- new task with description \textbar{} ITask
TaskID TaskCmd -\/- send command to task by ID \textbar{} IAll TaskCmd -\/- send
command to all tasks deriving Show

data TaskCmd = CDelete -\/- delete \textbar{} CPrune -\/- delete if completed
\textbar{} CComplete Bool -\/- set completed status \textbar{} CModify String
-\/- modify description \textbar{} CNop -\/- do nothing deriving Show

data Task = Task \{ taskDescr :: String , taskCompleted :: Bool \} deriving
(Show, Generic)

instance Serialize Task -\/- from Data.Serialize, from the cereal library
\textasciitilde{}\textasciitilde{}\textasciitilde{}

We have a type to represent our inputs, \texttt{TodoInp}, which can be an "add"
command with a \texttt{String}, a "task" command with a \texttt{TaskId}
(\texttt{Int}) and a \texttt{TaskCmd}, and an "all" command with a
\texttt{TaskCmd} that is supposed to represent sending that command to all
tasks.

Our \texttt{TaskCmd} represents commands we can send to individual tasks -\/- we
can delete, prune (delete if completed), set the "completed" flag, or modify the
description.

We're going to represent our task list, \texttt{TaskMap}, as not a
\texttt{{[}{]}} list, but as an \texttt{IntMap} from \emph{containers}, which
associates an \texttt{Int} to a \texttt{Task} that we can look up with the
\texttt{IntMap} API. What would a \texttt{TaskMap} store other than a bunch of
\texttt{Task}s, which we are defining as jus a tupling of a \texttt{String}
description and a \texttt{Bool} completed/uncompleted status.

\section{The Todo Auto}

Time to go over the logic portion! The part that \emph{auto} is meant for! We're
going to structure the logic of our app (also known as the "model") by using
principles of local statefulness to avoid ever working with a "global state",
and working in a declarative, high-level manner.

\subsection{Tasks}

It's clear that the core of our entire thing is going to be the "task list"
construct itself...something that can dynamically add or remove tasks.

In \emph{auto}, there is a construct created just for this kind of situation:
dynamic collections indexed by a key (a "task id"), where you can add or
subtract \texttt{Auto}s from dynamically -\/-\/- they are \texttt{dynMap} and
\texttt{dynMapF} from
\emph{\href{http://hackage.haskell.org/package/auto/docs/Control-Auto-Collection.html}{Control.Auto.Collection}}.
We'll be using \texttt{dynMapF} because it's serializable, and we don't need the
extra power that \texttt{dynMap} offers.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell dynMapF :: (k
-\textgreater{} Interval m a b) -\/- \^{} function to initialize new
\texttt{Auto}s -\textgreater{} a -\/- \^{} default inputs -\textgreater{} Auto m
( IntMap a -\/- \^{} input for each internal \texttt{Auto}, indexed by key ,
Blip {[}k{]} -\/- \^{} blip stream to initialize new \texttt{Auto}s ) (IntMap b)
-\/- \^{} \texttt{Auto} outputs, by key
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\texttt{dynMapF} keeps a "dynamic collection" of \texttt{Interval\ m\ a\ b}s,
indexed by an \texttt{Int} key, or an "ID". It takes as input a stream of
\texttt{IntMap\ a}...basically a bunch of \texttt{(Int,\ a)} pairs.
\texttt{dynMapF} routes each input to the \texttt{Interval} at that ID/address
(with a suitable "default" \texttt{a} if none was sent in), and then outputs all
of the results as an \texttt{IntMap\ b} -\/-\/- a bunch of \texttt{(Int,\ b)}
pairs, each output with the address of the \texttt{Auto} that made it.

For example, \texttt{IM.singleton\ 5\ True} would send \texttt{True} to the
\texttt{Auto} stored at \texttt{5}. It'll then output something that includes
\texttt{(5,\ "received\ True!")} -\/-\/- the output of the \texttt{Auto} at slot
5.

Whenever an \texttt{Interval} turns "off" (is \texttt{Nothing}), it is removed
from the collection. In this way we can have \texttt{Auto}s "remove themselves".

It also takes as input a blip stream of \texttt{{[}k{]}}s. We use each emitted
\texttt{k} to "initialize a new \texttt{Interval}" and throw it into the
collection, creating a new unique key for it. Every time a new \texttt{Auto} is
initialized, \texttt{dynMapF} creates a new key for it.

Read over the
\href{https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md\#semantic-tools}{tutorial
section on blip streams and \texttt{Interval}s} if you are still unfamiliar with
them.

This pretty much fits exactly what we want for our task collection. If we
imagined that we had our \texttt{Task} as an \texttt{Auto}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell initTask :: Monad m
=\textgreater{} String -\textgreater{} Interval m TaskCmd Task
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\texttt{initTask} takes a string (a starting description) and initializes an
\texttt{Interval} that takes in a stream of task commands, and has a stream of
new, updated \texttt{Task}s as its output stream. At every step, it processes
the command and outputs the new appropriate \texttt{Task}.

We can then use this as our "initializer" for \texttt{dynMapF}...and now we have
a dynamic collection of tasks!

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs\#L48-L50
taskCollection :: Monad m =\textgreater{} Auto m (IntMap TaskCmd, Blip
{[}String{]}) (IntMap Task) taskCollection = dynMapF initTask CNop
\textasciitilde{}\textasciitilde{}\textasciitilde{}

If we wanted to send in the command \texttt{CModify\ "hey!"} to the task whose
id/key/address is \texttt{12}, I'd feed in
\texttt{IM.singleton\ 12\ (CModify\ "hey!")}. The output would then contain the
output of feeding that \texttt{CModify} to the \texttt{Auto} at that slot 12,
associated with slot 12 on the output \texttt{IntMap}.

Writing \texttt{initTask} and the task \texttt{Auto} is straightforward with
\texttt{accum}, which is basically like \texttt{foldl} on the inputs and a
"current state". (The current state is of course the \texttt{Task}).

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs\#L52-L62
initTask :: Monad m =\textgreater{} String -\textgreater{} Interval m TaskCmd
Task initTask descr = accum f (Just (Task descr False)) where f (Just t) tc =
case tc of CDelete -\textgreater{} Nothing CPrune \textbar{} taskCompleted t
-\textgreater{} Nothing \textbar{} otherwise -\textgreater{} Just t CComplete s
-\textgreater{} Just t \{ taskCompleted = s \} CModify descr -\textgreater{}
Just t \{ taskDescr = descr \} CNop -\textgreater{} Just t f Nothing \_ =
Nothing \textasciitilde{}\textasciitilde{}\textasciitilde{}

See that our \texttt{Auto} "turns off" by outputting \texttt{Nothing}. That's
interval semantics, and it's what \texttt{dynMapF} relies on for its internal
\texttt{Auto}s!

\subsection{Routing the inputs}

The only thing left, then, is just to route our input stream to send everything
to the correct \texttt{Auto} in \texttt{taskCollection}.

Our input stream is going to be a stream of \texttt{TodoInp}, which can be
"add", "send command to a single task", or "send command to all tasks". Really,
though, you can think of it three separate streams all "jammed" into one stream.

This is a common pattern that we can use \emph{blip streams} for. Instead of
working with one big fatty stream, we can work with several blip streams that
only emit when the input that we care about comes in.

Typically, we'd do this with \texttt{emitJusts}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell emitJusts :: (a
-\textgreater{} Maybe b) -\textgreater{} Auto m a (Blip b)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

You can imagine \texttt{emitJusts} is a "siphon" off of the input stream of
\texttt{a}s...and pulling out only the values that we care about, as a blip
stream of \texttt{b}'s.

We can build our "siphoners":

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs\#L95-L105
getAddEvts :: TodoInp -\textgreater{} Maybe {[}String{]} getAddEvts (IAdd descr)
= Just {[}descr{]} getAddEvts \_ = Nothing

getModEvts :: TodoInp -\textgreater{} Maybe (IntMap TaskCmd) getModEvts (ITask n
te) = Just \$ IM.singleton n te getModEvts \_ = Nothing

getMassEvts :: ({[}TaskID{]}, TodoInp) -\textgreater{} Maybe (IntMap TaskCmd)
getMassEvts (allIds, IAll te) = Just \$ IM.fromList (map (,te) allIds)
getMassEvts \_ = Nothing \textasciitilde{}\textasciitilde{}\textasciitilde{}

\texttt{getAddEvts}, when used with \texttt{emitJusts}, will siphon off all
\texttt{IAdd} commands as a blip stream of \texttt{{[}String{]}}s, emitting
descriptions of new tasks to add.

\texttt{getModEvts}, when used with \texttt{emitJusts}, will siphon off all
\texttt{ITask} commands as a blip stream of \texttt{IntMap\ TaskCmd}, which will
be fed into \texttt{taskCollection} and \texttt{dynMapF}.

\texttt{getMassEvts} is pretty much the same thing...siphoning off all
\texttt{IAll} commands as a blip stream of \texttt{IntMap\ TaskCmd}. It needs a
list of all \texttt{TaskID}s though, to do its job...because it needs to make an
\texttt{IntMap} targeting all of the current tasks.

Remember, we interace with tasks through an \texttt{IntMap\ TaskCmd}...which is
a map of task id-task command pairs. The \texttt{TaskCmd} stored at key
\texttt{1} will be the command we want to send to task id 1.

Let's see it all work together!

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/auto/Todo.hs\#L64-L93
todoApp :: MonadFix m =\textgreater{} Auto m TodoInp (IntMap Task) todoApp =
proc inpEvt -\textgreater{} do

\begin{verbatim}
rec -- all id's currently alive
    allIds <- arrD IM.keys [] -< taskMap

    -- "forking" `inpEvt` into three blip streams:
    -- newTaskB :: Blip [String]
    newTaskB  <- emitJusts getAddEvts  -< inpEvt
    -- modTaskB :: Blip (IntMap TaskCmd)
    modTaskB  <- emitJusts getModEvts  -< inpEvt
    -- massTaskB :: Blip (IntMap TaskCmd)
    massTaskB <- emitJusts getMassEvts -< (allIds, inpEvt)

    -- merge the two streams together to get "all" inputs, single and
    -- mass.
    let allInpB :: Blip (IntMap TaskCmd)
        allInpB = modTaskB <> massTaskB

    -- from a blip stream to an `IntMap` stream that is empty when the
    -- stream doesn't emit
    -- taskCommands :: IntMap TaskCmd
    taskCommands <- fromBlips IM.empty -< allInpB

    -- feed the commands and the new tasks to `taskMap`...the result is
    -- the `IntMap` of tasks.
    -- taskMap :: IntMap Task
    taskMap <- taskCollection -< (taskCommands, newTaskB)

id -< taskMap
\end{verbatim}

\textasciitilde{}\textasciitilde{}\textasciitilde{}

To read the proc block, it does help to sort of see all of the lines as english
statements of what things "are".

\begin{enumerate}
\item
  \texttt{allIds} is a list of keys (id's) currently in the task map
  \texttt{taskMap}. All of the id's of the tasks currently alive.
\item
  Now, we fork into blip streams:

  \begin{itemize}
  \tightlist
  \item
    \texttt{newTaskB} is a blip stream that emits with task descriptions
    whenever \texttt{inpEvt} calls for one.
  \item
    \texttt{modTaskB} is a blip stream that emits with a command to a specific
    task whenever \texttt{inpEvt} calls for one.
  \item
    \texttt{massTaskB} is a blip stream that emits commands to every single task
    in \texttt{allIds} whenever \texttt{inpEvt} calls for it.
  \item
    \texttt{allInpB} is a blip stream with addressed commands whenever either
    \texttt{modTaskB} or \texttt{massTaskB} emits.
  \end{itemize}
\item
  \texttt{taskCommands} is a map of addressed commands for each task. It's
  whatever \texttt{allInpB} emits, when it does emit...or just \texttt{IM.empty}
  (an empty map) when it doesn't.
\item
  \texttt{taskMap} is the map of tasks that we get from our
  \texttt{taskCollection} updater, which manages a collection of tasks.
  \texttt{taskCollection} needs the commands for each task and the new tasks we
  want to do its job.
\end{enumerate}

We state things as an interplay of streams. And in the end, the result is what
we want -\/-\/- an indexed list of tasks.

Note that we needed the \texttt{rec} block because we referred to
\texttt{taskMap} at the beginning (to get \texttt{allIds}), but we don't define
\texttt{taskMap} until the end.

Note that we use \texttt{arrD} for \texttt{allIds}. What we really "meant" was
something like:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell allIds \textless{}-
arr IM.keys -\textless{} taskMap
\textasciitilde{}\textasciitilde{}\textasciitilde{}

But...this doesn't really work out, because when the whole thing "starts", we
don't know what \texttt{taskMap} is. We need to know \texttt{massTaskB} to know
\texttt{taskMap}, and we need to know \texttt{allIds} to know
\texttt{massTaskB}, and...recursive dependency!

We can use \texttt{arrD} to specify an "initial output" to "close the loop" (in
technical terms). We want \texttt{allIds} to initially be \texttt{{[}{]}} (we
can assume we start with no task id's), so instead of

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell allIds \textless{}-
arr IM.keys -\textless{} taskMap
\textasciitilde{}\textasciitilde{}\textasciitilde{}

we have

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell allIds \textless{}-
arrD IM.keys {[}{]} -\textless{} taskMap
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Where \texttt{{[}{]}} is the "initial output", so when we first try to do
anything, we don't need \texttt{taskMap} -\/-\/- we just pop out
\texttt{{[}{]}}!

This is just a small thing to worry about whenever you have recursive bindings.
There is a small cognitive price to pay, but in return, you have something that
really just looks like laying out relationships between different quantities :)

\section{Interfacing with the world}

Our application logic is done; let's explore ways to interface with it!

\subsection{Testing/command line}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs\#L25-L62
parseInp :: String -\textgreater{} Maybe TodoInp parseInp = p . words where p
("A":xs) = Just (IAdd (unwords xs)) p ("D":n:\emph{) = onId n CDelete p
("C":n:}) = onId n (CComplete True) p ("U":n:\emph{) = onId n (CComplete False)
p ("P":n:}) = onId n CPrune p ("M":n:xs) = onId n (CModify (unwords xs)) p \_ =
Nothing

\begin{verbatim}
onId :: String -> TaskCmd -> Maybe TodoInp
onId "*" te = Just (IAll te)
onId n   te = (`ITask` te) <$> readMaybe n
\end{verbatim}

formatTodo :: IntMap Task -\textgreater{} String formatTodo = unlines . map
format . IM.toList where format (n, Task desc compl) = concat {[} show n , ".
{[}" , if compl then "X" else " " , "{]} " , desc {]}

main :: IO () main = do putStrLn "Enter command! 'A descr' or '{[}D/C/U/P/M{]}
{[}id/*{]}'" void . interactAuto \$ -\/- interactAuto takes an Interval;
\texttt{toOn} gives -\/- one that runs forever toOn -\/- default output value on
bad command . fromBlips "Bad command!" -\/- run
\texttt{formatTodo\ \textless{}\$\textgreater{}\ todoApp} on emitted commands .
perBlip (formatTodo \textless{}\$\textgreater{} todoApp) -\/- emit when input is
parseable . emitJusts parseInp
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\texttt{interactAuto} runs an \texttt{Interval} by feeding it in strings from
stdin printing the output to stdout, until the output is "off"/\texttt{Nothing}
-\/-\/- then stops. Here we use \texttt{parseInp} to emit input events whenever
there is a parse, run \texttt{todoApp} (formatted) on the emitted events, and
then condense it all with \texttt{fromBlips} and wrap it in an "always on"
\texttt{toOn}.

\textasciitilde{}\textasciitilde{}\textasciitilde{} \$ cabal sandbox init \$
cabal install auto \$ cabal exec runghc todo-cmd.hs Enter command! 'A descr' or
'{[}D/C/U/P/M{]} {[}id/*{]}'

\begin{quote}
A take out the trash 0. {[} {]} take out the trash
\end{quote}

\begin{quote}
A do the dishes 0. {[} {]} take out the trash 1. {[} {]} do the dishes
\end{quote}

\begin{quote}
C 1 0. {[} {]} take out the trash 1. {[}X{]} do the dishes
\end{quote}

\begin{quote}
U 1 0. {[} {]} take out the trash 1. {[} {]} do the dishes
\end{quote}

\begin{quote}
C 0 0. {[}X{]} take out the trash 1. {[} {]} do the dishes
\end{quote}

\begin{quote}
P * 1. {[} {]} do the dishes \textasciitilde{}\textasciitilde{}\textasciitilde{}
\end{quote}

You can
\href{https://github.com/mstksg/inCode/tree/master/code-samples/auto/todo-cmd.hs}{download
and run this yourself}!

Looks like the logic works! Time to take it to GUI!

\subsection{As a GUI}

To build a GUI, we must build an \texttt{Auto} that takes in inputs from events
and output everything the front-end renderer needs to render the interface.

For a typical todomvc gui, we need to be able to filter and select things. So
that means we need to be extend our input type with filtering and selecting
events. And our output has to also indicate the current filter selected, and the
current task selected, as well.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data GUIOpts = GUI \{
\emph{currFilter :: Filter -\/- currently applied filter , }currSelected ::
Maybe TaskID -\/- currently selected task \}

data GUIInp = GIFilter Filter \textbar{} GISelect (Maybe TaskID)

data Filter = All \textbar{} Active \textbar{} Completed deriving (Show,
Generic, Enum, Eq)

instance Serialize Filter \textasciitilde{}\textasciitilde{}\textasciitilde{}

Instead of defining a new input mega-type with all input events and the todo map
with the options, we can use good ol' fashioned \texttt{Either} and
\texttt{(,)}. So now, instead of:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell todoApp :: Auto m
TodoInp (IntMap Task) \textasciitilde{}\textasciitilde{}\textasciitilde{}

We have:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell todoAppGUI :: Auto m
(Either TodoInp GUIInp) (IntMap Task, GUIOpts)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Now we take \emph{either} \texttt{TodoInp} or \texttt{GUIInp} and then return
\emph{both} \texttt{IntMap\ Task} \emph{and} \texttt{GUIOpts}.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell todoAppGUI :: Auto'
(Either TodoInp GUIInp) (IntMap Task, GUIOpts) todoAppGUI = proc inp
-\textgreater{} do filt \textless{}- holdWith All . emitJusts filtInps
-\textless{} inp selc \textless{}- holdWith Nothing . emitJusts selcInps
-\textless{} inp tasks \textless{}- holdWith mempty . perBlip todoApp .
emitJusts todoInps -\textless{} inp

\begin{verbatim}
id -< (tasks, GUI filt selc)
\end{verbatim}

where todoInps :: Either TodoInp GUIInp -\textgreater{} Maybe TodoInp todoInps
(Left ti) = Just ti todoInps \_ = Nothing filtInps :: Either TodoInp GUIInp
-\textgreater{} Maybe Filter filtInps (Right (GIFilter filt)) = Just filt
filtInps \_ = Nothing selcInps :: Either TodoInp GUIInp -\textgreater{} Maybe
(Maybe TaskID) selcInps (Right (GISelect sec)) = Just selc selcInps \_ = Nothing
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Here we have the same idea as before. One input stream of
\texttt{Either\ TodoInp\ GUIInp} comes through, and we fork it into three blip
streams that each do what we want.
\texttt{holdWith\ x\ ::\ Auto\ m\ (Blip\ b)\ b} is always the value of the last
emitted item...but starts off as \texttt{x} first.

By the way, the above code is much more succinct if you are willing to use
\emph{\href{http://lens.github.com}{lens}}...

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell todoAppGUI :: Auto'
(Either TodoInp GUIInp) (IntMap Task, GUIOpts) todoAppGUI = proc inp
-\textgreater{} do filt \textless{}- holdWith All . emitJusts (preview
(\emph{Right . }GIFilter)) -\textless{} inp selc \textless{}- holdWith Nothing .
emitJusts (preview (\emph{Right . }GISelect)) -\textless{} inp tasks
\textless{}- holdWith mempty . perBlip todoApp . emitJusts (preview \_Left)
-\textless{} inp

\begin{verbatim}
id -< (tasks, GUI filt selc)
\end{verbatim}

\textasciitilde{}\textasciitilde{}\textasciitilde{}

(assuming we defined the prisms for \texttt{GUIInp} or used
\texttt{\textquotesingle{}\textquotesingle{}mkPrisms})

Neat, right? In a way, you can say that \texttt{emitJusts} and
\texttt{Prisms}/lens was a match made in heaven :)

\subsection{Giving it life}

The last step is to hook everything up together -\/-\/-

\begin{enumerate}
\tightlist
\item
  Setting up events in our GUI to feed inputs to a queue
\item
  Setting up the queue to wait on inputs, and output the task map/gui status on
  every one using \texttt{todoAppGUI}
\item
  Rendering the output into the GUI framework of your choice
\end{enumerate}

The second step in particular can be handled with good ol'
\texttt{{[}runOnChan{]}{[}{]}}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell runOnChan :: (b
-\textgreater{} IO Bool) -\textgreater{} Chan a -\textgreater{} Auto' a b
-\textgreater{} IO (Auto' a b)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

We know and love \texttt{runOnChan} from when we used it to make our
\href{http://blog.jle.im/entry/auto-building-a-declarative-chatbot-with-implicit-serialization\#irc-backend-the-ugly-part}{chatbot}.
It runs an \texttt{Auto\textquotesingle{}\ a\ b} "on a \texttt{Chan}"
(concurrent queue). The first argument is an "output hander" -\/-\/- it handles
the \texttt{b}s that the \texttt{Auto\textquotesingle{}} pops out. It decides
whether to stop the whole thing or keep on listening based on the \texttt{Bool}
result of the handler. The second argument is the \texttt{Chan\ a} to listen for
inputs on. Whenever something is dropped into that \texttt{Chan}, it runs the
\texttt{Auto\textquotesingle{}} with the \texttt{a} and processes the output
\texttt{b} with the handler.

Our final runner is then just:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell runOnChan renderGUI
inputChan todoAppGUI \textasciitilde{}\textasciitilde{}\textasciitilde{}

where

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell renderGUI :: (IntMap
Task, GUIOpts) -\textgreater{} IO Bool inputChan :: Chan (Either TodoInp GUIInp)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

The rendering is done with \texttt{renderGUI}...and it really depends on your
framework here. That's \#3 from the list above.

All you need after that is just to have your GUI hook up event handlers to drop
the appropriate \texttt{Either\ TodoInp\ GUIInp} into \texttt{inputChan}...and
you're golden!

\section{Seeing it in action}

We've reached the end of our tutorial -\/-\/- the parts about \texttt{auto}. It
is my hope that whatever GUI front-end you want to work with, it'll be simple
enough to "plug in" our \texttt{Auto} logic.

A \href{https://mstksg.github.com/auto-examples/todo}{live demo} is online too;
you can see
\href{https://github.com/mstksg/auto-examples/blob/master/src/TodoJS.hs}{the
source of the front-end bindings}

This is a bare-bons \emph{ghcjs} implementation using \emph{ghcjs-dom}, which
uses direct dom manipulation.

User \href{https://github.com/eryx67}{eryx67} has been kind enough to provide
\href{https://github.com/eryx67/auto-examples/blob/master/src/TodoJS.hs}{an
implementation in \emph{ghcjs}} with the
\emph{\href{https://github.com/ocharles/virtual-dom}{virtual-dom}} library
(\href{https://github.com/mstksg/auto-examples/commit/246133a89fbca6a2ec7ea276d8536701f6ab8d2c?diff=split}{side-by-side
comparison}), so there is a slightly less uglier implementation with abstraction
:)

As always, feel free to ask questions in the comments, hop over to
\emph{\#haskell-game} or \emph{\#haskell-auto} on freenode, or send me a
\href{https://twitter.com/mstk}{tweet}! And look forward to more tutorials as
the \href{http://blog.jle.im/entries/series/+all-about-auto}{All About Auto}
series progresses!

\end{document}
