\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Unique sample drawing \& searches with List and StateT -\/-\/- "Send more
money" \% Justin Le \% April 24, 2015

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html}{in
Code}}.}

Nothing too crazy today, just a cute (basic/intermediate) haskell trick as a
response to Mark Dominus's excellent \href{http://blog.plover.com}{Universe of
Discourse} post on
\href{http://blog.plover.com/prog/haskell/monad-search.html}{Easy exhaustive
search with the list monad} intended for people new or unfamiliar with haskell
demonstrating the common "list monad as a constraint solver" approach that is
standard fare for learning Haskell. I myself have literally done
\href{http://blog.jle.im/entries/series/+monadplus-success-failure-monads}{an
entire series of blog posts} on this usage.

Mark's use case however incorporates a bit of an extra pattern not typically
discussed. The list monad is good for taking "independent samples" of things
(looking at different samples from a list):

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{} do
x \textless{}- "abc" y \textless{}- "abc" z \textless{}- "abc" return
{[}x,y,z{]} {[}"aaa","aab","aac","aba","abb" ... {]}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

However, what if you wanted to instead "draw" from a pool, and represent
different drawings? Traditionally, the answer was something like:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{} do
x \textless{}- "abc" y \textless{}- filter (/= x) "abc" z \textless{}- filter
(/= y) . filter (/= x) \$ "abc" return {[}x,y,z{]}
"abc","acb","bac","bca","cab","cba"{]}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

This is a little bit awkward...and it definitely gets a lot worse
(\$O(n\^{}2)\$) when you have more items. Also, it relies on an \texttt{Eq}
constraint -\/-\/- what if our thing doesn't have an \texttt{Eq} instance? And
this also falls apart when our list contains duplicate items. If we had used
\texttt{"aabc"} instead of \texttt{"abc"}, the result would be the same -\/-\/-
despite having more \texttt{\textquotesingle{}a\textquotesingle{}}s to pick
from!

\textbf{Important note:} After writing this article, I found out that Douglas
Auclair in \href{https://wiki.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf}{11th
issue of the Monad Reader} solved this exact same problem with pretty much the
exact same approach. (Oops!) If you want to do further reading, check it out! :D

\section{StateT}

There's a type in the \emph{transformers} library that provides a very useful
monad instance:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data StateT s m a =
StateT (s -\textgreater{} m (a, s))
\textasciitilde{}\textasciitilde{}\textasciitilde{}

A \texttt{StateT\ s\ m\ a} is a function that takes an initial state \texttt{s}
and returns a result \texttt{a} with a modified state...in the context of
\texttt{m}.

Specialize for \texttt{m\ \textasciitilde{}\ {[}{]}} and we get

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data StateT s {[}{]}
a = StateT (s -\textgreater{} {[}(a, s){]})
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which is basically describing a function from a initial state to a list of
\emph{ways you can modify the state}, and different results from each one. It
returns a list of "all ways you can mutate this state".

For example,

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell foo :: StateT Int
{[}{]} Bool foo = StateT \$ \textbackslash{}x -\textgreater{} {[}(even x, x+1),
(odd x, x-1), (x \textgreater{} 0, negate x){]}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

So \texttt{foo} takes a number, \texttt{x}, and says, "here are three ways we
might proceed from having this number. We can return whether or not it's even,
in which case the new state is \texttt{x+1}...we can return whether or not it's
odd, in which case the new state is \texttt{x-1}....or we can return whether or
not it's positive, in which case the new state is \texttt{negate\ x}"

What the monad instance does is that it allows you to "chain" forks, and go
along different forks, and gather together "all possible forks" you could have
taken. At the end, it outputs all possible forks. So if you did
\texttt{foo\ \textgreater{}\textgreater{}\ foo}, there'd be nine results -\/-\/-
one result for when you took the first route (the \texttt{x+1}) twice, one for
when you took the first and then the second (\texttt{x-1}), one for when you
took the first and the third....and the second and the first...etc., etc.

\subsection{MonadPlus}

One other tool we have at our disposal is \texttt{guard}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell guard :: Bool
-\textgreater{} StateT Int {[}{]} ()
\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}

which is a \texttt{StateT} action that says "kill this current branch if given
\texttt{False}, or go on if given \texttt{True}"

\section{The Problem}

The problem, as stated, was to find distinct digits for each letter to solve:

\textasciitilde{}\textasciitilde{}\textasciitilde{} S E N D + M O R E
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/- M O N E Y
\textasciitilde{}\textasciitilde{}\textasciitilde{}

So \texttt{SEND} is a four-digit number, \texttt{MORE} is a four-digit number,
and \texttt{MONEY} is a five-digit number that is the sum of the two. The first
digit of \texttt{MONEY} has to be the first digit of \texttt{MORE}, the last
digit of \texttt{MORE} has to be the second digit of \texttt{SEND}, etc.

The previous approach was done using the entire "pick from all
possibilities...except for the ones already chosen", using \texttt{(/=)} and
filtering over all of the things seen vs all of the things to pick from.

However, we can abstract over "picking dependently from a sample" by defining a
function called \texttt{select}, which really should be in the base libraries
but isn't for some reason:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs\#L7-L9
select :: {[}a{]} -\textgreater{} {[}(a, {[}a{]}){]} select {[}{]} = {[}{]}
select (x:xs) = (x,xs) : {[}(y,x:ys) \textbar{} (y,ys) \textless{}- select xs{]}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

(Implementation thanks to Cale, who has fought valiantly yet fruitlessly to get
this into base for many years.)

\texttt{select} will take a list \texttt{{[}a{]}} and return a list of different
"selected" \texttt{a}s, with the rest of the list, too:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
select "abcd" {[}('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc"){]}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

But, hey...does the type signature of \texttt{select} look like anything
familiar?

It looks \emph{exactly} like something that \texttt{StateT} is supposed to
describe! Give an initial state (\texttt{{[}a{]}}), and returns a list of all
possible ways to "mutate" that state (by removing one element from the state),
and a result from each mutation (the removed element).

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell StateT select ::
StateT {[}a{]} {[}{]} a \textasciitilde{}\textasciitilde{}\textasciitilde{}

And armed with this...we have all we need

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs\#L3-L35
import Control.Monad (guard, mfilter) import Control.Monad.Trans.State import
Data.List (foldl')

asNumber :: {[}Int{]} -\textgreater{} Int asNumber = foldl' (\textbackslash{}t o
-\textgreater{} t*10 + o) 0

main :: IO () main = print . flip evalStateT {[}0..9{]} \$ do s \textless{}-
StateT select e \textless{}- StateT select n \textless{}- StateT select d
\textless{}- StateT select m \textless{}- StateT select o \textless{}- StateT
select r \textless{}- StateT select y \textless{}- StateT select guard \$ s /= 0
\&\& m /= 0 let send = asNumber {[}s,e,n,d{]} more = asNumber {[}m,o,r,e{]}
money = asNumber {[}m,o,n,e,y{]} guard \$ send + more == money return (send,
more, money) \textasciitilde{}\textasciitilde{}\textasciitilde{}

Remember, \texttt{StateT} here operates with an underlying state of
\texttt{{[}Int{]}}, a list of numbers not yet picked. \texttt{StateT\ select}
picks one of these numbers, and modifies the state to now only include the items
that were not picked. So every time you sequence \texttt{StateT\ select},
\texttt{select} draws from a smaller and smaller pool of numbers, and makes the
state list smaller and smaller. What sequencing \texttt{StateT} does is allow us
to explore \emph{all} of the possible ways we could pick and modify state, all
at once. Using \texttt{guard}, we then "close off" and kill off the paths that
don't end up how we'd like.

\texttt{asNumber} takes a list like \texttt{{[}1,2,3{]}} and turns it into the
number \texttt{123}; credit to the source blog.

And, to test it out...

\textasciitilde{}\textasciitilde{}\textasciitilde{}bash \$ ghc -O2
send-more-money.hs \$ ./send-more-money

\section{{[}(9567,1085,10652){]}}

\textasciitilde{}\textasciitilde{}\textasciitilde{}

It returns the one and only solution, \texttt{SEND\ =\ 9567},
\texttt{MORE\ =\ 1085}, and \texttt{MONEY\ =\ 10652}.{[}\^{}perf{]}

\textless{}div class="note"\textgreater{} \textbf{Aside}

We can make things a little bit more efficient with minimal cost in
expressiveness. But not that it matters...the original version runs fast
already.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs\#L38-L59
select' :: {[}a{]} -\textgreater{} {[}(a,{[}a{]}){]} select' = go {[}{]} where
go xs {[}{]} = {[}{]} go xs (y:ys) = (y,xs++ys) : go (y:xs) ys

main' :: IO () main' = print . flip evalStateT {[}0..9{]} \$ do s \textless{}-
mfilter (/= 0) \$ StateT select' m \textless{}- mfilter (/= 0) \$ StateT select'
e \textless{}- StateT select' n \textless{}- StateT select' d \textless{}-
StateT select' o \textless{}- StateT select' r \textless{}- StateT select' y
\textless{}- StateT select' let send = asNumber {[}s,e,n,d{]} more = asNumber
{[}m,o,r,e{]} money = asNumber {[}m,o,n,e,y{]} guard \$ send + more == money
return (send, more, money) \textasciitilde{}\textasciitilde{}\textasciitilde{}

This is a more performant version of \texttt{select}
\href{http://chimera.labs.oreilly.com/books/1230000000929/pr01.html}{courtesy of
Simon Marlow} that doesn't preserve the order of the "rest of the elements".

Also, we use \texttt{mfilter} to "eliminate bad \texttt{s} and \texttt{m}s"
right off the bat, before having to pick any more things. \texttt{mfilter} can
be thought of as "killing the fork immediately" if the action doesn't satisfy
the predicate. If the \texttt{s} picked doesn't match \texttt{(/=\ 0)}, then the
entire branch/fork is immediately ruled invalid. \textless{}/div\textgreater{}

By the way, isn't it neat that it does all of this in "constant space"? It just
keeps track of the output list, but the actual search processes is in constant
space. You don't need to keep track of all \texttt{10!} combinations in memory
at once. Hooray laziness!

\section{Other Applications}

Using \texttt{select} and \texttt{StateT}, we can do a lot of things involving
picking from a sample, or permutations. Anything that you used to awkwardly do
by using filter not-equal-to's can work now. You can do things like drawing from
a deck:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell pokerGame ::
{[}Ordering{]} pokerGame = flip evalStateT {[}0..51{]} \$ do p2Hand \textless{}-
replicateM 5 (StateT select) p1Hand \textless{}- replicateM 5 (StateT select)
return \$ pokerCompare p1Hand p2Hand
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which would draw five distinct cards from a deck of \texttt{{[}0..51{]}}, and
return who won for each draw (assuming you had a suitable
\texttt{pokerCompare\ ::\ {[}Card{]}\ -\textgreater{}\ {[}Card{]}\ -\textgreater{}\ Ordering}).
Note that if you use \texttt{runStateT}, you'd get the results (the winner),
\emph{as well as} the leftover cards in the deck for each path!

\textless{}!-\/- I used to have an example here about simulating russian
roulette -\/-\textgreater{}

\textless{}!-\/- But this doesn't really work in a useful way...because the
paths all "stop" -\/-\textgreater{} \textless{}!-\/- after the first shot. In
reality, you are just as likely to be shot on the -\/-\textgreater{}
\textless{}!-\/- first pull as you are on the second. But as this simulation
runs, it "stops" -\/-\textgreater{} \textless{}!-\/- after the first shot...so
\texttt{1} will only show up once. -\/-\textgreater{}

You can even combine the two sorts of drawings -\/-\/- sampling independently
(like rolling dice) using \texttt{lift}, and drawing from an underlying deck.
For example, you might encode some game logic from a board game like monopoly:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell combo = flip
evalStateT initialDeck \$ do roll \textless{}- lift {[}1..6{]} draw \textless{}-
StateT select ... \textasciitilde{}\textasciitilde{}\textasciitilde{}

Whenever you want a dice roll, use \texttt{lift\ {[}1..6{]}}...and whenever you
want to draw from the deck, use \texttt{StateT\ select}.

What you get in the end, remember, is a list of "all possible paths". You'll get
a list of every possible result from all of your different rolling and drawing
choices.

Happy Haskelling!

\end{document}
