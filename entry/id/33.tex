\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Abstracting over Sequential Random Algorithms with Free \% Justin Le

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/abstracting-over-sequential-random-algorithms-with-free.html}{in
Code}}.}

It's fair enough to say that I'm a little late to the free monad party, but I
still think their power is greatly either misunderstood or underrated or obscure
in Haskell, and this article will be my attempt to throw more examples of its
usage.

Here we're going to construct a type that can represent sequential computations
using randomness or entropy, and we're going to abstract over our entropy source
-\/-\/- not by swapping out the pseudorandom generator, but by really
abstracting over what our computation really \emph{is} to the barest essentials.
We're going to abstract over what an sequential random algorithm even is.

The man plain is to first create a type that represents just a value produced
from a random number...and then figure out how to chain them.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/free-random/Rand.hs\#L18-L22
data RandF a where FromRandom :: Random r =\textgreater{} ( r -\textgreater{} a)
-\textgreater{} RandF a FromRandomR :: Random r =\textgreater{} r
-\textgreater{} r -\textgreater{} ( r -\textgreater{} a) -\textgreater{} RandF a
FromRandoms :: Random r =\textgreater{} ({[}r{]} -\textgreater{} a)
-\textgreater{} RandF a FromRandomRs :: Random r =\textgreater{} r
-\textgreater{} r -\textgreater{} ({[}r{]} -\textgreater{} a) -\textgreater{}
RandF a \textasciitilde{}\textasciitilde{}\textasciitilde{}

For those of you unfamiliar with GADT syntax, this is just basically specifying
a type by the type of its contructors; \texttt{RandF} has four constructors
-\/-\/- one of which, \texttt{FromRandom}, takes a function
\texttt{(r\ -\textgreater{}\ a)}, and returns a \texttt{RandF\ a}...as long as
the \texttt{r} is an instance of the \texttt{Random} typeclass (from the
\emph{random} package).

For comparison, \texttt{Maybe} could have been written like:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Maybe a where
Just :: a -\textgreater{} Maybe a Nothing :: Maybe a
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Anyways, every constructor is basically made with a function, "\emph{If} I had a
random number, what would I do with it?" \texttt{FromRandom} basically contains
a function \texttt{r\ -\textgreater{}\ a}...if I had a random number, how would
I get my \texttt{a}? Note that this can really contain a function from
\emph{any} \texttt{r} you want, as long as it is a part of the \texttt{Random}
typeclass. So we can have something that takes any random \texttt{Bool} to a
\texttt{String}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell FromRandom
(\textbackslash{}r -\textgreater{} show (r :: Bool)) :: RandF String
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which says, "if I had a random \texttt{Bool}, then I'd \texttt{show} it, to get
a \texttt{String}".

Or maybe something that takes any random \texttt{Double} to an \texttt{Int},
like:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell FromRandom
(\textbackslash{}r -\textgreater{} round (100 * r * r :: Double)) :: RandF Int
\textasciitilde{}\textasciitilde{}\textasciitilde{}

"If I had a random \texttt{Double}, I'd square it and divide it by three, then
round it, to get my \texttt{Int}".

Or something as simple as just getting a random \texttt{Double}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell FromRandom id ::
RandF Double \textasciitilde{}\textasciitilde{}\textasciitilde{}

"If I had a random \texttt{Double}...well, that's what I want in the end."

\texttt{FromRandomR} takes a range first before giving the function;
\texttt{FromRandoms} asks, "if I had an infinite list of random items, what
would I do?"

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell FromRandomR 0 10
(\textbackslash{}r -\textgreater{} 1 / sqrt r) :: RandF Double FromRandoms
(\textbackslash{}rs -\textgreater{} sum (take 10 rs)) :: RandF Double
\textasciitilde{}\textasciitilde{}\textasciitilde{}

We can "evaluate" the random value in a \texttt{RandF} by just generating a
random value of the type desired and then applying the function to it. One
typical way of doing this is to ask for a random generator/seed from the user:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/free-random/Rand.hs\#L31-L35
runRandomF :: RandomGen g =\textgreater{} RandF a -\textgreater{} g
-\textgreater{} a runRandomF (FromRandom f) = f . fst . random runRandomF
(FromRandomR r0 r1 f) = f . fst . randomR (r0, r1) runRandomF (FromRandoms f) =
f . randoms runRandomF (FromRandomRs r0 r1 f) = f . randomRs (r0, r1)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

We can try some of these out:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
let s = mkStdGen 192837465 ghci\textgreater{} runRandomF (FromRandom
(\textbackslash{}r -\textgreater{} show (r :: Bool))) s "False"
ghci\textgreater{} runRandomF (FromRandom (\textbackslash{}r -\textgreater{}
round (100 * r * r))) s 32 ghci\textgreater{} runRandomF (FromRandom id :: RandF
Double) s 0.5631451666688826 ghci\textgreater{} runRandomF (FromRandomR 0 10
(\textbackslash{}r -\textgreater{} 1 / sqrt r)) s 0.4213954281350406
ghci\textgreater{} runRandomF (FromRandoms (sum . take 10) :: RandF Double) s
9.434604856390711 \textasciitilde{}\textasciitilde{}\textasciitilde{}

We might also realize that we can make a \texttt{Functor} instance on
\texttt{RandF}, where \texttt{fmap} is like applying the fmapping function to
the outbound value. For example, if we had
\texttt{FromRandom\ (\textbackslash{}r\ -\textgreater{}\ r\ *\ 2)}, if we
\texttt{fmap\ show}, we would want
\texttt{FromRandom\ (\textbackslash{}r\ -\textgreater{}\ show\ (r\ *\ 2))}, so
whenever we "ran" the \texttt{RandF}...if it was "meant" to make a \texttt{10}
originally, it would now make a \texttt{"10"}.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/free-random/Rand.hs\#L24-L29
instance Functor RandF where fmap h rnd = case rnd of FromRandom f
-\textgreater{} FromRandom (h . f) FromRandomR r0 r1 f -\textgreater{}
FromRandomR r0 r1 (h . f) FromRandoms f -\textgreater{} FromRandoms (h . f)
FromRandomRs r0 r1 f -\textgreater{} FromRandomRs r0 r1 (h . f)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
let s = mkStdGen 192837465 ghci\textgreater{} let r = FromRandom
(\textbackslash{}r -\textgreater{} round (100 * r * r)) ghci\textgreater{}
runRandomF r s 32 ghci\textgreater{} runRandomF (fmap show r) s "32"
ghci\textgreater{} runRandomF (fmap negate r) s -32
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Put in a rather abstract way, if you think of a \texttt{RandF\ Double} as
something that "contains" a random \texttt{Double}, waiting to be
computed...then \texttt{fmap\ show} applies \texttt{show} to the "contained"
random \texttt{Double}.

\end{document}
