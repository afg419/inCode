\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% A Non-Unique Monad Instance \% Justin Le \% January 28, 2015

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/a-non-unique-monad-instance.html}{in
Code}}.}

Just stopping in for a short post before continuing with a long-overdue series
or two :) This post is a bit of a short fun one that describes a quest I had,
and hopefully some useful extra ideas I found along the way.

Soon after I discovered Haskell, one question has plagued my mind. Day and
night, I wondered...

\begin{quote}
Are there any Haskell types with more than one unique \texttt{Monad} instance?
\end{quote}

This was a question that was pretty simple...so simple that I was sure many
people had already asked and answered this. But I couldn't really find any
answers and nobody I asked at the time could really give me one either, so this
soon embedded itself as a pretty deep mystery to my psyche.

The background?

\section{Functor and Applicative}

All \texttt{Functor} instances, if they exist, are \emph{unique} for the type.
The type uniquely determines the instance. There is only one possible
\texttt{Functor} instance for \texttt{{[}{]}}, one possible \texttt{Functor}
instance for \texttt{Maybe}, \texttt{Either}, etc.

This fact is taken advantage of by GHC to allow you to derive, for some types, a
\texttt{Functor} instance automatically.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
:set -XDeriveFunctor ghci\textgreater{} data Foo a = Bar {[}a{]} (Maybe (Foo a))
\textbar{} Baz (Either String a) (Foo a) ghci\textgreater{} let x = Bar {[}1,
3{]} (Just (Baz (Right 4) (Bar {[}10{]} Nothing))) ghci\textgreater{} fmap (*2)
x Bar {[}2, 6{]} (Just (Baz (Right 8) (Bar {[}20{]} Nothing)))
\textasciitilde{}\textasciitilde{}\textasciitilde{}

There is no other possible \texttt{Functor} instance for that data type. Go
ahead, try :D

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Foo a = Bar
{[}a{]} (Maybe (Foo a)) \textbar{} Baz (Either String a) (Foo a)

instance Functor Foo where fmap f (Bar xs y) = Bar (fmap f xs) (fmap f y) fmap f
(Baz x fy) = Baz (fmap f x) (fmap f fy)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

However, this is not the case for \texttt{Applicative}. Everyone knows of course
about the normal (cartesian product) Applicative instance and the zippy
Applicative instance for list:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Applicative
{[}{]} where pure x = {[}x{]} fs \textless{}*\textgreater{} xs = {[} f x
\textbar{} f \textless{}- fs, x \textless{}- xs {]}

instance Applicative {[}{]} where pure = repeat fs \textless{}*\textgreater{} xs
= zipWith (\$) fs xs \textasciitilde{}\textasciitilde{}\textasciitilde{}

What is also fairly established is that every \emph{noncommutative}
\texttt{Applicative} instance also has a "flipped" version:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- a flipped IO
Applicative data FlipIO a = FlipIO \{ runFlipIO :: IO a \}

instance Applicative FlipIO where pure x = FlipIO (pure x) fi
\textless{}*\textgreater{} xi = FlipIO \$ do x \textless{}- runFlipIO xi f
\textless{}- runFlipIO fi -\/- note the backwards effects return (f x)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data State s a =
State \{ runState :: s -\textgreater{} (a, s) \}

-\/- the normal instance instance Applicative (State s) where pure x = State \$
\textbackslash{}s0 -\textgreater{} (x, s0) fs \textless{}*\textgreater{} xs =
State \$ \textbackslash{}s0 -\textgreater{} let (f, s1) = runState fs s0 (x, s2)
= runState xs s1 in (f x, s2)

-\/- the flipped instance instance Applicative (State s) where pure x = State \$
\textbackslash{}s0 -\textgreater{} (x, s0) fs \textless{}*\textgreater{} xs =
State \$ \textbackslash{}s0 -\textgreater{} let (x, s1) = runState xs s0 (f, s2)
= runState fs s1 in (f x, s2)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
liftA2 (,) getLine getLine

\begin{quote}
hello -\/- asking for the first field world -\/- asking for the second field
("hello", "world") ghci\textgreater{} runFlipIO \$ liftA2 (,) (FlipIO getLine)
(FlipIO getLine) hello -\/- asking for the second field world -\/- asking for
the first field ("world", "hello")
\textasciitilde{}\textasciitilde{}\textasciitilde{}
\end{quote}

Every non-commutative \texttt{Applicative} admits an alternative instance where
"flipping" the order of the "effects" is also a valid \texttt{Applicative}
instance. So, not \texttt{Maybe} or \texttt{Either}, but \texttt{State},
\texttt{{[}{]}}, and \texttt{IO}.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- free "flipped"
Applicative instance data Flipped f a = Flipped \{ runFlipped :: f a \}

-\/- instance where (\textless{}\emph{\textgreater{}) is the same, but the order
of effects is switched instance Applicative f =\textgreater{} Applicative
(Flipped f) where pure = Flipped . pure Flipped f \textless{}}\textgreater{}
Flipped x = Flipped \$ liftA2 (flip (\$)) x f
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Cool. Types that have \texttt{Functor} instances only have one. Types that have
\texttt{Applicative} instances very often have more than one.

So, the obvious next question is...what about \texttt{Monad}s? Is a
\texttt{Monad} instance uniquely determined by its type?

\section{Monad}

The answer wasn't that simple, for me. Yes, \emph{most} \texttt{Applicative}s in
the wild are non-unique, and there was a generating rule. But not so for
\texttt{Monad}s. You can't have a \texttt{Monad} where the effects are switched,
because for \texttt{(\textgreater{}\textgreater{}=)}, you need the effects of
the first action in order to even decide what the effects of the next action
are.

I vaguely remember from my past two data types that are very similar yet have
very different \texttt{Monad} and \texttt{Applicative} instances: (finite)
lists, (infinite) {[}streams{]}. From the outset, the two have almost identical
structure. A \texttt{Stream} is just a list with no \texttt{{[}{]}}/nil:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Stream a = a
:\textasciitilde{} Stream a \textasciitilde{}\textasciitilde{}\textasciitilde{}

The \texttt{Functor} instance is identical:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Functor
Stream where fmap f (x :\textasciitilde{} xs) = f x :\textasciitilde{} fmap f xs
\textasciitilde{}\textasciitilde{}\textasciitilde{}

And the (only??) \texttt{Applicative} instance is the \texttt{ZipList} instance
for lists:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Applicative
Stream where pure x = x :\textasciitilde{} pure x (f :\textasciitilde{} fs)
\textless{}\emph{\textgreater{} (x :\textasciitilde{} xs) = f x
:\textasciitilde{} (fs \textless{}}\textgreater{} xs)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

The \texttt{Monad} instance is however very different from that of lists:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Monad Stream
where return x = x :\textasciitilde{} return x xs \textgreater{}\textgreater{}=
f = join' (fmap f xs) where join' :: Stream (Stream a) -\textgreater{} Stream a
join' ((x :\textasciitilde{} \emph{) :\textasciitilde{} yss) = x
:\textasciitilde{} join' (fmap tail' yss) tail' (} :\textasciitilde{} xs) = xs
\textasciitilde{}\textasciitilde{}\textasciitilde{}

The \texttt{Monad} instance itself is actually interesting enough to write
about. It all revolves around \texttt{join}, where \texttt{join} takes a stream
of streams and creates a stream \emph{of the diagonals}. So it takes the first
element of the first stream, the second element of the second stream, the third
element of the third stream, etc.

This is actually a special case of the \texttt{Monad} instance for all
fixed-sized ordered containers. A length 5 vector, for example, will have the
same \texttt{Applicative} and \texttt{Monad} instance as described here:
\texttt{(\textless{}*\textgreater{})} with "zipping", and \texttt{join} with
grabbing the diagonal of the 5-vector of 5-vectors.

This was a promising lead, but, it doesn't take \emph{too} much thought to see
that neither lists nor \texttt{Stream} are appropriate for \emph{both}
instances.

\textless{}div class="note"\textgreater{} \textbf{Aside}

In case you were wondering, here is an elaboration :D

\begin{itemize}
\item
  Fixed length vectors can't have the normal list Applicative instance at all,
  unless they are of size 0 or 1. That's because the result after
  \texttt{(\textless{}*\textgreater{})}, the resulting list's length is the
  product of the original lists. So you can forget the \texttt{Monad} instance,
  too.
\item
  Streams give you no luck, either. The easiest way to see is by considering the
  analogous \texttt{Monad} instance, where \texttt{join} is the straight-up
  concatenation. \texttt{m\ \textgreater{}\textgreater{}=\ return\ ==\ m} is
  clearly violated. If \texttt{m} is an infinite list, \texttt{fmap\ return}
  gives you an infinite list of infinite lists, "joining"/concatenating them
  back will just give you an infinite list of the first item in \texttt{m}.

  To put succincently, for \texttt{Stream}, \texttt{concat\ ==\ head}.
\item
  Lists can have the \texttt{Applicative} instance fine, but not the
  \texttt{Monad} instance. Here we assume that zipping and "getting the
  diagonal" go only as "far as possible", and stop when one of the lists is too
  short.

  This one is a little trickier, but the weakness is when you have lists of
  lists of lists of different lengths.

  \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
  let counterexample = {[}{[}{[}1{]}{]}, {[}{[}{]}, {[}2,3{]}{]}{]}
  ghci\textgreater{} join counterexample {[}{[}1{]}, {[}2,3{]}{]}
  ghci\textgreater{} join. join \$ counterexample {[}1,3{]} ghci\textgreater{}
  fmap join counterexample {[}{[}1{]}, {[}{]}{]} ghci\textgreater{} join . fmap
  join \$ counterexample {[}1{]}
  \textasciitilde{}\textasciitilde{}\textasciitilde{}

  For a monad, joining the inner layer and then joining it all should be the
  same as joining it all and joining it all. The order of the joining shouldn't
  count. We can see this in the more haskelly monad laws by noting:

  \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
  id \textless{}=\textless{} (id \textless{}=\textless{} id) \$ counterexample
  {[}1,2{]} ghci\textgreater{} (id \textless{}=\textless{} id)
  \textless{}=\textless{} id \$ counterexample {[}1{]}
  \textasciitilde{}\textasciitilde{}\textasciitilde{}

  So, dead end here.
\end{itemize}

\textless{}/div\textgreater{}

So I didn't really have any leads at that point; I tried a couple of other paths
but nothing really panned out. So I shelved it for a while.

\section{Revelation}

Several centuries later{[}\^{}timeframe{]}, the final revelation came as many
revelations do in Haskell -\/-\/- from a hint by Edward Kmett. He pointed out
something interesting regarding a \texttt{Monad} instance that I had yet to
notice:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Monoid w
=\textgreater{} Monad ((,) w) where
\textasciitilde{}\textasciitilde{}\textasciitilde{}

This is the classic "Writer" monad instance, which is literally about as old as
monads in functional programming is.

The key is that the \texttt{Monad} instance of \texttt{(w,)} depends on the
\texttt{Monoid} instance of \texttt{w}. This is the "log", so to speak. You need
a \texttt{Monoid} instance in order to make the \texttt{Monad} instance...and
the behavior of the \texttt{Monad} instance is directly determined by the
behavior of the \texttt{Monoid} instance of \texttt{w}.

And...\texttt{Monoid} instances in Haskell are rarely ever unique! A different
\texttt{Monoid} instance would create a very different \texttt{Monad} instance
for the same type!

So, by factoring out the dependency on an external \texttt{Monoid} instance, you
get...

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Two a = One a
\textbar{} Two a

instance Functor Two where fmap f (One a) = One (f a) fmap f (Two a) = Two (f a)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

and...voila! There it is!

This type is basically equivalent to \texttt{(Bool,\ a)}. And \texttt{Bool} has
multiple \texttt{Monoid}s on it. Instead of requiring an outside \texttt{Monoid}
instance, we can encode the instance directly into the behavior of
\texttt{(\textgreater{}\textgreater{}=)}. And here we go!

Our instances are basically the \texttt{Writer} instance for
\texttt{(Bool,\ a)}, with different \texttt{Monoid} instances for \texttt{Bool}.

The first instance:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Applicative
Two where pure = One One f \textless{}\emph{\textgreater{} One x = One (f x) One
f \textless{}}\textgreater{} Two x = Two (f x) Two f
\textless{}\emph{\textgreater{} One x = Two (f x) Two f
\textless{}}\textgreater{} Two x = Two (f x)

instance Monad Two where return = One One x \textgreater{}\textgreater{}= f = f
x Two x \textgreater{}\textgreater{}= f = case f x of One y -\textgreater{} Two
y Two y -\textgreater{} Two y
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which represents the monoids formed by \texttt{(\&\&)} with \texttt{True} or by
\texttt{(\textbar{}\textbar{})} with \texttt{False} (depending on which one you
pick as \texttt{True} and which one you pick as \texttt{False}; the two
instances are isomorphic)

The second:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Applicative
Two where pure = One One f \textless{}\emph{\textgreater{} One x = One (f x) One
f \textless{}}\textgreater{} Two x = Two (f x) Two f
\textless{}\emph{\textgreater{} One x = Two (f x) Two f
\textless{}}\textgreater{} Two x = One (f x)

instance Monad Two where return = One One x \textgreater{}\textgreater{}= f = f
x Two x \textgreater{}\textgreater{}= f = case f x of One y -\textgreater{} Two
y Two y -\textgreater{} One y
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which represents the monoid formed by \texttt{(/=)} (or "XOR") with
\texttt{False}.

And there you go. One type, two possible unique, non-isomorphic \texttt{Monad}
instances.

\textless{}div class="note"\textgreater{} \textbf{Aside}

One interesting thing to note is that the Monad instance for
\texttt{(-\textgreater{})\ a} requires no monoid constraint, and the Monad
instance for \texttt{(,)\ a} \emph{does}.

Interestingly enough, if we look at \emph{comonads}, the Comonad instance for
\texttt{(-\textgreater{})\ a} \emph{does} require a monoid constraint on
\texttt{a} (so for example there are many unique Comonad instances for things
isomorphic to \texttt{(-\textgreater{})\ a} where \texttt{a} has more than one
Monoid instance) and and the Comonad instance for \texttt{(,)\ a} \emph{does
not} require a monoid constraint on \texttt{a}.

Is there some duality at play here?

The answer is, apparently, yes! But according to Edward Kmett, it is one that is
pretty hard to arrive at and a big headache and overall not worth the time to
dig into. So you're going to have to take my second-hand word for it.
\textless{}/div\textgreater{}

\end{document}
