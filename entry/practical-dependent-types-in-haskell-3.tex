\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Practical Dependent Types: A Deeper Look at Proofs \% Justin Le

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-3.html}{in
Code}}.}

Hi! This will be the final post of the
\href{https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html}{dependently
typed neural network series}. This post has been long put-off because there
really wasn't \emph{too} much more we can learn about dependent types and
programming with dependent types from this example. Still, this example still
has a bit more to offer us, so let's take one last look :) Think of this post as
an epilogue.

In
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html}{Part
1}, we tried solving our problem in an "untyped" way, recognized all of those
Haskell red flags, and then added types to make things safer and reap benefits
in API clarity, compiler support, and a smoother code writing experience. In
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html}{Part
2}, we looked at how integrating our typed programs with the real world, where
types might vary at runtime, by levering existential types in two different
forms.

\section{The Secret Life of Proofs}

So far in this journey, we've hand-waved the idea of "proofs", and their role in
this dependently typed programming. In fact, I've sort of intentionally left the
idea vague, because I feel like a lot of other dependent type
introductions/tutorials over-emphasize proofs, to the point there is a public
impression that
\href{https://www.reddit.com/r/haskell/comments/62uv6g/verify_your_typeclass_instances_in_haskell_today/dfpt2g7/}{dependently
typed programming is all about proofs}:

\begin{quote}
I think dependent types are pretty cool, but honestly the sheer difficulty jump
from quickcheck tests to actual proofs to me seems a bit too massive to justify
having to deal with them much.

I think if we just had testable functions (basically just predicates that should
always return true) alongside classes that could be quickchecked against. And
actually took it very seriously when an instance isn't lawful (basically just
disallow it almost always), then I think we would be in a pretty darn good spot.
\end{quote}

There's a popular (mis?)conception that dependent types are basically a
replacement for QuickCheck, or refinement types (like Liquid Haskell). But
really, as we have seen, they are much more -\/-\/- they let you leverage the
compiler to help you write your code, help you enforce properties at the
structural level for your types, create more expressive API's, and much more.
They aren't "just" to prove properties about your program.

In reality, the idea of dependent types and the idea of proofs sort of are
separate but complementing ideas. Dependent types enable this "proofy" style
discussed in the comment, but, also, the ability to dynamically construct and
manipulate proofs opens up many doors for the capabilities of dependently typed
programs.

\subsection{What are they?}

In the context of dependent types (in Haskell), a "proof" is general
(non-rigorous, informal) term for a \emph{runtime value} that GHC/Haskell can
use for \emph{type-level} shenanigans. In other words, it's a \emph{term-level}
witness for a \emph{type-level} truth.

It's the critical \emph{run-time} values that we use to power our
\emph{type-level} fun, and are also commonly known as "witnesses".

I don't believe there is any rigorous definition, but the term comes up whenever
we talk about generating or using run-time values that give us type-level power.

In this article, the simplest example of something that can be called a proof or
a witness is the singleton for \texttt{Nat}s: A value of type \texttt{Sing\ n}
(for \texttt{Nat\ n}) "witnesses" a \texttt{KnownNat\ n} constraint.

We saw it earlier when we wanted to pass along evidence that our \texttt{n} has
an instance of \texttt{KnownNat}:

\texttt{haskell\ nIsKnownNatWePromise\ ::\ forall\ n.\ Sing\ n\ -\textgreater{}\ Integer\ nIsKnonwNatWePromise\ =\ \textbackslash{}case\ \ \ \ \ SNat\ -\textgreater{}\ natVal\ (Proxy\ ::\ Proxy\ n)}

In the case statement above, in the \texttt{SNat\ -\textgreater{}} branch, GHC
knows that \texttt{n} has a \texttt{KnownNat} instance. This runtime value,
\texttt{SNat}, carries the fact that we have an instance of
\texttt{KnownNat\ n}. Remember that
\texttt{natVal\ ::\ KnownNat\ n\ =\textgreater{}\ p\ n\ -\textgreater{}\ Integer}
-\/- it only works of \texttt{n} is an instance of \texttt{KnownNat}.
\texttt{SNat\ ::\ Sing\ n} is a runtime value that "gives us" that instance.
It's a "proof" that \texttt{n} is an instance of \texttt{KnownNat}.

\subsection{First-Class Values}

The \emph{key} to their usefulness is that, as runtime values, they are
\emph{first-class values} in Haskell. We can manipulate them, pass them,
construct them, etc., just as if they were normal values. You can construct
complex proofs from simple ones, compose them, etc.

For example, check out the function \texttt{\%:+} from the \emph{singletons}
package:

\texttt{haskell\ (\%:+)\ ::\ forall\ (n\ ::\ Nat)\ (m\ ::\ Nat).\ Sing\ n\ -\textgreater{}\ Sing\ m\ -\textgreater{}\ Sing\ (n\ +\ m)}

Given, at runtime, a witness for \texttt{KnownNat\ n} (our \texttt{Sing\ n}) and
a witness for \texttt{KnownNat\ m}, we can construct, at runtime a witness for
\texttt{KnownNat\ (n\ +\ m)}:

\texttt{haskell\ add\ ::\ Integer\ -\textgreater{}\ Integer\ -\textgreater{}\ Integer\ add\ x\ y\ =\ withSomeSing\ x\ \$\ \textbackslash{}(sx\ ::\ Sing\ x)\ -\textgreater{}\ \ \ \ \ \ \ \ \ \ \ withSomeSing\ y\ \$\ \textbackslash{}(sy\ ::\ Sing\ y)\ -\textgreater{}\ \ \ \ \ \ \ \ \ \ \ \ \ case\ sx\ \%:+\ sy\ of\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ z\ is\ x\ +\ y\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (SNat\ ::\ Sing\ z)\ -\textgreater{}\ natVal\ (Proxy\ ::\ Proxy\ z)}

\texttt{haskell\ ghci\textgreater{}\ add\ 5\ 7\ 12}

\textless{}!-\/- Uniting Existential Contexts -\/-\textgreater{}
\textless{}!-\/-
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-
-\/-\textgreater{}

\textless{}!-\/- In the last exercise, we introduced \texttt{SomeNet}:
-\/-\textgreater{}

\textless{}!-\/- \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell
-\/-\textgreater{} \textless{}!-\/- !!!dependent-haskell/NetworkTyped2.hs "data
SomeNet" -\/-\textgreater{} \textless{}!-\/-
\textasciitilde{}\textasciitilde{}\textasciitilde{} -\/-\textgreater{}

\textless{}!-\/- \texttt{SomeNet} is actually a big step above
\texttt{OpaqueNet} because now its external API -\/-\textgreater{}
\textless{}!-\/- (the size of vectors that it takes/outputs) is now
existentially quantified, so -\/-\textgreater{} \textless{}!-\/- this presents
some unique challenges. -\/-\textgreater{}

\textless{}!-\/- Recall that we was able to write \texttt{runOpaqueNet} without
much problems, because -\/-\textgreater{} \textless{}!-\/- the types guaranteed
that everything made sense: -\/-\textgreater{}

\textless{}!-\/- \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell
-\/-\textgreater{} \textless{}!-\/- !!!dependent-haskell/NetworkTyped2.hs
"runOpaqueNet ::" -\/-\textgreater{} \textless{}!-\/-
\textasciitilde{}\textasciitilde{}\textasciitilde{} -\/-\textgreater{}

\textless{}!-\/- In fact, GHC actually enforces that everything works out
-\/-\/- it knows that you -\/-\textgreater{} \textless{}!-\/- run a
\texttt{n\textquotesingle{}} with an \texttt{R\ i}, and sees that \texttt{x} is
an \texttt{R\ i}, and also knows that -\/-\textgreater{} \textless{}!-\/-
whatever the internal structure is, an \texttt{R\ o} is always what pops out
regardless -\/-\textgreater{} \textless{}!-\/- if \texttt{hs} is
\texttt{\textquotesingle{}{[}{]}}, \texttt{\textquotesingle{}{[}5,3{]}} or
\texttt{\textquotesingle{}{[}100,200,4{]}}. -\/-\textgreater{}

\textless{}!-\/- But can we write a sensible \texttt{runSomeNet}? What would the
type even be? Let's -\/-\textgreater{} \textless{}!-\/- try an initial attempt:
-\/-\textgreater{}

\textless{}!-\/- \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell
-\/-\textgreater{} \textless{}!-\/- runSomeNet :: (KnownNat i, KnownNat o)
-\/-\textgreater{} \textless{}!-\/- =\textgreater{} SomeNet -\/-\textgreater{}
\textless{}!-\/- -\textgreater{} R i -\/-\textgreater{} \textless{}!-\/-
-\textgreater{} R o -\/-\textgreater{} \textless{}!-\/- runSomeNet n x = case n
of -\/-\textgreater{} \textless{}!-\/- SNet n' -\textgreater{} runNet n' x
-\/-\textgreater{} \textless{}!-\/-
\textasciitilde{}\textasciitilde{}\textasciitilde{} -\/-\textgreater{}

\textless{}!-\/- Hm. This clearly won't work, because the network inside
\texttt{SomeNet} might not -\/-\textgreater{} \textless{}!-\/- even take the
\texttt{R\ i} that we give it. What if it takes a \texttt{R\ 5}, but we pass in
-\/-\textgreater{} \textless{}!-\/- an \texttt{R\ 10}? Remember, because of
universal quantification, \texttt{runSomeNet} has to -\/-\textgreater{}
\textless{}!-\/- work with \emph{any} \texttt{i}, be it 5, 10, or 100. But the
internal network might not -\/-\textgreater{} \textless{}!-\/- be so
accommodating. If we try to write it, GHC will complain immediately. In
-\/-\textgreater{} \textless{}!-\/- short, \texttt{runSomeNet} should be
\emph{partial}, and return a \texttt{Maybe}. -\/-\textgreater{}

\textless{}!-\/- \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell
-\/-\textgreater{} \textless{}!-\/- runSomeNet :: (KnownNat i, KnownNat o)
-\/-\textgreater{} \textless{}!-\/- =\textgreater{} SomeNet -\/-\textgreater{}
\textless{}!-\/- -\textgreater{} R i -\/-\textgreater{} \textless{}!-\/-
-\textgreater{} Maybe (R o) -\/-\textgreater{} \textless{}!-\/-
\textasciitilde{}\textasciitilde{}\textasciitilde{} -\/-\textgreater{}

\textless{}!-\/- We can see another problem here -\/-\/- We can't have it return
\texttt{R\ o}, of course, -\/-\textgreater{} \textless{}!-\/- because \texttt{o}
is universally quantified here, so the user can decide \texttt{o}. But
-\/-\textgreater{} \textless{}!-\/- \texttt{o} isn't free for the user to
pick...it's determined by the network inside -\/-\textgreater{} \textless{}!-\/-
\texttt{SNet}. So, the \texttt{o} has to be existentially quantified. We'll
return a -\/-\textgreater{} \textless{}!-\/- continuation-style existentially
quantified \texttt{o} here, because \emph{hmatrix} doesn't -\/-\textgreater{}
\textless{}!-\/- come with a built-in constructor-style quantifier:
-\/-\textgreater{}

\textless{}!-\/- \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell
-\/-\textgreater{} \textless{}!-\/- runSomeNet :: KnownNat i -\/-\textgreater{}
\textless{}!-\/- =\textgreater{} SomeNet -\/-\textgreater{} \textless{}!-\/-
-\textgreater{} R i -\/-\textgreater{} \textless{}!-\/- -\textgreater{} (forall
o. KnownNat o =\textgreater{} R o -\textgreater{} r) -\/-\textgreater{}
\textless{}!-\/- -\textgreater{} Maybe r -\/-\textgreater{} \textless{}!-\/-
\textasciitilde{}\textasciitilde{}\textasciitilde{} -\/-\textgreater{}

\textless{}!-\/- And finally, we have a type signature that makes sense: give a
\texttt{SomeNet} and an -\/-\textgreater{} \textless{}!-\/- \texttt{R\ i}, and
possibly get in return an existentially quantified \texttt{R\ o}. If the
\texttt{R\ -\/-\textgreater{}\ \textless{}!-\/-\ i} doesn't fit into the
\texttt{SomeNet}, the result will be \texttt{Nothing}. -\/-\textgreater{}

\textless{}!-\/- Now that we have a type, let's try implementing it:
-\/-\textgreater{}

\textless{}!-\/- \textasciitilde{}\textasciitilde{}\textasciitilde{}haskell
-\/-\textgreater{} \textless{}!-\/- runSomeNet :: KnownNat i -\/-\textgreater{}
\textless{}!-\/- =\textgreater{} SomeNet -\/-\textgreater{} \textless{}!-\/-
-\textgreater{} R i -\/-\textgreater{} \textless{}!-\/- -\textgreater{} (forall
o. KnownNat o =\textgreater{} R o -\textgreater{} r) -\/-\textgreater{}
\textless{}!-\/- -\textgreater{} Maybe r -\/-\textgreater{} \textless{}!-\/-
runSomeNet n x f = case n of -\/-\textgreater{} \textless{}!-\/- SNet (n' ::
Network i' hs o) -\textgreater{} -\/-\textgreater{} \textless{}!-\/- if natVal
(Proxy @i') == natVal (Proxy @i) -\/-\textgreater{} \textless{}!-\/- then Just
(f (runNet n' x)) -\/-\textgreater{} \textless{}!-\/- else Nothing
-\/-\textgreater{} \textless{}!-\/-
\textasciitilde{}\textasciitilde{}\textasciitilde{} -\/-\textgreater{}

\textless{}!-\/- First, we open it and check if the \texttt{i\textquotesingle{}}
inside the \texttt{SNet} is the same as the -\/-\textgreater{} \textless{}!-\/-
\texttt{i} we get as input. If it is, we return \texttt{Just}, and if not,
\texttt{Nothing}. -\/-\textgreater{}

\textless{}!-\/- Unfortunately, this doesn't really work. That's because our
silly little \texttt{==} -\/-\textgreater{} \textless{}!-\/- doesn't actually
prove to GHC that the two lengths are equal. GHC will still -\/-\textgreater{}
\textless{}!-\/- believe that \texttt{i} and \texttt{i\textquotesingle{}} are
different, in general. -\/-\textgreater{}

\textless{}!-\/- And why should it believe that
\texttt{i\ \textasciitilde{}\ i\textquotesingle{}}, just because of \texttt{==}?
Remember that -\/-\textgreater{} \textless{}!-\/- \texttt{==} is a user-defined
function, and can return anything. Why should the type -\/-\textgreater{}
\textless{}!-\/- checker be
\textasciitilde{}\textasciitilde{}fooled\textasciitilde{}\textasciitilde{}
convinced by a silly user-defined function? -\/-\textgreater{}

\textless{}!-\/- The problem is that the \texttt{Bool} returned doesn't really
tell the compiler -\/-\textgreater{} \textless{}!-\/- anything. It's just a bit
of information, and doesn't really come with any -\/-\textgreater{}
\textless{}!-\/- proof that the two types are actually equal. What we need is a
way to \emph{prove} -\/-\textgreater{} \textless{}!-\/- to the compiler (and the
typechecker) that the two are equal. -\/-\textgreater{}

\textless{}!-\/- \#\#\# Proofs -\/-\textgreater{}

\textless{}!-\/- We got far without talking about proofs, but really, you can
only expect to -\/-\textgreater{} \textless{}!-\/- get so far when talking about
dependently typed programming without talking -\/-\textgreater{}
\textless{}!-\/- about proofs! Proofs are, in a way, essential to the very
essence of -\/-\textgreater{} \textless{}!-\/- dependently typed
programming.{[}\^{}proofs{]} -\/-\textgreater{}

\textless{}!-\/- {[}\^{}proofs{]}: One thing I've noticed, however, is that a
lot of dependently typed -\/-\textgreater{} \textless{}!-\/- programming
introductions \emph{begin} with proofs, and go to applications later.
-\/-\textgreater{} \textless{}!-\/- Here, I hope I can change that trend by
starting with the applications, and -\/-\textgreater{} \textless{}!-\/- bringing
proofs later after being able to see their motivation! -\/-\textgreater{}

\end{document}
