<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 3) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back! This article is part 3 of our journey through the singleton design pattern, and the great singletons library! This post will be a continuation of Part 1 and Part 2, so if you haven’t read those first, now would be a good time to pause and do so and also work on some of the exercises. Today we will be expanding on the ideas in those posts by working with more complex relationships between values and lifting functions on values to functions on types. Like the previous posts, we will start by writing things “by hand”, and then jumping into the singletons library and seeing how the framework gives you tools to work with these ideas in a smoother way. Code in this post is built on GHC 8.4.3 with the lts-12.9 snapshot (so, singletons-2.4.1)."><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 3)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-3.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-3.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Introduction to Singletons (Part 3)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-3.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-3.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-3.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back! This article is part 3 of our journey through the <em>singleton design pattern</em>, and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>This post will be a continuation of <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Part 1</a> and <a href="https://blog.jle.im/entry/introduction-to-singletons-2.html">Part 2</a>, so if you haven’t read those first, now would be a good time to pause and do so and also work on some of the exercises. Today we will be expanding on the ideas in those posts by working with more complex relationships between values and lifting functions on values to functions on types. Like the previous posts, we will start by writing things “by hand”, and then jumping into the singletons library and seeing how the framework gives you tools to work with these ideas in a smoother way.</p>
<p>Code in this post is built on <em>GHC 8.4.3</em> with the <em><a href="https://www.stackage.org/lts-12.9">lts-12.9</a></em> snapshot (so, singletons-2.4.1).</p>
<h2 id="review">Review</h2>
<p>In the first post we looked at the <code>Door</code> type, indexed with a phantom type of kind <code>DoorState</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  data DoorState = Opened | Closed | Locked</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    deriving (Show, Eq)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  |])</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</a></code></pre></div>
<p>This gives us (at least) three distinct types <code>Door 'Opened</code>, <code>Door 'Closed</code>, and <code>Door 'Locked</code>, which can be used to represent opened, closed, and locked doors, respectively.</p>
<p>This scheme gives us a few super-powers:</p>
<ul>
<li><p>The fact that these are three <em>distinct</em> types allows us to enforce type-safety by prohibiting operations on certain types of doors.</p>
<p>We saw this in the types of functions like <code>openDoor :: Door 'Opened -&gt; Door 'Closed</code>, which can only work on non-locked and closed doors.</p></li>
<li><p>Because the types are distinct, this allows our functions to be more expressive by stating how they change door states, programmatically.</p>
<p>We saw this to a certain extent in functions like <code>openDoor</code>, <code>closeDoor</code>, and <code>lockDoor</code>, where the function type signatures tell the user how the input and output doors are related. However, we will be taking this to a new level in this post.</p></li>
<li><p>But, because these types are all “derived” from the same type, we can also write functions that work on <em>all</em> <code>Door</code>s. We saw this in functions like <code>lockAnyDoor</code>, and we also exploit this in our definition of <code>SomeDoor</code>.</p>
<p>Essentially we also get a fourth type “for free”: <code>forall s. Door s</code>, the type that can be used as any door. It’s a subtype of all three of the above types!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p></li>
</ul>
<p>Then we talked about situations where we want to “not care” about the door status in the type system, or when we want to return a door with a state that is not known statically, and must be determined dynamically at runtime. After going through many “analogous” and equivalent type, we arrived at the existential wrapper <code>SomeDoor</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">mkSomeDoor ds mat <span class="fu">=</span> withSomeSing ds <span class="fu">$</span> \dsSing <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="dt">MkSomeDoor</span> dsSing mat</a></code></pre></div>
<p>We must be careful to pack the <code>Sing s</code> with the <code>Door s</code>, so that we can pattern match at runtime to determine what the original <code>s</code> was.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">checkOpened ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">checkOpened (<span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> _) <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">checkOpened (<span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> _) <span class="fu">=</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">checkOpened (<span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> _) <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> mkSomeDoor <span class="dt">Opened</span> <span class="st">&quot;Oak&quot;</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="kw">let</span> y <span class="fu">=</span> mkSomeDoor <span class="dt">Closed</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">ghci<span class="fu">&gt;</span> checkOpened x</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dt">True</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">ghci<span class="fu">&gt;</span> checkOpened y</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dt">False</span></a></code></pre></div>
<p>Finally, we talked a bit about the “unified” singleton system that the <em>singleton</em> library offers. This included things like <code>SingI</code> to implicitly pass singletons, and the <code>SingKind</code> kind-class that associates types with their lifted kinds and lets you reify and reflect with functions like <code>withSomeSing</code> and <code>fromSing</code>.</p>
<h2 id="more-expressive-restrictions">More Expressive Restrictions</h2>
<p>Let’s write a function that “knocks” on a door in IO:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">knock ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">knock d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>Hm. This doesn’t seem right. We can’t knock on an opened door..can we? We could try enforcing this by writing:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">knockClosed ::</span> <span class="dt">Door</span> &#39;<span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">knockClosed d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="ot">knockLocked ::</span> <span class="dt">Door</span> &#39;<span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">knockLocked d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p>But, that means that the user must pick between one of two functions to open their door. This isn’t quite what we wanted…we want the function to work only for closed or locked doors, and not opened doors.</p>
<p>There are a couple of ways of doing this — we’re going to look at two possible ways involving singletons and the <em>singletons</em> library. Both of these methods allow us to write dependently typed functions that are “type-safe” in more expressive ways than before.</p>
<h3 id="dependently-typed-proofs">Dependently Typed Proofs</h3>
<p>The first way to do this is with a dependently-typed “proof” that an operation is legal.</p>
<p><em>Proofs</em> (in the dependently typed and Curry-Howard sense) are witnesses to some type-level predicate or proposition.</p>
<p>A value-level predicate in Haskell is (generally) a function of type <code>a -&gt; Bool</code>. Given a value of type <code>a</code>, if the function returns <code>True</code>, then the predicate is satisfied. If it returns <code>False</code>, it is not.</p>
<p>A type-level predicate is (generally) a type constructor of kind <code>k -&gt; Type</code>. Given a type of kind <code>k</code>, if <em>a value exists of that type</em>, then the predicate is satisfied. If no value exists, it is not. A value that “proves” a predicate is called a <em>witness</em> or a <em>proof</em>.</p>
<p>We can define a predicate <code>Knockable :: DoorState -&gt; Type</code> as a GADT that only has values if given <code>'Closed</code> and <code>'Locked</code>, but not <code>'Opened</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Knockable</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">KnockClosed</span><span class="ot"> ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="dt">KnockLocked</span><span class="ot"> ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Locked</span></a></code></pre></div>
<p>Now, we have a value of type <code>Knockable 'Closed</code> and <code>Knockable 'Locked</code> (<code>KnockClosed</code> and <code>KnockLocked</code>, respectively), but no value of type <code>Knockable 'Opened</code>. How can we use this?</p>
<p>Well, we can make a version of <code>knock</code> that requires a proof that <code>s</code> is <code>Knockable</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">knock ::</span> <span class="dt">Knockable</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">knock _ d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p><code>knock</code> can now only be called with <code>Closed</code> and <code>Locked</code> doors — do you see why? There is no way to call <code>knock</code> with <code>s ~ 'Opened</code>…because there is no way to pass a value of <code>Knockable 'Opened</code>. No such value exists! There’s no compiler error because it’s “not even wrong”!</p>
<p>This works well if we want to do things at compile-time</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">ghci<span class="fu">&gt;</span> knock <span class="dt">KnockClosed</span> (<span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Birch&quot;</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="dt">Knock</span> knock on <span class="dt">Birch</span> door<span class="fu">!</span></a></code></pre></div>
<h4 id="let-the-compiler-prove-it-for-you">Let the compiler prove it for you</h4>
<p>We can even make it more seamless to use by auto-generating proofs at compile-time, with a general class like <code>Auto</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Provable</span> p a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">    auto ::</span> p a</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Provable</span> <span class="dt">Knockable</span> &#39;<span class="dt">Closed</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    auto <span class="fu">=</span> <span class="dt">KnockClosed</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Provable</span> <span class="dt">Knockable</span> &#39;<span class="dt">Locked</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    auto <span class="fu">=</span> <span class="dt">KnockLocked</span></a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">ghci<span class="fu">&gt;</span> knock auto (<span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Acacia&quot;</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="dt">Knock</span> knock on <span class="dt">Acacia</span> door<span class="fu">!</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">ghci<span class="fu">&gt;</span> knock auto (<span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Jungle&quot;</span>)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="dt">COMPILER</span> <span class="dt">ERROR</span><span class="fu">!!</span> <span class="dt">COMPILER</span> <span class="dt">ERROR</span><span class="fu">!!</span></a></code></pre></div>
<p>Such a typeclass exists in libraries like <em><a href="http://hackage.haskell.org/package/type-combinators">type-combinators</a></em> (called <code>Known</code>), and in dependently typed languages like Idris, <code>auto</code> is actually a built-in language keyword that does this automatically!</p>
<h4 id="decidable-predicates">Decidable Predicates</h4>
<p>However, all of this only works if you know what <code>s</code> is at compile-time. What if you don’t? What if you are retrieving <code>s</code> at runtime (like from a <code>SomeDoor</code> or <code>withSomeSing</code>), or you are forced to handle all possible <code>s</code>s?</p>
<p>To do this, we’re going to take advantage of a property of some predicates called “decidability”. We say that a predicate is <em>decidable</em> if, for any input type, we can say whether or not the predicate is satisfiable.</p>
<p>We say that a predicate <code>p</code> in Haskell is decidable if we can write:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">decidePred</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Sing</span> a               <span class="co">-- ^ given a type</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Decision</span> (p a)       <span class="co">-- ^ return a decision</span></a></code></pre></div>
<p>Where:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Decision</span> a <span class="fu">=</span> <span class="dt">Proved</span> a                  <span class="co">-- ^ a value of a exists</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">                <span class="fu">|</span> <span class="dt">Disproved</span> (<span class="dt">Refuted</span> a)     <span class="co">-- ^ a value of a cannot exist</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="co">-- | The data type with no values</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="co">-- | &#39;a&#39; cannot exist.  Commonly also called `Not`</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="kw">type</span> <span class="dt">Refuted</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> <span class="dt">Void</span></a></code></pre></div>
<p><code>Decision a</code> is kinda like a <code>Maybe a</code>, except instead of <code>Nothing</code>, we include a proof that the predicate is <em>not</em> true.</p>
<p>For those unfamiliar with the <code>a -&gt; Void</code> idiom (often called <code>Not a</code>, or <code>Refuted a</code>), <code>a -&gt; Void</code> is a type we use in Haskell to represent the fact that it is impossible to construct a value of type <code>a</code>. That’s because if you could, then you could give it to an <code>a -&gt; Void</code> to get a value of type <code>Void</code>, which is impossible to have.</p>
<p>It’s a lot to handle all at once, so let’s look at an example. Is <code>Knockable</code> a decidable predicate? Yes!</p>
<p>We need to write a function:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> s)</a></code></pre></div>
<p>I recommend taking a moment and trying to implement this yourself. Remember to enable <code>-Wall</code> to make sure you’re handling all potential pattern matching cases.</p>
<p>Are you ready? Here’s a solution:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> s)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">isKnockable <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Disproved</span> <span class="fu">$</span> \<span class="kw">case</span>            <span class="co">-- s ~ &#39;Opened</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockClosed</span>           <span class="co">-- s ~ &#39;Closed</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockLocked</span>           <span class="co">-- s ~ &#39;Locked</span></a></code></pre></div>
<p>This definition should seem pretty straightforward for the <code>SClosed</code> and <code>SLocked</code> branches. <code>isKnockable SClosed :: Decision (Knockable 'Closed)</code>, we give <code>Proved KnockClosed</code>, which gives us just that!</p>
<p>However, <code>isKnockable SOpened :: Decision (Knockable 'Opened)</code>. We can’t use <code>Proved :: a -&gt; Decision a</code>, because no such value of type <code>Knockable 'Opened</code> exists. So, we have to say that we <em>disprove</em> it: we have to prove to GHC that no such type could possibly exist. We do this by providing a function of type <code>Refuted (Knockable 'Opened)</code>, or type <code>Knockable 'Opened -&gt; Void</code>.</p>
<p>We can write it like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">disproveOpened ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">disproveOpened k <span class="fu">=</span> <span class="kw">case</span> k <span class="kw">of</span> {}             <span class="co">-- empty pattern match</span></a></code></pre></div>
<p>And we’re good to go!</p>
<p>How does this work?</p>
<p>Well, remember, we have to pattern match on the possible inputs. However, we can’t use any of the “legal” patterns:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">disproveOpened ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">disproveOpened k <span class="fu">=</span> <span class="kw">case</span> k <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    <span class="dt">KnockClosed</span> <span class="ot">-&gt;</span> <span class="fu">...</span>    <span class="co">-- not a valid pattern, since it&#39;s `Knockable &#39;Closed`</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="dt">KnockLocked</span> <span class="ot">-&gt;</span> <span class="fu">...</span>    <span class="co">-- not a valid pattern, since it&#39;s `Knockable &#39;Locked`</span></a></code></pre></div>
<p>If you include either of those patterns, GHC will complain. So, there is no valid pattern to match on… so <code>disproveOpened = \case</code> is enough to write the function <code>Knockable 'Opened -&gt; Void</code>.</p>
<p>We can use this decision function, finally, to handle an arbitrary <code>Door</code> whose status we not know until runtime:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">knockSomeDoor</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">SomeDoor</span>     <span class="co">-- ^ status not known until you pattern match at runtime</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">knockSomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> isKnockable s <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    <span class="dt">Proved</span> k    <span class="ot">-&gt;</span> knock k d</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    <span class="dt">Disproved</span> _ <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;No knocking allowed!&quot;</span></a></code></pre></div>
<h4 id="perspective-on-proofs">Perspective on Proofs</h4>
<p>We briefly touched on a very simple version of a dependently typed proof, and how to “prove” properties.</p>
<p>If you have heard things about dependently typed programming before, you might have heard that a lot of it involves “proving properties about your programs” and “forcing you to provide proofs for all of your actions”. The idea of a “proof” might seem a bit scary and “mathematical” to those coming from a software development world.</p>
<p>However, as we just saw, working with proofs and decisions of proofs can be as simple as a couple lines of GADTs and dependent pattern matches:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Knockable</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    <span class="dt">KnockClosed</span><span class="ot"> ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    <span class="dt">KnockLocked</span><span class="ot"> ::</span> <span class="dt">Knockable</span> &#39;<span class="dt">Locked</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> s)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">isKnockable <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Disproved</span> <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockClosed</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Proved</span> <span class="dt">KnockLocked</span></a></code></pre></div>
<p><code>Knockable</code> is our <em>predicate</em>, values of type <code>Knockable s</code> are our <em>proofs</em> (or witnesses), and <code>isKnockable</code> is our <em>decision function</em>. So, when we see a function like:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">knock ::</span> <span class="dt">Knockable</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>We can read the type signature as: “Knocking requires both a <code>Door s</code> and a <em>proof</em> that the door’s status is <code>Knockable</code>”. It makes it impossible for us to run <code>knock</code> on a status that is not <code>Knockable</code>, like, say, <code>'Opened</code>.</p>
<p>In this light, the role of a proof is like a “key” that a type (like <code>'Closed</code>) must provide to “unlock” functions like <code>knock</code>.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> A <em>decision function</em> is a function to generate these proofs (or prove that they are impossible) for given types.</p>
<p>Proofs are often thought of as “compiler tricks”, or things that exist only to appease the compiler. Compilers of languages that encourage heavy usage of proofs (like Agda, Coq, Idris) actually implement something called <em>proof erasure</em>. That is, values like <code>KnockClosed</code> and <code>KnockLocked</code> might never exist at runtime, since they never actually <em>do</em> anything at runtime. They only exist as ways to limit or enable specific programs from compiling, and serve no purpose after compilation. GHC Haskell does not implement proof erasure at the time of this post (current GHC version 8.6), but if proofs like this become commonplace, you might be reading this during a time where GHC Haskell erases proofs like <code>Knockable</code> witnesses :)</p>
<h4 id="the-role-of-singletons">The Role of Singletons</h4>
<p>Proofs themselves might not play a role at run-time, but generating/deciding them with types requires being able to pattern match and work with <em>types</em> at run-time. Because of this, singletons play an important practical role in working with proofs in Haskell.</p>
<p>After all, remember the type of our decision function:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">isKnockable ::</span> <span class="dt">Sing</span> a <span class="ot">-&gt;</span> <span class="dt">Decision</span> (<span class="dt">Knockable</span> a)</a></code></pre></div>
<p>The <code>Sing</code> allows <code>isKnockable</code> to pattern match and inspect the <em>type</em> <code>a</code> to create your proof.</p>
<p>In this light, the <em>singletons</em> library provides many tools for working with proofs and decisions. In fact, the entire <em>Data.Singletons.Decide</em> module is dedicated to working with proofs and decisions. It provides the <code>Decision</code> data type and <code>Refuted</code> type synonym, both featured above.</p>
<p>It also re-exports a particularly useful predicate from <em>base</em>, <em>propositional equality</em>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span><span class="ot"> (:~:) ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="fu">:~:</span> a</a></code></pre></div>
<p>Like how <code>Knockable</code> is a predicate that a given status is “knockable”, <code>'Blah :~:</code> is a predicate that a given type is <em>equal to</em> <code>'Blah</code>. A value of type <code>Knockable s</code> is a proof that <code>s</code> is knockable, and a value of type <code>'Blah :~: a</code> is a proof that <code>a</code> is <em>equal to</em> <code>'Blah</code>.</p>
<p>If you are having trouble seeing how, note the constructors that it allows. Remember that we limit <code>Knockable s</code> to only having “knockable” <code>s</code> by only allowing two constructors, so we can only construct valid values. The same thing happens here – <code>'Blah :~:</code> only has <em>one single constructor</em>: <code>Refl :: 'Blah :~: 'Blah</code>. The only valid constructor is one where the left hand side is equal to the right hand side.</p>
<p>It also offers the “kindclass” <code>SDecide</code>, which provides <em>decision functions</em> for the <code>a :~:</code> predicate:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">class</span> <span class="dt">SDecide</span> k <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">    (%~) ::</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">b ::</span> k)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">         <span class="ot">-&gt;</span> <span class="dt">Decision</span> (a <span class="fu">:~:</span> b)</a></code></pre></div>
<p>For example, <code>Bool</code> is an instance of <code>SDecide</code>, so we have a function:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">(<span class="dt">STrue</span> <span class="fu">%~</span>)<span class="ot"> ::</span> <span class="dt">Sing</span> b <span class="ot">-&gt;</span> <span class="dt">Decision</span> (&#39;<span class="dt">True</span> <span class="fu">:~:</span> b)</a></code></pre></div>
<p>which is a decision function to check if <code>b</code> is equal to <code>'True</code>. You can sort of imagine <code>SDecide</code> as a type-level <code>Eq</code> typeclass, but for “type equality”.</p>
<h3 id="type-level-functions">Type Level Functions</h3>
<p>Dependently typed proofs are useful because they are constructed to exploit the “structure” of the types you create. Essentially, we create a data type (predicate) in a way so that it is impossible to create an “invalid” proof. And, often, if we write our proofs in a clever enough way, we can actually use and combine proofs to generate new proofs.</p>
<p>Personally I find this to be the source of a lot of the “fun” of dependently typed programming — our proofs become first class values, and if we define them in a nice enough way, we can use manipulate them to create new proofs. That’s because they’re just first-class values!</p>
<p>However, a full exploration of this is well beyond the scope of this post. This type of stuff is covered in introductions to dependently typed programming proper. However, this is a singletons post, so I’m just here to give a taste of it to the extent that it is related to singletons :)</p>
<p>We’re now going to look at a method that is less “structural”. In practice, carefully constructing predicates and proofs (ones more complicated than the one we just looked at) requires some up-front cost in thinking about how to best express your predicate, and is sometimes not straightforward. Here is another way to express a similar <code>knock</code> that is slightly more mechanical.</p>
<p>Something we can do is define a type that expresses knockable-or-not-knockable, as a value:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  data Pass = Obstruct | Allow</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  |])</a></code></pre></div>
<p>And we can write a <em>type-level function</em> (implemented as <em>type family</em>) from <code>DoorState</code> to a <code>Pass</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">PassState</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">Pass</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">    <span class="dt">PassState</span> &#39;<span class="dt">Opened</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">    <span class="dt">PassState</span> &#39;<span class="dt">Closed</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    <span class="dt">PassState</span> &#39;<span class="dt">Locked</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a></code></pre></div>
<p>We’ve briefly touched on type families before (in talking about <code>SingKind</code>), but as a quick review, type families act a bit like type-level functions. They take types as input arguments and return types in return.</p>
<p>Like type synonyms, type families can’t be partially applied. They only ever make sense in “fully applied” form, with all arguments given syntactically.</p>
<p>We can inspect how type families are applied by using the <code>:kind!</code> command in ghci:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">PassState</span> &#39;<span class="dt">Opened</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">&#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">PassState</span> &#39;<span class="dt">Closed</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">&#39;<span class="dt">Allow</span></a></code></pre></div>
<p>Armed with this type family, we can write a new version of <code>knock</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">knock ::</span> (<span class="dt">PassState</span> s <span class="fu">~</span> &#39;<span class="dt">Allow</span>) <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">knock d <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Knock knock on &quot;</span> <span class="fu">++</span> doorMaterial d <span class="fu">++</span> <span class="st">&quot; door!&quot;</span></a></code></pre></div>
<p><code>a ~ b</code> is a constraint for <em>type equality</em>. This constraint means that calling <code>knock</code> requires that <code>PassState s</code> being <em>equal</em> to <code>'Allow</code>. So, if attempt to call <code>knock</code> with a <code>'Locked</code> door, <code>PassState 'Locked</code> is <code>'Allow</code>, so the constraint is satisfied and everyone is happy. If we attempt to call <code>knock</code> with an <code>'Opened</code> door, <code>PassState 'Opened</code> is <code>'Obstruct</code>, so the constraint is not satisfied and everyone is sad.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door1 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Closed</span> <span class="st">&quot;Oak&quot;</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">ghci<span class="fu">&gt;</span> <span class="kw">let</span> door2 <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span>&#39;<span class="dt">Opened</span> <span class="st">&quot;Spruce&quot;</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">ghci<span class="fu">&gt;</span> knock door1</a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="dt">Knock</span> knock on <span class="dt">Oak</span> door<span class="fu">!</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">ghci<span class="fu">&gt;</span> knock door2</a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="dt">COMPILE</span> <span class="dt">ERROR</span><span class="fu">!</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="co">--     • Couldn&#39;t match type ‘&#39;Allow’ with ‘&#39;Obstruct’</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8"><span class="co">--             arising from a use of ‘knock’</span></a></code></pre></div>
<p>(Note that we could have just used <code>Bool</code> instead of defining a <code>Pass</code> type, and defining something like a <code>Knockable</code> type family, and test on <code>Knockable s ~ 'True</code>. We’re just going through a new type for the sake of example, and it can be useful because a type like <code>Pass</code> might potentially have even more constructors!)</p>
<h4 id="deciding-at-runtime">Deciding at Runtime</h4>
<p>One nice thing about this way is that the compiler will provide the proof for us. However, how can we run into the same issue as before — what happens if we don’t know <code>s</code> until runtime? How do we prove to the compiler that <code>Passable s</code> is <code>'Allow</code>?</p>
<p>Remember that type families take <em>types</em> as inputs, so we can’t write:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">knockSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">knockSomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> <span class="dt">PassState</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">                                  <span class="co">-- ...</span></a></code></pre></div>
<p>because <code>s</code>, a value, can’t be given to <code>PassState</code>.</p>
<p>What we really want to do is pass <code>s</code>, the singleton representing a type, to <code>PassState</code>, the type family. And then, we want to match on the <em>resulting type</em>, so we can decide what to do based on the result.</p>
<p>If you think about this predicament long enough, you might begin to see a solution. Essentially, we want a function that takes a <em>singleton</em> of <code>s</code>, and return a <em>singleton</em> of <code>PassState s</code>.</p>
<p>In practice, we need to <em>mirror</em> the type-level function <em>at the value level</em>. We need to write a function of type <code>Sing s -&gt; Sing (PassState s)</code>: given a singleton of a type, return a singleton of the type family applied to the type.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">PassState</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)<span class="ot"> ::</span> <span class="dt">Pass</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="dt">PassState</span> &#39;<span class="dt">Opened</span> <span class="fu">=</span> &#39;<span class="dt">Obstruct</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="dt">PassState</span> &#39;<span class="dt">Closed</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    <span class="dt">PassState</span> &#39;<span class="dt">Locked</span> <span class="fu">=</span> &#39;<span class="dt">Allow</span></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"><span class="ot">sPassState ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">PassState</span> s)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">sPassState <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb32-8" data-line-number="8">    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">SObstruct</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">SAllow</span></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">SAllw</span></a></code></pre></div>
<p>We have to be very careful with how we define <code>sPassState</code>, because GHC isn’t too smart. It’ll reject any definition that isn’t structurally identical to the type family it’s mirroring.</p>
<p>With our new tool, we can now write:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">knockSomeDoor</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">SomeDoor</span>     <span class="co">-- ^ status not known until you pattern match at runtime</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">knockSomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> sPassState s <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    <span class="dt">SAllow</span> <span class="ot">-&gt;</span> knock d                           <span class="co">-- ^ `PassState s ~ &#39;Allow`</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    _      <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;No knocking allowed!&quot;</span>   <span class="co">-- ^ `PassState s ~ &#39;Obstruct`</span></a></code></pre></div>
<p>First we use <code>sPassState s</code> to check the “pass state” of the <code>s</code>. Then, we match on the <code>Pass</code>: if it’s <code>Allow</code>, like the type signature of <code>knock</code> requires, we can run <code>knock</code>. If not, then we cannot!</p>
<h3 id="a-comparison">A Comparison</h3>
<h2 id="type-level-functions-as-relationships">Type-Level Functions as Relationships</h2>
<h3 id="lets-fold">Let’s Fold</h3>
<h3 id="the-problem-with-higher-order-functions">The Problem with Higher Order Functions</h3>
<h2 id="next-steps">Next Steps</h2>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Some subtle points for those more familiar with Haskell’s type system: In Haskell, we say that a type <code>B</code> is a subtype of type <code>A</code> if, wherever a function expects an <code>A</code>, we can give a <code>B</code> instead. Any function that expects a <code>Door 'Opened</code> will take a <code>forall s. Door s</code> (a type that can be instantiated with any <code>s</code>). However, the opposite is not true — if a Rank-N function expects a <code>forall s. Door s</code>, you cannot give it a <code>Door 'Opened</code>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>Sorry to mix up similar metaphors like this! Definitely not intentional :)<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Introduction to Singletons&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series" title="+Introduction to Singletons"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+introduction-to-singletons.html" class="tag-a-series">+Introduction to Singletons</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-3.html';
    this.page.identifier = 'singletons-3';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/mstksg">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>