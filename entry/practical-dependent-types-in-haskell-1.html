<!DOCTYPE HTML>
<html><head><title>Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 1) Â· in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="It seems these days like programming with dependent types in Haskell (and its advantages) is moving slowly but steadily to the mainstream of Haskell programming. In the current state of Haskell education, dependent types are often considered topics for &quot;advanced&quot; Haskell users. However, I can foresee a day where the ease of use of modern Haskell libraries relying on dependent types forces programming with dependent types to be an integral part of normal intermediate (or even beginner) Haskell education. There are more and more and more and more great resources and tutorials and introductions to integrating dependent types into your Haskell every day. The point of this series is to show more some practical examples of using dependent types in guiding your programming, and to also walk through the &quot;why&quot; and high-level philosophy of the way you structure your Haskell programs. It&#39;ll also hopefully instill an intuition of a dependently typed work flow of &quot;exploring&quot; how dependent types can help your current programs. The intended audience of this post is for intermediate Haskell programmers in general, with no required knowledge of dependently typed programming. I should also point out that I&#39;m no expert --- I&#39;m still in the process of learning this all, myself :) The first project in this series will build up to a type-safe artificial neural network implementation with back-propagation training."><meta property="og:type" content="article"><meta property="og:title" content="Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 1)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 1)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2016-05-25T11:46:21Z" pubdate="" class="pubdate">Wednesday May 25, 2016</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/dependent-haskell-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/practical-dependent-types-in-haskell-1.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>It seems these days like programming with dependent types in Haskell (and its advantages) is moving slowly but steadily to the mainstream of Haskell programming. In the current state of Haskell education, dependent types are often considered topics for &quot;advanced&quot; Haskell users. However, I can foresee a day where the ease of use of modern Haskell libraries relying on dependent types forces programming with dependent types to be an integral part of normal intermediate (or even beginner) Haskell education.</p>
<p>There are <a href="https://www.youtube.com/watch?v=rhWMhTjQzsU">more</a> and <a href="http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/">more</a> and <a href="https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety">more</a> and <a href="http://jozefg.bitbucket.org/posts/2014-08-25-dep-types-part-1.html">more</a> great resources and tutorials and introductions to integrating dependent types into your Haskell every day. The point of this series is to show more some practical examples of using dependent types in guiding your programming, and to also walk through the &quot;why&quot; and high-level philosophy of the way you structure your Haskell programs. It'll also hopefully instill an intuition of a dependently typed work flow of &quot;exploring&quot; how dependent types can help your current programs. The intended audience of this post is for intermediate Haskell programmers in general, with no required knowledge of dependently typed programming. I should also point out that I'm no expert --- I'm still in the process of learning this all, myself :)</p>
<p>The first project in this series will build up to a type-safe <strong><a href="https://en.wikipedia.org/wiki/Artificial_neural_network">artificial neural network</a></strong> implementation with back-propagation training.</p>
<h4>Setup</h4>
<p>This post is written on <em><a href="http://www.haskellstack.org">stack</a></em> snapshot <em><a href="https://www.stackage.org/nightly-2016-06-28">nightly-2016-06-28</a></em>, with <em>singletons-2.2</em>, but uses an unreleased version of <em>hmatrix</em>, <em><a href="https://github.com/albertoruiz/hmatrix/tree/42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1">hmatrix-0.18 (commit 42a88fb)</a></em>. I <a href="http://mstksg.github.io/hmatrix/">maintain my own documentation</a> for reference.</p>
<p>If you're forced to use GHC 7.10 for some reason, there's also a bug in <em><a href="http://hackage.haskell.org/package/singletons-2.0.1">singletons-2.0.1</a></em> package that's fixed in <em><a href="http://hackage.haskell.org/package/singletons-2.1">singletons-2.1</a></em>, but <em>2.1</em> is not available with GHC 7.10 -- I have a <a href="https://github.com/mstksg/singletons/releases/tag/v2.0.2">github fork</a> that fixes the bug if you want to stay on GHC 7.10.</p>
<p>You can add this:</p>
<p>~~~yaml packages: - location: git: git@github.com:albertoruiz/hmatrix.git commit: 42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1 subdirs: - packages/base</p>
<h1># If stuck on GHC 7.10:</h1>
<h1>- location:</h1>
<h1>git: git@github.com:mstksg/singletons.git</h1>
<h1>commit: v2.0.2</h1>
<p>~~~</p>
<p>to the <code>packages</code> field of your directory or global <em>stack.yaml</em> and <em>stack</em> will know what version of <em>hmatrix</em> and <em>singletons</em> to use when you use <code>stack runghc</code> or <code>stack ghc</code>, etc. to build your files.</p>
<h2>Neural Networks</h2>
<p><a href="https://en.wikipedia.org/wiki/Artificial_neural_network">Artificial neural networks</a> have been somewhat of a hot topic in computing recently. Implementations of training algorithms (like back-propagation) are tricky to implement correctly --- despite being simple, there are many locations where accidental bugs might pop up when multiplying the wrong matrices, for example.</p>
<p>Though some might recognize that complicated matrix and vector arithmetic is a common application of phantom type-based dependent types, it's not necessarily always easy to gauge before-the-fact what would or would not be a good candidate for adding dependent types to. Often times, it can even be considered premature to start off with &quot;as powerful types as you can&quot;. So let's walk through programming things with as &quot;dumb&quot; types as possible, and see where types can help.</p>
<p>We'll be following a process called &quot;type-driven development&quot; --- start with general and non-descriptive types, write the implementation and recognize partial functions and red flags, and slowly refine and add more and more powerful types to fix the problems.</p>
<h3>Background</h3>
<p><img src="/img/entries/dependent-haskell-1/ffneural.png" title="Feed-forward ANN architecture" alt="Feed-forward ANN architecture" /></p>
<p>Here's a quick run through on background for ANN's --- but remember, this isn't an article on ANN's, so we are going to be glossing over some of the details.</p>
<p>We're going to be implementing a <em>feed-forward neural network</em> with back-propagation training. These networks are layers of &quot;nodes&quot;, each connected to the each of the nodes of the previous layer. Input goes to the first layer, which feeds information to the next layer, which feeds it to the next, etc., until the final layer, where we read it off as the &quot;answer&quot; that the network is giving us. Layers between the input and output layers are called <em>hidden</em> layers. Every node &quot;outputs&quot; a weighted sum of all of the outputs of the <em>previous</em> layer, plus an always-on &quot;bias&quot; term (so that its result can be non-zero even when all of its inputs are zero). Symbolically, it looks like:</p>
<p>$$ y<em>j = b</em>j + \sum<em>i^m w</em>{ij} x_i $$</p>
<p>Or, if we treat the output of a layer and the list of list of weights as a matrix, we can write it a little cleaner:</p>
<p>$$ \mathbf{y} = \mathbf{b} + W \mathbf{x} $$</p>
<p>The result, the $n$-vector of nodes $\mathbf{y}$, is computed from the $n$-vector of biases $\mathbf{b}$ and the $n \times m$ weight matrix $W$ multiplied with the $m$-vector input, $\mathbf{x}$.</p>
<p>To &quot;scale&quot; the result (and to give the system the magical powers of nonlinearity), we actually apply an &quot;activation function&quot; to the output before passing it down to the next step. We'll be using the popular <a href="https://en.wikipedia.org/wiki/Logistic_function">logistic function</a>, $f(x) = 1 / (1 + e^{-x})$.</p>
<p><em>Training</em> a network involves picking the right set of weights to get the network to answer the question you want.</p>
<h2>Vanilla Types</h2>
<p>We can store a network by storing the matrix of of weights and biases between each layer:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L18-20 data Weights = W { wBiases :: !(Vector Double) -- n , wNodes :: !(Matrix Double) -- n x m } -- &quot;m to n&quot; layer ~~~</p>
<p>Now, a <code>Weights</code> linking an <em>m</em>-node layer to an <em>n</em>-node layer has an <em>n</em>-dimensional bias vector (one component for each output) and an <em>n</em>-by-<em>m</em> node weight matrix (one column for each output, one row for each input).</p>
<p>(We're using the <code>Matrix</code> type from the awesome <em><a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a></em> library for performant linear algebra, implemented using blas/lapack under the hood)</p>
<p>A feed-forward neural network is then just a linked list of these weights:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L22-28 data Network :: * where O :: !Weights -&gt; Network (:&amp;~) :: !Weights -&gt; !Network -&gt; Network infixr 5 :&amp;~ ~~~</p>
<p>Note that we're using <a href="https://en.wikibooks.org/wiki/Haskell/GADT">GADT</a> syntax here, which just lets us define <code>Network</code> (with a kind signature, <code>*</code>) by providing the type of its <em>constructors</em>, <code>O</code> and <code>(:&amp;~)</code>. It'd be equivalent to the following normal data declaration:</p>
<p>~~~haskell data Network = O Weights | Weights :&amp;~ Network ~~~</p>
<p>A network with one input layer, two inner layers, and one output layer would look like:</p>
<p>~~~haskell ih :&amp;~ hh :&amp;~ O ho ~~~</p>
<p>The first component is the weights from the input to first inner layer, the second is the weights between the two hidden layers, and the last is the weights between the last hidden layer and the output layer.</p>
<p>&lt;!-- TODO: graphs using diagrams? --&gt;</p>
<p>We can write simple procedures, like generating random networks:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L46-56 randomWeights :: MonadRandom m =&gt; Int -&gt; Int -&gt; m Weights randomWeights i o = do seed1 :: Int &lt;- getRandom seed2 :: Int &lt;- getRandom let wB = randomVector seed1 Uniform o * 2 - 1 wN = uniformSample seed2 o (replicate i (-1, 1)) return $ W wB wN</p>
<p>randomNet :: MonadRandom m =&gt; Int -&gt; [Int] -&gt; Int -&gt; m Network randomNet i [] o = O &lt;$&gt; randomWeights i o randomNet i (h:hs) o = (:&amp;~) &lt;$&gt; randomWeights i h &lt;*&gt; randomNet h hs o ~~~</p>
<p>(We're using the <code>MonadRandom</code> typeclass from the <em><a href="http://hackage.haskell.org/package/MonadRandom">MonadRandom</a></em> library, which uses the mechanisms in <em><a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html">System.Random</a></em> and gives us a generic way of working with monads where we can get random values with <code>getRandom</code>, etc.)</p>
<p>(<a href="http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:randomVector"><code>randomVector</code></a> and <a href="http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:uniformSample"><code>uniformSample</code></a> are from the <em><a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a></em> library, generating random vectors and matrices from a random <code>Int</code> seed. We manipulate them here to generate them with numbers between -1 and 1)</p>
<p>And now we can write a function to &quot;run&quot; our network on a given input vector, following the matrix equation we wrote earlier:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L30-44 logistic :: Floating a =&gt; a -&gt; a logistic x = 1 / (1 + exp (-x))</p>
<p>runLayer :: Weights -&gt; Vector Double -&gt; Vector Double runLayer (W wB wN) v = wB + wN #&gt; v</p>
<p>runNet :: Network -&gt; Vector Double -&gt; Vector Double runNet (O w) !v = logistic (runLayer w v) runNet (w :&amp;~ n') !v = let v' = logistic (runLayer w v) in runNet n' v' ~~~</p>
<p>(<code>#&gt;</code> is matrix-vector multiplication)</p>
<p>&lt;!-- TODO: examples of running --&gt;</p>
<p>If you're a non-Haskell programmer, this might all seem perfectly fine and normal, and you probably have only a slightly elevated heart rate. If you are a Haskell programmer, you are most likely already having heart attacks. Let's imagine all of the bad things that could happen:</p>
<ul>
<li><p>How do we know that we didn't accidentally mix up the dimensions for our implementation of <code>randomWeights</code>? We could have switched parameters and be none the wiser.</p></li>
<li><p>How do we even know that each subsequent matrix in the network is &quot;compatible&quot;? We want the outputs of one matrix to line up with the inputs of the next, but there's no way to know. It's possible to build a bad network, and things will just explode at runtime.</p></li>
<li><p>How do we know the size of vector the network expects? What stops you from sending in a bad vector at run-time? We might do runtime-checks, but the compiler won't help us.</p></li>
<li><p>How do we verify that we have implemented <code>runLayer</code> and <code>runNet</code> in a way that they won't suddenly fail at runtime? We write <code>l #&gt; v</code>, but how do we know that it's even correct...what if we forgot to multiply something, or used something in the wrong places? We can it prove ourselves, but the compiler won't help us.</p></li>
</ul>
<h3>Back-propagation</h3>
<p>Now, let's try implementing back-propagation! It's a textbook gradient descent algorithm. There are <a href="https://en.wikipedia.org/wiki/Backpropagation">many explanations</a> on the internet; the basic idea is that you try to minimize the squared error of what the neural network outputs for a given input vs. the actual expected output. You find the direction of change that minimizes the error (by finding the derivative), and move that direction. The implementation of backpropagation is found in many sources online and in literature, so let's see the implementation in Haskell:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L58-96 train :: Double -- ^ learning rate -&gt; Vector Double -- ^ input vector -&gt; Vector Double -- ^ target vector -&gt; Network -- ^ network to train -&gt; Network train rate x0 target = fst . go x0 where go :: Vector Double -- ^ input vector -&gt; Network -- ^ network to train -&gt; (Network, Vector Double) -- handle the output layer go !x (O w@(W wB wN)) = let y = runLayer w x o = logistic y -- the gradient (how much y affects the error) -- (logistic' is the derivative of logistic) dEdy = logistic' y * (o - target) -- new bias weights and node weights wB' = wB - scale rate dEdy wN' = wN - scale rate (dEdy <code>outer</code> x) w' = W wB' wN' -- bundle of derivatives for next step dWs = tr wN #&gt; dEdy in (O w', dWs) -- handle the inner layers go !x (w@(W wB wN) :&amp;~ n) = let y = runLayer w x o = logistic y -- get dWs', bundle of derivatives from rest of the net (n', dWs') = go o n -- the gradient (how much y affects the error) dEdy = logistic' y * dWs' -- new bias weights and node weights wB' = wB - scale rate dEdy wN' = wN - scale rate (dEdy <code>outer</code> x) w' = W wB' wN' -- bundle of derivatives for next step dWs = tr wN #&gt; dEdy in (w' :&amp;~ n', dWs) ~~~</p>
<p>The algorithm computes the <em>updated</em> network by recursively updating the layers, backwards up from the output layer. At every step, it returns the updated layer/network, as well as a bundle of derivatives (<code>dWs</code>) for the next layer up to use to calculate its descent direction.</p>
<p>At the output layer, all it needs to calculate the direction of descent is just <code>o - targ</code>, the target. At the inner layers, it has to use the <code>dWs</code> bundle it receives from the lower layers to figure it out. <code>dWs</code> essentially &quot;bubbles up&quot; from the output layer up to the input layer calculations.</p>
<p>Writing this is a bit of a struggle. I actually implemented this incorrectly several times before writing it as you see here. The type system doesn't help you like it normally does in Haskell, and you can't really use parametricity to help you write your code like normal Haskell. Everything is monomorphic, and everything multiplies with everything else. You don't have any hints about what to multiply with what at any point in time. It's like all of the bad things mentioned before, but amplified.</p>
<p>In short, you're leaving yourself open to many potential bugs...and the compiler doesn't help you write your code at all! This is the nightmare of every Haskell programmer. There must be a better way![^better]</p>
<h4>Putting it to the test</h4>
<p>Pretty much the only way you can verify this code is to test it out on example cases. In the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs">source file</a>, I have <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L128-136"><code>main</code></a> test out the backprop, training a network on a 2D function that was &quot;on&quot; for two small circles and &quot;off&quot; everywhere else (A nice cute non-linearly-separable function to test our network on). We basically train the network to be able to recognize the two-circle pattern. I implemented a simple printing function and tested the trained network on a grid:</p>
<p>~~~bash $ stack install hmatrix MonadRandom $ stack ghc -- -O2 ./NetworkUntyped.hs $ ./NetworkUntyped</p>
<h1>Training network...</h1>
<h1></h1>
<h1></h1>
<h1>.=########=</h1>
<h1>.##############.</h1>
<h1></h1>
<h1></h1>
<h1>.##############-</h1>
<h1>.</h1>
<h1>... ...</h1>
<h1>-##########.</h1>
<h1>-##############.</h1>
<h1></h1>
<h1></h1>
<h1>=############=</h1>
<h1>.#######=.</h1>
<h1></h1>
<h1></h1>
<p>~~~</p>
<p>Not too bad! The network learned to recognize the circles. But, I was basically forced to resort to unit testing to ensure my code was correct. Let's see if we can do better.</p>
<h3>The Call of Types</h3>
<p>Before we go on to the &quot;typed&quot; version of our program, let's take a step back and look at some big checks you might want to ask yourself after you write code in Haskell.</p>
<ol>
<li>Are any of my functions either partial or implemented using partial functions?</li>
<li>How could I have written things that are <em>incorrect</em>, and yet still type check? Where does the compiler <em>not</em> help me by restricting my choices?</li>
</ol>
<p>Both of these questions usually yield some truth about the code you write and the things you should worry about. As a Haskeller, they should always be at the back of your mind!</p>
<p>Looking back at our untyped implementation, we notice some things:</p>
<ol>
<li>Literally every single function we wrote is partial. Like, actually.[^literally] If we had passed in the incorrectly sized matrix/vector, or stored mismatched vectors in our network, everything would fall apart.</li>
<li>There are billions of ways we could have implemented our functions where they would still typechecked. We could multiply mismatched matrices, or forget to multiply a matrix, etc.</li>
</ol>
<h2>With Static Size-Indexed Types</h2>
<h3>Networks</h3>
<p>Gauging our potential problems, it seems like the first major class of bugs we can address is improperly sized and incompatible matrices. If the compiler always made sure we used compatible matrices, we can avoid bugs at compile-time, and we also can get a friendly helper when we write programs (by knowing what works with what, and what we need were, and helping us organize our logic)</p>
<p>Let's write a <code>Weights</code> type that tells you the size of its output and the input it expects. Let's have, say, a <code>Weights 10 5</code> be a set of weights that takes you from a layer of 10 nodes to a layer of 5 nodes. <code>w :: Weights 4 6</code> would take you from a layer of 4 nodes to a layer of 6 nodes:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L21-23 data Weights i o = W { wBiases :: !(R o) , wNodes :: !(L o i) } -- an &quot;o x i&quot; layer ~~~</p>
<p>The type constructor <code>Weights</code> has the kind <code>Weights :: Nat -&gt; Nat -&gt; *</code> --- it takes two types of kind <code>Nat</code> (from the <em><a href="http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html">GHC.TypeLits</a></em> module, which the integer type literals give us with <em><a href="https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell#type-level-naturals">DataKinds</a></em> enabled) and returns a <code>*</code> --- a &quot;normal type&quot;.</p>
<p>We're using the <em><a href="http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html">Numeric.LinearAlgebra.Static</a></em> module from <em><a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a></em>, which offers matrix and vector types with their size in their types: an <code>R 5</code> is a vector of Doubles with 5 elements, and a <code>L 3 6</code> is a 3x6 vector of Doubles.</p>
<p>These types are called &quot;dependent&quot; types because the type itself <em>depends</em> on its value. If an <code>R n</code> contains a 5-element vector, its type is <code>R 5</code>.</p>
<p>The <em>Static</em> module in <em>hmatrix</em> relies on the <a href="http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#t:KnownNat"><code>KnownNat</code></a> mechanism that GHC offers. Almost all operations in the library require a <code>KnownNat</code> constraint on the type-level Nats --- for example, you can take the dot product of two vectors with <code>dot :: KnownNat n =&gt; R n -&gt; R n -&gt; Double</code>. It lets the library use the information in the <code>n</code> at runtime as an <code>Integer</code>. (More on this later!)</p>
<p>Moving on, our network type for this post will be something like <code>Network 10 '[7,5,3] 2</code>: Take 10 inputs, return 2 outputs --- and internally, have hidden layers of size 7, 5, and 3. (The <code>'[7,5,3]</code> is a type-level list of Nats; the optional <code>'</code> apostrophe is just for our own benefit to distinguish it from a value-level list of integers.)</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L25-32 data Network :: Nat -&gt; [Nat] -&gt; Nat -&gt; * where O :: !(Weights i o) -&gt; Network i '[] o (:&amp;~) :: KnownNat h =&gt; !(Weights i h) -&gt; !(Network h hs o) -&gt; Network i (h ': hs) o infixr 5 :&amp;~ ~~~</p>
<p>We use GADT syntax here again. The <em>kind signature</em> of the type constructor means that the <code>Network</code> type constructor takes three inputs: a <code>Nat</code> (type-level numeral, like <code>10</code> or <code>5</code>), list of <code>Nat</code>s, and another <code>Nat</code> (the input, hidden layers, and output sizes). Let's go over the two constructors.</p>
<ul>
<li><p>The <code>O</code> constructor takes a <code>Weights i o</code> and returns a <code>Network i '[] o</code>. That is, if your network is just weights from <code>i</code> inputs to <code>o</code> outputs, your network itself just takes <code>i</code> inputs and returns <code>o</code> outputs, with no hidden layers.</p></li>
<li><p>The <code>(:&amp;~)</code> constructor takes a <code>Network h hs o</code> -- a network with <code>h</code> inputs and <code>o</code> outputs -- and &quot;conses&quot; an extra input layer in front. If you give it a <code>Weights i h</code>, its outputs fit perfectly into the inputs of the subnetwork, and you get a <code>Network i (h ': hs) o</code>. (<code>(':)</code>, or <code>(:)</code>, is the same as normal <code>(:)</code>, but is for type-level lists. The apostrophe is optional here too, but it's just nice to be able to visually distinguish the two)</p>
<p>We add a <code>KnownNat</code> constraint on the <code>h</code>, so that whenever you pattern match on <code>w :&amp;~ net</code>, you automatically get a <code>KnownNat</code> constraint for the input size of <code>net</code> (and the output of <code>w</code>) that the <em>hmatrix</em> library can use.</p></li>
</ul>
<p>We can still construct them the same way:</p>
<p>~~~haskell -- given: ih :: Weights 10 7 hh :: Weights 7 4 ho :: Weights 4 2</p>
<p>-- we have: O ho :: Network 4 '[] 2 hh :&amp;~ O ho :: Network 7 '[4] 2 ih :&amp;~ hh :&amp;~ O ho :: Network 10 '[7,4] 2 ~~~</p>
<p>Note that the shape of the constructors requires all of the weight vectors to &quot;fit together&quot;. <code>ih :&amp;~ O ho</code> would be a type error (feeding a 7-output layer to a 4-input layer). Also, if we ever pattern match on <code>:&amp;~</code>, we know that the resulting matrices and vectors are compatible!</p>
<p>One neat thing is that this approach is also self-documenting. I don't need to specify what the dimensions are in the docs and trust the users to read it and obey it. The types tell them! And if they don't listen, they get a compiler error! (You should, of course, still provide reasonable documentation. But, in this case, the compiler actually enforces your documentation's statements!)</p>
<p>Generating random weights and networks is even nicer now:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L57-64 randomWeights :: (MonadRandom m, KnownNat i, KnownNat o) =&gt; m (Weights i o) randomWeights = do s1 :: Int &lt;- getRandom s2 :: Int &lt;- getRandom let wB = randomVector s1 Uniform * 2 - 1 wN = uniformSample s2 (-1) 1 return $ W wB wN ~~~</p>
<p>Notice that the <em>Static</em> versions of <a href="http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:randomVector"><code>randomVector</code></a> and <a href="http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:uniformSample"><code>uniformSample</code></a> don't actually require the size of the vector/matrix you want as an input -- they just use <em>type inference</em> to figure out what size you want! This is the same process that <a href="http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:read"><code>read</code></a> uses to figure out what type of thing you want to return. You would use <code>randomVector s Uniform :: R 10</code>, and type inference would give you a 10-element vector the same way <code>read &quot;hello&quot; :: Int</code> would give you an <code>Int</code>.</p>
<p>It's important to note that it's much harder to implement this incorrectly. Before, you could give the matrix the wrong dimensions (maybe you flipped the parameters?), or gave the wrong parameter to the vector generator.</p>
<p>But here, you are guaranteed/forced to return the correctly sized vectors and matrices. In fact, you <em>don't even have to worry</em> about it --- it's handled automatically by the magic of type inference[^hindley]! I consider this a very big victory. One of the whole points of types is to give you less to &quot;worry about&quot;, as a programmer. Here, we completely eliminate an <em>entire dimension</em> of programmer concern.</p>
<h4>Benefits to the user</h4>
<p>Not only is this style nicer for you as the implementer, it's also very beneficial for the <em>user</em> of the function. Consider looking at the two competing type signatures side-by-side:</p>
<p>~~~haskell randomWeights :: Int -&gt; Int -&gt; m Weights randomWeights :: m (Weights i o) ~~~</p>
<p>If you want to <em>use</em> this function, you have to look up some things from the documentation:</p>
<ol>
<li>What do the two arguments represent?</li>
<li>What <em>order</em> is the function expecting these two arguments?</li>
<li>What will be the dimension of the result?</li>
</ol>
<p>These are three things you <em>need</em> to look up in the documentation. There's simply no way around it.</p>
<p>But, here, all of these questions are answered <em>immediately</em>, just from the type (which you can get from GHC, or from ghci). You don't need to worry about arguments. You don't need to worry about what order the function is expecting the arguments to be in. And you already know <em>exactly</em> what the dimensions of the result is, right in the type.</p>
<p>I often implement many of my functions in this style, even if the rest of my program isn't intended to be dependently typed (I can just convert the type to a &quot;dumb&quot; type as soon as I get the result). All of these benefits come even when the caller doesn't <em>care</em> at all about dependently typed programming --- it's just a better style of defining functions/offering an API!</p>
<h3>Singletons and Induction</h3>
<p>The code for the updated <code>randomNet</code> takes a bit of background to understand, so let's take a quick detour through the concepts of singletons, dependent pattern matching, and induction on dependent data types.[^old]</p>
<p>Let's say we want to implement an algorithm that can create any <code>Network i hs o</code>, so that we can construct a <code>Network 4 '[3,2] 1</code> or something. In true Haskell fashion, we want do this recursively (&quot;inductively&quot;). After all, we know how to make a <code>Network i '[] o</code> (just <code>O &lt;$&gt; randomWeights</code>), and we know how to create a <code>Network i (h ': hs) o</code> if we had a <code>Network h hs o</code> (just use <code>(:&amp;~)</code> with <code>randomWeights</code>). Now all we have to do is just &quot;pattern match&quot; on the type-level list, and...</p>
<p>Oh wait. We can't pattern match on types like that in Haskell. This is a consequence of one of Haskell's fundamental design decisions: types are <strong>erased</strong> at runtime. We need to have a way to &quot;access&quot; the type (at run-time) as a <em>value</em> so we can pattern match on it and do things with it.</p>
<p>In Haskell, the popular way to deal with this is by using <em>singletons</em> --- (parameterized) types which only have valid constructor. The canonical method of working with singletons in Haskell is with the <em><a href="https://hackage.haskell.org/package/singletons">singletons</a></em> library, which provides a uniform interface for all sorts of singletons of types you'll encounter in everyday use.</p>
<p>We want to &quot;pattern match&quot; on a type-level list, so we want a singleton for lists. The <em>singletons</em> library provides them:</p>
<p>~~~haskell SNil :: Sing '[] SCons :: Sing a -&gt; Sing as -&gt; Sing (a ': as) ~~~</p>
<p>This means that if we ever get value of type <code>Sing as</code> (and <code>as</code> is a type-level list), we can pattern match on it. If we match on the <code>SNil</code> constructor, we <em>know</em> it's a <code>Sing '[]</code> in that branch, and if we match on the <code>SCons</code> constructor, we <em>know</em> it's a <code>Sing (a ': as)</code> -- a non-empty list. This is called <em>dependent pattern matching</em>. Every &quot;branch&quot; of your case statement has a different inferred type of the arguments, depending on the constructor you match on.</p>
<p>~~~haskell case foo of SNil -&gt; ... -- here, GHC knows <code>foo :: Sing '[]</code> SCons _ _ -&gt; ... -- here, GHC knows <code>foo :: Sing (a ': as)</code> ~~~</p>
<p><em>singletons</em> actually provides a whole bunch of singleton constructors for different types and kinds, like for <code>Bool</code>:</p>
<p>~~~haskell STrue :: Sing 'True SFalse :: Sing 'False ~~~</p>
<p>(That's the <em>type</em> <code>'True</code>, of <em>kind</em> <code>Bool</code>)</p>
<p>So, if we ever are given a <code>Sing b</code> with some type-level <code>Bool</code> we don't know, we can pattern match on it. And in the branch that <code>STrue</code> matches on, <code>b</code> is <code>'True</code>, and in the branch that <code>SFalse</code> matches on, <code>b</code> is <code>False</code>.</p>
<p>Singletons give us a way to pattern match on types by having an actual term-level value we can pattern match on. So, we <em>could</em> implement:</p>
<p>~~~haskell randomNet :: (MonadRandom m, KnownNat i, KnownNat o) =&gt; Sing hs -&gt; m (Network i hs o) ~~~</p>
<p>And <code>randomNet</code> gets to directly pattern match and deconstruct on <code>Sing hs</code>.</p>
<p>However, for actual API's, it's often more convenient to <em>not</em> require the extra parameter, and have it be &quot;inferred&quot; in the way we've been doing it before. That way the <em>user</em> doesn't have the burden of supplying it. The <em>singletons</em> library offers a typeclass we can use to implicitly conjure up values of a singleton type -- <code>SingI</code>. We can use <code>sing :: SingI s =&gt; Sing s</code> to generate the &quot;inferred&quot; singleton:</p>
<p>~~~haskell ghci&gt; sing :: Sing '[] SNil ghci&gt; sing :: Sing 'True STrue ghci&gt; sing :: Sing '['True, 'False, 'True] STrue <code>SCons</code> SFalse <code>SCons</code> STrue <code>SCons</code> SNil ~~~</p>
<p>So if you have a function <code>SingI hs =&gt; ...</code>, it's really no different than <code>Sing hs -&gt; ...</code>. The function itself gets to use a <code>Sing hs</code> either way ... but for the first, the argument is implicit.</p>
<p>The final piece of the puzzle is the singleton for a type-level <code>Nat</code>. It's a little different because when you pattern match on it, instead of directly learning about the type, you &quot;receive&quot; a <code>KnownNat</code> instance you can use.</p>
<p>~~~haskell SNat :: KnownNat n =&gt; Sing n ~~~</p>
<p>~~~haskell -- <code>foo :: Sing n</code>, but we don't know what <code>n</code> it is case foo of SNat -&gt; ... -- in this branch, we have a <code>KnownNat n</code> instance ~~~</p>
<p>Essentially, the data constructor comes &quot;packaged&quot; with a <code>KnownNat n</code> instance. The <em>creation</em> of <code>SNat :: Sing n</code> requires the presence of <code>KnownNat n</code>. So if you ever pattern match on a validly created <code>SNat</code>, the fact that that <code>SNat</code> constructor even exists (instead of, say, being <code>undefined</code>) is a <em>witness</em> to that very <code>KnownNat</code> instance, and the type system lets us use this. It's as if you &quot;pattern match&quot; out the instance itself, like any other value the constructor might have.</p>
<p>Now we have enough pieces of the puzzle:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L66-75 randomNet :: forall m i hs o. (MonadRandom m, KnownNat i, SingI hs, KnownNat o) =&gt; m (Network i hs o) randomNet = go sing where go :: forall h hs'. KnownNat h =&gt; Sing hs' -&gt; m (Network h hs' o) go = \case SNil -&gt; O &lt;$&gt; randomWeights SNat <code>SCons</code> ss -&gt; (:&amp;~) &lt;$&gt; randomWeights &lt;*&gt; go ss ~~~</p>
<p>The real heavy lifting is done by <code>go</code> (written with <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase">LambdaCase</a>), which takes the singleton structure it needs and recursively calls it until it reaches the base case (<code>SNil</code>, an output layer). We just call <code>go sing</code> to give it the initial structure it needs. Note there, <code>sing :: Sing hs</code>, but this is inferred, because <code>go</code> is <code>Sing hs -&gt; Network i hs o</code>, and it's being asked to return a <code>Network i hs o</code>, so it's safely inferable that we want <code>Sing hs</code>.</p>
<p>Remember that we can write <code>O &lt;$&gt; randomWeights</code> because <code>randomWeights</code>, like <code>read</code>, adapts to whatever type we want from it --- in this case, we ask for a <code>Weights h o</code>, and type inference is the real hero.</p>
<p>When possible, we like to write functions like <code>go</code> that take <em>explicit</em> singletons. In a lot of situations, we'll actually write our internal <em>logic</em> itself using explicit singletons, and only use <code>SingI</code> and implicit singletons at the <em>external</em> boundaries of our API (like <code>randomNet</code>) for convenience to the user.</p>
<p>We've stumbled upon common pattern in dependent Haskell: &quot;building up&quot; a value-level singleton <em>structure</em> from a type that we want (either explicitly given as an argument, or provided through a typeclass like <code>SingI</code>) and then inductively piggybacking on that structure's constructors to build the thing you <em>really</em> want (called &quot;elimination&quot;). Here, we use <code>SingI hs</code> and &quot;eliminate&quot; that structure to create our <code>Network i hs o</code>.</p>
<h4>On Typeclasses and Dictionaries</h4>
<p>One of the more bizarre things here, to me, is that <code>SNat</code> somehow gave us a <code>KnownNat n</code> instance that we can use and pass off to <code>randomWeights</code>. However, once you realize that typeclasses in Haskell really aren't any more than a way to pass in implicit arguments, it starts to make sense.</p>
<p>The only thing you can really do from a <code>KnownNat</code> is to get an <code>Integer</code> from it with <code>natVal</code>. So really, <code>KnownNat n =&gt; ...</code> is more or less the same as <code>Integer -&gt; ...</code>. That's right --- at runtime, a <code>KnownNat n</code> constraint is more or less just an <code>Integer</code> that GHC passes around automatically for you, to save you the hassle of manually passing it in yourself. (We say that the &quot;dictionary&quot; of <code>KnownNat</code> is <code>Integer</code>.)</p>
<p>So, the constructor:</p>
<p>~~~haskell SNat :: KnownNat n =&gt; Sing n ~~~</p>
<p>Is really <em>kind</em> of like:</p>
<p>~~~haskell SNat :: Integer -&gt; Sing n -- or, in normal data type notation SNat Integer -- kinda! ~~~</p>
<p>The GADT constructor for <code>SNat</code> requires a <code>KnownNat n</code> instance in scope to produce. That instance is essentially stored inside the constructor (as if it were just an <code>Integer</code>). Then, later, when you pattern match on it, you pattern match out the instance that was originally put in there, and you can use it!</p>
<p>So what's the big deal, why not just ditch <code>KnownNat</code> and just pass around integers? The difference is that GHC and the compiler can now <em>track</em> these at compile-time to give you <em>checks</em> on how your Nat's act together on the type level, allowing it to catch mismatches with compile-time checks instead of run-time checks.</p>
<h3>Running with it</h3>
<p>So now, you can use <code>randomNet :: IO (Network 5 '[4,3] 2)</code> to get a random network of the desired dimensions! (<code>IO</code> is an instance of <code>MonadRandom</code>)</p>
<p>Can we just pause right here to just appreciate how awesome it is that we can generate random networks of whatever size we want by <em>just requesting something by its type</em>? Our implementation is also <em>guaranteed</em> to have the right sized matrices --- no worrying about using the right size parameters for the right matrix in the right order. GHC does it for you automatically! And, for the person who <em>uses</em> <code>randomNet</code>, they don't have to bungle around with figuring out what function argument indicates what, and in what order, and they don't have to play a guessing game about the shape of the returned matrix.</p>
<p>The code for <em>running</em> the nets is actually literally identical from before:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L42-55 runLayer :: (KnownNat i, KnownNat o) =&gt; Weights i o -&gt; R i -&gt; R o runLayer (W wB wN) v = wB + wN #&gt; v</p>
<p>runNet :: (KnownNat i, KnownNat o) =&gt; Network i hs o -&gt; R i -&gt; R o runNet = \case O w -&gt; (!v) -&gt; logistic (runLayer w v) (w :&amp;~ n') -&gt; (!v) -&gt; let v' = logistic (runLayer w v) in runNet n' v' ~~~</p>
<p>But now, we get the assurance that the matrices and vectors all fit each-other, at compile-time. GHC basically writes our code for us. The operations all demand vectors and matrices that &quot;fit together&quot;, so you can only ever multiply a matrix by a properly sized vector.</p>
<p>~~~haskell (+) :: KnownNat n =&gt; R n -&gt; R n -&gt; R n (#&gt;) :: (KnownNat n, KnownNat m) =&gt; L n m -&gt; R m -&gt; R n</p>
<p>logistic :: KnownNat n =&gt; R n -&gt; R n ~~~</p>
<p>The source code is the same from before, so there isn't any extra overhead in annotation. The correctness proofs and guarantees basically come without any extra work --- they're free!</p>
<p>Our back-prop algorithm is ported pretty nicely too:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L77-116 train :: forall i hs o. (KnownNat i, KnownNat o) =&gt; Double -- ^ learning rate -&gt; R i -- ^ input vector -&gt; R o -- ^ target vector -&gt; Network i hs o -- ^ network to train -&gt; Network i hs o train rate x0 target = fst . go x0 where go :: forall j js. KnownNat j =&gt; R j -- ^ input vector -&gt; Network j js o -- ^ network to train -&gt; (Network j js o, R j) go !x (O w@(W wB wN)) = let y = runLayer w x o = logistic y -- the gradient (how much y affects the error) -- (logistic' is the derivative of logistic) dEdy = logistic' y * (o - target) -- new bias weights and node weights wB' = wB - konst rate * dEdy wN' = wN - konst rate * (dEdy <code>outer</code> x) w' = W wB' wN' -- bundle of derivatives for next step dWs = tr wN #&gt; dEdy in (O w', dWs) -- handle the inner layers go !x (w@(W wB wN) :&amp;~ n) = let y = runLayer w x o = logistic y -- get dWs', bundle of derivatives from rest of the net (n', dWs') = go o n -- the gradient (how much y affects the error) dEdy = logistic' y * dWs' -- new bias weights and node weights wB' = wB - konst rate * dEdy wN' = wN - konst rate * (dEdy <code>outer</code> x) w' = W wB' wN' -- bundle of derivatives for next step dWs = tr wN #&gt; dEdy in (w' :&amp;~ n', dWs) ~~~</p>
<p>It's pretty much again almost an exact copy-and-paste, but now with GHC checking to make sure everything fits together in our implementation.</p>
<p>One thing that's hard for me to convey here without walking through the implementation step-by-step is how much the types <em>help you</em> in writing this code.</p>
<p>Before starting writing a back-prop implementation without the help of types, I'd probably be a bit concerned. I mentioned earlier that writing the untyped version was no fun at all. But, with the types, writing the implementation became a <em>joy</em> again. And, you have the help of <em>hole driven development</em>, too.</p>
<p>If you need, say, an <code>R n</code>, there might be only one way get it! And if you have something that you need to combine with something you don't know about, you can use typed holes (<code>_</code>) and GHC will give you a list of all the values you have in scope that can fit there. Your programs basically write themselves!</p>
<p>The more you can restrict the implementations of your functions with your types, the more of a joy programming in Haskell is. Things fit together and fall together before your eyes...and the best part is that if they're wrong, the compiler will nudge you gently into the correct direction.</p>
<p>The most stressful part of programming happens when you have to tenuously hold a complex and fragile network of ideas and constraints in your brain, and any slight distraction or break in focus causes everything to crash down in your mind. Over time, people have begun to believe that this is &quot;normal&quot; in programming. Don't believe this lie --- it's <em>not</em>! A good programming experience involves maintaining as <em>little</em> in your head as possible, and letting the compiler handle remembering/checking the rest.</p>
<h4>The final test</h4>
<p>You can download the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs">typed network</a> source code and run it yourself. Again, the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L151-159"><code>main</code></a> method is written identically to that of the other file and tests the identical function.</p>
<p>~~~bash $ stack install hmatrix MonadRandom singletons $ stack ghc -- -O2 ./NetworkTyped.hs $ ./NetworkTyped</p>
<h1>Training network...</h1>
<h1></h1>
<h1></h1>
<h1>-#########-</h1>
<h1>-#############=</h1>
<h1>-###############-</h1>
<h1>=###############=</h1>
<h1>##############=.</h1>
<h1>.##########=.</h1>
<h1>.==#=-</h1>
<h1>-###########-</h1>
<h1>=##############.</h1>
<h1>.###############=</h1>
<h1>=##############-</h1>
<h1>=############-</h1>
<h1>-######=-.</h1>
<h1></h1>
<h1></h1>
<p>~~~</p>
<h2>Finding Something to Depend on</h2>
<p>We wrote out an initial &quot;non-typed&quot; implementation and recognized a lot red flags that you might already be trained to recognize if you have been programming Haskell for a while: <em>partial functions</em> and <em>multiple potential implementations</em>.</p>
<p>We followed our well-tuned Haskell guts, listened to our hearts, and introduced extra power in our types to remove all partial functions and eliminate <em>most</em> potential implementations (though not all, yet --- there are more gains to be made from pulling in more parametric polymorphism).</p>
<p>Though we might have been able to find the bugs we avoided &quot;eventually&quot;, we were able to remove entire <em>dimensions</em> of programmer concern and also leverage parametric polymorphism to help write our programs for us. We found joy again in programming.</p>
<p>In the process, however, we encountered some unexpected resistance from Haskell (the language). We couldn't directly pattern match on our types, so we ended up playing games with singletons and GADT constructors to pass instances.</p>
<p>In practice, using types as powerful and descriptive as these begin to require a whole new set of tools once you get past the simplest use cases here. For example, our <code>Network</code> types so far required you to specify their size in the program itself (<code>Network 2 '[16, 8] 1</code> in the example source code, for instance). But what if we wanted to generate a network that has runtime-determined size (For example, getting the size from user input)? What if we wanted to load a pre-trained network whose size we don't know? How can we manipulate our networks in a &quot;dynamic&quot; and generic way that still gives us all of the benefits of type-safe programming? We'll found out next post!</p>
<p>What we're looking at here is a world where <em>types</em> can depend on run-time values ... and values can depend on types. A world where types can be returned from functions and where types become as much of a manipulatable citizen of as values are.</p>
<p>The art of working with types like this is <em>dependently typed programming</em>. We're going to feel a bit of push back from Haskell at first, but after we hit our stride and tame the tools we need, we're going to open up a whole new world of potential!</p>
<h3>Exercises</h3>
<p>Here are some exercises you can do for fun to test your understanding and apply some of the concepts! The links are to the solutions in the source file.</p>
<ol>
<li><p>Write a function that <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L167-168">&quot;pops&quot; the input layer</a> off of a <code>Network</code>, returning both the input layer's weights and the rest of the network, <code>(Weights i h, Network h hs o)</code>.</p>
<p>Think about what its type would have to be. Could it possibly be called with a network that cannot be popped? (that is, that has only one layer?)</p></li>
<li><p>Write a <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L170-187">function that takes two networks of the same dimensions and adds together their weights</a>. Remember that <code>L m n</code> has a <code>Num</code> instance that adds the matrices together element-by-element.</p>
<p>Could this function ever be accidentally called on two networks that have different internal structures?</p></li>
<li><p>Write a function that takes a <code>Network i hs o</code> and <a href="https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L189-192">returns the singleton representing its hidden layer structure</a> --- <code>Sing hs</code>:</p>
<p>~~~haskell hiddenSing :: Network i hs o -&gt; Sing hs ~~~</p>
<p>~~~haskell ghci&gt; n &lt;- randomNet :: IO (Network 10 '[5,3] 1) ghci&gt; let s = hiddenSing n ghci&gt; :t s s :: Sing '[5,3] ghci&gt; s SNat <code>SCons</code> SNat <code>SCons</code> SNil ~~~</p></li>
</ol></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/artificial-neural-networks.html" class="tag-a-tag">#artificial neural networks</a></li><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/linear-algebra.html" class="tag-a-tag">#linear algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/machine-learning.html" class="tag-a-tag">#machine learning</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical.html" class="tag-a-tag">#numerical</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html">Automatic Propagation of Uncertainty with AD</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html">Practical Dependent Types in Haskell 2: Existential Neural Networks and Types at
Runtime</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html';
    this.page.identifier = 'dependent-haskell-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>