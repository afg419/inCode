<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 2) Â· in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back to our journey through the singleton design pattern and the great singletons library! This post is a direct continuation of Part 1, so be sure to check that out first if you haven&#39;t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven&#39;t already! Again, code is built on GHC 8.2.2 with the lts-10.0 snapshot (so, singletons-2.3.1)."><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Introduction to Singletons (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back to our journey through the singleton design pattern and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>This post is a direct continuation of <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Part 1</a>, so be sure to check that out first if you haven't already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven't already!</p>
<p>Again, code is built on <em>GHC 8.2.2</em> with the <em><a href="https://www.stackage.org/lts-10.0">lts-10.0</a></em> snapshot (so, singletons-2.3.1).</p>
<h2>Review</h2>
<p>Let's return to our <code>Door</code> type:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L19-25 $(singletons [d| data DoorState = Opened | Closed | Locked deriving (Show, Eq) |])</p>
<p>data Door :: DoorState -&gt; Type where UnsafeMkDoor :: { doorMaterial :: String } -&gt; Door s ```</p>
<p>First, this derives the <em>type</em> <code>DoorState</code> with the values <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>, and also the <em>kind</em> <code>DoorState</code> with the <em>types</em> <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>. We then also derive the singletons (and implicit-style typeclass instances, reflectors, etc.) with the template haskell.</p>
<p>Then, there's <code>Door</code>. <code>Door</code> is great! It is an <em>indexed data type</em> (indexed by a type of kind <code>DoorState</code>) in that picking a different type variable gives a different &quot;type&quot; of Door:</p>
<ul>
<li><code>Door 'Opened</code> is a type that represents the type of an opened door</li>
<li><code>Door 'Closed</code> is a <em>different</em> type that represents the type of a <em>closed</em> door</li>
<li><code>Door 'Locked</code> is yet another (third) type that represents the type of a <em>locked</em> door.</li>
</ul>
<p>So, really, when we define <code>Door s</code>, we really are defining <em>three distinct</em> types[^fourth].</p>
<p>This is great and all, but isn't Haskell a language with static, compile-time types? Doesn't that mean that we have to know if our doors are opened, closed, or locked at compile-time?</p>
<p>This is something we can foresee being a big issue. It's easy enough to create a <code>Door s</code> if you know <code>s</code> at compile-time by just typing in a type annotation (<code>UnsafeMkDoor &quot;Oak&quot; :: Door 'Opened</code>). But what if we <em>don't</em> know <code>s</code> at compile-time?</p>
<p>To learn how to do this, we first need to learn how to <em>not care</em>.</p>
<h2>Ditching the Phantom</h2>
<p>Sometimes we don't <em>actually</em> care about the state of the door in the <em>type</em> of the door. We don't want <code>Door 'Opened</code> and <code>Door 'Closed</code>...we want a type to just represent a door, without the status in its type.</p>
<p>This might come about a bunch of different ways. Maybe you're reading a <code>Door</code> data from a serialization format, and you want to be able to parse <em>any</em> door (whatever door is serialized).</p>
<p>More concretely, we've seen this in <code>lockAnyDoor</code>, as well -- <code>lockAnyDoor</code> doesn't care about the type of its input (it can be <em>any</em> <code>Door</code>). It only cares about the type of its output (<code>Door 'Locked</code>).</p>
<p>To learn how to not care, we can describe a type for a door that does <em>not</em> have its status in its type.</p>
<p>We have a couple of options here. First, we can create a new type <code>SomeDoor</code> that is the same as <code>Door</code>, except instead of keeping its status in its type, it keeps it as a runtime value:</p>
<p>```haskell data SomeDoor = MkSomeDoor { someDoorState :: DoorState , someDoorMaterial :: String }</p>
<p>-- or, in GADT syntax data SomeDoor :: Type where MkSomeDoor :: { someDoorState :: DoorState , someDoorMaterial :: String } -&gt; SomeDoor ```</p>
<p>Note the similarity of <code>SomeDoor</code>'s declaration to <code>Door</code>'s declaration above. It's mostly the same, except, instead of <code>DoorState</code> being a type parameter, it is instead a runtime value inside <code>SomeDoor</code>.</p>
<p>Now, this is actually a type that we <em>could</em> have been using this entire time, if we didn't care about type safety. In the real world and in real applications, we actually might have written <code>SomeDoor</code> <em>before</em> we ever thought about <code>Door</code> with a phantom type. It's definitely the more typical &quot;standard&quot; Haskell thing.</p>
<p><code>SomeDoor</code> is great. But because it's a completely different type, we can't re-use any of our <code>Door</code> functions on this <code>SomeDoor</code>. We potentially have to write the same function twice for both <code>Door</code> and <code>SomeDoor</code>, because they have different implementations.</p>
<h3>The Existential Datatype</h3>
<p>However, there's another path we can take. With the power of singletons, we can actually implement <code>SomeDoor</code> <em>in terms of</em> <code>Door</code>, using an <strong>existential data type</strong>:</p>
<p>```haskell -- using existential constructor syntax data SomeDoor = forall s. MkSomeDoor (Sing s) (Door s)</p>
<p>-- or, using GADT syntax (preferred) -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L56-57 data SomeDoor :: Type where MkSomeDoor :: Sing s -&gt; Door s -&gt; SomeDoor ```</p>
<p><code>MkSomeDoor</code> is a constructor for an existential data type, meaning that the data type &quot;hides&quot; a type variable <code>s</code>. Note the type (<code>Sing s -&gt; Door s -&gt; SomeDoor</code>) and how the result type (<code>SomeDoor</code>) <em>forgets</em> the <code>s</code> and hides all traces of it. Think of it like a type variable sponge -- type variable goes in, but it's absorbed opaquely into the result type.</p>
<p>Note the similarities between our original <code>SomeDoor</code> and this one.</p>
<p>```haskell -- | Re-implementing door data SomeDoor where MkSomeDoor :: DoorState -&gt; String -&gt; SomeDoor</p>
<p>-- | Re-using Door, as an existential type data SomeDoor where MkSomeDoor :: Sing s -&gt; Door s -&gt; SomeDoor -- ^ data Door s = UnsafeMkDoor String ```</p>
<p>Basically, our type before re-implements <code>Door</code>. But the new one actually directly uses the original <code>Door s</code>. This means we can <em>directly</em> re-use our <code>Door</code> functions on <code>SomeDoor</code>s, without needing to convert our implementations.</p>
<p>In Haskell, existential data types are pretty nice, syntactically, to work with. Let's write some basic functions to see. First, a function to &quot;make&quot; a <code>SomeDoor</code> from a <code>Door</code>:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L59-63 fromDoor :: Sing s -&gt; Door s -&gt; SomeDoor fromDoor = MkSomeDoor</p>
<p>fromDoor_ :: SingI s =&gt; Door s -&gt; SomeDoor fromDoor_ = MkSomeDoor sing ```</p>
<p>So that's how we <em>make</em> one...how do we <em>use</em> it? Let's port our <code>Door</code> functions to <code>SomeDoor</code>, by re-using our pre-existing functions whenever we can:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L65-72 closeSomeOpenedDoor :: SomeDoor -&gt; Maybe SomeDoor closeSomeOpenedDoor (MkSomeDoor s d) = case s of SOpened -&gt; Just . fromDoor_ $ closeDoor d SClosed -&gt; Nothing SLocked -&gt; Nothing</p>
<p>lockAnySomeDoor :: SomeDoor -&gt; SomeDoor lockAnySomeDoor (MkSomeDoor s d) = fromDoor_ $ lockAnyDoor s d ```</p>
<p>Using an existential wrapper with a singleton makes this pretty simple -- just a simple unwrapping and re-wrapping! Imagine having to re-implement all of these functions for a completely different type, and having to re-implement all of our previous <code>Door</code> functions.</p>
<p>It's important to remember that the secret ingredient here is the <code>Sing s</code> we store inside <code>MkSomeDoor</code> -- it gives our pattern matchers the ability to deduce the <code>s</code> type. Without it, the <code>s</code> would be lost forever.</p>
<p>Imagine if <code>MkSomeDoor</code> did not have the <code>Sing</code>:</p>
<p><code>haskell data SomeDoor where     MkSomeDoor  :: Door s -&gt; SomeDoor       -- no Sing s ???</code></p>
<p>It would then be impossible to write <code>closeSomeOpenedDoor</code>:</p>
<p><code>haskell closeSomeOpenedDoor :: SomeDoor -&gt; Maybe SomeDoor closeSomeOpenedDoor (MkSomeDoor d) =             -- is the door opened, closed, or locked?             -- there's no way to know!             -- curses, type erasure!</code></p>
<h3>The Link</h3>
<p>It's important to remember that our original separate-implementation <code>SomeDoor</code> is, functionally, identical to the new code-reusing <code>Door</code>. All of the contents are isomorphic with each other, and you could write a function converting one to the other. The reason why they are the same is that <em>having an existentially quantified singleton is the same as having a value of the corresponding type.</em> Having an existentially quantified <code>SingDS s</code> is <em>the same as</em> having a value of type <code>DoorState</code>.</p>
<p>In fact, the <em>singletons</em> library gives us a direct existential wrapper:</p>
<p><code>haskell -- from singletons (not the actual definition) data SomeSing DoorState :: Type where     SomeSing :: Sing s -&gt; SomeSing DoorState</code></p>
<p>There are three values of type <code>SomeSing DoorState</code>:</p>
<p><code>haskell SomeSing SOpened :: SomeSing DoorState SomeSing SClosed :: SomeSing DoorState SomeSing SLocked :: SomeSing DoorState</code></p>
<p>A value of type <code>SomeSing DoorState</code> (which contains an existentially quantified <code>Sing s</code> -- a <code>SingDS</code>) is <em>the same</em> as a value of type <code>DoorState</code>. The two types are identical! (Or, well, isomorphic. As a fun exercise, write out the explicit isomorphism -- the <code>SomeSing DoorState -&gt; DoorState</code> and the <code>DoorState -&gt; SomeSing DoorState</code>).</p>
<p>Our new <code>SomeDoor</code> containing an existentially quantified <code>Sing s</code> is the same as our first <code>SomeDoor</code> containing just a <code>DoorState</code>.</p>
<h4>Why Bother</h4>
<p>If they're identical, why use a <code>Sing</code> or the new <code>SomeDoor</code> at all? Why not just use a <code>DoorState</code> value?</p>
<p>The main reason (besides allowing code-reuse) is that <em>using the singleton lets us directly recover the type</em>. Essentially, a <code>Sing s</code> not only contains whether it is Opened/Closed/Locked (like a <code>DoorState</code> would)...it contains it in a way that GHC can use to <em>bring it all back</em> to the type level.</p>
<p>A <code>forall s. SomeDoor (Sing s) (Door s)</code> essentially contains <code>s</code> <em>with</em> <code>Door s</code>. When you see this, you <em>should read this as</em> <code>forall s. SomeDoor s (Door s)</code> (and, indeed, this is similar to how it is written in dependently typed languages.)</p>
<p>It's kind of like how, when you're used to reading Applicative style, you start seeing <code>f &lt;$&gt; x &lt;*&gt; y</code> and reading it like <code>f x y</code>. When you see <code>forall s. SomeDoor (Sing s) (Door s)</code>, you should read (the pseudo-haskell) <code>forall s. SomeDoor s (Door s)</code>. The role of <code>Sing s</code> there is, like in Part 1, simply to be a run-time stand-in for the type <code>s</code> itself.</p>
<p>So, for our original <code>Door s</code> functions, we need to know <code>s</code> at runtime -- storing the <code>Sing s</code> gives GHC exactly that. Once you get the <code>Sing s</code> back, you can now use it in all of our type-safe functions from Part 1, and you're back in type-safe land.[^pos]</p>
<h3>Some Lingo</h3>
<p>In the language of dependently typed programming, we call <code>SomeDoor</code> a <strong>dependent sum</strong>, because you can imagine it basically as a sum type:</p>
<p><code>haskell data SomeDoor = SDOpened (Door 'Opened)               | SDClosed (Door 'Closed)               | SDLocked (Door 'Locked)</code></p>
<p>A three-way sum between a <code>Door 'Opened</code>, a <code>Door 'Closed</code>, and a <code>Door 'Locked</code>, essentially. If you have a <code>SomeDoor</code>, it's <em>either</em> an opened door, a closed door, or a locked door. Try looking at this new <code>SomeDoor</code> until you realize that this type is the same type as the previous <code>SomeDoor</code>!</p>
<p>You might also see <code>SomeDoor</code> called a <strong>dependent pair</strong> -- it's a &quot;tuple&quot; where the <em>type</em> of the second item (our <code>Door s</code>) is determined by the <em>value</em> of the first item (our <code>Sing s</code>).</p>
<p>In Idris, we could write <code>SomeDoor</code> as a type alias, using its native dependent pair syntax, as <code>(s ** Door s)</code>. The <em>value</em> of the first item reveals to us (through a pattern match, in Haskell) the <em>type</em> of the second.</p>
<h3>Types at Runtime</h3>
<p>With this last tool, we finally have enough to build a function to &quot;make&quot; a door with the status unknown until runtime:</p>
<p><code>haskell mkSomeDoor :: DoorState -&gt; String -&gt; SomeDoor mkSomeDoor = \case     Opened -&gt; MkSomeDoor SOpened . mkDoor SOpened     Closed -&gt; MkSomeDoor SClosed . mkDoor SClosed     Locked -&gt; MkSomeDoor SLocked . mkDoor SLocked</code></p>
<p><code>haskell ghci&gt; let mySomeDoor = mkSomeDoor Opened &quot;Birch&quot; ghci&gt; :t mySomeDoor SomeDoor ghci&gt; putStrLn $ case mySomeDoor of         MkSomeDoor SOpened _ -&gt; &quot;mySomeDoor was opened!&quot;         MkSomeDoor SClosed _ -&gt; &quot;mySomeDoor was closed!&quot;         MkSomeDoor SLocked _ -&gt; &quot;mySomeDoor was locked!&quot; mySomeDoor was opened!</code></p>
<p>Using <code>mkSomeDoor</code>, we can truly pass in a <code>DoorState</code> that we generate at runtime (from IO, or a user prompt, or a configuration file, maybe), and create a <code>Door</code> based on it.</p>
<p>Take <em>that</em>, type erasure! :D</p>
<h3>The Existential Type</h3>
<p>An <em>existentially quantified</em> type is one that is hidden to the user/consumer, but directly chosen by the producer. The producer chooses the type, and the user has to handle any possible type that the producer gave.</p>
<p>This is in direct contrast to the <em>universally quantified</em> type (which most Haskellers are used to seeing), where the type is directly chosen by the <em>user</em>. The user chooses the type, and the producer has to handle any possible type that the user asks for.</p>
<p>For example, a function like:</p>
<p><code>haskell read :: Read a =&gt; String -&gt; a</code></p>
<p>Is universally quantified over <code>a</code>: The <em>caller</em> of <code>read</code> gets to pick which type is given. The burden is on the implementor of <code>read</code> to be able to handle whatever <code>a</code> the user picks.</p>
<p>But, for a value like:</p>
<p><code>haskell myDoor :: SomeDoor</code></p>
<p>The type variable <code>s</code> is existentially quantified. The person who <em>made</em> <code>myDoor</code> picked what <code>s</code> was. And, if you <em>use</em> <code>myDoor</code>, you have to be ready to handle <em>any</em> <code>s</code> they could have chosen.</p>
<p>In Haskell, there's another way to express an existentially quantified type: the CPS-style encoding. To help us understand it, let's compare a basic function in both styles. We saw earlier <code>mkSomeDoor</code>, which takes a <code>DoorState</code> and a <code>String</code> and returns an existentially quantified <code>Door</code> in the form of <code>SomeDoor</code>:</p>
<p><code>haskell mkSomeDoor     :: DoorState     -&gt; String     -&gt; SomeDoor mkSomeDoor s m = case s of     Opened -&gt; MkSomeDoor SOpened (mkDoor SOpened m)     Closed -&gt; MkSomeDoor SClosed (mkDoor SClosed m)     Locked -&gt; MkSomeDoor SLocked (mkDoor SLocked m)</code></p>
<p>The caller of the function can then break open the <code>SomeDoor</code> and must handle whatever <code>s</code> they find inside.</p>
<p>We can write the same function using a <em>CPS-style</em> existential instead:</p>
<p><code>haskell withDoor     :: DoorState     -&gt; String     -&gt; (forall s. Sing s -&gt; Door s -&gt; r) -&gt; r withDoor s m f = case s of     Opened -&gt; f SOpened (mkDoor SOpened m)     Closed -&gt; f SClosed (mkDoor SClosed m)     Locked -&gt; f SLocked (mkDoor SLocked m)</code></p>
<p>With a Rank-N Type, <code>withDoor</code> takes a <code>DoorState</code> and a <code>String</code> and a <em>function to handle a <code>Door s</code> polymorphically</em>. The caller of <code>withDoor</code> must provide a handler that can handle <em>any</em> <code>s</code>, in a uniform and parametrically polymorphic way. The function then gives the result of the handler function called on the resulting <code>Sing s</code> and <code>Door s</code>.</p>
<p><code>haskell ghci&gt; withDoor Opened &quot;Birch&quot; $ \s d -&gt; case s of          SOpened -&gt; &quot;Opened door!&quot;          SClosed -&gt; &quot;Closed door!&quot;          SLocked -&gt; &quot;Locked door!&quot; Opened door!</code></p>
<p>The key to making this work is that your handler function <em>has to be polymorphic</em> over all possible <code>s</code>s. This way, it can handle any potential <code>s</code> that the producer gives. Essentially, the producer is &quot;returning&quot; an <code>s</code> -- existentially quantified.</p>
<h3>Reification</h3>
<p>The general pattern we are exploring here is called <strong>reification</strong> -- we're taking a dynamic run-time value, and lifting it to the type level as a type (here, the type variable <code>s</code>). You can think of reification as the opposite of <em>reflection</em>, and imagine the two as being the &quot;gateway&quot; between the type-safe and unsafe world. In the dynamic world of a <code>DoorState</code> term-level value, you have no type safety. You live in the world of <code>SomeDoor</code>, <code>closeSomeOpenedDoor</code>, <code>lockAnySomeDoor</code>, etc. But, you can <em>reify</em> your <code>DoorState</code> value to a <em>type</em>, and enter the type-safe world of <code>Door s</code>, <code>closeDoor</code>, <code>lockDoor</code>, and <code>lockAnyDoor</code>.</p>
<p>The <em>singletons</em> library automatically generates functions to directly reify <code>DoorState</code> values:</p>
<p><code>haskell toSing       :: DoorState -&gt; SomeSing DoorState withSomeSing :: DoorState -&gt; (forall s. Sing (s :: DoorState) -&gt; r) -&gt; r withSomeSing :: DoorState -&gt; (forall s. SDoorState s  -&gt; r) -&gt; r                                      -- ^ using the convenience type synonym</code></p>
<p>The first one reifies a <code>DoorState</code> as an existentially quantified data type, and the second one reifies one in CPS-style, without the intermediate data type.</p>
<p>We can actually use these to write <code>mkSomeDoor</code> and <code>withDoor</code> in a nicer way, without directly pattern matching on our constructors:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L74-79 mkSomeDoor :: DoorState -&gt; String -&gt; SomeDoor mkSomeDoor ds = case toSing ds of SomeSing s -&gt; MkSomeDoor s . mkDoor s</p>
<p>withDoor :: DoorState -&gt; String -&gt; (forall s. Sing s -&gt; Door s -&gt; r) -&gt; r withDoor ds m f = withSomeSing ds $ \s -&gt; f s (UnsafeMkDoor m) ```</p>
<h2>Zooming Out</h2>
<p>Alright! We've spent two blog posts going over a lot of different things in the context of our humble <code>Door s</code> type. Let's zoom out and take a large-scale look at how <em>singletons</em> (the design pattern, and the library) helps us in general.</p>
<h3>Sing</h3>
<p>The crux of everything is the <code>Sing :: Type -&gt; Type</code> indexed type. If you see a value of type <code>Sing s</code>, you should really just think &quot;a runtime witness for <code>s</code>&quot;. If you see:</p>
<p><code>haskell lockAnyDoor :: Sing s -&gt; Door s -&gt; Door 'Locked MkSomeDoor  :: Sing s -&gt; Door s -&gt; SomeDoor</code></p>
<p>You should read it as (in pseudo-Haskell)</p>
<p><code>haskell lockAnyDoor :: { s } -&gt; Door s -&gt; Door 'Locked MkSomeDoor  :: { s } -&gt; Door s -&gt; SomeDoor</code></p>
<p>This is seen clearly if we look at the partially applied type signatures:</p>
<p><code>haskell lockAnyDoor SOpened :: Door 'Opened -&gt; Door 'Locked MkSomeDoor  SLocked :: Door 'Locked -&gt; SomeDoor</code></p>
<p>If you squint, this kinda looks like:</p>
<p><code>haskell lockAnyDoor 'Opened :: Door 'Opened -&gt; Door 'Locked MkSomeDoor  'Locked :: Door 'Locked -&gt; SomeDoor</code></p>
<p>And indeed, when we get real dependent types in Haskell, we will really be directly passing types (that act as their own runtime values) instead of singletons.</p>
<p>It is important to remember that <code>Sing</code> is poly-kinded, so we can have <code>Sing 'Opened</code>, but also <code>Sing 'True</code>, <code>Sing 5</code>, and <code>Sing '['Just 3, 'Nothing, 'Just 0]</code> as well. This is the real benefit of using the <em>singletons</em> library instead of writing our own singletons -- we get to work uniformly with singletons of all kinds.</p>
<h4>SingI</h4>
<p><code>SingI</code> is a bit of typeclass trickery that lets us implicitly pass <code>Sing</code>s to functions:</p>
<p><code>haskell class SingI s where     sing :: Sing s</code></p>
<p>If you see:</p>
<p><code>haskell lockAnyDoor :: Sing  s -&gt; Door s -&gt; Door 'Locked MkSomeDoor  :: Sing  s -&gt; Door s -&gt; SomeDoor</code></p>
<p>These are <em>identical</em> to</p>
<p><code>haskell lockAnyDoor :: SingI s =&gt; Door s -&gt; Door 'Locked MkSomeDoor  :: SingI s =&gt; Door s -&gt; SomeDoor</code></p>
<p>Either way, you're passing in the ability to get a runtime witness on <code>s</code> -- just in one way, it is asked for as an explicit argument, and the second way, it is passed in using a typeclass.</p>
<p>We can <em>convert</em> from <code>SingI s -&gt;</code> style to <code>SingI s =&gt;</code> style using <code>sing</code>:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L50-63 lockAnyDoor_ :: SingI s =&gt; Door s -&gt; Door 'Locked lockAnyDoor_ = lockAnyDoor sing</p>
<p>fromDoor_ :: SingI s =&gt; Door s -&gt; SomeDoor fromDoor_ = MkSomeDoor sing ```</p>
<p>And we can convert from <code>SingI s =&gt;</code> style to <code>SingI s -&gt;</code> style using <code>withSingI</code>:</p>
<p>```haskell lockAnyDoor :: Sing s -&gt; Door s -&gt; Door 'Locked lockAnyDoor s d = withSingI s (lockAnyDoor_ d)</p>
<p>fromDoor :: Sing s -&gt; Door s -&gt; SomeDoor fromDoor s d = withSingI s (fromDoor_ d) ```</p>
<p>Again, the same function -- just two different styles of calling them.</p>
<h3>Reflection and Reification</h3>
<p>Reflection is the process of bringing a type-level thing to a value at the term level (&quot;losing&quot; the type information in the process) and reification is the process of bringing a value-level Reification is the process of going from a value at the <em>term level</em> to the <em>type level</em>.</p>
<p>You can think of reflection and reification as being the &quot;gateways&quot; between the untyped/unsafe world and the typed/safe world. Reflection takes you from the typed world to the untyped world (from <code>Sing s</code> to <code>DoorState</code>) and reification takes you from the untyped world to the typed world (from <code>DoorState</code> to <code>Sing s</code>).</p>
<p>One limitation in Haskell is that there is no actual link between the type <code>DoorState</code> and its <em>values</em> with the <em>kind</em> <code>DoorState</code> with its <em>types</em>. Sure, the constructors have the same names, but the language doesn't actually link them together for us.</p>
<h4>SingKind</h4>
<p>The <em>singletons</em> library handles this by using a typeclass with associated types to implement a generalized reflection and reification process. It gives us the <code>SingKind</code> &quot;kindclass&quot;:</p>
<p>``<code>haskell class SingKind k where      --</code>k` is a kind! -- | Associate a kind k with its reflected type type Demote k = (r :: Type)</p>
<pre><code>-- | Reflect a singleton to its term-level value
fromSing :: Sing (a :: k) -&gt; Demote k

-- | Reify a term-level value to the type level, as an existentially
-- quantified singleton
toSing :: Demote k -&gt; SomeSing k</code></pre>
<p>```</p>
<p>Instances of <code>SingKind</code> are (promoted) <em>kinds</em> like <code>Bool</code>-the-kind, <code>DoorState</code>-the-kind, etc., and <code>Demote</code> is an associated type/type family that associates each instance with the <em>type</em> it is promoted from. (Note -- writing these type signatures requires the <code>-XTypeInType</code> extension, which lets us treat kinds as types)</p>
<p>For example, remember how <code>data DoorState = Opened | Closed | Locked</code> created the <em>type</em> <code>DoorState</code> (with value constructors <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>), and also the <em>kind</em> <code>DoorState</code> (with <em>type</em> constructors <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>). Our <em>kind</em> <code>DoorState</code> would be the instance of <code>SingKind</code>, and <code>Demote DoorState</code> would be the <em>type</em> <code>DoorState</code>.</p>
<p>The reason we need an explicit <code>Demote</code> associated type is, again, that GHC doesn't actually link the type and its promoted kind. <code>Demote</code> lets us explicitly specify what type a <code>Kind</code> should expect its term-level reflected values to be.</p>
<h4>Examples</h4>
<p>To illustrate explicitly, here is the automatically generated instance of <code>SingKind</code> for the <code>DoorState</code> <em>kind</em>:</p>
<p>```haskell instance SingKind DoorState where -- the <em>kind</em> DoorState type Demote DoorState = DoorState -- the <em>type</em> DoorState</p>
<pre><code>fromSing
    :: Sing (s :: DoorState)        -- the *kind* DoorState
    -&gt; DoorState                    -- the *type* DoorState
fromSing = \case
    SOpened -&gt; Opened
    SClosed -&gt; Closed
    SLocked -&gt; Locked

toSing
    :: DoorState                    -- the *type* DoorState
    -&gt; SomeSing DoorState           -- the *kind* DoorState
toSing = \case
    Opened -&gt; SomeSing SOpened
    Closed -&gt; SomeSing SClosed
    Locked -&gt; SomeSing SLocked</code></pre>
<p>```</p>
<p>If you are unfamiliar with how associated types work, <code>type Demote DoorState = DoorState</code> means that wherever we see <code>Demote DoorState</code> (with <code>DoorState</code> the <em>kind</em>), we replace it with <code>DoorState</code> (the <em>type</em>). That's why the type of our reflection function <code>fromSing :: Sing s -&gt; Demote DoorState</code> can be simplified to <code>fromSing :: Sing s -&gt; DoorState</code>.</p>
<p>Let's take a look at the instance for <code>Bool</code>, to compare:</p>
<p>```haskell -- Bool singletons have two constructors: SFalse :: Sing 'False STrue :: Sing 'True</p>
<p>instance SingKind Bool where -- the <em>kind</em> Bool type Demote Bool = Bool -- the <em>type</em> Bool</p>
<pre><code>fromSing
    :: Sing (b :: Bool)        -- the *kind* Bool
    -&gt; Bool                    -- the *type* Bool
fromSing = \case
    SFalse -&gt; False
    STrue  -&gt; True

toSing
    :: Bool                    -- the *type* Bool
    -&gt; SomeSing Bool           -- the *kind* Bool
toSing = \case
    False -&gt; SomeSing SFalse
    True  -&gt; SomeSing STrue</code></pre>
<p>```</p>
<p>And a more sophisticated example, let's look at the instance for <code>Maybe</code>:</p>
<p>```haskell -- Maybe singletons have two constructors: SNothing :: Sing 'Nothing SJust :: Sing x -&gt; Sing ('Just x)</p>
<p>instance SingKind k =&gt; SingKind (Maybe k) where -- the <em>kind</em> Maybe type Demote (Maybe k) = Maybe (Demote k) -- the <em>type</em> Maybe</p>
<pre><code>fromSing
    :: Sing (m :: Maybe k)        -- the *kind* Maybe
    -&gt; Maybe (Demote k)           -- the *type* Maybe
fromSing = \case
    SNothing -&gt; Nothing
    SJust sx -&gt; Just (fromSing sx)

toSing
    :: Maybe (Demote k)             -- the *type* Maybe
    -&gt; SomeSing (Maybe k)           -- the *kind* Maybe
toSing = \case
    Nothing -&gt; SomeSing SNothing
    Just x  -&gt; case toSing x of
      SomeSing sx -&gt; SomeSing (SJust sx)</code></pre>
<p>```</p>
<p>This definition, I think, is a real testament to the usefulness of having all of our singletons be unified under the same system. Because of how <code>SingKind</code> works, <code>Demote (Maybe DoorState)</code> is evaluated to <code>Maybe (Demote DoorState)</code>, which is simplified to <code>Maybe DoorState</code>. This means that if we have a way to reify <code>DoorState</code> values, we also have a way to reify <code>Maybe DoorState</code> values! And, if we have a way to reflect <code>DoorState</code> singletons, we also have a way to reflect <code>Maybe DoorState</code> singletons!</p>
<h4>SomeSing</h4>
<p>Throughout all of this, we utilize <code>SomeSing</code> as a generic poly-kinded existential wrapper:</p>
<p><code>haskell data SomeSing :: Type -&gt; Type where     SomeSing :: Sing (x :: k) -&gt; SomeSing k</code></p>
<p>Basically, this says that <code>SomeSing k</code> contains a <code>Sing x</code>, where <code>x</code> is of kind <code>k</code>. This is why we had, earlier:</p>
<p><code>haskell SomeSing :: Sing (s :: DoorState) -&gt; SomeSing DoorState SomeSing :: Sing (s :: Bool)      -&gt; SomeSing Bool SomeSing :: Sing (s :: Maybe k)   -&gt; SomeSing (Maybe k)</code></p>
<p>If we use <code>SomeSing</code> with, say, <code>SClosed</code>, we get <code>SomeSing :: Sing 'Closed -&gt; SomeSing DoorState</code>. <code>SomeSing</code> is an indexed type that tells us the <em>kind</em> of the type variable we existentially quantifying over. The value <code>SomeSing STrue</code> would have the type <code>SomeSing Bool</code>. The value <code>SomeSing (SJust SClosed)</code> would have the type <code>SomeSing (Maybe DoorState)</code>.</p>
<h2>Looking Forward</h2>
<p>Between these first two parts, we explored a specific use case that would benefit from dependent types (simple phantom types for state transitions) and explored how the <em>singletons</em> and design pattern help us implement the functionality necessary to make things useful, and snuck in some concepts from dependently typed programming as well. We then took a step back to explore the <em>singletons</em> library in a more &quot;universal&quot; way, and saw how it is generalized to many different types.</p>
<p>The code is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">here</a> for you to play around with yourself!</p>
<p>Now that the basics are out of the way, in Part 3 we'll jump deep into type-level programming and being able to lift our term-level functions on values up to become type-level functions, and how to use this to enhance our code!</p>
<p>Let me know in the comments if you have any questions! I'm also usually idling on the freenode <code>#haskell</code> channel, as well, as <em>jle`</em>.</p>
<p>Again, check out the <a href="https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf">original singletons paper</a> for a really nice technical overview of all of these techniques!</p>
<h3>Exercise</h3>
<p>Check out the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">sample code</a> for solutions!</p>
<ol>
<li><p>Let's revisit our original redundant <code>SomeDoor</code>, compared to our final <code>SomeDoor</code>:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L56-87 data OldSomeDoor :: Type where OldMkSomeDoor :: DoorState -&gt; String -&gt; OldSomeDoor</p>
<p>data SomeDoor :: Type where MkSomeDoor :: Sing s -&gt; Door s -&gt; SomeDoor ```</p>
<p>To help convince yourself that the two are equal, write functions converting between the two:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L89-92 toOld :: SomeDoor -&gt; OldSomeDoor</p>
<p>fromOld :: OldSomeDoor -&gt; SomeDoor ```</p>
<p><strong>Avoid directly pattern matching on the singletons or constructors</strong>. Instead, use <em>singletons</em> library tools like <code>toSing</code>, <code>withSomeSing</code>, <code>fromSing</code>, etc.</p></li>
<li><p>Previously, we had an <code>unlockDoor</code> function that took an <code>Int</code> (the &quot;password&quot;) with a <code>Door 'Locked</code> and returned a <code>Maybe (Door 'Closed)</code>. It returns a <code>Door 'Closed</code> (unlocked door) in <code>Just</code> if an odd number was given, and <code>Nothing</code> otherwise (a failed unlock)</p>
<p>Use this to implement a that would return a <code>SomeDoor</code>. Re-use the &quot;password&quot; logic from the original <code>unlockDoor</code>. If the door is successfully unlocked (with a <code>Just</code>), return the unlocked door in a <code>SomeDoor</code>. Otherwise, <em>return the original locked door</em> (in a <code>SomeDoor</code>).</p>
<p>``<code>haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L95-100 unlockDoor :: Int -&gt; Door 'Locked -&gt; Maybe (Door 'Closed) unlockDoor n (UnsafeMkDoor m)     | n</code>mod` 2 == 1 = Just (UnsafeMkDoor m) | otherwise = Nothing</p>
<p>unlockDoor' :: Int -&gt; Door 'Locked -&gt; SomeDoor ```</p></li>
<li><p>Implement <code>openAnyDoor'</code> in the same style, with respect to <code>openAnyDoor</code>:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L105-114 openAnyDoor :: SingI s =&gt; Int -&gt; Door s -&gt; Maybe (Door 'Opened) openAnyDoor n = openAnyDoor_ sing where openAnyDoor_ :: Sing s -&gt; Door s -&gt; Maybe (Door 'Opened) openAnyDoor_ = \case SOpened -&gt; Just SClosed -&gt; Just . openDoor SLocked -&gt; fmap openDoor . unlockDoor n</p>
<p>openAnyDoor' :: Int -&gt; SomeDoor -&gt; SomeDoor ```</p>
<p>Remember to re-use <code>openAnyDoor</code>.</p></li>
<li><p>Write the <code>SingKind</code> instance for the promoted kind of a custom list type:</p>
<p>```haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L120-126 data List a = Nil | Cons a (List a)</p>
<p>data instance Sing (x :: List k) where SNil :: Sing 'Nil SCons :: Sing x -&gt; Sing xs -&gt; Sing ('Cons x xs)</p>
<p>instance SingKind k =&gt; SingKind (List k) where ```</p>
<p>The singletons for <code>List</code> are:</p>
<p>```haskell SNil :: Sing 'Nil SCons :: Sing x -&gt; Sing xs -&gt; Sing ('Cons x xs)</p>
<p>```</p></li>
</ol></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-2.html';
    this.page.identifier = 'singletons-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>