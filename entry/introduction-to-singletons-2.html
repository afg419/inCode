<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back to our journey through the singleton design pattern and the great singletons library! This post is a direct continuation of Part 1, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already! Again, code is built on GHC 8.2.2 with the lts-10.0 snapshot (so, singletons-2.3.1)."><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Introduction to Singletons (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back to our journey through the singleton design pattern and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>This post is a direct continuation of <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Part 1</a>, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already!</p>
<p>Again, code is built on <em>GHC 8.2.2</em> with the <em><a href="https://www.stackage.org/lts-10.0">lts-10.0</a></em> snapshot (so, singletons-2.3.1).</p>
<h2 id="review">Review</h2>
<p>Let’s return to our <code>Door</code> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L17-23</span>
<span class="fu">$</span>(singletons [d|
  data DoorState = Opened | Closed | Locked
    deriving (Show, Eq)
  |])

<span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</code></pre></div>
<p>First, this derives the <em>type</em> <code>DoorState</code> with the values <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>, and also the <em>kind</em> <code>DoorState</code> with the <em>types</em> <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>. We then also derive the singletons (and implicit-style typeclass instances, reflectors, etc.) with the template haskell.</p>
<p>Then, there’s <code>Door</code>. <code>Door</code> is great! It is an <em>indexed data type</em> (indexed by a type of kind <code>DoorState</code>) in that picking a different type variable gives a different “type” of Door:</p>
<ul>
<li><code>Door 'Opened</code> is a type that represents the type of an opened door</li>
<li><code>Door 'Closed</code> is a <em>different</em> type that represents the type of a <em>closed</em> door</li>
<li><code>Door 'Locked</code> is yet another (third) type that represents the type of a <em>locked</em> door.</li>
</ul>
<p>So, really, when we define <code>Door s</code>, we really are defining <em>three distinct</em> types<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>This is great and all, but isn’t Haskell a language with static, compile-time types? Doesn’t that mean that we have to know if our doors are opened, closed, or locked at compile-time?</p>
<p>This is something we can foresee being a big issue. It’s easy enough to create a <code>Door s</code> if you know <code>s</code> at compile-time by just typing in a type annotation (<code>UnsafeMkDoor &quot;Oak&quot; :: Door 'Opened</code>). But what if we <em>don’t</em> know <code>s</code> at compile-time?</p>
<p>To learn how to do this, we first need to learn how to <em>not care</em>.</p>
<h2 id="ditching-the-phantom">Ditching the Phantom</h2>
<p>Sometimes we don’t <em>actually</em> care about the state of the door in the <em>type</em> of the door. We don’t want <code>Door 'Opened</code> and <code>Door 'Closed</code>…we want a type to just represent a door, without the status in its type.</p>
<p>This might come about a bunch of different ways. Maybe you’re reading a <code>Door</code> data from a serialization format, and you want to be able to parse <em>any</em> door (whatever door is serialized).</p>
<p>More concretely, we’ve seen this in <code>lockAnyDoor</code>, as well – <code>lockAnyDoor</code> doesn’t care about the type of its input (it can be <em>any</em> <code>Door</code>). It only cares about the type of its output (<code>Door 'Locked</code>).</p>
<p>To learn how to not care, we can describe a type for a door that does <em>not</em> have its status in its type.</p>
<p>We have a couple of options here. First, we can create a new type <code>SomeDoor</code> that is the same as <code>Door</code>, except instead of keeping its status in its type, it keeps it as a runtime value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">MkSomeDoor</span>
    {<span class="ot"> someDoorState    ::</span> <span class="dt">DoorState</span>
    ,<span class="ot"> someDoorMaterial ::</span> <span class="dt">String</span>
    }

<span class="co">-- or, in GADT syntax</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span> <span class="ot">::</span>
      {<span class="ot"> someDoorState    ::</span> <span class="dt">DoorState</span>
      ,<span class="ot"> someDoorMaterial ::</span> <span class="dt">String</span>
      } <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>Note the similarity of <code>SomeDoor</code>’s declaration to <code>Door</code>’s declaration above. It’s mostly the same, except, instead of <code>DoorState</code> being a type parameter, it is instead a runtime value inside <code>SomeDoor</code>.</p>
<p>Now, this is actually a type that we <em>could</em> have been using this entire time, if we didn’t care about type safety. In the real world and in real applications, we actually might have written <code>SomeDoor</code> <em>before</em> we ever thought about <code>Door</code> with a phantom type. It’s definitely the more typical “standard” Haskell thing.</p>
<p><code>SomeDoor</code> is great. But because it’s a completely different type, we can’t re-use any of our <code>Door</code> functions on this <code>SomeDoor</code>. We potentially have to write the same function twice for both <code>Door</code> and <code>SomeDoor</code>, because they have different implementations.</p>
<h3 id="the-existential-datatype">The Existential Datatype</h3>
<p>However, there’s another path we can take. With the power of singletons, we can actually implement <code>SomeDoor</code> <em>in terms of</em> <code>Door</code>, using an <strong>existential data type</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- using existential constructor syntax</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> forall s<span class="fu">.</span> <span class="dt">MkSomeDoor</span> (<span class="dt">Sing</span> s) (<span class="dt">Door</span> s)

<span class="co">-- or, using GADT syntax (preferred)</span>
<span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L54-55</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p><code>MkSomeDoor</code> is a constructor for an existential data type, meaning that the data type “hides” a type variable <code>s</code>. Note the type (<code>Sing s -&gt; Door s -&gt; SomeDoor</code>) and how the result type (<code>SomeDoor</code>) <em>forgets</em> the <code>s</code> and hides all traces of it.</p>
<p>Note the similarities between our original <code>SomeDoor</code> and this one.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Re-implementing door</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>

<span class="co">-- | Re-using Door, as an existential type</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> s  <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
                            <span class="co">-- ^ data Door s = UnsafeMkDoor String</span></code></pre></div>
<p>Basically, our type before re-implements <code>Door</code>. But the new one actually directly uses the original <code>Door s</code>. This means we can <em>directly</em> re-use our <code>Door</code> functions on <code>SomeDoor</code>s, without needing to convert our implementations.</p>
<p>In Haskell, existential data types are pretty nice, syntactically, to work with. Let’s write some basic functions to see. First, a function to “make” a <code>SomeDoor</code> from a <code>Door</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L57-61</span>
<span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor <span class="fu">=</span> <span class="dt">MkSomeDoor</span>

<span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor_ <span class="fu">=</span> <span class="dt">MkSomeDoor</span> sing</code></pre></div>
<p>So that’s how we <em>make</em> one…how do we <em>use</em> it? Let’s port our <code>Door</code> functions to <code>SomeDoor</code>, by re-using our pre-existing functions whenever we can:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L63-70</span>
<span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span>
closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">.</span> fromDoor_ <span class="fu">$</span> closeDoor d
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">lockAnySomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
lockAnySomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> fromDoor_ <span class="fu">$</span> lockAnyDoor s d</code></pre></div>
<p>Using an existential wrapper with a singleton makes this pretty simple – just a simple unwrapping and re-wrapping! Imagine having to re-implement all of these functions for a completely different type, and having to re-implement all of our previous <code>Door</code> functions!</p>
<p>It’s important to remember that the secret ingredient here is the <code>Sing s</code> we store inside <code>MkSomeDoor</code> – it gives our pattern matchers the ability to deduce the <code>s</code> type. Without it, the <code>s</code> would be lost forever.</p>
<p>Imagine if <code>MkSomeDoor</code> did not have the <code>Sing</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>It would then be impossible to write <code>closeSomeOpenedDoor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span>
closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> d) <span class="fu">=</span>
            <span class="co">-- is the door opened, closed, or locked?</span>
            <span class="co">-- there&#39;s no awy to know!</span></code></pre></div>
<h3 id="the-link">The Link</h3>
<p>It’s important to remember that our original separate-implementation <code>SomeDoor</code> is, functionally, identical to the new code-reusing <code>Door</code>. All of the contents are isomorphic with each other, and you could write a function converting one to the other. The reason why they are the same is that <em>having an existentially quantified singleton is the same as having a value of the corresponding type.</em> Having an existentially quantified <code>SingDS s</code> is <em>the same as</em> having a value of type <code>DoorState</code>.</p>
<p>In fact, the <em>singletons</em> library gives us a direct existential wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- from singletons (not the actual definition)</span>
<span class="kw">data</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></code></pre></div>
<p>There are three values of type <code>SomeSing DoorState</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SomeSing</span> <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
<span class="dt">SomeSing</span> <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
<span class="dt">SomeSing</span> <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></code></pre></div>
<p>A value of type <code>SomeSing DoorState</code> (which contains an existentially quantified <code>Sing s</code> – a <code>SingDS</code>) is <em>the same</em> as a value of type <code>DoorState</code>. The two types are identical! (Or, well, isomorphic. As a fun exercise, write out the explicit isomorphism – the <code>SomeSing DoorState -&gt; DoorState</code> and the <code>DoorState -&gt; SomeSing DoorState</code>).</p>
<p>Our new <code>SomeDoor</code> containing an existentially quantified <code>Sing s</code> is the same as our first <code>SomeDoor</code> containing just a <code>DoorState</code>.</p>
<h4 id="why-bother">Why Bother</h4>
<p>If they’re identical, why use a <code>Sing</code> or the new <code>SomeDoor</code> at all? Why not just use a <code>DoorState</code> value?</p>
<p>The main reason (besides allowing code-reuse) is that <em>using the singleton lets us directly recover the type</em>. Essentially, a <code>Sing s</code> not only contains whether it is Opened/Closed/Locked (like a <code>DoorState</code> would)…it contains it in a way that GHC can use to <em>bring it all back</em> to the type level.</p>
<p>A <code>forall s. SomeDoor (Sing s) (Door s)</code> essentially contains <code>s</code> <em>with</em> <code>Door s</code>. When you see this, you <em>should read this as</em> <code>forall s. SomeDoor s (Door s)</code> (and, indeed, this is similar to how it is written in dependently typed languages.)</p>
<p>It’s kind of like how, when you’re used to reading Applicative style, you start seeing <code>f &lt;$&gt; x &lt;*&gt; y</code> and reading <code>f x y</code>. When you see <code>forall s. SomeDoor (Sing s) (Door s)</code>, you should read (the pseudo-haskell) <code>forall s. SomeDoor s (Door s)</code>. The role of <code>Sing s</code> there is, like in Part 1, simply to be a run-time stand-in for the type <code>s</code> itself.</p>
<p>So, for our original <code>Door s</code> functions, we need to know <code>s</code> at runtime – storing the <code>Sing s</code> gives GHC exactly that. Once you get the <code>Sing s</code> back, you can now use it in all of our type-safe functions from Part 1, and you’re back in type-safe land.</p>
<h3 id="some-lingo">Some Lingo</h3>
<p>In the language of dependently typed programming, we call <code>SomeDoor</code> a <strong>dependent sum</strong>, because you can imagine it basically as a sum type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">SDOpened</span> (<span class="dt">Door</span> <span class="ch">&#39;Opened)</span>
              <span class="fu">|</span> <span class="dt">SDClosed</span> (<span class="dt">Door</span> <span class="ch">&#39;Closed)</span>
              <span class="fu">|</span> <span class="dt">SDLocked</span> (<span class="dt">Door</span> <span class="ch">&#39;Locked)</span></code></pre></div>
<p>A three-way sum between a <code>Door 'Opened</code>, a <code>Door 'Closed</code>, and a <code>Door 'Locked</code>, essentially. If you have a <code>SomeDoor</code>, it’s <em>either</em> an opened door, a closed door, or a locked door. Try looking at this new <code>SomeDoor</code> until you realize that this type is the same type as the previous <code>SomeDoor</code>!</p>
<p>You might also see <code>SomeDoor</code> called a <strong>dependent pair</strong> – it’s a “tuple” where the <em>type</em> of the second item (our <code>Door s</code>) is determined by the <em>value</em> of the first item (our <code>Sing s</code>).</p>
<p>In Idris, we could write <code>SomeDoor</code> as a type alias, using its native dependent sum syntax, as <code>s ** Door s</code>. The <em>value</em> of the first item reveals to us (through a pattern match, in Haskell) the <em>type</em> of the second.</p>
<h3 id="types-at-runtime">Types at Runtime</h3>
<p>With this last tool, we finally have enough to build a function to “make” a door with the status unknown until runtime:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
mkSomeDoor <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> <span class="fu">.</span> mkDoor <span class="dt">SOpened</span>
    <span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> <span class="fu">.</span> mkDoor <span class="dt">SClosed</span>
    <span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> <span class="fu">.</span> mkDoor <span class="dt">SLocked</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">let</span> mySomeDoor <span class="fu">=</span> mkSomeDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mySomeDoor
<span class="dt">SomeDoor</span>
ghci<span class="fu">&gt;</span> putStrLn <span class="fu">$</span> <span class="kw">case</span> mySomeDoor <span class="kw">of</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was opened!&quot;</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was closed!&quot;</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was locked!&quot;</span>
mySomeDoor was opened<span class="fu">!</span></code></pre></div>
<p>Using <code>mkSomeDoor</code>, we can truly pass in a <code>DoorState</code> that we generate at runtime (from IO, or a user prompt, or a configuration file, maybe), and create a <code>Door</code> based on it.</p>
<p>Take <em>that</em>, type erasure! :D</p>
<h3 id="the-existential-type">The Existential Type</h3>
<p>An <em>existentially quantified</em> type is one that is hidden to the user/consumer, but directly chosen by the producer. The producer chooses the type, and the user has to handle any possible type that the producer gave.</p>
<p>This is in direct contrast to the <em>universally quantified</em> type (which most Haskellers are used to seeing), where the type is directly chosen by the <em>user</em>. The user chooses the type, and the producer has to handle any possible type that the user asks for.</p>
<p>For example, a function like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">read<span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</code></pre></div>
<p>Is universally quantified over <code>a</code>: The <em>caller</em> of <code>read</code> gets to pick which type is given. The implementor of <code>read</code> has to be able to handle whatever <code>a</code> the user picks.</p>
<p>But, for a value like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myDoor ::</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>The type variable <code>s</code> is existentially quantified. The person who <em>made</em> <code>myDoor</code> picked what <code>s</code> was. And, if you <em>use</em> <code>myDoor</code>, you have to be ready to handle <em>any</em> <code>s</code> they could have chosen.</p>
<p>In Haskell, there’s another way to express an existentially quantified type: the CPS-style encoding. To help us understand it, let’s compare a basic function in both styles. We saw earlier <code>mkSomeDoor</code>, which takes a <code>DoorState</code> and a <code>String</code> and returns an existentially quantified <code>Door</code> in the form of <code>SomeDoor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mkSomeDoor
<span class="ot">    ::</span> <span class="dt">DoorState</span>
    <span class="ot">-&gt;</span> <span class="dt">String</span>
    <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
mkSomeDoor s m <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> (mkDoor <span class="dt">SOpened</span> m)
    <span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> (mkDoor <span class="dt">SClosed</span> m)
    <span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> (mkDoor <span class="dt">SLocked</span> m)</code></pre></div>
<p>The caller of the function can then break open the <code>SomeDoor</code> and must handle whatever <code>s</code> they find inside.</p>
<p>We can write the same function using a CPS-style existential instead:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">withDoor
<span class="ot">    ::</span> <span class="dt">DoorState</span>
    <span class="ot">-&gt;</span> <span class="dt">String</span>
    <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
withDoor s m f <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="dt">Opened</span> <span class="ot">-&gt;</span> f <span class="dt">SOpened</span> (mkDoor <span class="dt">SOpened</span> m)
    <span class="dt">Closed</span> <span class="ot">-&gt;</span> f <span class="dt">SClosed</span> (mkDoor <span class="dt">SClosed</span> m)
    <span class="dt">Locked</span> <span class="ot">-&gt;</span> f <span class="dt">SLocked</span> (mkDoor <span class="dt">SLocked</span> m)</code></pre></div>
<p>With a Rank-N Type, <code>withDoor</code> takes a <code>DoorState</code> and a <code>String</code> and a <em>function to handle one polymorphically</em>. The caller of <code>withDoor</code> must provide a handler that can handle <em>any</em> <code>s</code>, in a uniform and parametrically polymorphic way. It then gives the result of the handler function called on the resulting <code>Sing s</code> and <code>Door s</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> withDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span> <span class="fu">$</span> \s d <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span>
         <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="st">&quot;Opened door!&quot;</span>
         <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="st">&quot;Closed door!&quot;</span>
         <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="st">&quot;Locked door!&quot;</span>
<span class="dt">Opened</span> door<span class="fu">!</span></code></pre></div>
<p>The key to making this work is that your handler function <em>has to be polymorphic</em> over all possible <code>s</code>s. This way, it can handle any potential <code>s</code> that the producer gives. Essentially, the producer is returning an <code>s</code> – existentially quantified.</p>
<h3 id="reification">Reification</h3>
<p>The general pattern we are exploring here is called <strong>reification</strong> – we’re taking a dynamic run-time value, and lifting it to the type level as a type (here, the type variable <code>s</code>). You can think of reification as the opposite of <em>reflection</em>, and imagine the two as being the “gateway” between the type-safe and unsafe world. In the dynamic world of a <code>DoorState</code> term-level value, you have no type safety. You live in the world of <code>SomeDoor</code>, <code>closeSomeOpenedDoor</code>, <code>lockAnySomeDoor</code>, etc. But, you can <em>reify</em> your <code>DoorState</code> value to a <em>type</em>, and enter the type-safe world of <code>Door s</code>, <code>closeDoor</code>, <code>lockDoor</code>, and <code>lockAnyDoor</code>.</p>
<p>The <em>singletons</em> library automatically generates functions to directly reify <code>DoorState</code> values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toSing       ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
<span class="ot">withSomeSing ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div>
<p>The first one reifies a <code>DoorState</code> as an existentially quantified data type, and the second one reifies in CPS-style, without the intermediate data type.</p>
<p>We can use these to write <code>mkSomeDoor</code> and <code>withDoor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L72-77</span>
<span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
mkSomeDoor ds <span class="fu">=</span> <span class="kw">case</span> toSing ds <span class="kw">of</span>
    <span class="dt">SomeSing</span> s <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> s <span class="fu">.</span> mkDoor s

<span class="ot">withDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
withDoor ds m f <span class="fu">=</span> withSomeSing ds <span class="fu">$</span> \s <span class="ot">-&gt;</span> f s (<span class="dt">UnsafeMkDoor</span> m)</code></pre></div>
<h3 id="all-about-positions">All about positions</h3>
<p>You might have noticed I was a bit sneaky by jumping straight <code>SomeDoor</code> when we already had a perfectly good “I don’t care” option. We used it last post!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p>This does work! <code>lockAnyDoor</code> takes a <code>Door s</code> and doesn’t “care” about what <code>s</code> it gets (it’s parametrically polymorphic).</p>
<p>So, this normal “parametrically polymorphic” way is how we have, in the past, treated functions that <em>can take</em> a <code>Door</code> with an <code>s</code> we don’t want the type system to care about. However, the reason we need <code>SomeDoor</code> and existentially quantified types is for the situation where we want to <em>return</em> something that we want to the type system to not care about.</p>
<h2 id="zooming-out">Zooming Out</h2>
<p>Alright! We’ve spent two blog posts going over a lot of different things in the context of our humble <code>Door s</code> type. Let’s zoom out and take a large-scale look at how <em>singletons</em> (the design pattern, and the library) helps us in general.</p>
<h3 id="sing">Sing</h3>
<p>The crux of everything is the <code>Sing :: Type -&gt; Type</code> indexed type. If you see a value of type <code>Sing s</code>, you should really just think “a runtime witness for <code>s</code>”. If you see:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>You should read it as (in pseudo-Haskell)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> { s } <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> { s } <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>This is seen clearly if we look at the partially applied type signatures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lockAnyDoor <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Opened -&gt; Door &#39;</span><span class="dt">Locked</span>
<span class="dt">MkSomeDoor</span>  <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Locked -&gt; SomeDoor</span></code></pre></div>
<p>If you squint, this kinda looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lockAnyDoor <span class="ch">&#39;Opened :: Door &#39;</span><span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span>  <span class="ch">&#39;Locked :: Door &#39;</span><span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>And indeed, when we get real dependent types in Haskell, we will really be directly passing types (that act as their own runtime values) instead of singletons.</p>
<p>It is important to remember that <code>Sing</code> is poly-kinded, so we can have <code>Sing 'Opened</code>, but also <code>Sing 'True</code>, <code>Sing 5</code>, and <code>Sing '['Just 3, 'Nothing, 'Just 0]</code> as well. This is the real benefit of using the <em>singletons</em> library instead of writing our own singletons – we get to work uniformly with singletons of all kinds.</p>
<h4 id="singi">SingI</h4>
<p><code>SingI</code> is a bit of typeclass trickery that lets us implicitly pass <code>Sing</code>s to functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">SingI</span> s <span class="kw">where</span>
<span class="ot">    sing ::</span> <span class="dt">Sing</span> s</code></pre></div>
<p>If you see:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span>  s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span>  s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>These are <em>identical</em> to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>Either way, you’re passing in the ability to get a runtime witness on <code>s</code> – just in one way, it is asked for as an explicit argument, and the second way, it is passed in using a typeclass.</p>
<p>We can <em>convert</em> from <code>SingI s -&gt;</code> style to <code>SingI s =&gt;</code> style using <code>sing</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L48-61</span>
<span class="ot">lockAnyDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnyDoor_ <span class="fu">=</span> lockAnyDoor sing

<span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor_ <span class="fu">=</span> <span class="dt">MkSomeDoor</span> sing</code></pre></div>
<p>And we can convert from <code>SingI s =&gt;</code> style to <code>SingI s -&gt;</code> style using <code>withSingI</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnyDoor s d <span class="fu">=</span> withSingI s (lockAnyDoor_ d)

<span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor s d <span class="fu">=</span> withSingI s (fromDoor_ d)</code></pre></div>
<p>Again, the same function – just two different styles of calling them.</p>
<h3 id="reflection-and-reification">Reflection and Reification</h3>
<p>Reflection is the process of bringing a type-level thing to a value at the term level (“losing” the type information in the process) and reification is the process of bringing a value-level Reification is the process of going from a value at the <em>term level</em> to the <em>type level</em>.</p>
<p>You can think of reflection and reification as being the “gateways” between the untyped/unsafe world and the typed/safe world. Reflection takes you from the typed world to the untyped world (from <code>Sing s</code> to <code>DoorState</code>) and reification takes you from the untyped world to the typed world (from <code>DoorState</code> to <code>Sing s</code>).</p>
<p>One limitation in Haskell is that there is no actual link between the type <code>DoorState</code> and its <em>values</em> with the <em>kind</em> <code>DoorState</code> with its <em>types</em>. Sure, the constructors have the same names, but the language doesn’t actually link them together for us.</p>
<h4 id="singkind">SingKind</h4>
<p>The <em>singletons</em> library handles this by using a typeclass with associated types to implement a generalized reflection and reification process. It gives us the <code>SingKind</code> “kindclass”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">SingKind</span> k <span class="kw">where</span>
    <span class="co">-- | Associate a kind k with its reflected type</span>
    <span class="kw">type</span> <span class="dt">Demote</span> k <span class="fu">=</span> (<span class="ot">r ::</span> <span class="dt">Type</span>)

    <span class="co">-- | Reflect a singleton to its term-level value</span>
<span class="ot">    fromSing ::</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="ot">-&gt;</span> <span class="dt">Demote</span> k

    <span class="co">-- | Reflect a singleton to its term-level value</span>
<span class="ot">    toSing ::</span> <span class="dt">Demote</span> k <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> k</code></pre></div>
<p>Instances of <code>SingKind</code> are promoted kinds like <code>Bool</code>, <code>DoorState</code>, etc., and <code>Demote</code> is an associated type/type family that associates each instance with the <em>type</em> it is promoted from.</p>
<p>For example, remember how <code>data DoorState = Opened | Closed | Locked</code> created the <em>type</em> <code>DoorState</code> (with value constructors <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>), and also the <em>kind</em> <code>DoorState</code> (with <em>type</em> constructors <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>). Our <em>kind</em> <code>DoorState</code> would be the instance of <code>SingKind</code>, and <code>Demote DoorState</code> would be the <em>type</em> <code>DoorState</code>.</p>
<p>The reason we need an explicit <code>Demote</code> associated type is, again, that GHC doesn’t actually link the type and its promoted kind. <code>Demote</code> lets us explicitly specify what type a <code>Kind</code> should expect its term-level reflected values to be.</p>
<h4 id="examples">Examples</h4>
<p>To illustrate explicitly, here is the automatically generated instance of <code>SingKind</code> for the <code>DoorState</code> <em>kind</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">SingKind</span> <span class="dt">DoorState</span> <span class="kw">where</span>       <span class="co">-- the *kind* DoorState</span>
    <span class="kw">type</span> <span class="dt">Demote</span> <span class="dt">DoorState</span> <span class="fu">=</span> <span class="dt">DoorState</span>   <span class="co">-- the *type* DoorState</span>

    fromSing
<span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>)        <span class="co">-- the *kind* DoorState</span>
        <span class="ot">-&gt;</span> <span class="dt">DoorState</span>                    <span class="co">-- the *type* DoorState</span>
    fromSing <span class="fu">=</span> \<span class="kw">case</span>
        <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Opened</span>
        <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Closed</span>
        <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Locked</span>

    toSing
<span class="ot">        ::</span> <span class="dt">DoorState</span>                    <span class="co">-- the *type* DoorState</span>
        <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>           <span class="co">-- the *kind* DoorState</span>
    toSing <span class="fu">=</span> \<span class="kw">case</span>
        <span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SOpened</span>
        <span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SClosed</span>
        <span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SLocked</span></code></pre></div>
<p>If you are unfamiliar with how associated types work, <code>type Demote DoorState = DoorState</code> means that wherever we see <code>Demote DoorState</code> (with <code>DoorState</code> the <em>kind</em>), we replace it with <code>DoorState</code> (the <em>type</em>). That’s why the type of our reflection function <code>fromSing :: Sing s -&gt; Demote DoorState</code> can be simplified to <code>fromSing :: Sing s -&gt; DoorState</code>.</p>
<p>Let’s take a look at the instance for <code>Bool</code>, to compare:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Bool singletons have two constructors:</span>
<span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;False</span>
<span class="dt">STrue</span><span class="ot">  ::</span> <span class="dt">Sing</span> <span class="ch">&#39;True</span>

<span class="kw">instance</span> <span class="dt">SingKind</span> <span class="dt">Bool</span> <span class="kw">where</span>    <span class="co">-- the *kind* Bool</span>
    <span class="kw">type</span> <span class="dt">Demote</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">Bool</span>     <span class="co">-- the *type* Bool</span>

    fromSing
<span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">b ::</span> <span class="dt">Bool</span>)        <span class="co">-- the *kind* Bool</span>
        <span class="ot">-&gt;</span> <span class="dt">Bool</span>                    <span class="co">-- the *type* Bool</span>
    fromSing <span class="fu">=</span> \<span class="kw">case</span>
        <span class="dt">SFalse</span> <span class="ot">-&gt;</span> <span class="dt">False</span>
        <span class="dt">STrue</span>  <span class="ot">-&gt;</span> <span class="dt">True</span>

    toSing
<span class="ot">        ::</span> <span class="dt">Bool</span>                    <span class="co">-- the *type* Bool</span>
        <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">Bool</span>           <span class="co">-- the *kind* Bool</span>
    toSing <span class="fu">=</span> \<span class="kw">case</span>
        <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SFalse</span>
        <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">STrue</span></code></pre></div>
<p>And a more sophisticated example, let’s look at the instance for <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Maybe singletons have two constructors:</span>
<span class="dt">SNothing</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Nothing</span>
<span class="dt">SJust</span><span class="ot">    ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ch">&#39;Just x)</span>

<span class="kw">instance</span> <span class="dt">SingKind</span> a <span class="ot">=&gt;</span> <span class="dt">SingKind</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>     <span class="co">-- the *kind* Maybe</span>
    <span class="kw">type</span> <span class="dt">Demote</span> (<span class="dt">Maybe</span> a) <span class="fu">=</span> <span class="dt">Maybe</span> (<span class="dt">Demote</span> a)        <span class="co">-- the *type* Maybe</span>

    fromSing
<span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">m ::</span> <span class="dt">Maybe</span> a)        <span class="co">-- the *kind* Maybe</span>
        <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a                    <span class="co">-- the *type* Maybe</span>
    fromSing <span class="fu">=</span> \<span class="kw">case</span>
        <span class="dt">SNothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
        <span class="dt">SJust</span> sx <span class="ot">-&gt;</span> <span class="dt">Just</span> (fromSing sx)

    toSing
<span class="ot">        ::</span> <span class="dt">Maybe</span> (<span class="dt">Demote</span> a)             <span class="co">-- the *type* Maybe</span>
        <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> (<span class="dt">Maybe</span> a)           <span class="co">-- the *kind* Maybe</span>
    toSing <span class="fu">=</span> \<span class="kw">case</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">SNothing</span>
        <span class="dt">Just</span> x  <span class="ot">-&gt;</span> <span class="kw">case</span> toSing x <span class="kw">of</span>
          <span class="dt">SomeSing</span> sx <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> (<span class="dt">SJust</span> sx)</code></pre></div>
<p>This definition, I think, is a real testament to the usefulness of having all of our singletons be unified under the same system. Because of how <code>SingKind</code> works, <code>Demote (Maybe DoorState)</code> is evaluated to <code>Maybe (Demote DoorState)</code>, which is simplified to <code>Maybe DoorState</code>. This means that if we have a way to reify <code>DoorState</code> values, we also have a way to reify <code>Maybe DoorState</code> values! And, if we have a way to reflect <code>DoorState</code> singletons, we also have a way to reflect <code>Maybe DoorState</code> singletons!</p>
<h4 id="somesing">SomeSing</h4>
<p>Throughout all of this, we utilize <code>SomeSing</code> as a generic poly-kinded existential wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> k) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> k</code></pre></div>
<p>Basically, this says that <code>SomeSing k</code> contains a <code>Sing x</code>, where <code>x</code> is of kind <code>k</code>. This is why we had, earlier:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></code></pre></div>
<p>If we use <code>SomeSing</code> with, say, <code>SClosed</code>, we get <code>SomeSing :: Sing 'Closed -&gt; SomeSing DoorState</code> <code>SomeSing</code> is an indexed type that tells us the <em>kind</em> of the type variable we existentially quantifying over. The value <code>SomeSing STrue</code> would have the type <code>SomeSing Bool</code>. The value <code>SomeSing (SJust SClosed)</code> would have the type <code>SomeSing (Maybe DoorState)</code>.</p>
<h2 id="a-dependently-typed-outlook">A Dependently Typed Outlook</h2>
<p>We now have a few good tools to do some real useful dependently typed programming in Haskell leveraging singletons, and have a way to unite all of these tools under a common interface.</p>
<p>I did note at the beginning of the first post that dependent types are coming soon in Haskell. Let’s take a moment to briefly discuss what purpose <em>singletons</em> serves us today in that context.</p>
<p>At the end of the day, we really want to be able to write functions like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p>Where we can directly observe and pattern match on the type and decide what to do based on it. This requires actual dependent types, but for now, with singletons, we write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p>To “emulate” it with a runtime witness.</p>
<p>We also want to be able to write functions like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loadDoor ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (s <span class="fu">**</span> <span class="dt">Door</span> s)</code></pre></div>
<p>Where the <code>(s ** Door s)</code> dependent tuple notation signifies an existentially quantified <code>s</code> type that is chosen by <code>loadDoor</code> at runtime.</p>
<p>For now, we can use singletons with Haskell’s encodings of existentially quantified types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> forall s<span class="fu">.</span> <span class="dt">SomeDoor</span> (<span class="dt">Sing</span> s) (<span class="dt">Door</span> s)
<span class="ot">loadDoor ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SomeDoor</span>

withLoadedDoor
<span class="ot">    ::</span> FilePath
    <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r</code></pre></div>
<p>I mention this here before moving on to remind you of the “big picture” of <em>why</em> singletons is important in the current state of Haskell. We really <em>want</em> to be able to pattern match and branch on types, and we really <em>want</em> to be able to encode existential types using the quantified type directly. However, “until then”, we have <code>Sing s</code> instead of <code>s</code>, and <code>forall s. SomeDoor (Sing s) (Door s)</code>, instead of <code>s ** Door s</code>.</p>
<p>You can see, syntactically, the appeal. The two are sort of designed to look very syntactically similar. For now, I hope when you read and write the Haskell encodings, you can really “see” the true dependently typed versions that is really being written behind the syntax.</p>
<h2 id="looking-forward">Looking Forward</h2>
<p>Between these first two parts, we explored a specific use case that would benefit from dependent types (simple phantom types for state transitions) and explored how the <em>singletons</em> and design pattern help us implement the functionality necessary to make things useful, and snuck in some concepts from dependently typed programming as well.</p>
<p>The code is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">here</a> for you to play around with yourself!</p>
<p>Now that the basics are out of the way, in Part 3 we’ll jump deep into type-level programming and being able to lift our term-level functions on values up to become type-level functions, and how to use this to enhance our code!</p>
<p>Let me know in the comments if you have any questions! I’m also usually idling on the freenode <code>#haskell</code> channel, as well, as <em>jle`</em>.</p>
<p>Again, check out the <a href="https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf">original singletons paper</a> for a really nice technical overview of all of these techniques!</p>
<h3 id="exercise">Exercise</h3>
<p>Check out the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs">sample code</a> for solutions!</p>
<ol type="1">
<li><p>Let’s revisit our original redundant <code>SomeDoor</code>, compared to our final <code>SomeDoor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L54-85</span>
<span class="kw">data</span> <span class="dt">OldSomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">OldMkSomeDoor</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">OldSomeDoor</span>

<span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>To help convince yourself that the two are equal, write functions converting between the two:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L87-90</span>
<span class="ot">toOld ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">OldSomeDoor</span>

<span class="ot">fromOld ::</span> <span class="dt">OldSomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p><strong>Avoid directly pattern matching on the singletons or constructors</strong>. Instead, use <em>singletons</em> library tools like <code>toSing</code>, <code>withSomeSing</code>, <code>fromSing</code>, etc.</p></li>
<li><p>Previously, we had an <code>unlockDoor</code> function that took an <code>Int</code> (the “password”) with a <code>Door 'Locked</code> and returned a <code>Maybe (Door 'Closed)</code>. It returns a <code>Door 'Closed</code> (unlocked door) in <code>Just</code> if an odd number was given, and <code>Nothing</code> otherwise (a failed unlock)</p>
<p>Use this to implement a that would return a <code>SomeDoor</code>. Re-use the “password” logic from the original <code>unlockDoor</code>. If the door is successfully unlocked (with a <code>Just</code>), return the unlocked door in a <code>SomeDoor</code>. Otherwise, <em>return the original locked door</em> (in a <code>SomeDoor</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L93-98</span>
<span class="ot">unlockDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked -&gt; Maybe (Door &#39;</span><span class="dt">Closed</span>)
unlockDoor n (<span class="dt">UnsafeMkDoor</span> m)
    <span class="fu">|</span> n <span class="ot">`mod`</span> <span class="dv">2</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">UnsafeMkDoor</span> m)
    <span class="fu">|</span> otherwise      <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="ot">unlockDoor&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked -&gt; SomeDoor</span></code></pre></div></li>
<li><p>Implement <code>openAnyDoor'</code> in the same style, with respect to <code>openAnyDoor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L103-112</span>
<span class="ot">openAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="ch">&#39;Opened)</span>
openAnyDoor n <span class="fu">=</span> openAnyDoor_ sing
  <span class="kw">where</span>
<span class="ot">    openAnyDoor_ ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="ch">&#39;Opened)</span>
    openAnyDoor_ <span class="fu">=</span> \<span class="kw">case</span>
      <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Just</span>
      <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">.</span> openDoor
      <span class="dt">SLocked</span> <span class="ot">-&gt;</span> fmap openDoor <span class="fu">.</span> unlockDoor n

<span class="ot">openAnyDoor&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>Remember to re-use <code>openAnyDoor</code>.</p></li>
</ol>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>And also a not-so-obvious fourth type, <code>forall s. Door s</code>, which is a subtype of all of those three!<a href="#fnref1">↩</a></p></li>
</ol>
</section></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-2.html';
    this.page.identifier = 'singletons-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>