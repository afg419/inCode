<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="&lt;!-- Ditching the Phantom --&gt; &lt;!-- -------------------- --&gt; &lt;!-- Now, sometimes we don&#39;t actually care about the state of the door in our type, --&gt; &lt;!-- and we don&#39;t *want* the state of the door in its type. Our `lockAnyDoor` --&gt; &lt;!-- function earlier was an example. --&gt; &lt;!-- We have a couple of options here --- first, we can create a new type --&gt;"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Introduction to Singletons (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><!-- Ditching the Phantom -->
<!-- -------------------- -->
<!-- Now, sometimes we don't actually care about the state of the door in our type, -->
<!-- and we don't *want* the state of the door in its type.  Our `lockAnyDoor` -->
<!-- function earlier was an example. -->
<!-- We have a couple of options here --- first, we can create a new type -->
<!-- `SomeDoor`, that doesn't have the opened/closed status in its type, but rather -->
<!-- as a runtime value: -->
<!-- ```haskell -->
<!-- data SomeDoor = MkSomeDoor -->
<!--     { someDoorState    :: DoorState -->
<!--     , someDoorMaterial :: String -->
<!--     } -->
<!-- -- or, in GADT syntax -->
<!-- data SomeDoor :: Type where -->
<!--     MkSomeDoor :: -->
<!--       { someDoorState    :: DoorState -->
<!--       , someDoorMaterial :: String -->
<!--       } -> SomeDoor -->
<!-- ``` -->
<!-- We could have actually been using this type the entire time, if we didn't care -->
<!-- about type safety.  In the real world and in real applications, we might have -->
<!-- actually written `SomeDoor` *before* we ever thought about `Door` with a -->
<!-- phantom type.  It's definitely the more typical "standard" Haskell thing. -->
<!-- It's possible to "construct" this from our original typed `Door`, using a smart -->
<!-- constructor/conversion function: -->
<!-- ```haskell -->
<!-- fromDoor :: SingDS s -> Door s -> SomeDoor -->
<!-- fromDoor SOpened (UnsafeMkDoor m) = MkSomeDoor Opened m -->
<!-- formDoor SClosed (UnsafeMkDoor m) = MkSomeDoor Closed m -->
<!-- formDoor SLocked (UnsafeMkDoor m) = MkSomeDoor Locked m -->
<!-- ``` -->
<!-- ### SomeDoor to Door -->
<!-- Now, `SomeDoor` is great.  But because it's a completely different type, we -->
<!-- potentially have to write the same function for both `Door` and `SomeDoor`, -->
<!-- because they have different implementations.  For example: -->
<!-- ```haskell -->
<!-- closeSomeOpenedDoor :: SomeDoor -> Maybe SomeDoor -->
<!-- closeSomeOpenedDoor (MkSomeDoor Opened m) = Just (MkSomeDoor Closed m) -->
<!-- closeSomeOpenedDoor (MkSomeDoor Closed m) = Nothing -->
<!-- closeSomeOpenedDoor (MkSomeDoor Locked m) = Nothing -->
<!-- ``` -->
<!-- Wouldn't it be nice if we can *re-use* our original `closeDoor`?  This is a toy -->
<!-- example, and in real life, closing a door might have some complicated runtime -->
<!-- logic, and it'd be annoying to have to *re-implement* it for both `SomeDoor` -->
<!-- and `Door`. -->
<!-- #### Converting into an existential -->
<!-- One thing we can do is write a function to convert a `SomeDoor` into a `Door`, -->
<!-- so we can re-use our original `closeDoor`.  We'd convert our `SomeDoor` into a -->
<!-- `Door` to re-use our `closeDoor :: Door 'Opened -> Door 'Closed` on it if -->
<!-- possible! -->
<!-- However, going from `SomeDoor` to `Door s` is slightly trickier in Haskell than -->
<!-- going the other way around.  One trick we often use is a CPS-style existential -->
<!-- type. -->
<!-- The essential concept is that normal Haskell type variables are universally -->
<!-- qualified, meaning that the *caller* can pick how to instantiate `s`.  However, -->
<!-- we want a function where the *function* can pick the `s`, and the caller must -->
<!-- handle whatever `s` is given by the function: -->
<!-- ```haskell -->
<!-- withSomeDoor :: SomeDoor -> (forall s. SingDS s -> Door s -> r) -> r -->
<!-- withSomeDoor (MkSomeDoor Opened m) f = f SOpened (UnsafeMkDoor m) -->
<!-- withSomeDoor (MkSomeDoor Closed m) f = f SClosed (UnsafeMkDoor m) -->
<!-- withSomeDoor (MkSomeDoor Locked m) f = f SLocked (UnsafeMkDoor m) -->
<!-- ``` -->
<!-- Notice the funky CPS-like type signature of `withSomeDoor`.  To use -->
<!-- `withSomeDoor` and access the `Door`, you have to pass in a function to handle -->
<!-- *any possible `s`*.  And, as you can see, the function passed in might be given -->
<!-- an `SOpened`, an `SClosed`, or an `SLocked`.  It has to be able to handle all -->
<!-- three! -->
<!-- Here, we call `s` *existentially quantified*.  The `withSomeDoor` function gets -->
<!-- to pick which `s` to give `f`.  So, the `s` type variable is directly chosen by -->
<!-- the *function*, and not by the caller. -->
<!-- So we can implement `closeSomeOpenedDoor` (and even a `lockAnySomeDoor`) using this -->
<!-- conversion function: -->
<!-- ```haskell -->
<!-- closeSomeOpenedDoor :: SomeDoor -> Maybe (Door 'Closed) -->
<!-- closeSomeOpenedDoor sd = withSomeDoor sd $ \case -->
<!--     SOpened -> \d -> Just (closeDoor d) -->
<!--     SClosed -> \_ -> Nothing -->
<!--     SLocked -> \_ -> Nothing -->
<!-- lockAnySomeDoor :: SomeDoor -> Door 'Locked -->
<!-- lockAnySomeDoor sd = withSomeDoor sd $ \s d -> -->
<!--     lockAnyDoor s d -->
<!-- ``` -->
<!-- #### The Existential Datatype -->
<!-- However, there's another path we can take.  With the power of singletons, we -->
<!-- can actually implement `SomeDoor` *in terms of* `Door`, using an **existential -->
<!-- data type**: -->
<!-- ```haskell -->
<!-- -- using existential constructor syntax -->
<!-- data SomeDoor = forall s. MkSomeDoor (SingDS s) (Door s) -->
<!-- -- or, using GADT syntax (preferred) -->
<!-- !!!singletons/Door.hs "data SomeDoor ::" -->
<!-- ``` -->
<!-- `MkSomeDoor` is a constructor for an existential data type, meaning that the -->
<!-- data type "hides" a type variable `s`. -->
<!-- Hopefully you can see the similarities between our original `SomeDoor` and this -->
<!-- one. -->
<!-- ```haskell -->
<!-- -- Original type -->
<!-- data SomeDoor where -->
<!--     MkSomeDoor :: DoorState -> String -> SomeDoor -->
<!-- -- New existential type -->
<!-- data SomeDoor where -->
<!--     MkSomeDoor :: SingDS s  -> Door s -> SomeDoor -->
<!-- ``` -->
<!-- The key differences are: -->
<!-- *   Our first `SomeDoor` contains a `DoorState`, and this new `SomeDoor` -->
<!--     contains a `SingDS` (a *singleton* for the `DoorState`): -->
<!-- *   Our first `SomeDoor` contains essentially a re-implementation of the `Door` -->
<!--     type, but the new `SomeDoor` contains an actual `Door`, so we can re-use -->
<!--     functions on `Door`s. -->
<!-- In Haskell, existential data types are pretty nice, syntactically, to work -->
<!-- with.  For a comparison, let's re-implement our previous functions with our new -->
<!-- data type: -->
<!-- ```haskell -->
<!-- !!!singletons/Door.hs "closeSomeOpenedDoor ::" "lockAnySomeDoor ::" -->
<!-- ``` -->
<!-- Much more convenient, because *we already have a `Door`!*  And we don't have to -->
<!-- re-implement one like we did for our original `SomeDoor` -- all of our original -->
<!-- code works directly! -->
<!-- It's important to remember that our original separate-implementation `SomeDoor` -->
<!-- is, functionally, identical to the new code-reusing `Door`.  The reason why -->
<!-- they are the same is that *having an existentially quantified singleton is the -->
<!-- same as having a value of the corresponding type.*  Having an existentially -->
<!-- quantified `SingDS s` is *the same as* having a value of type `DoorState`. -->
<!-- If they're identical, why use a `SingDS` or the new `SomeDoor` at all?  One -->
<!-- main reason (besides allowing code-reuse) is that *using the singleton lets us -->
<!-- recover the type*.  Essentially, a `SingDS s` not only contains whether it is -->
<!-- Opened/Closed/Locked...it contains it in a way that GHC can use to *bring it -->
<!-- all back* to the type level. -->
<!-- Basically, `SingDS` allows us to re-use our original `Door s` implementation, -->
<!-- because we store both the `Door`...*and* the `s` at the type level.  You should -->
<!-- read it as storing `s` and `Door s`, together, at runtime.  It also lets GHC -->
<!-- *check* our implementations, to help ensure that they are correct, because you -->
<!-- maintain the `s` at the type level. -->
<!-- #### Some Lingo -->
<!-- In the language of dependently typed programming, we call `SomeDoor` a -->
<!-- **dependent sum**, because you can imagine it basically as: -->
<!-- ```haskell -->
<!-- data SomeDoor = SDOpened (Door 'Opened) -->
<!--               | SDClosed (Door 'Closed) -->
<!--               | SDLocked (Door 'Locked) -->
<!-- ``` -->
<!-- A three-way sum between a `Door 'Opened`, a `Door 'Closed`, and a `Door -->
<!-- 'Locked`, essentially.  If you have a `SomeDoor`, it's *either* an opened door, -->
<!-- a closed door, or a locked door.  Try looking at this new `SomeDoor` until you -->
<!-- realize that this type is the same type as the previous `SomeDoor`! -->
<!-- You might also see `SomeDoor` called a **dependent pair**, because it's -->
<!-- basically an existentially quantified tuple of the type (the `s`, witnessed by -->
<!-- the `SingDS s`) with a value (the `Door s`). -->
<!-- ### Types at Runtime -->
<!-- With this last tool, we finally have enough to build a function to "make" a -->
<!-- door with the status unknown until runtime: -->
<!-- ```haskell -->
<!-- !!!singletons/Door.hs "mkSomeDoor ::" -->
<!-- ``` -->
<!-- ```haskell -->
<!-- ghci> let mySomeDoor = mkSomeDoor Opened "Birch" -->
<!-- ghci> :t mySomeDoor -->
<!-- SomeDoor -->
<!-- ghci> putStrLn $ case mySomeDoor of -->
<!--         MkSomeDoor SOpened _ -> "mySomeDoor was opened!" -->
<!--         MkSomeDoor SClosed _ -> "mySomeDoor was closed!" -->
<!--         MkSomeDoor SLocked _ -> "mySomeDoor was locked!" -->
<!-- mySomeDoor was opened! -->
<!-- ``` -->
<!-- Using `mkSomeDoor`, we can truly pass in a `DoorState` that we generate at -->
<!-- runtime (from IO, or a user prompt, or a configuration file, maybe), and create -->
<!-- a `Door` based on it. -->
<!-- Take *that*, type erasure! :D -->
<!-- We could even directly return a `Door` with an existentially quantified door -->
<!-- status in CPS style: -->
<!-- ```haskell -->
<!-- withDoor :: DoorState -> String -> (forall s. SingDS s -> Door s -> r) -> r -->
<!-- withDoor s m f = case s of -->
<!--     Opened -> f SOpened (UnsafeMkDoor m) -->
<!--     Closed -> f SClosed (UnsafeMkDoor m) -->
<!--     Locked -> f SLocked (UnsafeMkDoor m) -->
<!-- ``` -->
<!-- ```haskell -->
<!-- ghci> withDoor Opened "Birch" $ \s d -> case s of -->
<!--          SOpened -> "Opened door!" -->
<!--          SClosed -> "Closed door!" -->
<!--          SLocked -> "Locked door!" -->
<!-- Opened door! -->
<!-- ``` -->
<!-- This allows us to *truly* directly generate a `Door s` with an `s` that can -->
<!-- vary at runtime. -->
<!-- #### Reification -->
<!-- The general pattern we are exploiting here is called **reification** -- we're -->
<!-- taking a dynamic run-time value, and lifting it to the type level as a type -->
<!-- (here, the type variable `s`).  You can think of reification as the opposite of -->
<!-- reflection, and imagine the two as being the "gateway" between the type-safe -->
<!-- and unsafe world.  In the dynamic world of a `DoorState` value, you have no -->
<!-- type safety.  You live in the world of `SomeDoor`, `closeSomeOpenedDoor`, -->
<!-- `lockAnySomeDoor`, etc.  But, you can *reify* your `DoorState` value to a *type*, and -->
<!-- enter the type-safe world of `Door s`, `closeDoor`, `lockDoor`, and -->
<!-- `lockAnyDoor`. -->
<!-- It might be more meaningful then to write a direct reification function for our -->
<!-- `DoorState`, in CPS style.  Then, we can actually write our `withDoor` in terms -->
<!-- of it! -->
<!-- ```haskell -->
<!-- !!!singletons/Door.hs "withDoorState ::" "withDoor ::" -->
<!-- ``` -->
<!-- ## Sing -->
<!-- *   `toSing :: DoorState -> SomeSing DoorState` takes us from values to their -->
<!--     (existentially quantified) singletons -->
<!--     ```haskell -->
<!--     ghci> let s = toSing Opened -->
<!--     ghci> :t s -->
<!--     s :: SomeSing DoorState -->
<!--     ghci> putStrLn $ case s of -->
<!--             SomeSing SOpened -> "Opened." -->
<!--             SomeSing SClosed -> "SClosed." -->
<!--             SomeSing SLocked -> "SLocked." -->
<!--     "Opened." -->
<!--     ``` -->
<!--     `SomeSing` is like `SomeDoor` in that it is an existentially quantified -->
<!--     singleton: -->
<!--     ```haskell -->
<!--     data SomeSing DoorState :: Type where -->
<!--         SomeSing :: Sing s -> SomeSing DoorState -->
<!--     -- or, more accurately, since `SomeSing` is polykinded -->
<!--     data SomeSing :: k -> Type where -->
<!--         SomeSing :: Sing (a :: k) -> SomeSing k -->
<!--     ``` -->
<!-- 3.  Implement `withSomeDoor` for the existentially quantified `SomeDoor` type. -->
<!--     ```haskell -->
<!--     !!!singletons/DoorSingletons.hs "data SomeDoor" "withSomeDoor ::"1 -->
<!--     ``` -->
<!-- 4.  Implement `openAnySomeDoor`, which should work like `lockAnySomeDoor`, just -->
<!--     wrapping an application of `openAnyDoor` inside a `SomeDoor`. -->
<!--     ```haskell -->
<!--     !!!singletons/DoorSingletons.hs "openAnySomeDoor ::"1 -->
<!--     ``` -->
<!--     You **shouild not** use `UnsafeMkDoor` directly. -->
<!--     Note that because we wrote `openAnyDoor` in "implicit style", we might have -->
<!--     to convert between `SingI s =>` and `Sing s ->` style, using `withSingI`. -->
<!-- However, full expressively with phantom types is still out of our reach.  If we -->
<!-- want to express more complicated relationships and to be able to treat phantom -->
<!-- types (and *types*, in general) as first-class values, and delve into the -->
<!-- frighteningly beautiful world of "type-level programming", we are going to have -->
<!-- to dig a bit deeper.  Come back for the next post to see how!  Singletons will -->
<!-- be our tool, and we'll also see how the singletons library is a very clean -->
<!-- unification of a lot of concepts. -->
<h3 id="a-reflection-on-subtyping">A Reflection on Subtyping</h3>
<p>Without phantom types you might have imagined being able to do something like this:</p>
<pre class="hskell"><code>data DoorOpened = MkDoorOpened { doorMaterial :: String }
data DoorClosed = MkDoorClosed { doorMaterial :: String }
data DoorLocked = MkDoorLocked { doorMaterial :: String }</code></pre>
<p>Which is even possible now with <code>-XDuplicateRecordFields</code>. And, for the most part, you get a similar API:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">closeDoor ::</span> <span class="dt">DoorOpened</span> <span class="ot">-&gt;</span> <span class="dt">DoorClosed</span>
<span class="ot">lockDoor  ::</span> <span class="dt">DoorClosed</span> <span class="ot">-&gt;</span> <span class="dt">DoorLocked</span></code></pre></div>
<p>But what about writing things that take on “all” door types?</p>
<p>The only real way (besides typeclass magic) would be to make some sum type like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">DO</span> <span class="dt">DoorOpened</span> <span class="fu">|</span> <span class="dt">DC</span> <span class="dt">DoorClosed</span> <span class="fu">|</span> <span class="dt">DL</span> <span class="dt">DoorLocked</span>

<span class="ot">lockAnyDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">DoorLocked</span></code></pre></div>
<p>However, we see that if we parameterize a single <code>Door</code> type, we can have it stand in <em>both</em> for a “known status” <code>Door</code> <em>and</em> for a “polymorphic status” <code>Door</code>.</p>
<p>This actually leverages Haskell’s <em>subtyping</em> system. We say that <code>forall s. Door s</code> (a <code>Door</code> that is polymorphic on all <code>s</code>) is a <em>subtype</em> of <code>Door 'Opened</code>. This means that a <code>forall s. Door s</code> can be used anywhere a function would expect a <code>Door 'Opened</code>…but not the other way around.</p></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-2.html';
    this.page.identifier = 'singletons-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>