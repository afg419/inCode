<!DOCTYPE HTML>
<html><head><title>Introduction to Singletons (Part 2) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Welcome back to our journey through the singleton design pattern and the great singletons library! This post is a direct continuation of Part 1, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already! Again, code is built on GHC 8.2.2 with the lts-10.0 snapshot (so, singletons-2.3.1)."><meta property="og:type" content="article"><meta property="og:title" content="Introduction to Singletons (Part 2)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-2.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-2.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Introduction to Singletons (Part 2)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-2.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-2.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Welcome back to our journey through the singleton design pattern and the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library!</p>
<p>This post is a direct continuation of <a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">Part 1</a>, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already!</p>
<p>Again, code is built on <em>GHC 8.2.2</em> with the <em><a href="https://www.stackage.org/lts-10.0">lts-10.0</a></em> snapshot (so, singletons-2.3.1).</p>
<h2 id="review">Review</h2>
<p>Let’s return to our <code>Door</code> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L17-23</span>
<span class="fu">$</span>(singletons [d|
  data DoorState = Opened | Closed | Locked
    deriving (Show, Eq)
  |])

<span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> {<span class="ot"> doorMaterial ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">Door</span> s</code></pre></div>
<p><code>Door</code> is great! It is an <em>indexed data type</em>, in that picking a different type variable gives a different “type” of Door:</p>
<ul>
<li><code>Door 'Opened</code> is a type that represents the type of an opened door</li>
<li><code>Door 'Closed</code> is a <em>different</em> type that represents the type of a <em>closed</em> door</li>
<li><code>Door 'Locked</code> is yet another (third) type that represents the type of a <em>locked</em> door.</li>
</ul>
<p>So, really, when we define <code>Door s</code>, we really are defining <em>three distinct</em> types (and also a not-so-obvious fourth one, which we will discuss later).</p>
<p>This is great and all, but isn’t Haskell a language with static, compile-time types? Doesn’t that mean that we have to know if our doors are opened, closed, or locked at compile-time?</p>
<p>This is something we can foresee being a big issue. It’s easy enough to create a <code>Door s</code> if you know <code>s</code> at compile-time by just typing in a type annotation (<code>UnsafeMkDoor &quot;Oak&quot; :: Door 'Opened</code>). But what if we <em>don’t</em> know <code>s</code> at compile-time?</p>
<p>To learn how to do this, we first need to learn how to <em>not care</em>.</p>
<h2 id="ditching-the-phantom">Ditching the Phantom</h2>
<p>Sometimes we don’t <em>actually</em> care about the state of the door in the <em>type</em> of the door. We don’t want <code>Door 'Opened</code> and <code>Door 'Closed</code>…we want a type to just represent a door, without the status in its type.</p>
<p>This might come about a bunch of different ways. Maybe you’re reading a <code>Door</code> data from a serialization format, and you want to be able to parse <em>any</em> door (whatever door is serialized).</p>
<p>More concretely, we’ve seen this in <code>lockAnyDoor</code>, as well – <code>lockAnyDoor</code> doesn’t care about the type of its input (it can be <em>any</em> <code>Door</code>). It only cares about the type of its output (<code>Door 'Locked</code>)</p>
<p>To learn how to not care, we can describe a type for a door that does <em>not</em> have its status in its type.</p>
<p>We have a couple of options here. First, we can create a new type <code>SomeDoor</code> that is the same as <code>Door</code>, except instead of keeping its status in its type, it keeps it as a runtime value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">MkSomeDoor</span>
    {<span class="ot"> someDoorState    ::</span> <span class="dt">DoorState</span>
    ,<span class="ot"> someDoorMaterial ::</span> <span class="dt">String</span>
    }

<span class="co">-- or, in GADT syntax</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span> <span class="ot">::</span>
      {<span class="ot"> someDoorState    ::</span> <span class="dt">DoorState</span>
      ,<span class="ot"> someDoorMaterial ::</span> <span class="dt">String</span>
      } <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>Note the similarity of <code>SomeDoor</code>’s declaration to <code>Door</code>’s declaration above. It’s mostly the same, except, instead of <code>DoorState</code> being a type parameter, it is instead a runtime value inside <code>SomeDoor</code>.</p>
<p>Now, this is actually a type that we <em>could</em> have been using this entire time, if we didn’t care about type safety. In the real world and in real applications, we actually might have written <code>SomeDoor</code> <em>before</em> we ever thought about <code>Door</code> with a phantom type. It’s definitely the more typical “standard” Haskell thing.</p>
<p>It’s possible to “construct” this from our original typed <code>Door</code>, using a smart constructor/conversion function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor <span class="dt">SOpened</span> (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">MkSomeDoor</span> <span class="dt">Opened</span> m
formDoor <span class="dt">SClosed</span> (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">MkSomeDoor</span> <span class="dt">Closed</span> m
formDoor <span class="dt">SLocked</span> (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">MkSomeDoor</span> <span class="dt">Locked</span> m

<span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor_ <span class="fu">=</span> fromDoor sing</code></pre></div>
<p>We can now write functions on this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span>
closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> <span class="dt">Opened</span> m) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">MkSomeDoor</span> <span class="dt">Closed</span> m)
closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> <span class="dt">Closed</span> m) <span class="fu">=</span> <span class="dt">Nothing</span>
closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> <span class="dt">Locked</span> m) <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<h3 id="somedoor-to-door">SomeDoor to Door</h3>
<p><code>SomeDoor</code> is great. But because it’s a completely different type, we potentially have to write the same function for both <code>Door</code> and <code>SomeDoor</code>, because they have different implementations. Wouldn’t it be nice if we can <em>re-use</em> our original <code>closeDoor</code>? This is a toy example, and in real life, closing a door might have some complicated runtime logic, and it’d be annoying to have to <em>re-implement</em> it for both <code>SomeDoor</code> and <code>Door</code>.</p>
<h4 id="converting-into-an-existential">Converting into an existential</h4>
<p>One thing we can do is write a function to convert a <code>SomeDoor</code> into a <code>Door</code>, so we can re-use our original <code>closeDoor</code>. We’d convert our <code>SomeDoor</code> into a <code>Door</code> to re-use our <code>closeDoor :: Door 'Opened -&gt; Door 'Closed</code> on it if possible!</p>
<p>However, going from <code>SomeDoor</code> to <code>Door s</code> is slightly trickier in Haskell than going the other way around. The main thing stopping us is that normal Haskell type variables are universally qualified, meaning that the <em>caller</em> can pick how to instantiate <code>s</code> (and not the conversion function). However, we want a function where the <em>function</em> can pick the <code>s</code>, and the caller must handle whatever <code>s</code> is given by the function:</p>
<p>One trick we often use is a CPS-style existential type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
withSomeDoor (<span class="dt">MkSomeDoor</span> <span class="dt">Opened</span> m) f <span class="fu">=</span> f <span class="dt">SOpened</span> (<span class="dt">UnsafeMkDoor</span> m)
withSomeDoor (<span class="dt">MkSomeDoor</span> <span class="dt">Closed</span> m) f <span class="fu">=</span> f <span class="dt">SClosed</span> (<span class="dt">UnsafeMkDoor</span> m)
withSomeDoor (<span class="dt">MkSomeDoor</span> <span class="dt">Locked</span> m) f <span class="fu">=</span> f <span class="dt">SLocked</span> (<span class="dt">UnsafeMkDoor</span> m)</code></pre></div>
<p>Notice the funky CPS-like type signature of <code>withSomeDoor</code>. To use <code>withSomeDoor</code> and access the <code>Door</code>, you have to pass in a function to handle <em>any possible <code>s</code></em>. And, as you can see, the function passed in might be given an <code>SOpened</code>, an <code>SClosed</code>, or an <code>SLocked</code>. It has to be able to handle all three!</p>
<p>Here, we call <code>s</code> <em>existentially quantified</em>. The <code>withSomeDoor</code> function gets to pick which <code>s</code> to give <code>f</code>. So, the <code>s</code> type variable is directly chosen by the <em>function</em>, and not by the caller.</p>
<p>We can implement <code>closeSomeOpenedDoor</code> (and even a <code>lockAnySomeDoor</code>) using this conversion function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span>
closeSomeOpenedDoor sd <span class="fu">=</span> withSomeDoor sd <span class="fu">$</span> \<span class="kw">case</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> \d <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">.</span> fromDoor_ <span class="fu">.</span> closeDoor <span class="fu">$</span> d
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">lockAnySomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
lockAnySomeDoor sd <span class="fu">=</span> withSomeDoor sd <span class="fu">$</span> \s d <span class="ot">-&gt;</span>
    fromDoor_ <span class="fu">$</span> lockAnyDoor s d</code></pre></div>
<p>Now, our goal is complete – we can <em>re-use</em> our previous <code>closeDoor</code> and <code>lockAnyDoor</code>! We <em>convert</em> our <code>SomeDoor</code> into a <code>Door s</code> (with an existentially quantified <code>s</code>), so we can use <code>closeDoor :: Door 'Opened -&gt; Door 'Closed</code> and <code>lockAnyDoor :: Door s -&gt; Door 'Locked</code> on it. Then we “convert it back” using <code>fromDoor</code>.</p>
<h3 id="the-existential-datatype">The Existential Datatype</h3>
<p>However, there’s another path we can take. With the power of singletons, we can actually implement <code>SomeDoor</code> <em>in terms of</em> <code>Door</code>, using an <strong>existential data type</strong>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- using existential constructor syntax</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> forall s<span class="fu">.</span> <span class="dt">MkSomeDoor</span> (<span class="dt">Sing</span> s) (<span class="dt">Door</span> s)

<span class="co">-- or, using GADT syntax (preferred)</span>
<span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L57-58</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p><code>MkSomeDoor</code> is a constructor for an existential data type, meaning that the data type “hides” a type variable <code>s</code>.</p>
<p>Note the similarities between our original <code>SomeDoor</code> and this one.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Re-implementing door</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>

<span class="co">-- | Re-using Door, as an existential type</span>
<span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">DoorState</span> <span class="kw">where</span>
    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s

<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> s  <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>Basically, our type before re-implements <code>Door</code>. But the new one actually directly uses the original <code>Door s</code>. This means we can <em>directly</em> re-use our <code>Door</code> functions on <code>SomeDoor</code>s, without needing to convert our implementations.</p>
<p>In Haskell, existential data types are pretty nice, syntactically, to work with. For a comparison, let’s re-implement our previous functions with our new data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L60-73</span>
<span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor <span class="fu">=</span> <span class="dt">MkSomeDoor</span>

<span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor_ <span class="fu">=</span> <span class="dt">MkSomeDoor</span> sing

<span class="ot">closeSomeOpenedDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span>
closeSomeOpenedDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">.</span> fromDoor_ <span class="fu">$</span> closeDoor d
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">lockAnySomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
lockAnySomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> fromDoor_ <span class="fu">$</span> lockAnyDoor s d</code></pre></div>
<p>Much more convenient, because <em>we already have a <code>Door</code>!</em> And we don’t have to re-implement one like we did for our original <code>SomeDoor</code> – all of our original code works directly!</p>
<h3 id="the-link">The Link</h3>
<p>It’s important to remember that our original separate-implementation <code>SomeDoor</code> is, functionally, identical to the new code-reusing <code>Door</code>. The reason why they are the same is that <em>having an existentially quantified singleton is the same as having a value of the corresponding type.</em> Having an existentially quantified <code>SingDS s</code> is <em>the same as</em> having a value of type <code>DoorState</code>.</p>
<p>In fact, the <em>singletons</em> library gives us a direct existential wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- (not the actual definition)</span>
<span class="kw">data</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></code></pre></div>
<p>There are three values of type <code>SomeSing DoorState</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SomeSing</span> <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
<span class="dt">SomeSing</span> <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
<span class="dt">SomeSing</span> <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span></code></pre></div>
<p>A value of type <code>SomeSing DoorState</code> (which contains an existentially quantified <code>Sing s</code> – a <code>SingDS</code>) is <em>the same</em> as a value of type <code>DoorState</code>. The two types are identical! (Or, well, isomorphic. As a fun exercise, write out the explicit isomorphism – the <code>SomeSing DoorState -&gt; DoorState</code> and the <code>DoorState -&gt; SomeSing DoorState</code>).</p>
<p>Our new <code>SomeDoor</code> containing an existentially quantified <code>Sing s</code> is the same as our first <code>SomeDoor</code> containing just a <code>DoorState</code>.</p>
<h4 id="why-bother">Why Bother</h4>
<p>If they’re identical, why use a <code>Sing</code> or the new <code>SomeDoor</code> at all? Why not just use a <code>DoorState</code> value?</p>
<p>The main reason (besides allowing code-reuse) is that <em>using the singleton lets us directly recover the type</em>. Essentially, a <code>SingDS s</code> not only contains whether it is Opened/Closed/Locked…it contains it in a way that GHC can use to <em>bring it all back</em> to the type level.</p>
<p>A <code>forall s. SomeDoor (Sing s) (Door s)</code> essentially contains <code>s</code> <em>with</em> <code>Door s</code>. When you see this, you <em>should read this as</em> <code>forall s. SomeDoor s (Door s)</code> (and, indeed, this is similar to how it is written in dependently typed languages.)</p>
<p>It’s kind of like how, when you’re used to reading Applicative style, when you see <code>f &lt;$&gt; x &lt;*&gt; y</code>, you should read <code>f x y</code>. When you see <code>forall s. SomeDoor (Sing s) (Door s)</code>, you should read <code>forall s. SomeDoor s (Door s)</code>. The role of <code>Sing s</code> there is, like in Part 1, simply to be a run-time stand-in for the type <code>s</code> itself.</p>
<p>So, for our original <code>Door s</code> functions, we need to know <code>s</code> at runtime – storing the <code>Sing s</code> gives GHC exactly that. Once you get the <code>Sing s</code> back, you can now use it in all of our type-safe functions from Part 1, and you’re back in type-safe land.</p>
<h3 id="some-lingo">Some Lingo</h3>
<p>In the language of dependently typed programming, we call <code>SomeDoor</code> a <strong>dependent sum</strong>, because you can imagine it basically as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">SDOpened</span> (<span class="dt">Door</span> <span class="ch">&#39;Opened)</span>
              <span class="fu">|</span> <span class="dt">SDClosed</span> (<span class="dt">Door</span> <span class="ch">&#39;Closed)</span>
              <span class="fu">|</span> <span class="dt">SDLocked</span> (<span class="dt">Door</span> <span class="ch">&#39;Locked)</span></code></pre></div>
<p>A three-way sum between a <code>Door 'Opened</code>, a <code>Door 'Closed</code>, and a <code>Door 'Locked</code>, essentially. If you have a <code>SomeDoor</code>, it’s <em>either</em> an opened door, a closed door, or a locked door. Try looking at this new <code>SomeDoor</code> until you realize that this type is the same type as the previous <code>SomeDoor</code>!</p>
<p>You might also see <code>SomeDoor</code> called a <strong>dependent pair</strong> – it’s a “tuple” where the <em>type</em> of the second item (our <code>Door s</code>) is determined by the <em>value</em> of the first item (our <code>Sing s</code>).</p>
<p>In Idris, we could write <code>SomeDoor</code> as a type alias, using its native dependent sum syntax, as <code>s ** Door s</code>. The <em>value</em> of the first item reveals to us (through a pattern match, in Haskell) the <em>type</em> of the second.</p>
<h3 id="types-at-runtime">Types at Runtime</h3>
<p>With this last tool, we finally have enough to build a function to “make” a door with the status unknown until runtime:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
mkSomeDoor <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> <span class="fu">.</span> mkDoor <span class="dt">SOpened</span>
    <span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> <span class="fu">.</span> mkDoor <span class="dt">SClosed</span>
    <span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> <span class="fu">.</span> mkDoor <span class="dt">SLocked</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">let</span> mySomeDoor <span class="fu">=</span> mkSomeDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mySomeDoor
<span class="dt">SomeDoor</span>
ghci<span class="fu">&gt;</span> putStrLn <span class="fu">$</span> <span class="kw">case</span> mySomeDoor <span class="kw">of</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was opened!&quot;</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was closed!&quot;</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was locked!&quot;</span>
mySomeDoor was opened<span class="fu">!</span></code></pre></div>
<p>Using <code>mkSomeDoor</code>, we can truly pass in a <code>DoorState</code> that we generate at runtime (from IO, or a user prompt, or a configuration file, maybe), and create a <code>Door</code> based on it.</p>
<p>Take <em>that</em>, type erasure! :D</p>
<p>We could even directly return a <code>Door</code> with an existentially quantified door status in CPS style:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
withDoor s m f <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="dt">Opened</span> <span class="ot">-&gt;</span> f <span class="dt">SOpened</span> (<span class="dt">UnsafeMkDoor</span> m)
    <span class="dt">Closed</span> <span class="ot">-&gt;</span> f <span class="dt">SClosed</span> (<span class="dt">UnsafeMkDoor</span> m)
    <span class="dt">Locked</span> <span class="ot">-&gt;</span> f <span class="dt">SLocked</span> (<span class="dt">UnsafeMkDoor</span> m)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> withDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span> <span class="fu">$</span> \s d <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span>
         <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="st">&quot;Opened door!&quot;</span>
         <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="st">&quot;Closed door!&quot;</span>
         <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="st">&quot;Locked door!&quot;</span>
<span class="dt">Opened</span> door<span class="fu">!</span></code></pre></div>
<p>This allows us to <em>directly</em> generate a <code>Door s</code> with an <code>s</code> that can vary at runtime.</p>
<h3 id="reification">Reification</h3>
<p>The general pattern we are exploiting here is called <strong>reification</strong> – we’re taking a dynamic run-time value, and lifting it to the type level as a type (here, the type variable <code>s</code>). You can think of reification as the opposite of <em>reflection</em>, and imagine the two as being the “gateway” between the type-safe and unsafe world. In the dynamic world of a <code>DoorState</code> term-level value, you have no type safety. You live in the world of <code>SomeDoor</code>, <code>closeSomeOpenedDoor</code>, <code>lockAnySomeDoor</code>, etc. But, you can <em>reify</em> your <code>DoorState</code> value to a <em>type</em>, and enter the type-safe world of <code>Door s</code>, <code>closeDoor</code>, <code>lockDoor</code>, and <code>lockAnyDoor</code>.</p>
<p>The <em>singletons</em> library automatically generates functions to directly reify <code>DoorState</code> values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toSing       ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
<span class="ot">withSomeSing ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div>
<p>The first one reifies a <code>DoorState</code> as an existentially quantified data type, and the second one reifies in CPS-style, without the intermediate data type.</p>
<p>We can use these to write <code>mkSomeDoor</code> and <code>withDoor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L75-80</span>
<span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
mkSomeDoor ds <span class="fu">=</span> <span class="kw">case</span> toSing ds <span class="kw">of</span>
    <span class="dt">SomeSing</span> s <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> s <span class="fu">.</span> mkDoor s

<span class="ot">withDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
withDoor ds m f <span class="fu">=</span> withSomeSing ds <span class="fu">$</span> \s <span class="ot">-&gt;</span> f s (<span class="dt">UnsafeMkDoor</span> m)</code></pre></div>
<!-- ## A Reflection on Subtyping -->
<!-- Let's take a step back to look at the concept of "subtyping" in Haskell, and -->
<!-- how it relates to what we've done here.  Without phantom types you might have -->
<!-- imagined being able to do something like this: -->
<!-- ```hskell -->
<!-- data DoorOpened = MkDoorOpened String -->
<!-- data DoorClosed = MkDoorClosed String -->
<!-- data DoorLocked = MkDoorLocked String -->
<!-- ``` -->
<!-- And, for the most part, you get a similar API: -->
<!-- ```haskell -->
<!-- closeDoor :: DoorOpened -> DoorClosed -->
<!-- lockDoor  :: DoorClosed -> DoorLocked -->
<!-- ``` -->
<!-- This is all stuff we can do in "normal Haskell", and get the same type-safety. -->
<!-- The advantage of the *indexed type* ("type family", in dependent types -->
<!-- lingo[^fam]) is that we can write functions that work on *any* door state: -->
<!-- [^fam]: Again, not to be confused with GHC's Type Families language feature -->
<!-- ```haskell -->
<!-- doorMaterial :: Door s -> String -->
<!-- lockAnyDoor  :: Door s -> Door 'Locked -->
<!-- ``` -->
<!-- Remember how I said earlier that our declaration of `Door` created three types? -->
<!-- `Door 'Opened`, `Door 'Closed`, and `Door 'Locked`?  I lied -- it actually -->
<!-- gives us a *fourth* type, `forall s. Door s` -- a type that can be instantiated -->
<!-- as *any* status door.  This is the return type of `UnsafeMkDoor :: String -> -->
<!-- (forall s. Door s)`. -->
<!-- As a return type, `forall s. Door s` is what we call a **subtype** of `Door -->
<!-- 'Opened`, `Door 'Closed`, and `Door 'Locked`.  In type theory, a subtype is -->
<!-- something that can be used whenever something expects a value of its supertype, -->
<!-- but not necessarily the other way around. -->
<h2 id="zooming-out">Zooming Out</h2>
<p>Alright! We’ve spent two blog posts going over a lot of different things in the context of our humble <code>Door s</code> type. Let’s zoom out and take a large-scale look at how <em>singletons</em> (the design pattern, and the library) helps us in general.</p>
<h3 id="sing">Sing</h3>
<p>The crux of everything is the <code>Sing :: Type -&gt; Type</code> indexed type. If you see a value of type <code>Sing s</code>, you should really just think “a runtime witness for <code>s</code>”. If you see:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>You should read it as (in pseudo-Haskell)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> { s } <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> { s } <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>This is seen clearly if we look at the partially applied type signatures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lockAnyDoor <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Opened -&gt; Door &#39;</span><span class="dt">Locked</span>
<span class="dt">MkSomeDoor</span>  <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Locked -&gt; SomeDoor</span></code></pre></div>
<p>If you squint, this kinda looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lockAnyDoor <span class="ch">&#39;Opened :: Door &#39;</span><span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span>  <span class="ch">&#39;Locked :: Door &#39;</span><span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>And indeed, when we get real dependent types in Haskell, we will really be directly passing types (that act as their own runtime values) instead of singletons.</p>
<p>It is important to remember that <code>Sing</code> is poly-kinded, so we can have <code>Sing 'Opened</code>, but also <code>Sing 'True</code>, <code>Sing 5</code>, and <code>Sing '['Just 3, 'Nothing, 'Just 0]</code> as well. This is the real benefit of using the <em>singletons</em> library instead of writing our own singletons – we get to work uniformly with singletons of all kinds.</p>
<h4 id="singi">SingI</h4>
<p><code>SingI</code> is a bit of typeclass trickery that lets us implicitly pass <code>Sing</code>s to functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">SingI</span> s <span class="kw">where</span>
<span class="ot">    sing ::</span> <span class="dt">Sing</span> s</code></pre></div>
<p>If you see:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span>  s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">Sing</span>  s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>These are <em>identical</em> to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">MkSomeDoor</span><span class="ot">  ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p>Either way, you’re passing in the ability to get a runtime witness on <code>s</code> – just in one way, it is asked for as an explicit argument, and the second way, it is passed in using a typeclass.</p>
<p>We can <em>convert</em> from <code>SingI s -&gt;</code> style to <code>SingI s =&gt;</code> style using <code>sing</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L48-64</span>
<span class="ot">lockAnyDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnyDoor_ <span class="fu">=</span> lockAnyDoor sing

<span class="ot">fromDoor_ ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor_ <span class="fu">=</span> <span class="dt">MkSomeDoor</span> sing</code></pre></div>
<p>And we can convert from <code>SingI s =&gt;</code> style to <code>SingI s -&gt;</code> style using <code>withSingI</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lockAnyDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnyDoor s d <span class="fu">=</span> withSingI s (lockAnyDoor_ d)

<span class="ot">fromDoor ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor s d <span class="fu">=</span> withSingI s (fromDoor_ d)</code></pre></div>
<p>Again, the same function – just two different styles of calling them.</p>
<h3 id="reflection-and-reification">Reflection and Reification</h3>
<p>Reflection is the process of bringing a type-level thing to a value at the term level (“losing” the type information in the process) and reification is the process of bringing a value-level Reification is the process of going from a value at the <em>term level</em> to the <em>type level</em>.</p>
<p>One limitation in Haskell is that there is no actual link between the type <code>DoorState</code> and its <em>values</em> with the <em>kind</em> <code>DoorState</code> with its <em>types</em>. Sure, the constructors have the same names, but the language doesn’t actually link them together for us.</p>
<p>The <em>singletons</em> library handles this by using a typeclass with associated types to implement a generalized reflection and reification process. It gives us the <code>SingKind</code> typeclass:</p>
<!-- *   `toSing :: DoorState -> SomeSing DoorState` takes us from values to their -->
<!--     (existentially quantified) singletons -->
<!--     ```haskell -->
<!--     ghci> let s = toSing Opened -->
<!--     ghci> :t s -->
<!--     s :: SomeSing DoorState -->
<!--     ghci> putStrLn $ case s of -->
<!--             SomeSing SOpened -> "Opened." -->
<!--             SomeSing SClosed -> "SClosed." -->
<!--             SomeSing SLocked -> "SLocked." -->
<!--     "Opened." -->
<!--     ``` -->
<!--     `SomeSing` is like `SomeDoor` in that it is an existentially quantified -->
<!--     singleton: -->
<!--     ```haskell -->
<!--     data SomeSing DoorState :: Type where -->
<!--         SomeSing :: Sing s -> SomeSing DoorState -->
<!--     -- or, more accurately, since `SomeSing` is polykinded -->
<!--     data SomeSing :: k -> Type where -->
<!--         SomeSing :: Sing (a :: k) -> SomeSing k -->
<!--     ``` -->
<!-- 3.  Implement `withSomeDoor` for the existentially quantified `SomeDoor` type. -->
<!--     ```haskell -->
<!--     !!!singletons/DoorSingletons.hs "data SomeDoor" "withSomeDoor ::"1 -->
<!--     ``` -->
<!-- 4.  Implement `openAnySomeDoor`, which should work like `lockAnySomeDoor`, just -->
<!--     wrapping an application of `openAnyDoor` inside a `SomeDoor`. -->
<!--     ```haskell -->
<!--     !!!singletons/DoorSingletons.hs "openAnySomeDoor ::"1 -->
<!--     ``` -->
<!--     You **shouild not** use `UnsafeMkDoor` directly. -->
<!--     Note that because we wrote `openAnyDoor` in "implicit style", we might have -->
<!--     to convert between `SingI s =>` and `Sing s ->` style, using `withSingI`. -->
<!-- However, full expressively with phantom types is still out of our reach.  If we -->
<!-- want to express more complicated relationships and to be able to treat phantom -->
<!-- types (and *types*, in general) as first-class values, and delve into the -->
<!-- frighteningly beautiful world of "type-level programming", we are going to have -->
<!-- to dig a bit deeper.  Come back for the next post to see how!  Singletons will -->
<!-- be our tool, and we'll also see how the singletons library is a very clean -->
<!-- unification of a lot of concepts. -->
<!-- ### A Reflection on Subtyping -->
<!-- Without phantom types you might have imagined being able to do something like -->
<!-- this: -->
<!-- ```hskell -->
<!-- data DoorOpened = MkDoorOpened { doorMaterial :: String } -->
<!-- data DoorClosed = MkDoorClosed { doorMaterial :: String } -->
<!-- data DoorLocked = MkDoorLocked { doorMaterial :: String } -->
<!-- ``` -->
<!-- Which is even possible now with `-XDuplicateRecordFields`.  And, for the most -->
<!-- part, you get a similar API: -->
<!-- ```haskell -->
<!-- closeDoor :: DoorOpened -> DoorClosed -->
<!-- lockDoor  :: DoorClosed -> DoorLocked -->
<!-- ``` -->
<!-- But what about writing things that take on "all" door types? -->
<!-- The only real way (besides typeclass magic) would be to make some sum type -->
<!-- like: -->
<!-- ```haskell -->
<!-- data SomeDoor = DO DoorOpened | DC DoorClosed | DL DoorLocked -->
<!-- lockAnyDoor :: SomeDoor -> DoorLocked -->
<!-- ``` -->
<!-- However, we see that if we parameterize a single `Door` type, we can have it -->
<!-- stand in *both* for a "known status" `Door` *and* for a "polymorphic status" -->
<!-- `Door`. -->
<!-- This actually leverages Haskell's *subtyping* system.  We say that `forall s. -->
<!-- Door s` (a `Door` that is polymorphic on all `s`) is a *subtype* of `Door -->
<!-- 'Opened`.  This means that a `forall s. Door s` can be used anywhere a function -->
<!-- would expect a `Door 'Opened`...but not the other way around. --></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-2.html';
    this.page.identifier = 'singletons-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>