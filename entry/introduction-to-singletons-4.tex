\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Introduction to Singletons (Part 4)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Introduction to Singletons (Part 4)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-4.html}{in
Code}}.}

Hi again! Welcome back; let's jump right into part 4 of our journey through the
\emph{singleton design pattern} and the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library!

Please check out
\href{https://blog.jle.im/entries/series/+introduction-to-singletons.html}{the
first three parts of the series} and make sure you are comfortable with them
before reading on. I definitely also recommend trying out some or all of the
exercises, since we are going to be building on the concepts in those posts in a
pretty heavy way.

Today we're going to jump straight into \emph{functional programming} at the
type level!

\hypertarget{review}{%
\section{Review}\label{review}}

Just as a quick review, this entire series we have been working with a
\texttt{Door} type:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}

\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::}\NormalTok{ \{}\OtherTok{ doorMaterial ::} \DataTypeTok{String}\NormalTok{ \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

And we talked about using \texttt{Sing\ s}, or \texttt{SDoorState\ s}, to
represent the state of the door (in its type) as a run-time value. We've been
using a wrapper to existentially hide the door state type, but also stuffing in
a singleton to let us recover the type information once we want it again:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}

\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor ds mat }\FunctionTok{=}\NormalTok{ withSomeSing ds }\FunctionTok{$}\NormalTok{ \textbackslash{}dsSing }\OtherTok{->}
    \DataTypeTok{MkSomeDoor}\NormalTok{ dsSing (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ mat)}
\end{Highlighting}
\end{Shaded}

In Part 3 we talked about a \texttt{Pass} data type that we used to talk about
whether or not we can walk through or knock on a door:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data Pass = Obstruct | Allow}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

And we defined type-level functions on it using \emph{singletons} Template
Haskell:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  statePass :: DoorState -> Pass}
\NormalTok{  statePass Opened = Allow}
\NormalTok{  statePass Closed = Obstruct}
\NormalTok{  statePass Locked = Obstruct}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

This essentially generates these three things:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{statePass ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Pass}
\NormalTok{statePass }\DataTypeTok{Opened} \FunctionTok{=} \DataTypeTok{Allow}
\NormalTok{statePass }\DataTypeTok{Closed} \FunctionTok{=} \DataTypeTok{Obstruct}
\NormalTok{statePass }\DataTypeTok{Locked} \FunctionTok{=} \DataTypeTok{Obstruct}

\KeywordTok{type}\NormalTok{ family }\DataTypeTok{StatePass}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Pass} \KeywordTok{where}
    \DataTypeTok{StatePass}\NormalTok{ '}\DataTypeTok{Opened} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Allow}
    \DataTypeTok{StatePass}\NormalTok{ '}\DataTypeTok{Closed} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Obstruct}
    \DataTypeTok{StatePass}\NormalTok{ '}\DataTypeTok{Locked} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Obstruct}

\OtherTok{sStatePass ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{StatePass}\NormalTok{ s)}
\NormalTok{sStatePass }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{SAllow}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{SObstruct}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{SObstruct}
\end{Highlighting}
\end{Shaded}

And we can use \texttt{StatePass} as a type-level function while using
\texttt{sStatePass} to manipulate the singletons representing \texttt{s} and
\texttt{StatePass\ s}.

We used this as a constraint to restrict how we can call our functions:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knockP ::}\NormalTok{ (}\DataTypeTok{StatePass}\NormalTok{ s }\FunctionTok{~}\NormalTok{ '}\DataTypeTok{Obstruct}\NormalTok{) }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockP d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

But then we wondered\ldots{}is there a way to not only \emph{restrict} our
functions, but to describe how the inputs and outputs are related to each other?

\hypertarget{inputs-and-outputs}{%
\section{Inputs and Outputs}\label{inputs-and-outputs}}

In the past we have settled with very simple relationships, like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeDoor ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Closed}
\NormalTok{closeDoor (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor}\NormalTok{ m}
\end{Highlighting}
\end{Shaded}

This means that the relationship between the input and output is that the input
is opened\ldots{}and is then closed.

However, armed with promotion of type-level functions, writing more complex
relationships becomes fairly straightforward!

We can write a function \texttt{mergeDoor} that ``merges'' two doors together,
in sequence:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeDoor ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ t }\OtherTok{->} \DataTypeTok{Door} \FunctionTok{????}
\NormalTok{mergeDoor d e }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{$}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" and "} \FunctionTok{++}\NormalTok{ doorMaterial e}
\end{Highlighting}
\end{Shaded}

A merged door will have a material that is composite of the original materials.
But, what will the new \texttt{DoorState} be? What goes in the \texttt{???}
above?

Well, if we can write the function as a normal function in
values\ldots{}\emph{singletons} lets us use it as a function on types. Let's
write that relationship. Let's say merging takes on the higher ``security''
option --- merging opened with locked is locked, merging closed with opened is
closed, merging locked with closed is locked.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  mergeState :: DoorState -> DoorState -> DoorState}
\NormalTok{  mergeState Opened d      = d}
\NormalTok{  mergeState Closed Opened = Closed}
\NormalTok{  mergeState Closed Closed = Closed}
\NormalTok{  mergeState Closed Locked = Locked}
\NormalTok{  mergeState Locked _      = Locked}
\NormalTok{  |])}

\CommentTok{-- Alternatively, taking advantage of the derived Ord instance:}
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  mergeState :: DoorState -> DoorState -> DoorState}
\NormalTok{  mergeState = max}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

This makes writing \texttt{mergeDoor}'s type fairly straightforward!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mergeDoor}
\OtherTok{    ::} \DataTypeTok{Door}\NormalTok{ s}
    \OtherTok{->} \DataTypeTok{Door}\NormalTok{ t}
    \OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t)}
\NormalTok{mergeDoor d e }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{$}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" and "} \FunctionTok{++}\NormalTok{ doorMaterial e}
\end{Highlighting}
\end{Shaded}

And, with the help of singletons, we can also write this for our doors where we
don't know the types until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mergeSomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mergSomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) (}\DataTypeTok{MkSomeDoor}\NormalTok{ t e) }\FunctionTok{=}
    \DataTypeTok{MkSomeDoor}\NormalTok{ (sMergeState s t) (mergeDoor d e)}
\end{Highlighting}
\end{Shaded}

To see why this typechecks properly, compare the types of \texttt{sMergeState}
and \texttt{mergeDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{sMergeState ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ t }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t)}
\OtherTok{mergeDoor   ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ t }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t)}

\DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t) }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeState}\NormalTok{ s t) }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Because the results both create types \texttt{MergeState\ s\ t},
\texttt{MkSomeDoor} is happy to apply them to each other, and everything
typechecks. However, if, say, we directly stuffed \texttt{s} or \texttt{t} into
\texttt{MkSomeDoor}, things would fall apart and not typecheck.

And so now we have full expressiveness in determining input and output
relationships! Once we unlock the power of type-level functions with
\emph{singletons}, writing type-level relationships become as simple as writing
value-level ones. If you can write a value-level function, you can write a
type-level function!

\hypertarget{kicking-it-up-a-notch}{%
\section{Kicking it up a notch}\label{kicking-it-up-a-notch}}

Alright, so let's see how far we can really take this!

Let's make a data type that represents a \emph{series of hallways}, each linked
by a door. A hallway is either an empty stretch with no door, or two hallways
linked by a door. We'll structure it like a linked list, and store the list of
all door states as a type-level list as a type parameter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Hallway}\OtherTok{ ::}\NormalTok{ [}\DataTypeTok{DoorState}\NormalTok{] }\OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{HEnd}\OtherTok{  ::} \DataTypeTok{Hallway}\NormalTok{ '[]}
    \CommentTok{-- ^ end of the hallway, a stretch with no doors}
\OtherTok{    (:<#) ::} \DataTypeTok{Door}\NormalTok{ s}
          \OtherTok{->} \DataTypeTok{Hallway}\NormalTok{ ss}
          \OtherTok{->} \DataTypeTok{Hallway}\NormalTok{ (s '}\FunctionTok{:}\NormalTok{ ss)}
    \CommentTok{-- ^ A door connected to a hallway is a new}
    \CommentTok{--   hallway, and we track the door's state in the list}
    \CommentTok{--   of hallway door states}

\KeywordTok{infixr} \DecValTok{5} \FunctionTok{:<#}
\end{Highlighting}
\end{Shaded}

So we might have:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door1 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Oak"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door2 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Opened} \StringTok{"Spruce"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door3 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Locked} \StringTok{"Acacia"}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t door1 }\FunctionTok{:<#}\NormalTok{ door2 }\FunctionTok{:<#}\NormalTok{ door3 }\FunctionTok{:<#} \DataTypeTok{HEnd}
\DataTypeTok{Hallway}\NormalTok{ '[ '}\DataTypeTok{Closed}\NormalTok{, '}\DataTypeTok{Opened}\NormalTok{, '}\DataTypeTok{Locked}\NormalTok{ ]}
\end{Highlighting}
\end{Shaded}

That is, a \texttt{Hallway\ \textquotesingle{}{[}\ s,\ t,\ u\ {]}} is a hallway
consisting of a \texttt{Door\ s}, a \texttt{Door\ t}, and a \texttt{Door\ u},
constructed like a linked list in Haskell.

Now, let's write a function to \emph{collapse all doors in a hallway down to a
single door}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{collapseHallway ::} \DataTypeTok{Hallway}\NormalTok{ ss }\OtherTok{->} \DataTypeTok{Door} \FunctionTok{?????}
\end{Highlighting}
\end{Shaded}

Basically, we want to merge all of the doors one after the other, collapsing it
until we have a single door state. Luckily, \texttt{MergeState} is both
commutative and associative and has an identity, so this can be defined
sensibly.

First, let's think about the type we want. What will the result of merging
\texttt{ss} be?

We can pattern match and collapse an entire list down item-by-item:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  mergeStates :: [DoorState] -> DoorState}
\NormalTok{  mergeStates []     = Opened               -- ^ the identity of mergeState}
\NormalTok{  mergeStates (s:ss) = s `mergeState` mergeStates ss}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

Again, remember that this also defines the type family \texttt{MergeStates} and
the singleton function
\texttt{sMergeStates\ ::\ Sing\ ss\ -\textgreater{}\ Sing\ (MergeStates\ ss)}.

With this, we can write \texttt{collapseHallway}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{collapseHallway ::} \DataTypeTok{Hallway}\NormalTok{ ss }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ (}\DataTypeTok{MergeStates}\NormalTok{ ss)}
\NormalTok{collapseHallway }\DataTypeTok{HEnd}       \FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \StringTok{"End of Hallway"}
\NormalTok{collapseHallway (d }\FunctionTok{:<#}\NormalTok{ ds) }\FunctionTok{=}\NormalTok{ d }\OtherTok{`mergeDoor`}\NormalTok{ collapseHallway ds}
\end{Highlighting}
\end{Shaded}

Now, because the structure of \texttt{collapseHallway} perfectly mirrors the
structure of \texttt{mergeStates}, this all typechecks, and we're done!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ collapseHallway (door1 }\FunctionTok{:<#}\NormalTok{ door2 }\FunctionTok{:<#}\NormalTok{ door3 }\FunctionTok{:<#} \DataTypeTok{HEnd}\NormalTok{)}
\DataTypeTok{UnsafeMkDoor} \StringTok{"Oak and Spruce and Acacia and End of Hallway"}
\OtherTok{    ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Locked}
\end{Highlighting}
\end{Shaded}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
