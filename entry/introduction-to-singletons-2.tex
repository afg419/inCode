\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Introduction to Singletons (Part 2)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Introduction to Singletons (Part 2)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-2.html}{in
Code}}.}

Welcome back to our journey through the singleton design pattern and the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library!

This post is a direct continuation of
\href{https://blog.jle.im/entry/introduction-to-singletons-1.html}{Part 1}, so
be sure to check that out first if you haven't already! If you hare just jumping
in now, I suggest taking some time to to through the exercises if you haven't
already!

Again, code is built on \emph{GHC 8.2.2} with the
\emph{\href{https://www.stackage.org/lts-10.0}{lts-10.0}} snapshot (so,
singletons-2.3.1).

\section{Review}\label{review}

Let's return to our \texttt{Door} type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L17-23}
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}

\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::}\NormalTok{ \{}\OtherTok{ doorMaterial ::} \DataTypeTok{String}\NormalTok{ \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

\texttt{Door} is great! It is an \emph{indexed data type}, in that picking a
different type variable gives a different ``type'' of Door:

\begin{itemize}
\tightlist
\item
  \texttt{Door\ \textquotesingle{}Opened} is a type that represents the type of
  an opened door
\item
  \texttt{Door\ \textquotesingle{}Closed} is a \emph{different} type that
  represents the type of a \emph{closed} door
\item
  \texttt{Door\ \textquotesingle{}Locked} is yet another (third) type that
  represents the type of a \emph{locked} door.
\end{itemize}

So, really, when we define \texttt{Door\ s}, we really are defining \emph{three
distinct} types (and also a not-so-obvious fourth one, which we will discuss
later).

This is great and all, but isn't Haskell a language with static, compile-time
types? Doesn't that mean that we have to know if our doors are opened, closed,
or locked at compile-time?

This is something we can foresee being a big issue. It's easy enough to create a
\texttt{Door\ s} if you know \texttt{s} at compile-time by just typing in a type
annotation (\texttt{UnsafeMkDoor\ "Oak"\ ::\ Door\ \textquotesingle{}Opened}).
But what if we \emph{don't} know \texttt{s} at compile-time?

To learn how to do this, we first need to learn how to \emph{not care}.

\section{Ditching the Phantom}\label{ditching-the-phantom}

Sometimes we don't \emph{actually} care about the state of the door in the
\emph{type} of the door. We don't want \texttt{Door\ \textquotesingle{}Opened}
and \texttt{Door\ \textquotesingle{}Closed}\ldots{}we want a type to just
represent a door, without the status in its type.

This might come about a bunch of different ways. Maybe you're reading a
\texttt{Door} data from a serialization format, and you want to be able to parse
\emph{any} door (whatever door is serialized).

More concretely, we've seen this in \texttt{lockAnyDoor}, as well --
\texttt{lockAnyDoor} doesn't care about the type of its input (it can be
\emph{any} \texttt{Door}). It only cares about the type of its output
(\texttt{Door\ \textquotesingle{}Locked})

To learn how to not care, we can describe a type for a door that does \emph{not}
have its status in its type.

We have a couple of options here. First, we can create a new type
\texttt{SomeDoor} that is the same as \texttt{Door}, except instead of keeping
its status in its type, it keeps it as a runtime value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=} \DataTypeTok{MkSomeDoor}
\NormalTok{    \{}\OtherTok{ someDoorState    ::} \DataTypeTok{DoorState}
\NormalTok{    ,}\OtherTok{ someDoorMaterial ::} \DataTypeTok{String}
\NormalTok{    \}}

\CommentTok{-- or, in GADT syntax}
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor} \OtherTok{::}
\NormalTok{      \{}\OtherTok{ someDoorState    ::} \DataTypeTok{DoorState}
\NormalTok{      ,}\OtherTok{ someDoorMaterial ::} \DataTypeTok{String}
\NormalTok{      \} }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Note the similarity of \texttt{SomeDoor}'s declaration to \texttt{Door}'s
declaration above. It's mostly the same, except, instead of \texttt{DoorState}
being a type parameter, it is instead a runtime value inside \texttt{SomeDoor}.

Now, this is actually a type that we \emph{could} have been using this entire
time, if we didn't care about type safety. In the real world and in real
applications, we actually might have written \texttt{SomeDoor} \emph{before} we
ever thought about \texttt{Door} with a phantom type. It's definitely the more
typical ``standard'' Haskell thing.

It's possible to ``construct'' this from our original typed \texttt{Door}, using
a smart constructor/conversion function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fromDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor }\DataTypeTok{SOpened}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{Opened}\NormalTok{ m}
\NormalTok{formDoor }\DataTypeTok{SClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m}
\NormalTok{formDoor }\DataTypeTok{SLocked}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{Locked}\NormalTok{ m}

\OtherTok{fromDoor_ ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor_ }\FunctionTok{=}\NormalTok{ fromDoor sing}
\end{Highlighting}
\end{Shaded}

We can now write functions on this type:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeSomeOpenedDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Maybe} \DataTypeTok{SomeDoor}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Opened}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m)}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{Nothing}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Locked}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

\subsection{SomeDoor to Door}\label{somedoor-to-door}

\texttt{SomeDoor} is great. But because it's a completely different type, we
potentially have to write the same function for both \texttt{Door} and
\texttt{SomeDoor}, because they have different implementations. Wouldn't it be
nice if we can \emph{re-use} our original \texttt{closeDoor}? This is a toy
example, and in real life, closing a door might have some complicated runtime
logic, and it'd be annoying to have to \emph{re-implement} it for both
\texttt{SomeDoor} and \texttt{Door}.

\subsubsection{Converting into an
existential}\label{converting-into-an-existential}

One thing we can do is write a function to convert a \texttt{SomeDoor} into a
\texttt{Door}, so we can re-use our original \texttt{closeDoor}. We'd convert
our \texttt{SomeDoor} into a \texttt{Door} to re-use our
\texttt{closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed}
on it if possible!

However, going from \texttt{SomeDoor} to \texttt{Door\ s} is slightly trickier
in Haskell than going the other way around. The main thing stopping us is that
normal Haskell type variables are universally qualified, meaning that the
\emph{caller} can pick how to instantiate \texttt{s} (and not the conversion
function). However, we want a function where the \emph{function} can pick the
\texttt{s}, and the caller must handle whatever \texttt{s} is given by the
function:

One trick we often use is a CPS-style existential type:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{withSomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\NormalTok{withSomeDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Opened}\NormalTok{ m) f }\FunctionTok{=}\NormalTok{ f }\DataTypeTok{SOpened}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\NormalTok{withSomeDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m) f }\FunctionTok{=}\NormalTok{ f }\DataTypeTok{SClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\NormalTok{withSomeDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Locked}\NormalTok{ m) f }\FunctionTok{=}\NormalTok{ f }\DataTypeTok{SLocked}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

Notice the funky CPS-like type signature of \texttt{withSomeDoor}. To use
\texttt{withSomeDoor} and access the \texttt{Door}, you have to pass in a
function to handle \emph{any possible \texttt{s}}. And, as you can see, the
function passed in might be given an \texttt{SOpened}, an \texttt{SClosed}, or
an \texttt{SLocked}. It has to be able to handle all three!

Here, we call \texttt{s} \emph{existentially quantified}. The
\texttt{withSomeDoor} function gets to pick which \texttt{s} to give \texttt{f}.
So, the \texttt{s} type variable is directly chosen by the \emph{function}, and
not by the caller.

We can implement \texttt{closeSomeOpenedDoor} (and even a
\texttt{lockAnySomeDoor}) using this conversion function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeSomeOpenedDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Maybe} \DataTypeTok{SomeDoor}
\NormalTok{closeSomeOpenedDoor sd }\FunctionTok{=}\NormalTok{ withSomeDoor sd }\FunctionTok{$}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->}\NormalTok{ \textbackslash{}d }\OtherTok{->} \DataTypeTok{Just} \FunctionTok{.}\NormalTok{ fromDoor_ }\FunctionTok{.}\NormalTok{ closeDoor }\FunctionTok{$}\NormalTok{ d}
    \DataTypeTok{SClosed} \OtherTok{->}\NormalTok{ \textbackslash{}_ }\OtherTok{->} \DataTypeTok{Nothing}
    \DataTypeTok{SLocked} \OtherTok{->}\NormalTok{ \textbackslash{}_ }\OtherTok{->} \DataTypeTok{Nothing}

\OtherTok{lockAnySomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{lockAnySomeDoor sd }\FunctionTok{=}\NormalTok{ withSomeDoor sd }\FunctionTok{$}\NormalTok{ \textbackslash{}s d }\OtherTok{->}
\NormalTok{    fromDoor_ }\FunctionTok{$}\NormalTok{ lockAnyDoor s d}
\end{Highlighting}
\end{Shaded}

Now, our goal is complete -- we can \emph{re-use} our previous
\texttt{closeDoor} and \texttt{lockAnyDoor}! We \emph{convert} our
\texttt{SomeDoor} into a \texttt{Door\ s} (with an existentially quantified
\texttt{s}), so we can use
\texttt{closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed}
and
\texttt{lockAnyDoor\ ::\ Door\ s\ -\textgreater{}\ Door\ \textquotesingle{}Locked}
on it. Then we ``convert it back'' using \texttt{fromDoor}.

\subsection{The Existential Datatype}\label{the-existential-datatype}

However, there's another path we can take. With the power of singletons, we can
actually implement \texttt{SomeDoor} \emph{in terms of} \texttt{Door}, using an
\textbf{existential data type}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- using existential constructor syntax}
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=}\NormalTok{ forall s}\FunctionTok{.} \DataTypeTok{MkSomeDoor}\NormalTok{ (}\DataTypeTok{Sing}\NormalTok{ s) (}\DataTypeTok{Door}\NormalTok{ s)}

\CommentTok{-- or, using GADT syntax (preferred)}
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L57-58}
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

\texttt{MkSomeDoor} is a constructor for an existential data type, meaning that
the data type ``hides'' a type variable \texttt{s}.

Note the similarities between our original \texttt{SomeDoor} and this one.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- | Re-implementing door}
\KeywordTok{data} \DataTypeTok{SomeDoor} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}

\CommentTok{-- | Re-using Door, as an existential type}
\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{DoorState} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}

\KeywordTok{data} \DataTypeTok{SomeDoor} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{Sing}\NormalTok{ s  }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Basically, our type before re-implements \texttt{Door}. But the new one actually
directly uses the original \texttt{Door\ s}. This means we can \emph{directly}
re-use our \texttt{Door} functions on \texttt{SomeDoor}s, without needing to
convert our implementations.

In Haskell, existential data types are pretty nice, syntactically, to work with.
For a comparison, let's re-implement our previous functions with our new data
type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L60-73}
\OtherTok{fromDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor }\FunctionTok{=} \DataTypeTok{MkSomeDoor}

\OtherTok{fromDoor_ ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor_ }\FunctionTok{=} \DataTypeTok{MkSomeDoor}\NormalTok{ sing}

\OtherTok{closeSomeOpenedDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Maybe} \DataTypeTok{SomeDoor}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Just} \FunctionTok{.}\NormalTok{ fromDoor_ }\FunctionTok{$}\NormalTok{ closeDoor d}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Nothing}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Nothing}

\OtherTok{lockAnySomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{lockAnySomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=}\NormalTok{ fromDoor_ }\FunctionTok{$}\NormalTok{ lockAnyDoor s d}
\end{Highlighting}
\end{Shaded}

Much more convenient, because \emph{we already have a \texttt{Door}!} And we
don't have to re-implement one like we did for our original \texttt{SomeDoor} --
all of our original code works directly!

\subsection{The Link}\label{the-link}

It's important to remember that our original separate-implementation
\texttt{SomeDoor} is, functionally, identical to the new code-reusing
\texttt{Door}. The reason why they are the same is that \emph{having an
existentially quantified singleton is the same as having a value of the
corresponding type.} Having an existentially quantified \texttt{SingDS\ s} is
\emph{the same as} having a value of type \texttt{DoorState}.

In fact, the \emph{singletons} library gives us a direct existential wrapper:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- (not the actual definition)}
\KeywordTok{data} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\end{Highlighting}
\end{Shaded}

There are three values of type \texttt{SomeSing\ DoorState}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{SomeSing} \DataTypeTok{SOpened}\OtherTok{ ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\DataTypeTok{SomeSing} \DataTypeTok{SClosed}\OtherTok{ ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\DataTypeTok{SomeSing} \DataTypeTok{SLocked}\OtherTok{ ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\end{Highlighting}
\end{Shaded}

A value of type \texttt{SomeSing\ DoorState} (which contains an existentially
quantified \texttt{Sing\ s} -- a \texttt{SingDS}) is \emph{the same} as a value
of type \texttt{DoorState}. The two types are identical! (Or, well, isomorphic.
As a fun exercise, write out the explicit isomorphism -- the
\texttt{SomeSing\ DoorState\ -\textgreater{}\ DoorState} and the
\texttt{DoorState\ -\textgreater{}\ SomeSing\ DoorState}).

Our new \texttt{SomeDoor} containing an existentially quantified
\texttt{Sing\ s} is the same as our first \texttt{SomeDoor} containing just a
\texttt{DoorState}.

\subsubsection{Why Bother}\label{why-bother}

If they're identical, why use a \texttt{Sing} or the new \texttt{SomeDoor} at
all? Why not just use a \texttt{DoorState} value?

The main reason (besides allowing code-reuse) is that \emph{using the singleton
lets us directly recover the type}. Essentially, a \texttt{SingDS\ s} not only
contains whether it is Opened/Closed/Locked\ldots{}it contains it in a way that
GHC can use to \emph{bring it all back} to the type level.

A \texttt{forall\ s.\ SomeDoor\ (Sing\ s)\ (Door\ s)} essentially contains
\texttt{s} \emph{with} \texttt{Door\ s}. When you see this, you \emph{should
read this as} \texttt{forall\ s.\ SomeDoor\ s\ (Door\ s)} (and, indeed, this is
similar to how it is written in dependently typed languages.)

It's kind of like how, when you're used to reading Applicative style, when you
see \texttt{f\ \textless{}\$\textgreater{}\ x\ \textless{}*\textgreater{}\ y},
you should read \texttt{f\ x\ y}. When you see
\texttt{forall\ s.\ SomeDoor\ (Sing\ s)\ (Door\ s)}, you should read
\texttt{forall\ s.\ SomeDoor\ s\ (Door\ s)}. The role of \texttt{Sing\ s} there
is, like in Part 1, simply to be a run-time stand-in for the type \texttt{s}
itself.

So, for our original \texttt{Door\ s} functions, we need to know \texttt{s} at
runtime -- storing the \texttt{Sing\ s} gives GHC exactly that. Once you get the
\texttt{Sing\ s} back, you can now use it in all of our type-safe functions from
Part 1, and you're back in type-safe land.

\subsection{Some Lingo}\label{some-lingo}

In the language of dependently typed programming, we call \texttt{SomeDoor} a
\textbf{dependent sum}, because you can imagine it basically as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=} \DataTypeTok{SDOpened}\NormalTok{ (}\DataTypeTok{Door} \CharTok{'Opened)}
              \FunctionTok{|} \DataTypeTok{SDClosed}\NormalTok{ (}\DataTypeTok{Door} \CharTok{'Closed)}
              \FunctionTok{|} \DataTypeTok{SDLocked}\NormalTok{ (}\DataTypeTok{Door} \CharTok{'Locked)}
\end{Highlighting}
\end{Shaded}

A three-way sum between a \texttt{Door\ \textquotesingle{}Opened}, a
\texttt{Door\ \textquotesingle{}Closed}, and a
\texttt{Door\ \textquotesingle{}Locked}, essentially. If you have a
\texttt{SomeDoor}, it's \emph{either} an opened door, a closed door, or a locked
door. Try looking at this new \texttt{SomeDoor} until you realize that this type
is the same type as the previous \texttt{SomeDoor}!

You might also see \texttt{SomeDoor} called a \textbf{dependent pair} -- it's a
``tuple'' where the \emph{type} of the second item (our \texttt{Door\ s}) is
determined by the \emph{value} of the first item (our \texttt{Sing\ s}).

In Idris, we could write \texttt{SomeDoor} as a type alias, using its native
dependent sum syntax, as \texttt{s\ **\ Door\ s}. The \emph{value} of the first
item reveals to us (through a pattern match, in Haskell) the \emph{type} of the
second.

\subsection{Types at Runtime}\label{types-at-runtime}

With this last tool, we finally have enough to build a function to ``make'' a
door with the status unknown until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened} \FunctionTok{.}\NormalTok{ mkDoor }\DataTypeTok{SOpened}
    \DataTypeTok{Closed} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed} \FunctionTok{.}\NormalTok{ mkDoor }\DataTypeTok{SClosed}
    \DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked} \FunctionTok{.}\NormalTok{ mkDoor }\DataTypeTok{SLocked}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ mySomeDoor }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Opened} \StringTok{"Birch"}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t mySomeDoor}
\DataTypeTok{SomeDoor}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ putStrLn }\FunctionTok{$} \KeywordTok{case}\NormalTok{ mySomeDoor }\KeywordTok{of}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was opened!"}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was closed!"}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was locked!"}
\NormalTok{mySomeDoor was opened}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

Using \texttt{mkSomeDoor}, we can truly pass in a \texttt{DoorState} that we
generate at runtime (from IO, or a user prompt, or a configuration file, maybe),
and create a \texttt{Door} based on it.

Take \emph{that}, type erasure! :D

We could even directly return a \texttt{Door} with an existentially quantified
door status in CPS style:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{withDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\NormalTok{withDoor s m f }\FunctionTok{=} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
    \DataTypeTok{Opened} \OtherTok{->}\NormalTok{ f }\DataTypeTok{SOpened}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
    \DataTypeTok{Closed} \OtherTok{->}\NormalTok{ f }\DataTypeTok{SClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
    \DataTypeTok{Locked} \OtherTok{->}\NormalTok{ f }\DataTypeTok{SLocked}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ withDoor }\DataTypeTok{Opened} \StringTok{"Birch"} \FunctionTok{$}\NormalTok{ \textbackslash{}s d }\OtherTok{->} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
         \DataTypeTok{SOpened} \OtherTok{->} \StringTok{"Opened door!"}
         \DataTypeTok{SClosed} \OtherTok{->} \StringTok{"Closed door!"}
         \DataTypeTok{SLocked} \OtherTok{->} \StringTok{"Locked door!"}
\DataTypeTok{Opened}\NormalTok{ door}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

This allows us to \emph{directly} generate a \texttt{Door\ s} with an \texttt{s}
that can vary at runtime.

\subsection{Reification}\label{reification}

The general pattern we are exploiting here is called \textbf{reification} --
we're taking a dynamic run-time value, and lifting it to the type level as a
type (here, the type variable \texttt{s}). You can think of reification as the
opposite of \emph{reflection}, and imagine the two as being the ``gateway''
between the type-safe and unsafe world. In the dynamic world of a
\texttt{DoorState} term-level value, you have no type safety. You live in the
world of \texttt{SomeDoor}, \texttt{closeSomeOpenedDoor},
\texttt{lockAnySomeDoor}, etc. But, you can \emph{reify} your \texttt{DoorState}
value to a \emph{type}, and enter the type-safe world of \texttt{Door\ s},
\texttt{closeDoor}, \texttt{lockDoor}, and \texttt{lockAnyDoor}.

The \emph{singletons} library automatically generates functions to directly
reify \texttt{DoorState} values:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{toSing       ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\OtherTok{withSomeSing ::} \DataTypeTok{DoorState} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\end{Highlighting}
\end{Shaded}

The first one reifies a \texttt{DoorState} as an existentially quantified data
type, and the second one reifies in CPS-style, without the intermediate data
type.

We can use these to write \texttt{mkSomeDoor} and \texttt{withDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L75-80}
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor ds }\FunctionTok{=} \KeywordTok{case}\NormalTok{ toSing ds }\KeywordTok{of}
    \DataTypeTok{SomeSing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{MkSomeDoor}\NormalTok{ s }\FunctionTok{.}\NormalTok{ mkDoor s}

\OtherTok{withDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\NormalTok{withDoor ds m f }\FunctionTok{=}\NormalTok{ withSomeSing ds }\FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->}\NormalTok{ f s (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\section{Zooming Out}\label{zooming-out}

Alright! We've spent two blog posts going over a lot of different things in the
context of our humble \texttt{Door\ s} type. Let's zoom out and take a
large-scale look at how \emph{singletons} (the design pattern, and the library)
helps us in general.

\subsection{Sing}\label{sing}

The crux of everything is the \texttt{Sing\ ::\ Type\ -\textgreater{}\ Type}
indexed type. If you see a value of type \texttt{Sing\ s}, you should really
just think ``a runtime witness for \texttt{s}''. If you see:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lockAnyDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

You should read it as (in pseudo-Haskell)

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lockAnyDoor ::}\NormalTok{ \{ s \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\DataTypeTok{MkSomeDoor}\OtherTok{  ::}\NormalTok{ \{ s \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

This is seen clearly if we look at the partially applied type signatures:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lockAnyDoor }\DataTypeTok{SOpened}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Opened -> Door '}\DataTypeTok{Locked}
\DataTypeTok{MkSomeDoor}  \DataTypeTok{SLocked}\OtherTok{ ::} \DataTypeTok{Door} \CharTok{'Locked -> SomeDoor}
\end{Highlighting}
\end{Shaded}

If you squint, this kinda looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lockAnyDoor }\CharTok{'Opened :: Door '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\DataTypeTok{MkSomeDoor}  \CharTok{'Locked :: Door '}\DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

And indeed, when we get real dependent types in Haskell, we will really be
directly passing types (that act as their own runtime values) instead of
singletons.

It is important to remember that \texttt{Sing} is poly-kinded, so we can have
\texttt{Sing\ \textquotesingle{}Opened}, but also
\texttt{Sing\ \textquotesingle{}True}, \texttt{Sing\ 5}, and
\texttt{Sing\ \textquotesingle{}{[}\textquotesingle{}Just\ 3,\ \textquotesingle{}Nothing,\ \textquotesingle{}Just\ 0{]}}
as well. This is the real benefit of using the \emph{singletons} library instead
of writing our own singletons -- we get to work uniformly with singletons of all
kinds.

\subsubsection{SingI}\label{singi}

\texttt{SingI} is a bit of typeclass trickery that lets us implicitly pass
\texttt{Sing}s to functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SingI}\NormalTok{ s }\KeywordTok{where}
\OtherTok{    sing ::} \DataTypeTok{Sing}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

If you see:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lockAnyDoor ::} \DataTypeTok{Sing}\NormalTok{  s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{Sing}\NormalTok{  s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

These are \emph{identical} to

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lockAnyDoor ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Either way, you're passing in the ability to get a runtime witness on \texttt{s}
-- just in one way, it is asked for as an explicit argument, and the second way,
it is passed in using a typeclass.

We can \emph{convert} from \texttt{SingI\ s\ -\textgreater{}} style to
\texttt{SingI\ s\ =\textgreater{}} style using \texttt{sing}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L48-64}
\OtherTok{lockAnyDoor_ ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\NormalTok{lockAnyDoor_ }\FunctionTok{=}\NormalTok{ lockAnyDoor sing}

\OtherTok{fromDoor_ ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor_ }\FunctionTok{=} \DataTypeTok{MkSomeDoor}\NormalTok{ sing}
\end{Highlighting}
\end{Shaded}

And we can convert from \texttt{SingI\ s\ =\textgreater{}} style to
\texttt{SingI\ s\ -\textgreater{}} style using \texttt{withSingI}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lockAnyDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door} \CharTok{'Locked}
\NormalTok{lockAnyDoor s d }\FunctionTok{=}\NormalTok{ withSingI s (lockAnyDoor_ d)}

\OtherTok{fromDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor s d }\FunctionTok{=}\NormalTok{ withSingI s (fromDoor_ d)}
\end{Highlighting}
\end{Shaded}

Again, the same function -- just two different styles of calling them.

\subsection{Reflection and Reification}\label{reflection-and-reification}

Reflection is the process of bringing a type-level thing to a value at the term
level (``losing'' the type information in the process) and reification is the
process of bringing a value-level Reification is the process of going from a
value at the \emph{term level} to the \emph{type level}.

You can think of reflection and reification as being the ``gateways'' between
the untyped/unsafe world and the typed/safe world. Reflection takes you from the
typed world to the untyped world (from \texttt{Sing\ s} to \texttt{DoorState})
and reification takes you from the untyped world to the typed world (from
\texttt{DoorState} to \texttt{Sing\ s}).

One limitation in Haskell is that there is no actual link between the type
\texttt{DoorState} and its \emph{values} with the \emph{kind} \texttt{DoorState}
with its \emph{types}. Sure, the constructors have the same names, but the
language doesn't actually link them together for us.

\subsubsection{SingKind}\label{singkind}

The \emph{singletons} library handles this by using a typeclass with associated
types to implement a generalized reflection and reification process. It gives us
the \texttt{SingKind} ``kindclass'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SingKind}\NormalTok{ k }\KeywordTok{where}
    \CommentTok{-- | Associate a kind k with its reflected type}
    \KeywordTok{type} \DataTypeTok{Demote}\NormalTok{ k }\FunctionTok{=}\NormalTok{ (}\OtherTok{r ::} \DataTypeTok{Type}\NormalTok{)}

    \CommentTok{-- | Reflect a singleton to its term-level value}
\OtherTok{    fromSing ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k) }\OtherTok{->} \DataTypeTok{Demote}\NormalTok{ k}

    \CommentTok{-- | Reflect a singleton to its term-level value}
\OtherTok{    toSing ::} \DataTypeTok{Demote}\NormalTok{ k }\OtherTok{->} \DataTypeTok{SomeSing}\NormalTok{ k}
\end{Highlighting}
\end{Shaded}

Instances of \texttt{SingKind} are promoted kinds like \texttt{Bool},
\texttt{DoorState}, etc., and \texttt{Demote} is an associated type/type family
that associates each instance with the \emph{type} it is promoted from.

For example, remember how
\texttt{data\ DoorState\ =\ Opened\ \textbar{}\ Closed\ \textbar{}\ Locked}
created the \emph{type} \texttt{DoorState} (with value constructors
\texttt{Opened}, \texttt{Closed}, and \texttt{Locked}), and also the \emph{kind}
\texttt{DoorState} (with \emph{type} constructors
\texttt{\textquotesingle{}Opened}, \texttt{\textquotesingle{}Closed}, and
\texttt{\textquotesingle{}Locked}). Our \emph{kind} \texttt{DoorState} would be
the instance of \texttt{SingKind}, and \texttt{Demote\ DoorState} would be the
\emph{type} \texttt{DoorState}.

The reason we need an explicit \texttt{Demote} associated type is, again, that
GHC doesn't actually link the type and its promoted kind. \texttt{Demote} lets
us explicitly specify what type a \texttt{Kind} should expect its term-level
reflected values to be.

\subsubsection{Examples}\label{examples}

To illustrate explicitly, here is the automatically generated instance of
\texttt{SingKind} for the \texttt{DoorState} \emph{kind}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{instance} \DataTypeTok{SingKind} \DataTypeTok{DoorState} \KeywordTok{where}       \CommentTok{-- the *kind* DoorState}
    \KeywordTok{type} \DataTypeTok{Demote} \DataTypeTok{DoorState} \FunctionTok{=} \DataTypeTok{DoorState}   \CommentTok{-- the *type* DoorState}

\NormalTok{    fromSing}
\OtherTok{        ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{)        }\CommentTok{-- the *kind* DoorState}
        \OtherTok{->} \DataTypeTok{DoorState}                    \CommentTok{-- the *type* DoorState}
\NormalTok{    fromSing }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
        \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Opened}
        \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Closed}
        \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Locked}

\NormalTok{    toSing}
\OtherTok{        ::} \DataTypeTok{DoorState}                    \CommentTok{-- the *type* DoorState}
        \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}           \CommentTok{-- the *kind* DoorState}
\NormalTok{    toSing }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
        \DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{SOpened}
        \DataTypeTok{Closed} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{SClosed}
        \DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{SLocked}
\end{Highlighting}
\end{Shaded}

If you are unfamiliar with how associated types work,
\texttt{type\ Demote\ DoorState\ =\ DoorState} means that wherever we see
\texttt{Demote\ DoorState} (with \texttt{DoorState} the \emph{kind}), we replace
it with \texttt{DoorState} (the \emph{type}). That's why the type of our
reflection function
\texttt{fromSing\ ::\ Sing\ s\ -\textgreater{}\ Demote\ DoorState} can be
simplified to \texttt{fromSing\ ::\ Sing\ s\ -\textgreater{}\ DoorState}.

Let's take a look at the instance for \texttt{Bool}, to compare:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- Bool singletons have two constructors:}
\DataTypeTok{SFalse}\OtherTok{ ::} \DataTypeTok{Sing} \CharTok{'False}
\DataTypeTok{STrue}\OtherTok{  ::} \DataTypeTok{Sing} \CharTok{'True}

\KeywordTok{instance} \DataTypeTok{SingKind} \DataTypeTok{Bool} \KeywordTok{where}    \CommentTok{-- the *kind* Bool}
    \KeywordTok{type} \DataTypeTok{Demote} \DataTypeTok{Bool} \FunctionTok{=} \DataTypeTok{Bool}     \CommentTok{-- the *type* Bool}

\NormalTok{    fromSing}
\OtherTok{        ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{b ::} \DataTypeTok{Bool}\NormalTok{)        }\CommentTok{-- the *kind* Bool}
        \OtherTok{->} \DataTypeTok{Bool}                    \CommentTok{-- the *type* Bool}
\NormalTok{    fromSing }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
        \DataTypeTok{SFalse} \OtherTok{->} \DataTypeTok{False}
        \DataTypeTok{STrue}  \OtherTok{->} \DataTypeTok{True}

\NormalTok{    toSing}
\OtherTok{        ::} \DataTypeTok{Bool}                    \CommentTok{-- the *type* Bool}
        \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{Bool}           \CommentTok{-- the *kind* Bool}
\NormalTok{    toSing }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
        \DataTypeTok{False} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{SFalse}
        \DataTypeTok{True}  \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{STrue}
\end{Highlighting}
\end{Shaded}

And a more sophisticated example, let's look at the instance for \texttt{Maybe}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- Maybe singletons have two constructors:}
\DataTypeTok{SNothing}\OtherTok{ ::} \DataTypeTok{Sing} \CharTok{'Nothing}
\DataTypeTok{SJust}\OtherTok{    ::} \DataTypeTok{Sing}\NormalTok{ x }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\CharTok{'Just x)}

\KeywordTok{instance} \DataTypeTok{SingKind}\NormalTok{ a }\OtherTok{=>} \DataTypeTok{SingKind}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a) }\KeywordTok{where}     \CommentTok{-- the *kind* Maybe}
    \KeywordTok{type} \DataTypeTok{Demote}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a) }\FunctionTok{=} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Demote}\NormalTok{ a)        }\CommentTok{-- the *type* Maybe}

\NormalTok{    fromSing}
\OtherTok{        ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{m ::} \DataTypeTok{Maybe}\NormalTok{ a)        }\CommentTok{-- the *kind* Maybe}
        \OtherTok{->} \DataTypeTok{Maybe}\NormalTok{ a                    }\CommentTok{-- the *type* Maybe}
\NormalTok{    fromSing }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
        \DataTypeTok{SNothing} \OtherTok{->} \DataTypeTok{Nothing}
        \DataTypeTok{SJust}\NormalTok{ sx }\OtherTok{->} \DataTypeTok{Just}\NormalTok{ (fromSing sx)}

\NormalTok{    toSing}
\OtherTok{        ::} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Demote}\NormalTok{ a)             }\CommentTok{-- the *type* Maybe}
        \OtherTok{->} \DataTypeTok{SomeSing}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a)           }\CommentTok{-- the *kind* Maybe}
\NormalTok{    toSing }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
        \DataTypeTok{Nothing} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{SNothing}
        \DataTypeTok{Just}\NormalTok{ x  }\OtherTok{->} \KeywordTok{case}\NormalTok{ toSing x }\KeywordTok{of}
          \DataTypeTok{SomeSing}\NormalTok{ sx }\OtherTok{->} \DataTypeTok{SomeSing}\NormalTok{ (}\DataTypeTok{SJust}\NormalTok{ sx)}
\end{Highlighting}
\end{Shaded}

This definition, I think, is a real testament to the usefulness of having all of
our singletons be unified under the same system. Because of how
\texttt{SingKind} works, \texttt{Demote\ (Maybe\ DoorState)} is evaluated to
\texttt{Maybe\ (Demote\ DoorState)}, which is simplified to
\texttt{Maybe\ DoorState}. This means that if we have a way to reify
\texttt{DoorState} values, we also have a way to reify \texttt{Maybe\ DoorState}
values! And, if we have a way to reflect \texttt{DoorState} singletons, we also
have a way to reflect \texttt{Maybe\ DoorState} singletons!

\subsubsection{SomeSing}\label{somesing}

Throughout all of this, we utilize \texttt{SomeSing} as a generic poly-kinded
existential wrapper:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{x ::}\NormalTok{ k) }\OtherTok{->} \DataTypeTok{SomeSing}\NormalTok{ k}
\end{Highlighting}
\end{Shaded}

Basically, this says that \texttt{SomeSing\ k} contains a \texttt{Sing\ x},
where \texttt{x} is of kind \texttt{k}. This is why we had, earlier:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{) }\OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\end{Highlighting}
\end{Shaded}

If we use \texttt{SomeSing} with, say, \texttt{SClosed}, we get
\texttt{SomeSing\ ::\ Sing\ \textquotesingle{}Closed\ -\textgreater{}\ SomeSing\ DoorState}
\texttt{SomeSing} is an indexed type that tells us the \emph{kind} of the type
variable we existentially quantifying over. The value \texttt{SomeSing\ STrue}
would have the type \texttt{SomeSing\ Bool}. The value
\texttt{SomeSing\ (SJust\ SClosed)} would have the type
\texttt{SomeSing\ (Maybe\ DoorState)}.

\end{document}
