\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Introduction to Singletons (Part 2)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Introduction to Singletons (Part 2)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-2.html}{in
Code}}.}

Welcome back to our journey through the singleton design pattern and the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library!

This post is a direct continuation of
\href{https://blog.jle.im/entry/introduction-to-singletons-1.html}{Part 1}, so
be sure to check that out first if you haven't already! If you hare just jumping
in now, I suggest taking some time to to through the exercises if you haven't
already!

Again, code is built on \emph{GHC 8.2.2} with the
\emph{\href{https://www.stackage.org/lts-10.0}{lts-10.0}} snapshot (so,
singletons-2.3.1).

\section{Review}\label{review}

Let's return to our \texttt{Door} type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L17-23}
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}

\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::}\NormalTok{ \{}\OtherTok{ doorMaterial ::} \DataTypeTok{String}\NormalTok{ \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

\texttt{Door} is great! It is an \emph{indexed data type}, in that picking a
different type variable gives a different ``type'' of Door:

\begin{itemize}
\tightlist
\item
  \texttt{Door\ \textquotesingle{}Opened} is a type that represents the type of
  an opened door
\item
  \texttt{Door\ \textquotesingle{}Closed} is a \emph{different} type that
  represents the type of a \emph{closed} door
\item
  \texttt{Door\ \textquotesingle{}Locked} is yet another (third) type that
  represents the type of a \emph{locked} door.
\end{itemize}

So, really, when we define \texttt{Door\ s}, we really are defining \emph{three
distinct} types (and also a not-so-obvious fourth one, which we will discuss
later).

This is great and all, but isn't Haskell a language with static, compile-time
types? Doesn't that mean that we have to know if our doors are opened, closed,
or locked at compile-time?

This is something we can foresee being a big issue. It's easy enough to create a
\texttt{Door\ s} if you know \texttt{s} at compile-time by just typing in a type
annotation (\texttt{UnsafeMkDoor\ "Oak"\ ::\ Door\ \textquotesingle{}Opened}).
But what if we \emph{don't} know \texttt{s} at compile-time?

To learn how to do this, we first need to learn how to \emph{not care}.

\section{Ditching the Phantom}\label{ditching-the-phantom}

Sometimes we don't \emph{actually} care about the state of the door in the
\emph{type} of the door. We don't want \texttt{Door\ \textquotesingle{}Opened}
and \texttt{Door\ \textquotesingle{}Closed}\ldots{}we want a type to just
represent a door, without the status in its type.

This might come about a bunch of different ways. Maybe you're reading a
\texttt{Door} data from a serialization format, and you want to be able to parse
\emph{any} door (whatever door is serialized).

More concretely, we've seen this in \texttt{lockAnyDoor}, as well --
\texttt{lockAnyDoor} doesn't care about the type of its input (it can be
\emph{any} \texttt{Door}). It only cares about the type of its output
(\texttt{Door\ \textquotesingle{}Locked})

To learn how to not care, we can describe a type for a door that does \emph{not}
have its status in its type.

We have a couple of options here. First, we can create a new type
\texttt{SomeDoor} that is the same as \texttt{Door}, except instead of keeping
its status in its type, it keeps it as a runtime value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=} \DataTypeTok{MkSomeDoor}
\NormalTok{    \{}\OtherTok{ someDoorState    ::} \DataTypeTok{DoorState}
\NormalTok{    ,}\OtherTok{ someDoorMaterial ::} \DataTypeTok{String}
\NormalTok{    \}}

\CommentTok{-- or, in GADT syntax}
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor} \OtherTok{::}
\NormalTok{      \{}\OtherTok{ someDoorState    ::} \DataTypeTok{DoorState}
\NormalTok{      ,}\OtherTok{ someDoorMaterial ::} \DataTypeTok{String}
\NormalTok{      \} }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Note the similarity of \texttt{SomeDoor}'s declaration to \texttt{Door}'s
declaration above. It's mostly the same, except, instead of \texttt{DoorState}
being a type parameter, it is instead a runtime value inside \texttt{SomeDoor}.

Now, this is actually a type that we \emph{could} have been using this entire
time, if we didn't care about type safety. In the real world and in real
applications, we actually might have written \texttt{SomeDoor} \emph{before} we
ever thought about \texttt{Door} with a phantom type. It's definitely the more
typical ``standard'' Haskell thing.

It's possible to ``construct'' this from our original typed \texttt{Door}, using
a smart constructor/conversion function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{fromDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor }\DataTypeTok{SOpened}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{Opened}\NormalTok{ m}
\NormalTok{formDoor }\DataTypeTok{SClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m}
\NormalTok{formDoor }\DataTypeTok{SLocked}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{MkSomeDoor} \DataTypeTok{Locked}\NormalTok{ m}

\OtherTok{fromDoor_ ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor_ }\FunctionTok{=}\NormalTok{ fromDoor sing}
\end{Highlighting}
\end{Shaded}

We can now write functions on this type:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeSomeOpenedDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Maybe} \DataTypeTok{SomeDoor}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Opened}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m)}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{Nothing}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Locked}\NormalTok{ m) }\FunctionTok{=} \DataTypeTok{Nothing}
\end{Highlighting}
\end{Shaded}

\subsection{SomeDoor to Door}\label{somedoor-to-door}

\texttt{SomeDoor} is great. But because it's a completely different type, we
potentially have to write the same function for both \texttt{Door} and
\texttt{SomeDoor}, because they have different implementations. Wouldn't it be
nice if we can \emph{re-use} our original \texttt{closeDoor}? This is a toy
example, and in real life, closing a door might have some complicated runtime
logic, and it'd be annoying to have to \emph{re-implement} it for both
\texttt{SomeDoor} and \texttt{Door}.

\subsubsection{Converting into an
existential}\label{converting-into-an-existential}

One thing we can do is write a function to convert a \texttt{SomeDoor} into a
\texttt{Door}, so we can re-use our original \texttt{closeDoor}. We'd convert
our \texttt{SomeDoor} into a \texttt{Door} to re-use our
\texttt{closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed}
on it if possible!

However, going from \texttt{SomeDoor} to \texttt{Door\ s} is slightly trickier
in Haskell than going the other way around. The main thing stopping us is that
normal Haskell type variables are universally qualified, meaning that the
\emph{caller} can pick how to instantiate \texttt{s} (and not the conversion
function). However, we want a function where the \emph{function} can pick the
\texttt{s}, and the caller must handle whatever \texttt{s} is given by the
function:

One trick we often use is a CPS-style existential type:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{withSomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\NormalTok{withSomeDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Opened}\NormalTok{ m) f }\FunctionTok{=}\NormalTok{ f }\DataTypeTok{SOpened}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\NormalTok{withSomeDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Closed}\NormalTok{ m) f }\FunctionTok{=}\NormalTok{ f }\DataTypeTok{SClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\NormalTok{withSomeDoor (}\DataTypeTok{MkSomeDoor} \DataTypeTok{Locked}\NormalTok{ m) f }\FunctionTok{=}\NormalTok{ f }\DataTypeTok{SLocked}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

Notice the funky CPS-like type signature of \texttt{withSomeDoor}. To use
\texttt{withSomeDoor} and access the \texttt{Door}, you have to pass in a
function to handle \emph{any possible \texttt{s}}. And, as you can see, the
function passed in might be given an \texttt{SOpened}, an \texttt{SClosed}, or
an \texttt{SLocked}. It has to be able to handle all three!

Here, we call \texttt{s} \emph{existentially quantified}. The
\texttt{withSomeDoor} function gets to pick which \texttt{s} to give \texttt{f}.
So, the \texttt{s} type variable is directly chosen by the \emph{function}, and
not by the caller.

We can implement \texttt{closeSomeOpenedDoor} (and even a
\texttt{lockAnySomeDoor}) using this conversion function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeSomeOpenedDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Maybe} \DataTypeTok{SomeDoor}
\NormalTok{closeSomeOpenedDoor sd }\FunctionTok{=}\NormalTok{ withSomeDoor sd }\FunctionTok{$}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->}\NormalTok{ \textbackslash{}d }\OtherTok{->} \DataTypeTok{Just} \FunctionTok{.}\NormalTok{ fromDoor_ }\FunctionTok{.}\NormalTok{ closeDoor }\FunctionTok{$}\NormalTok{ d}
    \DataTypeTok{SClosed} \OtherTok{->}\NormalTok{ \textbackslash{}_ }\OtherTok{->} \DataTypeTok{Nothing}
    \DataTypeTok{SLocked} \OtherTok{->}\NormalTok{ \textbackslash{}_ }\OtherTok{->} \DataTypeTok{Nothing}

\OtherTok{lockAnySomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{lockAnySomeDoor sd }\FunctionTok{=}\NormalTok{ withSomeDoor sd }\FunctionTok{$}\NormalTok{ \textbackslash{}s d }\OtherTok{->}
\NormalTok{    fromDoor_ }\FunctionTok{$}\NormalTok{ lockAnyDoor s d}
\end{Highlighting}
\end{Shaded}

Now, our goal is complete -- we can \emph{re-use} our previous
\texttt{closeDoor} and \texttt{lockAnyDoor}! We \emph{convert} our
\texttt{SomeDoor} into a \texttt{Door\ s} (with an existentially quantified
\texttt{s}), so we can use
\texttt{closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed}
and
\texttt{lockAnyDoor\ ::\ Door\ s\ -\textgreater{}\ Door\ \textquotesingle{}Locked}
on it. Then we ``convert it back'' using \texttt{fromDoor}.

\subsection{The Existential Datatype}\label{the-existential-datatype}

However, there's another path we can take. With the power of singletons, we can
actually implement \texttt{SomeDoor} \emph{in terms of} \texttt{Door}, using an
\textbf{existential data type}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- using existential constructor syntax}
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=}\NormalTok{ forall s}\FunctionTok{.} \DataTypeTok{MkSomeDoor}\NormalTok{ (}\DataTypeTok{Sing}\NormalTok{ s) (}\DataTypeTok{Door}\NormalTok{ s)}

\CommentTok{-- or, using GADT syntax (preferred)}
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L57-58}
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

\texttt{MkSomeDoor} is a constructor for an existential data type, meaning that
the data type ``hides'' a type variable \texttt{s}.

Note the similarities between our original \texttt{SomeDoor} and this one.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- | Re-implementing door}
\KeywordTok{data} \DataTypeTok{SomeDoor} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}

\CommentTok{-- | Re-using Door, as an existential type}
\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{DoorState} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}

\KeywordTok{data} \DataTypeTok{SomeDoor} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{  ::} \DataTypeTok{Sing}\NormalTok{ s  }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

Basically, our type before re-implements \texttt{Door}. But the new one actually
directly uses the original \texttt{Door\ s}. This means we can \emph{directly}
re-use our \texttt{Door} functions on \texttt{SomeDoor}s, without needing to
convert our implementations.

In Haskell, existential data types are pretty nice, syntactically, to work with.
For a comparison, let's re-implement our previous functions with our new data
type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L60-73}
\OtherTok{fromDoor ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor }\FunctionTok{=} \DataTypeTok{MkSomeDoor}

\OtherTok{fromDoor_ ::} \DataTypeTok{SingI}\NormalTok{ s }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{fromDoor_ }\FunctionTok{=} \DataTypeTok{MkSomeDoor}\NormalTok{ sing}

\OtherTok{closeSomeOpenedDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Maybe} \DataTypeTok{SomeDoor}
\NormalTok{closeSomeOpenedDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Just} \FunctionTok{.}\NormalTok{ fromDoor_ }\FunctionTok{$}\NormalTok{ closeDoor d}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Nothing}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Nothing}

\OtherTok{lockAnySomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{lockAnySomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=}\NormalTok{ fromDoor_ }\FunctionTok{$}\NormalTok{ lockAnyDoor s d}
\end{Highlighting}
\end{Shaded}

Much more convenient, because \emph{we already have a \texttt{Door}!} And we
don't have to re-implement one like we did for our original \texttt{SomeDoor} --
all of our original code works directly!

\subsection{The Link}\label{the-link}

It's important to remember that our original separate-implementation
\texttt{SomeDoor} is, functionally, identical to the new code-reusing
\texttt{Door}. The reason why they are the same is that \emph{having an
existentially quantified singleton is the same as having a value of the
corresponding type.} Having an existentially quantified \texttt{SingDS\ s} is
\emph{the same as} having a value of type \texttt{DoorState}.

In fact, the \emph{singletons} library gives us a direct existential wrapper:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- (not the actual definition)}
\KeywordTok{data} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{SomeSing}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\end{Highlighting}
\end{Shaded}

There are three values of type \texttt{SomeSing\ DoorState}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{SomeSing} \DataTypeTok{SOpened}\OtherTok{ ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\DataTypeTok{SomeSing} \DataTypeTok{SClosed}\OtherTok{ ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\DataTypeTok{SomeSing} \DataTypeTok{SLocked}\OtherTok{ ::} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\end{Highlighting}
\end{Shaded}

A value of type \texttt{SomeSing\ DoorState} (which contains an existentially
quantified \texttt{Sing\ s} -- a \texttt{SingDS}) is \emph{the same} as a value
of type \texttt{DoorState}. The two types are identical! (Or, well, isomorphic.
As a fun exercise, write out the explicit isomorphism -- the
\texttt{SomeSing\ DoorState\ -\textgreater{}\ DoorState} and the
\texttt{DoorState\ -\textgreater{}\ SomeSing\ DoorState}).

Our new \texttt{SomeDoor} containing an existentially quantified
\texttt{Sing\ s} is the same as our first \texttt{SomeDoor} containing just a
\texttt{DoorState}.

\subsubsection{Why Bother}\label{why-bother}

If they're identical, why use a \texttt{Sing} or the new \texttt{SomeDoor} at
all? Why not just use a \texttt{DoorState} value?

The main reason (besides allowing code-reuse) is that \emph{using the singleton
lets us directly recover the type}. Essentially, a \texttt{SingDS\ s} not only
contains whether it is Opened/Closed/Locked\ldots{}it contains it in a way that
GHC can use to \emph{bring it all back} to the type level.

A \texttt{forall\ s.\ SomeDoor\ (Sing\ s)\ (Door\ s)} essentially contains
\texttt{s} \emph{with} \texttt{Door\ s}. When you see this, you \emph{should
read this as} \texttt{forall\ s.\ SomeDoor\ s\ (Door\ s)} (and, indeed, this is
similar to how it is written in dependently typed languages.)

It's kind of like how, when you're used to reading Applicative style, when you
see \texttt{f\ \textless{}\$\textgreater{}\ x\ \textless{}*\textgreater{}\ y},
you should read \texttt{f\ x\ y}. When you see
\texttt{forall\ s.\ SomeDoor\ (Sing\ s)\ (Door\ s)}, you should read
\texttt{forall\ s.\ SomeDoor\ s\ (Door\ s)}. The role of \texttt{Sing\ s} there
is, like in Part 1, simply to be a run-time stand-in for the type \texttt{s}
itself.

So, for our original \texttt{Door\ s} functions, we need to know \texttt{s} at
runtime -- storing the \texttt{Sing\ s} gives GHC exactly that. Once you get the
\texttt{Sing\ s} back, you can now use it in all of our type-safe functions from
Part 1, and you're back in type-safe land.

\subsection{Some Lingo}\label{some-lingo}

In the language of dependently typed programming, we call \texttt{SomeDoor} a
\textbf{dependent sum}, because you can imagine it basically as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=} \DataTypeTok{SDOpened}\NormalTok{ (}\DataTypeTok{Door} \CharTok{'Opened)}
              \FunctionTok{|} \DataTypeTok{SDClosed}\NormalTok{ (}\DataTypeTok{Door} \CharTok{'Closed)}
              \FunctionTok{|} \DataTypeTok{SDLocked}\NormalTok{ (}\DataTypeTok{Door} \CharTok{'Locked)}
\end{Highlighting}
\end{Shaded}

A three-way sum between a \texttt{Door\ \textquotesingle{}Opened}, a
\texttt{Door\ \textquotesingle{}Closed}, and a
\texttt{Door\ \textquotesingle{}Locked}, essentially. If you have a
\texttt{SomeDoor}, it's \emph{either} an opened door, a closed door, or a locked
door. Try looking at this new \texttt{SomeDoor} until you realize that this type
is the same type as the previous \texttt{SomeDoor}!

You might also see \texttt{SomeDoor} called a \textbf{dependent pair} -- it's a
``tuple'' where the \emph{type} of the second item (our \texttt{Door\ s}) is
determined by the \emph{value} of the first item (our \texttt{Sing\ s}).

In Idris, we could write \texttt{SomeDoor} as a type alias, using its native
dependent sum syntax, as \texttt{s\ **\ Door\ s}. The \emph{value} of the first
item reveals to us (through a pattern match, in Haskell) the \emph{type} of the
second.

\subsection{Types at Runtime}\label{types-at-runtime}

With this last tool, we finally have enough to build a function to ``make'' a
door with the status unknown until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened} \FunctionTok{.}\NormalTok{ mkDoor }\DataTypeTok{SOpened}
    \DataTypeTok{Closed} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed} \FunctionTok{.}\NormalTok{ mkDoor }\DataTypeTok{SClosed}
    \DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked} \FunctionTok{.}\NormalTok{ mkDoor }\DataTypeTok{SLocked}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ mySomeDoor }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Opened} \StringTok{"Birch"}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{t mySomeDoor}
\DataTypeTok{SomeDoor}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ putStrLn }\FunctionTok{$} \KeywordTok{case}\NormalTok{ mySomeDoor }\KeywordTok{of}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was opened!"}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was closed!"}
        \DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ _ }\OtherTok{->} \StringTok{"mySomeDoor was locked!"}
\NormalTok{mySomeDoor was opened}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

Using \texttt{mkSomeDoor}, we can truly pass in a \texttt{DoorState} that we
generate at runtime (from IO, or a user prompt, or a configuration file, maybe),
and create a \texttt{Door} based on it.

Take \emph{that}, type erasure! :D

We could even directly return a \texttt{Door} with an existentially quantified
door status in CPS style:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{withDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\NormalTok{withDoor s m f }\FunctionTok{=} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
    \DataTypeTok{Opened} \OtherTok{->}\NormalTok{ f }\DataTypeTok{SOpened}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
    \DataTypeTok{Closed} \OtherTok{->}\NormalTok{ f }\DataTypeTok{SClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
    \DataTypeTok{Locked} \OtherTok{->}\NormalTok{ f }\DataTypeTok{SLocked}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ withDoor }\DataTypeTok{Opened} \StringTok{"Birch"} \FunctionTok{$}\NormalTok{ \textbackslash{}s d }\OtherTok{->} \KeywordTok{case}\NormalTok{ s }\KeywordTok{of}
         \DataTypeTok{SOpened} \OtherTok{->} \StringTok{"Opened door!"}
         \DataTypeTok{SClosed} \OtherTok{->} \StringTok{"Closed door!"}
         \DataTypeTok{SLocked} \OtherTok{->} \StringTok{"Locked door!"}
\DataTypeTok{Opened}\NormalTok{ door}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

This allows us to \emph{directly} generate a \texttt{Door\ s} with an \texttt{s}
that can vary at runtime.

\subsection{Reification}\label{reification}

The general pattern we are exploiting here is called \textbf{reification} --
we're taking a dynamic run-time value, and lifting it to the type level as a
type (here, the type variable \texttt{s}). You can think of reification as the
opposite of \emph{reflection}, and imagine the two as being the ``gateway''
between the type-safe and unsafe world. In the dynamic world of a
\texttt{DoorState} value, you have no type safety. You live in the world of
\texttt{SomeDoor}, \texttt{closeSomeOpenedDoor}, \texttt{lockAnySomeDoor}, etc.
But, you can \emph{reify} your \texttt{DoorState} value to a \emph{type}, and
enter the type-safe world of \texttt{Door\ s}, \texttt{closeDoor},
\texttt{lockDoor}, and \texttt{lockAnyDoor}.

The \emph{singletons} library automatically generates functions to directly
reify \texttt{DoorState} values:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{toSing       ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{SomeSing} \DataTypeTok{DoorState}
\OtherTok{withSomeSing ::} \DataTypeTok{DoorState} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\end{Highlighting}
\end{Shaded}

The first one reifies a \texttt{DoorState} as an existentially quantified data
type, and the second one reifies in CPS-style, without the intermediate data
type.

We can use these to write \texttt{mkSomeDoor} and \texttt{withDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L75-80}
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor ds }\FunctionTok{=} \KeywordTok{case}\NormalTok{ toSing ds }\KeywordTok{of}
    \DataTypeTok{SomeSing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{MkSomeDoor}\NormalTok{ s }\FunctionTok{.}\NormalTok{ mkDoor s}

\OtherTok{withDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->}\NormalTok{ (forall s}\FunctionTok{.} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->}\NormalTok{ r) }\OtherTok{->}\NormalTok{ r}
\NormalTok{withDoor ds m f }\FunctionTok{=}\NormalTok{ withSomeSing ds }\FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->}\NormalTok{ f s (}\DataTypeTok{UnsafeMkDoor}\NormalTok{ m)}
\end{Highlighting}
\end{Shaded}

\subsection{A Reflection on Subtyping}\label{a-reflection-on-subtyping}

Without phantom types you might have imagined being able to do something like
this:

\begin{verbatim}
data DoorOpened = MkDoorOpened { doorMaterial :: String }
data DoorClosed = MkDoorClosed { doorMaterial :: String }
data DoorLocked = MkDoorLocked { doorMaterial :: String }
\end{verbatim}

Which is even possible now with \texttt{-XDuplicateRecordFields}. And, for the
most part, you get a similar API:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{closeDoor ::} \DataTypeTok{DoorOpened} \OtherTok{->} \DataTypeTok{DoorClosed}
\OtherTok{lockDoor  ::} \DataTypeTok{DoorClosed} \OtherTok{->} \DataTypeTok{DoorLocked}
\end{Highlighting}
\end{Shaded}

But what about writing things that take on ``all'' door types?

The only real way (besides typeclass magic) would be to make some sum type like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor} \FunctionTok{=} \DataTypeTok{DO} \DataTypeTok{DoorOpened} \FunctionTok{|} \DataTypeTok{DC} \DataTypeTok{DoorClosed} \FunctionTok{|} \DataTypeTok{DL} \DataTypeTok{DoorLocked}

\OtherTok{lockAnyDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{DoorLocked}
\end{Highlighting}
\end{Shaded}

However, we see that if we parameterize a single \texttt{Door} type, we can have
it stand in \emph{both} for a ``known status'' \texttt{Door} \emph{and} for a
``polymorphic status'' \texttt{Door}.

This actually leverages Haskell's \emph{subtyping} system. We say that
\texttt{forall\ s.\ Door\ s} (a \texttt{Door} that is polymorphic on all
\texttt{s}) is a \emph{subtype} of \texttt{Door\ \textquotesingle{}Opened}. This
means that a \texttt{forall\ s.\ Door\ s} can be used anywhere a function would
expect a \texttt{Door\ \textquotesingle{}Opened}\ldots{}but not the other way
around.

\end{document}
