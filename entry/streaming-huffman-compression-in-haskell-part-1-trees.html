<!DOCTYPE HTML>
<html><head><title>Streaming Huffman Compression in Haskell (Part 1: Trees and State) Â· in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="So you&#39;re learning Haskell and are looking for some projects that aren&#39;t super trivial, are familiar enough that you can use what you already know, and are difficult enough to maybe help you learn new things. Hey, maybe this is for you :) Let&#39;s take a go at Huffman encoding in Haskell. We will look at two types of binary trees, which we use to implement immutable/persistent priority queues and prefix trees. We&#39;ll play around with the State monad a bit, explore some useful typeclasses, learn how to serialize, marshal, and unmarshal data structures using the binary library, and also look at how to load data from a file and write to another in a pure way, avoiding lazy IO using the ever-more-popular pipes library. And hopefully we learn some neat Haskell idioms! We&#39;re going to be assuming some basic Haskell knowledge, like algebraic data types, higher order functions, basic monad usage, and some basic familiarity with the functions in Prelude/base, the standard library. If you have any questions, feel free to leave a comment, drop by on #haskell on freenode, throw me a tweet, or give the great Learn You A Haskell a quick read!"><meta property="og:type" content="article"><meta property="og:title" content="Streaming Huffman Compression in Haskell (Part 1: Trees and State)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-1-trees.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-1-trees.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Streaming Huffman Compression in Haskell (Part 1: Trees and State)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2014-03-31T10:13:44Z" pubdate="" class="pubdate">Monday March 31, 2014</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/huffman-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/streaming-huffman-compression-in-haskell-part-1-trees.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-1-trees.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>So you're learning Haskell and are looking for some projects that aren't super trivial, are familiar enough that you can use what you already know, and are difficult enough to maybe help you learn new things. Hey, maybe this is for you :)</p>
<p>Let's take a go at <a href="http://en.wikipedia.org/wiki/Huffman_coding">Huffman encoding</a> in Haskell. We will look at two types of binary trees, which we use to implement immutable/persistent priority queues and prefix trees. We'll play around with the State monad a bit, explore some useful typeclasses, learn how to serialize, marshal, and unmarshal data structures using the <a href="http://hackage.haskell.org/package/binary">binary</a> library, and also look at how to load data from a file and write to another in a pure way, avoiding lazy IO using the ever-more-popular <em><a href="http://hackage.haskell.org/package/pipes">pipes</a></em> library. And hopefully we learn some neat Haskell idioms!</p>
<p>We're going to be assuming some basic Haskell knowledge, like algebraic data types, higher order functions, basic monad usage, and some basic familiarity with the functions in Prelude/base, the standard library. If you have any questions, feel free to leave a comment, drop by on #haskell on freenode, throw me a <a href="https://twitter.com/mstk">tweet</a>, or give the great <a href="http://learnyouahaskell.com">Learn You A Haskell</a> a quick read!</p>
<h2>Prefix trees &amp; Huffman coding</h2>
<p>You might have encountered this in the past, but Huffman encoding solves the problem of finding the optimal binary prefix code to encode a string.</p>
<p>I'll leave you to read <a href="http://en.wikipedia.org/wiki/Huffman_coding">the wikipedia article</a>, which explains it much better than I could. Basically, binary prefix codes are nice because you don't have to encode any &quot;stop&quot; symbol --- as soon as you reach a leaf of the tree, you know that you have found a letter, and can move on.</p>
<p>Huffman trees are built from the bottom-up using priority queues. The two lowest-frequency nodes are continually &quot;popped&quot; from the queue, combined into a new node, and placed back in the queue.</p>
<p>Our first challenge --- representing a Huffman tree as a data structure!</p>
<h3>The Tree</h3>
<p>(All the code in this section on is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs">available for download</a> for you to try it out yourself!)</p>
<p>So some properties about prefix trees that might be useful to us --- all data is stored in the leaves, and all internal nodes have exactly two children. This sounds like the perfect candidate for an Algebraic Data Structure.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs#L19-21 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding data PreTree a = PTLeaf a | PTNode (PreTree a) (PreTree a) deriving (Show, Eq, Generic) ~~~</p>
<p>We leave the type parameterized on <code>a</code> (which is like a template/generic in C++/Java) so we can decide what to put into it later.</p>
<h4><code>PreTree</code> operations</h4>
<p>So, what sort of things are we going to want to do with our <code>PreTree</code>?</p>
<p>Well..first of all, we might want a way to put something into an empty tree --- create a leaf containing just that data.</p>
<p>That function is sort of embarrassingly easy:</p>
<p>~~~haskell makePT' :: a -&gt; PreTree a makePT' x = PTLeaf x ~~~</p>
<p>Remember, that's <code>PTLeaf</code> is a data constructor that &quot;creates&quot; a <code>PreTree</code> when you use <code>PTLeaf x</code>.</p>
<p>However, something like this is just begging to be eta-reduced, and we can simplify it as:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs#L46-47 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding makePT :: a -&gt; PreTree a makePT = PTLeaf ~~~</p>
<p>Which does the same thing. Basically, <code>PTLeaf</code> is already a function <code>a -&gt; PreTree a</code>...so <code>makePT</code> is literally just <code>PTLeaf</code>.</p>
<p>~~~haskell ghci&gt; let pt = makePT 'c' ghci&gt; :t pt PreTree Char ghci&gt; pt PTLeaf 'c' ~~~</p>
<p>Now, we might also want a way to &quot;merge&quot; two <code>PreTree a</code>'s. This is at the heart of building the tree in the first place...successively merge two trees until everything is in one giant tree.</p>
<p>This isn't too bad either:</p>
<p>~~~haskell mergePT' :: PreTree a -&gt; PreTree a -&gt; PreTree a mergePT' t1 t2 = PTNode t1 t2 ~~~</p>
<p>Which, from what we saw before, can just be written as:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs#L50-51 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding mergePT :: PreTree a -&gt; PreTree a -&gt; PreTree a mergePT = PTNode ~~~</p>
<p>~~~haskell ghci&gt; let pt1 = makePT 'c' ghci&gt; let pt2 = makePT 't' ghci&gt; let pt3 = pt1 <code>mergePT</code> pt2 ghci&gt; :t pt3 PreTree Char ghci&gt; pt3 PTNode (PTLeaf 'c') (PTLeaf 't') ~~~</p>
<p>Hm. Maybe that's a bit too easy. Feels a little unsettling, isn't it?</p>
<p>Welcome to Haskell!</p>
<h3>Weighting things</h3>
<p>We're going to need some way of comparing the weights/priorities of two <code>PreTree</code>s when we are assembling the tree. Let's introduce a data type that includes both a <code>PreTree</code> and an (integer) weight.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Weighted.hs#L13-15 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding data Weighted a = WPair { <em>wWeight :: Int , </em>wItem :: a } deriving (Show, Functor) ~~~</p>
<p>(Code for the Weighted module is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Weighted.hs">available for download</a>)</p>
<p>We will say that a <code>Weighted a</code> is some <code>a</code> associated with an integer weight.</p>
<p>We can create, say, a <code>PreTree</code> containing the character 'a', weighted with integer 1:</p>
<p>~~~haskell ghci&gt; WPair 1 (makePTLeaf 'a') WPair 1 (makePTLeaf 'a') :: Weighted (PreTree Char) ~~~</p>
<p>This weighted <code>PreTree</code> is pretty useful, let's give it an alias/typedef:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs#L54-54 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding type WeightedPT a = Weighted (PreTree a) ~~~</p>
<p>Let's make the same functions for <code>WeightedPT</code> as we did for <code>PreTree</code>:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs#L58-59 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding makeWPT :: Int -&gt; a -&gt; WeightedPT a makeWPT w = WPair w . makePT ~~~</p>
<p>The above basically says &quot;to make a <code>WeightedPT</code> with weight <code>w</code>, first <code>makePT</code> it, and then add that result it to a <code>WPair w</code>.</p>
<p>~~~haskell ghci&gt; let pt = makeWPT 1 'w' ghci&gt; :t pt WeightedPT Char ghci&gt; pt WPair 1 (PTLeaf 'w') ~~~</p>
<p>We will also want to merge two <code>WeightedPT</code>s:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PreTree.hs#L62-64 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding mergeWPT :: WeightedPT a -&gt; WeightedPT a -&gt; WeightedPT a mergeWPT (WPair w1 pt1) (WPair w2 pt2) = WPair (w1 + w2) (mergePT pt1 pt2) ~~~</p>
<p>so that the total weight is the sum of the weights of the two subtrees.</p>
<p>Finally, the entire point of having weighted things is so that we can compare them and impose some total ordering. Haskell has a typeclass that abstracts these comparing operations, <code>Ord</code>:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Weighted.hs#L17-21 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding instance Eq (Weighted a) where WPair w1 _ == WPair w2 _ = w1 == w2</p>
<p>instance Ord (Weighted a) where compare (WPair w1 <em>) (WPair w2 </em>) = compare w1 w2 ~~~</p>
<p>Which says that <code>Weighted a</code> is an <code>Ord</code> (is orderable/comparable), and to compare two <code>WPair w x</code>'s, you compare the <code>w</code>'s.</p>
<p>~~~haskell ghci&gt; makeWPT 2 'a' &gt; makeWPT 3 'b' False ghci&gt; makeWPT 4 't' == makeWPT 4 'k' True ~~~</p>
<h2>Priority Queues</h2>
<p>There are some great priority queue libraries on Hackage, like <a href="http://hackage.haskell.org/package/PSQueue">PSQueue</a>. However, for fun, we're going to be making our own! Yay!</p>
<p>Our Priority Queue code module is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PQueue.hs">available for download</a> to try out!</p>
<h3>Skew heaps</h3>
<p>A traditional approach to making efficient priority queues is to use a <a href="http://en.wikipedia.org/wiki/Heap_(data_structure)">heap</a>, a tree with insertion algorithms that make sure the root of the tree is the most prioritized element and that the tree stays balanced. Heaps make heavy use of stateful mutation to do this, and while it's not so hard to do this in Haskell, we might consider a 'pure' version of a heap: a <a href="http://en.wikipedia.org/wiki/Skew_heap">skew heap</a>.</p>
<p>A skew heap is a heap that doesn't explicitly maintain its balance, but maintains &quot;heap ordering&quot; (parents are always higher priority than their children).</p>
<p>I'll leave it to the wikipedia article to do most of the explaining because they have pretty pictures, but here is the gist of it --- skew heaps have only three operations: making new (singleton) one, merging two skew heaps, and popping off the root. Traditional &quot;insert&quot; is done by making a new skew heap with one element, and merging it with the main heap.</p>
<p>Merging is simple enough: The higher-priority root becomes the new root, and the lower-priority root is merged with the child tree of that new root. (Some left-right flipping of branches is done to make sure things tend to stay balanced. Pictures provided in the wikipedia article.)</p>
<p>Popping the root is simple too; just take the root, and merge its two sub-trees to make the new tree.</p>
<p>This is a new type of binary tree, so let's define a new data type:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PQueue.hs#L20-22 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding data SkewHeap a = SEmpty | SNode a (SkewHeap a) (SkewHeap a) deriving (Show, Eq, Foldable) ~~~</p>
<p>Creating a new <code>SkewHeap</code> with one item:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PQueue.hs#L25-26 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding makeSH :: a -&gt; SkewHeap a makeSH x = SNode x SEmpty SEmpty ~~~</p>
<p>Popping the root off of a skew tree:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PQueue.hs#L31-33 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding popSH :: Ord a =&gt; SkewHeap a -&gt; (Maybe a, SkewHeap a) popSH SEmpty = (Nothing, SEmpty) popSH (SNode r h1 h2) = (Just r , mergeSH h1 h2) ~~~</p>
<p>We make it return a potential result (<code>Maybe a</code>), and the resulting new popped tree. The result is <code>Maybe a</code> because we might potentially not be able to pop anything! We also require an <code>Ord</code> constraint because in order to merge two skew heaps, the data must be comparable.</p>
<p>Finally, the hardest piece of code so far: merging two skew heaps:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PQueue.hs#L37-42 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding mergeSH :: Ord a =&gt; SkewHeap a -&gt; SkewHeap a -&gt; SkewHeap a mergeSH SEmpty h = h mergeSH h SEmpty = h mergeSH hA@(SNode xA lA rA) hB@(SNode xB lB rB) | xA &lt; xB = SNode xA (mergeSH rA hB) lA | otherwise = SNode xB (mergeSH rB hA) lB ~~~</p>
<p>Hopefully this is very pleasing to read --- it reads a lot like a specification, or a math formula:</p>
<ol>
<li>Merging any skew heap with an empty heap is that same skew heap.</li>
<li>When merging two heaps, the new heap is an <code>SNode</code> with the smaller root, whose children are the merge of the smaller tree and the original children. (Admittedly, the math/code is a bit more expressive than English in this case)</li>
</ol>
<p>(Remember that in our case, the <em>lower</em> value/weight is the <em>higher</em> priority.)</p>
<p>We require an <code>Ord</code> constraint because we compare the node element on the third case.</p>
<h3>Priority Queue interface</h3>
<p>Ok, neat!</p>
<p>Let's wrap this up in a tidy interface/API for a <code>PQueue</code> type:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/PQueue.hs#L48-71 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding newtype PQueue a = PQ (SkewHeap a) deriving Show</p>
<p>emptyPQ :: PQueue a emptyPQ = PQ SEmpty</p>
<p>insertPQ :: Ord a =&gt; a -&gt; PQueue a -&gt; PQueue a insertPQ x (PQ h) = PQ (mergeSH h (makeSH x))</p>
<p>popPQ :: Ord a =&gt; PQueue a -&gt; (Maybe a, PQueue a) popPQ (PQ h) = (res, PQ h') where (res, h') = popSH h</p>
<p>sizePQ :: PQueue a -&gt; Int sizePQ (PQ h) = length (toList h) ~~~</p>
<p>(Notice <code>toList</code>, from the [Foldable] module; we derived <code>Foldable</code> so that we can use <code>toList</code> on our <code>SkewHeap</code>s. If your Haskell implementation cannot derive foldable (if you are not using GHC, for example) --- and even if your implementation can --- it might be fun to think about how to implement <code>sizePQ</code> without it!)</p>
<p>We do this so that we hide our low-level skew heap implementation over a &quot;high-level&quot; priority queue interface. We do not export the <code>PQ</code> constructor, so users cannot ever directly access the underlying skew heap. In this case, the high level isn't much higher of a level, but it's good practice to hide away the implementation details when you can in Haskell, a language whose power lies so much in abstraction.</p>
<h2>Building our Huffman encoding tree</h2>
<p>Now that we have what we need in place, let's get to doing building our tree. (Again, all available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs">for download</a>.)</p>
<h3>Frequency Tables</h3>
<p>First, we need to have some sort of frequency table. We will use <code>Data.Map.Strict</code>'s <code>Map</code> type:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs#L19-19 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding type FreqTable a = Map a Int ~~~</p>
<p>and we'll import the operations from <code>Data.Map.Strict</code> qualified:</p>
<p>~~~haskell import qualified Data.Map.Strict as M ~~~</p>
<p>Just to work with things now, let's make a way to generate a <code>FreqTable</code> from an arbitrary string:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs#L22-25 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding listFreq :: Ord a =&gt; [a] -&gt; FreqTable a listFreq = foldr f M.empty where f x m = M.insertWith (+) x 1 m ~~~</p>
<p>This says that <code>listFreq</code> is a fold, where you start with <code>M.empty</code> (an empty <code>FreqTable</code>) and for every element, you insert it into the map as a key with value 1. If the key already exists, add one to its current value instead.</p>
<p>~~~haskell ghci&gt; listFreq &quot;hello world&quot; fromList [(' ',1),('d',1),('e',1),('h',1),('l',3),('o',2),('r',1),('w',1)] ~~~</p>
<h3>Building the queue</h3>
<p>Next, we would like to create Huffman leaves out of all of these elements, with associated weights, and insert them all into a <code>PQueue</code>. We can do this by using <code>M.foldrWithKey</code>, which is a <code>foldr</code> over the map, giving the folding function both the key and the value.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs#L43-46 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding listQueue :: Ord a =&gt; [a] -&gt; PQueue (Weighted a) listQueue = M.foldrWithKey f emptyPQ . listFreq where f k v pq = insertPQ (WPair v k) pq ~~~</p>
<p>~~~haskell ghci&gt; let pq = listQueue &quot;hello world&quot; ghci&gt; :t pq pq :: PQueue (WPair Int (PreTree Char)) ghci&gt; sizePQ pq 8 ghci&gt; let (popped1, pq') = popPQ pq ghci&gt; popped1 Just (WPair 1 ' ') ghci&gt; let (popped2, pq'') = popPQ pq' ghci&gt; popped2 Just (WPair 1 'd') ghci&gt; sizePQ pq'' 6 ~~~</p>
<h3>Building the tree</h3>
<p>Building the tree is going to be a bit harder than a simple fold over the queue, because we have to &quot;branch&quot; based on the state of the queue. Depending on the state of the queue, we make decisions on &quot;control flow&quot;.</p>
<p>The experienced Haskelleur will recognize that this language is very evocative of the Monad design pattern.</p>
<h4>The State monad</h4>
<p>In particular, we will be using the State monad, which is basically a plain ol' newtype wrapper around functions <code>s -&gt; (a, s)</code>. Basically, functions that act on a state and return a value with a modified state.</p>
<p>These functions are actually surprisingly useful, and as it turns out, all stateful computations can be described as &quot;compositions&quot; of these functions.</p>
<p>What do I mean by &quot;compositions&quot;?</p>
<p>Let's say I have two functions:</p>
<p>~~~haskell f1 :: s -&gt; (a, s) f2 :: s -&gt; (b, s) ~~~</p>
<p>And I wanted to sequence them:</p>
<p>~~~haskell f1 <code>andThen</code> f2 ~~~</p>
<p>What would that even &quot;look like&quot;?</p>
<p>Well, I expect that sequencing two state functions will return a new, &quot;giant&quot; state function that does both functions &quot;one after the other&quot;. That is:</p>
<p>~~~haskell f1 <code>andThen</code> f2 :: s -&gt; (b, s) ~~~</p>
<p>This new function will first run the input state on <code>f1</code>, and take that resulting state and pass it into <code>f2</code>, and then return the result of <code>f2</code> and the resulting modified state of <code>f2</code>.</p>
<p>So we have something like</p>
<p>~~~haskell andThen :: (s -&gt; (a,s)) -&gt; (s -&gt; (b,s)) -&gt; (s -&gt; (b,s)) andThen f1 f2 = \st -&gt; let (_,st') = f1 s in f2 st' ~~~</p>
<p>Think of <code>andThen</code> like a semicolon, of sorts.</p>
<p>Notice that we &quot;lose&quot; the result of <code>f1</code> with <code>andThen</code>. What if we wanted to use it? We might write a combinator:</p>
<p>~~~ andThenWith :: (s -&gt; (a, s)) -&gt; (a -&gt; (s -&gt; (b, s))) -&gt; (s -&gt; (b, s)) ~~~</p>
<p>Which you would use like</p>
<p>~~~haskell f1 <code>andThenWith</code> (\x -&gt; f2 x) ~~~</p>
<p>where <code>f2</code> is a function that takes an <code>a</code> and returns a <code>s -&gt; (a,s)</code>.</p>
<p>Basically, it would be exactly the same as <code>andThen</code>, except the second argument gets access to the result of the first. Writing it is almost as simple, actually ---</p>
<p>~~~haskell andThenWith :: (s -&gt; (a,s)) -&gt; (a -&gt; (s -&gt; (b, s))) -&gt; (s -&gt; (b, s)) andThenWith f1 f2 = \st -&gt; let (x,st') = f1 s in (f2 x) st' ~~~</p>
<p>As it turns out...if you squint hard enough, the type signature <code>andThenWith</code> looks a lot like the type signature for <code>(&gt;&gt;=)</code>:</p>
<p>~~~haskell (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b ~~~</p>
<p>Hm. Let's create a type synonym for our <code>s -&gt; (a, s)</code>, to make things more clear.</p>
<p>~~~haskell type State s a = s -&gt; (a, s) ~~~</p>
<p>So now our <code>andThenWith</code> looks like:</p>
<p>~~~haskell andThenWith :: State s a -&gt; (a -&gt; State s b) -&gt; State s b ~~~</p>
<p>If we let <code>m ~ State s</code>:</p>
<p>~~~haskell andThenWith :: m a -&gt; (a -&gt; m b) -&gt; m b ~~~</p>
<p>Neat!</p>
<p>As it turns out, we can turn our state functions into a Monad, which encapsulates &quot;sequencing&quot; state functions one after another.</p>
<p>We just need <code>return</code>:</p>
<p>~~~haskell returnState :: a -&gt; State s a returnState x = \st -&gt; (x, st) ~~~</p>
<p>And <code>return</code> is <code>returnState</code>, <code>(&gt;&gt;)</code> is <code>andThen</code>, and <code>(&gt;&gt;=)</code> is <code>andThenWith</code>.</p>
<p>In real life, we can't define typeclass instances on type synonyms, so we actually use a <code>newtype</code>. The standard implementation comes from the <a href="http://hackage.haskell.org/package/transformers">transformers</a> library. Because <code>State s</code> is a member of the <code>Monad</code> typeclass, we can use normal monad combinators, operators, and do notation. The transformers implementation comes with a few useful primitives:</p>
<p>~~~haskell -- wrap a normal state function into the State wrapper state :: (s -&gt; (a, s)) -&gt; State s a</p>
<p>-- get grabs the state as the result. get :: State s s get = state (\st -&gt; (st, st))</p>
<p>-- put sets the state to the input put :: s -&gt; State s () put s = state (_ -&gt; ((), st))</p>
<p>-- modifies the state with the given function modify :: (s -&gt; s) -&gt; State s () modify f = state (\st -&gt; ((), f st))</p>
<p>-- alternative implementation of <code>modify</code> modify' f :: (s -&gt; s) -&gt; State s () modify' f = do st &lt;- get put (f st) ~~~</p>
<p>If you're still lost, check out Brandon Simmon's <a href="http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/">state monad tutorial</a>, which was the article that eventually cleared it all up for myself. And feel free to ask questions!</p>
<p>The <em>big</em> usefulness for this &quot;composing stateful functions&quot; business, instead of manually unwrapping and re-wrapping the state, is that now <code>State</code> actions are first-class, and you can freely compose them and pass them around as objects, and you can write individual &quot;sub-routines&quot;, are little packets of commands that modify state, and then &quot;call them&quot; and compose them from other stateful computations.</p>
<h4>Why monads?</h4>
<p>One might pause to wonder why we would want to instance our <code>s -&gt; (a, s)</code> functions as a Monad. Why can't we just always sequence our state functions using <code>andThen</code> and <code>andThenWith</code>?</p>
<ol>
<li><p>Using monads, we can now use <code>do</code> notation, which is pretty nice sugar.</p></li>
<li><p>We now have access to the wide library of useful Haskell <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html">monad combinators</a>. And boy are there a lot --- <code>sequence</code>, <code>mapM</code>, <code>when</code>, <code>filterM</code>, etc.</p></li>
<li><p>We also get an Applicative instance for free, so we can do arbitrary-arity lifting with things like <code>f &lt;$&gt; x &lt;*&gt; y</code>, where <code>f</code> is a pure function like <code>(+)</code> and <code>x</code> and <code>y</code> are stateful functions. We also get a free Functor instance as well, so we can <code>fmap</code>.</p></li>
<li><p>We can now reason with our stateful functions with all of the powerful equational reasoning tools that the monad laws offer.</p></li>
</ol>
<p>As you can see, monads are not just a curiosity --- they are a powerful and expressive tool!</p>
<h4>A quick look back</h4>
<p>This is a bit of an unrelated aside...but notice that we could have actually done our previous <code>fold</code>s as state monad operations; like <code>listFreq</code>:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs#L29-36 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding runListFreq :: forall a. Ord a =&gt; [a] -&gt; FreqTable a runListFreq xs = execState listFreqState M.empty where listFreqState :: State (FreqTable a) () listFreqState = mapM_ addFreq xs</p>
<pre><code>addFreq :: a -&gt; State (FreqTable a) ()
addFreq x = modify (M.insertWith (+) x 1)</code></pre>
<p>~~~</p>
<p><code>execState</code> runs the given <code>State</code> computation with the given initial state, and returns the final state <code>s</code> at the end of it all. Basically, it takes an <code>s -&gt; (a, s)</code> (the <code>State s a</code>), an <code>s</code>, applies the function to it, and returns just the <code>s</code> in the tuple.</p>
<p>Remember that the best way to read <code>State s a</code> is just &quot;a type synonym for <code>s -&gt; (a,s)</code>&quot;. So when we say <code>listFreqState :: State (FreqTable a) ()</code>, we mean that <code>listFreqState</code> is a function from a <code>FreqTable a</code> to <code>((), FreqTable a)</code>.</p>
<p>How about <code>listQueue</code>? We could do it with the state monad too, if we wanted to.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs#L50-59 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding listQueueState :: Ord a =&gt; [a] -&gt; State (PQueue (WeightedPT a)) () listQueueState xs = M.traverseWithKey addNode (listFreq xs) &gt;&gt; return () where addNode :: a -&gt; Int -&gt; State (PQueue (WeightedPT a)) () addNode x i = modify (insertPQ (WPair i (makePT x)))</p>
<p>runListQueue :: Ord a =&gt; [a] -&gt; PQueue (WeightedPT a) runListQueue xs = execState (listQueueState xs) emptyPQ ~~~</p>
<p>In these cases, the monadic usage isn't quite necessary or useful on its own. A fold would have probably been more expressive and easier to read. The above examples were just for demonstrations/exercises.</p>
<p>But when do we &quot;need&quot; the state monad? (Or rather, when is a fold not powerful enough or much messier?)</p>
<p>It's when we want to make decisions or &quot;branch&quot; based on the current state, or the results of our state actions. &quot;Fold for three items; if the next list item is even then do this fold afterwards, otherwise do that fold&quot;. This is when the state monad shines as a monad.</p>
<p>Another case where we might want to use a state monad over a fold is if we forsee us wanting to &quot;compose&quot; our folds into bigger stateful computations. For example, in <code>listQueueState</code>, we &quot;process&quot; a state, and leave it modified for <em>another state monad action</em> to use.</p>
<p>For example:</p>
<p>~~~haskell prepareQueue :: State (PQueue (WeightedPT a)) () useQueue :: State (PQueue (WeightedPT a)) a</p>
<p>doAllTogether :: Ord a =&gt; [a] -&gt; State (PQueue (WeightedPT a)) a doAllTogether xs = prepareQueue &gt;&gt; listQueueState xs &gt;&gt; useQueue</p>
<p>-- alternatively, the same thing but in do notation doAllTogether' :: Ord a =&gt; [a] -&gt; State (PQueue (WeightedPT a)) a doAllTogether' xs = do prepareQueue listQueueState xs useQueue</p>
<p>runDoAllTogether :: Ord a =&gt; [a] -&gt; a runDoAllTogether xs = evalState (doAllTogether xs) emptyPQ ~~~</p>
<p>(Remember that <code>(&gt;&gt;)</code> is just our <code>andThen</code>, and when we sequence using <code>(&gt;&gt;)</code> we mean &quot;combine these two actions into one big action that feeds the resulting state of the left side into the beginning state of the right side.&quot;)</p>
<p>Anyways, see that we can just plop a call to <code>listQueueState</code> inside a sequence of stateful actions, and it'll just process the queue and leave it for the next action to use.</p>
<p>If we had used <code>listQueue</code> as a &quot;pure&quot; fold...this is a bit harder to do. You'd have to rewrite <code>listQueue</code> to take in any arbitrary &quot;starting queue&quot;...extract the starting queue using <code>get</code> after <code>prepareQueue</code>, use a <code>let</code> to bind it as a pure function, then use <code>put</code> to pop the result back into the state for <code>useQueue</code> to use. Or use <code>modify</code> in a just-as-convoluted way.</p>
<p>Moving on, we actually won't be using <code>runListFreq</code> in the future (it was mostly for fun), but (spoilers) we might want to hold onto <code>listQueueState</code> :)</p>
<h3>Building with State</h3>
<p>So let's remember how the building process works:</p>
<ol>
<li>Pop an item from the queue.</li>
<li>Pop another item. If the queue was actually empty, and nothing was poppable, you are done; return the result of step 1.</li>
<li>Merge the two popped items, and push them back into the queue. Go back to step 1.</li>
</ol>
<p>Sounds simple enough. We should take into account that we would fail to build a tree if the queue was empty to begin with, by returning a <code>Maybe (PreTree a)</code> instead of a <code>PreTree a</code>.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/huffman/Huffman.hs#L75-98 -- interactive: https://www.fpcomplete.com/user/jle/huffman-encoding buildTree :: State (PQueue (WeightedPT a)) (Maybe (PreTree a)) buildTree = do t1' &lt;- state popPQ case t1' of Nothing -&gt; -- queue was empty to begin with, so this fails. return Nothing Just t1 -&gt; do t2' &lt;- state popPQ case t2' of Nothing -&gt; -- We're done, there was only one item! Return a <code>Just</code> to -- indicate success. return (Just (_wItem t1)) -- break out of the loop Just t2 -&gt; do -- merge and push let combined = mergeWPT t1 t2 modify (insertPQ combined) buildTree -- recursive call</p>
<p>runBuildTree :: Ord a =&gt; [a] -&gt; (Maybe (PreTree a)) runBuildTree xs = evalState (listQueueState xs &gt;&gt; buildTree) emptyPQ ~~~</p>
<p>Note that due to our uncanny foresight, <code>popPQ :: PQueue a -&gt; (Maybe a, PQueue a)</code> is already a state function <code>s -&gt; (a, s)</code>, where the state is <code>PSQueue a</code> and the return value is <code>Maybe a</code>. So all we need to do is say <code>state popPQ</code> to wrap it in the <code>State s a</code> newtype wrapper/container, and it becomes an &quot;official&quot; <code>State (PQueue a) (Maybe a)</code>.</p>
<p>Remember that <code>State s a</code> is <em>just a thin wrapper/container</em> over a function <code>s -&gt; (a, s)</code>, anyway, so the two should be somewhat equivalent in your mind; the requirement to wrap it in <code>State</code> using <code>state</code> is only because of Haskell's own language limitations (namely, that you can't define a Monad instance for <code>s -&gt; (a, s)</code> in a clean way). When you read <code>State s a</code>, you <em>should really read</em> <code>s -&gt; (a, s)</code>, because they are for the most part <em>completely equivalent</em>.</p>
<p>Again, <code>(&gt;&gt;)</code> is Monad-speak for our <code>andThen</code> function we defined earlier, so for <code>buildTree</code>, we do &quot;<code>listQueueState xs</code> <em>and then</em> <code>buildTree</code>&quot;. <code>(&gt;&gt;)</code> joins two <code>s -&gt; (a, s)</code> functions into one giant <code>s -&gt; (a,s)</code>, by feeding the resulting state of the first action into the next one. <code>listQueueState</code> takes an empty priority queue and 'fills' it with nodes generated from <code>xs</code>, leaving a filled priority queue. <code>buildTree</code> then takes that filled queue and performs our building operations on it, modifying it as it goes along, and ends up with an empty queue as a state and returning the finished tree as a result.</p>
<p><code>evalState</code> is like partner of <code>execState</code> --- it runs the state operation on the given starting state, and outputs the final result (instead of the final state). It takes an <code>s -&gt; (a, s)</code>, an <code>s</code>, and applies the function to it and gives the resulting <code>a</code> of the tuple.</p>
<h3>Putting it all together</h3>
<p>Let's try it out, shall we?</p>
<p>~~~haskell ghci&gt; fromJust $ runBuildTree &quot;hello world&quot; PTNode (PTNode (PTNode (PTLeaf 'h') (PTLeaf 'e') ) (PTNode (PTLeaf 'w') (PTLeaf 'r') ) ) (PTNode (PTLeaf 'l') (PTNode (PTNode (PTLeaf 'd') (PTLeaf ' ') ) (PTLeaf 'o') ) ) ~~~</p>
<p>Congrats, we built a Huffman encoding tree! Notice that the most commonly used letter (<code>'l'</code>, occurring 3 times) is only at depth 2 (and is most accessible), while the others are at depths 3 and 4.</p>
<h2>Next steps</h2>
<p>That's it for this post, it's already long enough!</p>
<p>In the next posts we will look at how we would use this Huffman tree to encode and decode text, and general bytes (<code>Word8</code>s), and then hook it all up to make a &quot;streaming&quot; compressor and uncompressor that reads a file byte-by-byte and outputs a compressed file as it goes. We'll then figure out how to store this huffman tree in a compact, serialized binary way, and load it cleanly.</p>
<p>In the mean time, try <a href="https://github.com/mstksg/inCode/tree/master/code-samples/huffman">downloading the source</a>, or <a href="https://www.fpcomplete.com/user/jle/huffman-encoding">playing with it online</a> on [fpcomplete]!</p></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Beginner/Intermediate Haskell Projects&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series" title="+Beginner/Intermediate Haskell Projects"> series history</a>.</div></li><li><div>This entry is a part of a series called <b>&quot;Huffman Compression&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+huffman-compression.html" class="tag-a-series" title="+Huffman Compression"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/monads.html" class="tag-a-tag">#monads</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li><li><a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series">+Beginner/Intermediate Haskell Projects</a></li><li><a href="https://blog.jle.im/entries/series/+huffman-compression.html" class="tag-a-series">+Huffman Compression</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and.html">Intro to Machines &amp; Arrows (Part 1: Stream and Auto)</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/a-dead-end-arrowized-dataflow-parallelism-interface-attempt.html">A (Dead End?) Arrowized Dataflow Parallelism Interface Attempt</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-1-trees.html';
    this.page.identifier = 'huffman-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>