<!DOCTYPE HTML>
<html><head><title>Interpreters a la Carte (Advent of Code 2017 Duet) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="This post is just a fun one exploring a wide range of techniques that I applied to solve the Day 18 puzzles of this year’s great Advent of Code. The puzzles involved interpreting an assembly language on an abstract machine. The neat twist is that Part A gave you a description of one abstract machine, and Part B gave you a different abstract machine to interpret the same language in. This twist (one language, but different interpreters/abstract machines) is basically one of the textbook applications of the interpreter pattern in Haskell and functional programming, so it was fun to implement my solution in that pattern – the assembly language source was compiled to an abstract data type once, and the difference between Part A and Part B was just a different choice of interpreter. Even more interesting is that the two machines are only half different – there’s one aspect of the virtual machines that are the same between the two parts, and aspect that is different. This means that we can apply the data types a la carte technique in order to mix and match isolated components of virtual machine interpreters, and re-use code whenever possible in assembling our interpreters for our different machines! This blog post will not necessarily be a focused tutorial on this trick, but rather an explanation on my solution centered around this pattern, hopefully providing insight on how I approach and solve non-trivial Haskell problems. Along the way we’ll also use mtl typeclasses and classy lenses."><meta property="og:type" content="article"><meta property="og:title" content="Interpreters a la Carte (Advent of Code 2017 Duet)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/interpreters-a-la-carte.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/interpreters-a-la-carte.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Interpreters a la Carte (Advent of Code 2017 Duet)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/interpreters.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/interpreters-a-la-carte.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/interpreters-a-la-carte.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>This post is just a fun one exploring a wide range of techniques that I applied to solve the Day 18 puzzles of this year’s great <a href="http://adventofcode.com/2017">Advent of Code</a>. The puzzles involved interpreting an assembly language on an abstract machine. The neat twist is that Part A gave you a description of one abstract machine, and Part B gave you a <em>different</em> abstract machine to interpret the same language in. This twist (one language, but different interpreters/abstract machines) is basically one of the textbook applications of the <em>interpreter pattern</em> in Haskell and functional programming, so it was fun to implement my solution in that pattern – the assembly language source was “compiled” to an abstract data type once, and the difference between Part A and Part B was just a different choice of interpreter.</p>
<p>Even more interesting is that the two machines are only “half different” – there’s one aspect of the virtual machines that are the same between the two parts, and aspect that is different. This means that we can apply the “data types a la carte” technique in order to mix and match isolated components of virtual machine interpreters, and re-use code whenever possible in assembling our interpreters for our different machines!</p>
<p>This blog post will not necessarily be a focused tutorial on this trick, but rather an explanation on my solution centered around this pattern, hopefully providing insight on how I approach and solve non-trivial Haskell problems. Along the way we’ll also use mtl typeclasses and classy lenses.</p>
<h2 id="the-puzzle">The Puzzle</h2>
<p>The puzzle is <a href="http://adventofcode.com/2017/day/18">Advent of Code 2017 Day 18</a>, and Part A is:</p>
<blockquote>
<p>You discover a tablet containing some strange assembly code labeled simply “Duet”. Rather than bother the sound card with it, you decide to run the code yourself. Unfortunately, you don’t see any documentation, so you’re left to figure out what the instructions mean on your own.</p>
<p>It seems like the assembly is meant to operate on a set of <em>registers</em> that are each named with a single letter and that can each hold a single integer. You suppose each register should start with a value of <code>0</code>.</p>
<p>There aren’t that many instructions, so it shouldn’t be hard to figure out what they do. Here’s what you determine:</p>
<ul>
<li><code>snd X</code> <em>plays a sound</em> with a frequency equal to the value of <code>X</code>.</li>
<li><code>set X Y</code> <em>sets</em> register <code>X</code> to the value of <code>Y</code>.</li>
<li><code>add X Y</code> <em>increases</em> register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mul X Y</code> sets register <code>X</code> to the result of <em>multiplying</em> the value contained in register <code>X</code> by the value of <code>Y</code>.</li>
<li><code>mod X Y</code> sets register <code>X</code> to the <em>remainder</em> of dividing the value contained in register <code>X</code> by the value of <code>Y</code> (that is, it sets <code>X</code> to the result of <code>X</code> modulo <code>Y</code>).</li>
<li><code>rcv X</code> <em>recovers</em> the frequency of the last sound played, but only when the value of <code>X</code> is not zero. (If it is zero, the command does nothing.)</li>
<li><code>jgz X Y</code> <em>jumps</em> with an offset of the value of <code>Y</code>, but only if the value of <code>X</code> is <em>greater than zero</em>. (An offset of <code>2</code> skips the next instruction, an offset of <code>-1</code> jumps to the previous instruction, and so on.)</li>
</ul>
<p>Many of the instructions can take either a register (a single letter) or a number. The value of a register is the integer it contains; the value of a number is that number.</p>
<p>After each <em>jump</em> instruction, the program continues with the instruction to which the <em>jump</em> jumped. After any other instruction, the program continues with the next instruction. Continuing (or jumping) off either end of the program terminates it.</p>
<p><em>What is the value of the recovered frequency</em> (the value of the most recently played sound) the <em>first</em> time a <code>rcv</code> instruction is executed with a non-zero value?</p>
</blockquote>
<p>Part B, however, says:</p>
<blockquote>
<p>As you congratulate yourself for a job well done, you notice that the documentation has been on the back of the tablet this entire time. While you actually got most of the instructions correct, there are a few key differences. This assembly code isn’t about sound at all - it’s meant to be run <em>twice at the same time</em>.</p>
<p>Each running copy of the program has its own set of registers and follows the code independently - in fact, the programs don't even necessarily run at the same speed. To coordinate, they use the <em>send</em> (<code>snd</code>) and <em>receive</em> (<code>rcv</code>) instructions:</p>
<ul>
<li><code>snd X</code> <em>sends</em> the value of <code>X</code> to the other program. These values wait in a queue until that program is ready to receive them. Each program has its own message queue, so a program can never receive a message it sent.</li>
<li><code>rcv X</code> <em>receives</em> the next value and stores it in register <code>X</code>. If no values are in the queue, the program <em>waits for a value to be sent to it</em>. Programs do not continue to the next instruction until they have received a value. Values are received in the order they are sent.</li>
</ul>
<p>Each program also has its own <em>program ID</em> (one <code>0</code> and the other <code>1</code>); the register <code>p</code> should begin with this value.</p>
<p>Once both of your programs have terminated (regardless of what caused them to do so), <em>how many times did program <code>1</code> send a value</em>?</p>
</blockquote>
<p>Note that in each of these, “the program” is a program (written in the Duet assembly language), which is different for each user and given to us by the site.</p>
<p>What’s going on here is that both parts execute the same program in two different virtual machines – one has “sound” and “recover”, and the other has “send” and “receive”. We are supposed to run the same program in <em>both</em> of these machines.</p>
<p>However, note that these two machines aren’t <em>completely</em> different – they both have the ability to manipulate memory and read/shift program data. So really , we want to be able to create a “modular” spec and implementation of these machines, so that we may re-use this memory manipulation aspect when constructing our machine, without duplicating any code.</p>
<h2 id="parsing-duet">Parsing Duet</h2>
<p>First, let’s get the parsing of the actual input program out of the way. We’ll be parsing a program into a list of “ops” that we will read as our program.</p>
<p>Our program will be interpreted as a list of <code>Op</code> values, a data type representing opcodes. There are four categories: “snd”, “rcv”, “jgz”, and the binary mathematical operations:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L31-36</span>
<span class="kw">type</span> <span class="dt">Addr</span> <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">Char</span> <span class="dt">Int</span>

<span class="kw">data</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">OSnd</span> <span class="dt">Addr</span>
        <span class="fu">|</span> <span class="dt">ORcv</span> <span class="dt">Char</span>
        <span class="fu">|</span> <span class="dt">OJgz</span> <span class="dt">Addr</span> <span class="dt">Addr</span>
        <span class="fu">|</span> <span class="dt">OBin</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="dt">Char</span> <span class="dt">Addr</span></code></pre></div>
<p>It’s important to remember that “snd”, “jgz”, and the binary operations can all take either numbers or other registers.</p>
<p>Now, parsing a single <code>Op</code> is just a matter of pattern matching on <code>words</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L38-51</span>
<span class="ot">parseOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Op</span>
parseOp inp <span class="fu">=</span> <span class="kw">case</span> words inp <span class="kw">of</span>
    <span class="st">&quot;snd&quot;</span><span class="fu">:</span>c    <span class="fu">:</span>_   <span class="ot">-&gt;</span> <span class="dt">OSnd</span> (addr c)
    <span class="st">&quot;set&quot;</span><span class="fu">:</span>(x<span class="fu">:</span>_)<span class="fu">:</span>y<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="dt">OBin</span> (const id) x (addr y)
    <span class="st">&quot;add&quot;</span><span class="fu">:</span>(x<span class="fu">:</span>_)<span class="fu">:</span>y<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="dt">OBin</span> (<span class="fu">+</span>)        x (addr y)
    <span class="st">&quot;mul&quot;</span><span class="fu">:</span>(x<span class="fu">:</span>_)<span class="fu">:</span>y<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="dt">OBin</span> (<span class="fu">*</span>)        x (addr y)
    <span class="st">&quot;mod&quot;</span><span class="fu">:</span>(x<span class="fu">:</span>_)<span class="fu">:</span>y<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="dt">OBin</span> mod        x (addr y)
    <span class="st">&quot;rcv&quot;</span><span class="fu">:</span>(x<span class="fu">:</span>_)<span class="fu">:</span>_   <span class="ot">-&gt;</span> <span class="dt">ORcv</span> x
    <span class="st">&quot;jgz&quot;</span><span class="fu">:</span>x    <span class="fu">:</span>y<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="dt">OJgz</span> (addr x) (addr y)
    _               <span class="ot">-&gt;</span> error <span class="st">&quot;Bad parse&quot;</span>
  <span class="kw">where</span>
<span class="ot">    addr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Addr</span>
    addr [c] <span class="fu">|</span> isAlpha c <span class="fu">=</span> <span class="dt">Left</span> c
    addr str <span class="fu">=</span> <span class="dt">Right</span> (read str)</code></pre></div>
<p>We’re going to store our program in a <code>PointedList</code> from the <em><a href="http://hackage.haskell.org/package/pointedlist">pointedlist</a></em> package, which is a non-empty list with a “focus” at a given index, which we use to represent the program counter/program head/current instruction. Parsing our program is then just parsing each line in the program string, and collecting them into a <code>PointedList</code>. We’re ready to go!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L53-54</span>
<span class="ot">parseProgram ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">P.PointedList</span> <span class="dt">Op</span>
parseProgram <span class="fu">=</span> fromJust <span class="fu">.</span> P.fromList <span class="fu">.</span> map parseOp <span class="fu">.</span> lines</code></pre></div>
<h2 id="our-virtual-machine">Our Virtual Machine</h2>
<h3 id="monadprompt">MonadPrompt</h3>
<p>We’re going to be using the great <em><a href="http://hackage.haskell.org/package/MonadPrompt">MonadPrompt</a></em> library to build our representation of our interpreted language. Another common choice is to use <em><a href="http://hackage.haskell.org/package/free">free</a></em>, and a lot of other tutorials go down this route. However, <em>free</em> is a bit more power than you really need for the interpreter pattern, and I always felt like the implementation of interpreter pattern programs in <em>free</em> was a bit awkward.</p>
<p><em>MonadPrompt</em> lets us construct a language (and a monad) using GADTs to represent command primitives. For example, to implement something like <code>State Int</code>, you might use this GADT:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">StateCommand</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">Put</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StateCommand</span> ()
    <span class="dt">Get</span><span class="ot"> ::</span> <span class="dt">StateCommand</span> <span class="dt">Int</span></code></pre></div>
<p>Which says that the two “primitive” commands of <code>State Int</code> are “putting” (which requires an <code>Int</code> and produces a <code>()</code> result) and “getting” (which requires no inputs, and produces an <code>Int</code> result).</p>
<p>You can then write <code>State Int</code> as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">IntState</span> <span class="fu">=</span> <span class="dt">Prompt</span> <span class="dt">StateCommand</span></code></pre></div>
<p>And our primitives can be constructed using:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prompt ::</span> <span class="dt">StateCommand</span> a <span class="ot">-&gt;</span> <span class="dt">IntState</span> a

prompt (<span class="dt">Put</span> <span class="dv">10</span>)<span class="ot"> ::</span> <span class="dt">IntState</span> ()
prompt <span class="dt">Get</span><span class="ot">      ::</span> <span class="dt">IntState</span> <span class="dt">Int</span></code></pre></div>
<p>Now, we <em>interpret</em> an <code>IntState</code> in a monadic context using <code>runPromptM</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runPromptM
<span class="ot">    ::</span> <span class="dt">Monad</span> m                              <span class="co">-- m is the monad to interpret in</span>
    <span class="ot">=&gt;</span> (forall x<span class="fu">.</span> <span class="dt">StateCommand</span> x <span class="ot">-&gt;</span> m x)    <span class="co">-- a way to interpret each primitive in &#39;m&#39;</span>
    <span class="ot">-&gt;</span> <span class="dt">IntState</span> a                           <span class="co">-- IntState to interpret</span>
    <span class="ot">-&gt;</span> m a                                  <span class="co">-- resulting action in &#39;m&#39;</span></code></pre></div>
<p>So, if we wanted to use <code>IO</code> and <code>IORefs</code> as the mechanism for interpreting our <code>IntState</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">interpretIO
<span class="ot">    ::</span> <span class="dt">IORef</span> <span class="dt">Int</span>
    <span class="ot">-&gt;</span> <span class="dt">StateCommand</span> a
    <span class="ot">-&gt;</span> <span class="dt">IO</span> a
interpretIO r <span class="fu">=</span> \<span class="kw">case</span>           <span class="co">-- using -XLambdaCase</span>
    <span class="dt">Put</span> x <span class="ot">-&gt;</span> writeIORef r x
    <span class="dt">Get</span>   <span class="ot">-&gt;</span> readIORef r

<span class="ot">runAsIO ::</span> <span class="dt">IntState</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a
runAsIO m s0 <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> newIORef s0
    runPromptM (interpretIO r) m</code></pre></div>
<p><code>interpretIO</code> is our interpreter, in <code>IO</code>. <code>runPromptM</code> will interpret each primitive (<code>Put</code> and <code>Get</code>) using <code>interpretIO</code>, and generate the result for us.</p>
<p>We can also be boring and interpret it using <code>State Int</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpretState ::</span> <span class="dt">StateCommand</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> a
interpretState <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">Put</span> x <span class="ot">-&gt;</span> put x
    <span class="dt">Get</span>   <span class="ot">-&gt;</span> get

<span class="ot">runAsState ::</span> <span class="dt">IntState</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> a
runAsState <span class="fu">=</span> runPormptM interpretState</code></pre></div>
<p>Basically, an <code>IntState a</code> is an abstract representation of a program (as a Monad), and <code>interpretIO</code> and <code>interpretState</code> are different ways of <em>interpreting</em> that program, in different monadic contexts. To “run” or interpret our program in a context, we provide a function <code>forall x. StateCommand x -&gt; m x</code>, which interprets each individual primitive command.</p>
<h3 id="duet-commands">Duet Commands</h3>
<p>Now let’s specify the “primitives” of our program. It’ll be useful to separate out the “memory-based” primitive commands from the “communication-based” primitive commands. This is so that we can write interpreters that operate on each one individually.</p>
<p>For memory, we can access and modify register values, as well as jump around in the program tape and read the <code>Op</code> at the current program head:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L56-60</span>
<span class="kw">data</span> <span class="dt">Mem</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MGet</span><span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Mem</span> <span class="dt">Int</span>
    <span class="dt">MSet</span><span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Mem</span> ()
    <span class="dt">MJmp</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Mem</span> ()
    <span class="dt">MPk</span><span class="ot">  ::</span> <span class="dt">Mem</span> <span class="dt">Op</span></code></pre></div>
<p>For communication, we must be able to “snd” and “rcv”.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L62-64</span>
<span class="kw">data</span> <span class="dt">Com</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">CSnd</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Com</span> ()
    <span class="dt">CRcv</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Com</span> <span class="dt">Int</span></code></pre></div>
<p>Part A requires <code>CRcv</code> to take, as an argument, a number, since whether or not <code>CRcv</code> is a no-op depends on the value of a certain register for Part A’s virtual machine.</p>
<p>Now, we can leverage the <code>:|:</code> type from <em><a href="http://hackage.haskell.org/package/type-combinators">type-combinators</a></em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> (f <span class="fu">:|:</span> g) a <span class="fu">=</span> <span class="dt">L</span> (f a)
                 <span class="fu">|</span> <span class="dt">R</span> (g a)</code></pre></div>
<p><code>:|:</code> is a “functor disjunction” – a value of type <code>(f :|: g) a</code> is either <code>f a</code> or <code>g a</code>. <code>:|:</code> is in <em>base</em> twice, as <code>:+:</code> in <em>GHC.Generics</em> and as <code>Sum</code> in <em>Data.Functor.Sum</em>. However, the version in <em>type-combinators</em> has some nice utility combinators we will be using and is more fully-featured.</p>
<p>We can use <code>:|:</code> to create the type <code>Mem :|: Com</code>. If <code>Mem</code> and <code>Com</code> represent “primitives” in our Duet language, then <code>Mem :|: Com</code> represents <em>primitives from <code>Mem</code> and <code>Com</code> together</em>. It’s a type that contains all of the primitives of <code>Mem</code> and the primitives of <code>Com</code> – that is, it contains:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">L</span> (<span class="dt">MGet</span> <span class="ch">&#39;c&#39;</span>)<span class="ot"> ::</span> (<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>) <span class="dt">Int</span>
<span class="dt">L</span> <span class="dt">MPk</span><span class="ot">        ::</span> (<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>) <span class="dt">Op</span>
<span class="dt">R</span> (<span class="dt">CSnd</span> <span class="dv">5</span>)<span class="ot">   ::</span> (<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>) ()</code></pre></div>
<p>etc.</p>
<p>Our final data type then – a monad that encompasses <em>all</em> possible Duet primitive commands, is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L66-66</span>
<span class="kw">type</span> <span class="dt">Duet</span> <span class="fu">=</span> <span class="dt">Prompt</span> (<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>)</code></pre></div>
<p>We can write some convenient utility primitives to make things easier for us in the long run:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L68-84</span>
<span class="ot">dGet ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Duet</span> <span class="dt">Int</span>
dGet <span class="fu">=</span> prompt <span class="fu">.</span> <span class="dt">L</span> <span class="fu">.</span> <span class="dt">MGet</span>

<span class="ot">dSet ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Duet</span> ()
dSet r <span class="fu">=</span> prompt <span class="fu">.</span> <span class="dt">L</span> <span class="fu">.</span> <span class="dt">MSet</span> r

<span class="ot">dJmp ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Duet</span> ()
dJmp <span class="fu">=</span> prompt <span class="fu">.</span> <span class="dt">L</span> <span class="fu">.</span> <span class="dt">MJmp</span>

<span class="ot">dPk ::</span> <span class="dt">Duet</span> <span class="dt">Op</span>
dPk <span class="fu">=</span> prompt (<span class="dt">L</span> <span class="dt">MPk</span>)

<span class="ot">dSnd ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Duet</span> ()
dSnd <span class="fu">=</span> prompt <span class="fu">.</span> <span class="dt">R</span> <span class="fu">.</span> <span class="dt">CSnd</span>

<span class="ot">dRcv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Duet</span> <span class="dt">Int</span>
dRcv <span class="fu">=</span> prompt <span class="fu">.</span> <span class="dt">R</span> <span class="fu">.</span> <span class="dt">CRcv</span></code></pre></div>
<h3 id="constructing-duet-programs">Constructing Duet Programs</h3>
<p>Armed with our <code>Duet</code> monad, we can now write a real-life <code>Duet</code> action to represent <em>one step</em> of our duet programs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L86-107</span>
<span class="ot">stepProg ::</span> <span class="dt">Duet</span> ()
stepProg <span class="fu">=</span> dPk <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span>
    <span class="dt">OSnd</span> x <span class="ot">-&gt;</span> <span class="kw">do</span>
      dSnd <span class="fu">=&lt;&lt;</span> addrVal x
      dJmp <span class="dv">1</span>
    <span class="dt">OBin</span> f x y <span class="ot">-&gt;</span> <span class="kw">do</span>
      yVal <span class="ot">&lt;-</span> addrVal y
      xVal <span class="ot">&lt;-</span> dGet    x
      dSet x <span class="fu">$</span> f xVal yVal
      dJmp <span class="dv">1</span>
    <span class="dt">ORcv</span> x <span class="ot">-&gt;</span> <span class="kw">do</span>
      y <span class="ot">&lt;-</span> dRcv <span class="fu">=&lt;&lt;</span> dGet x
      dSet x y
      dJmp <span class="dv">1</span>
    <span class="dt">OJgz</span> x y <span class="ot">-&gt;</span> <span class="kw">do</span>
      xVal <span class="ot">&lt;-</span> addrVal x
      dJmp <span class="fu">=&lt;&lt;</span> <span class="kw">if</span> xVal <span class="fu">&gt;</span> <span class="dv">0</span>
                 <span class="kw">then</span> addrVal y
                 <span class="kw">else</span> return <span class="dv">1</span>
  <span class="kw">where</span>
    addrVal (<span class="dt">Left</span> r ) <span class="fu">=</span> dGet r
    addrVal (<span class="dt">Right</span> x) <span class="fu">=</span> return x</code></pre></div>
<p>This is basically a straightforward interpretation of the “rules” of our language, and what to do when encountering each op code.</p>
<p>The only non-trivial thing is the <code>ORcv</code> branch, where we include the contents of the register in question, so that our interpreter will know whether or not to treat it as a no-op.</p>
<h2 id="the-interpreters">The Interpreters</h2>
<p>Now for the fun part!</p>
<h3 id="interpreting-memory-primitives">Interpreting Memory Primitives</h3>
<p>To interpret our <code>Mem</code> primitives, we need to be in some sort of stateful monad that contains the program state. First, let’s make a type describing our relevant program state, along with classy lenses for operating on it polymorphically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L109-112</span>
<span class="kw">data</span> <span class="dt">ProgState</span> <span class="fu">=</span> <span class="dt">PS</span> {<span class="ot"> _psTape ::</span> <span class="dt">P.PointedList</span> <span class="dt">Op</span>
                    ,<span class="ot"> _psRegs ::</span> <span class="dt">M.Map</span> <span class="dt">Char</span> <span class="dt">Int</span>
                    }
makeClassy <span class="ch">&#39;&#39;</span><span class="dt">ProgState</span></code></pre></div>
<h4 id="brief-aside-on-lenses-with-state">Brief Aside on Lenses with State</h4>
<p>Using <em><a href="http://hackage.haskell.org/package/lens">lens</a></em> with lenses (especially classy ones) is one of the only things that makes programming against <code>State</code> with non-trivial state bearable for me! We store the current program and program head with the <code>PointedList</code>, and also represent the register contents with a <code>Map Char Int</code>.</p>
<p><code>makeClassy</code> gives us a typeclass <code>HasProgState</code>, which is for things that “have” a <code>ProgState</code>, as well as lenses into the <code>psTape</code> and <code>psRegs</code> field for that type. We can use these lenses with <em>lens</em> library machinery:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | &quot;get&quot; based on a lens</span>
<span class="ot">use   ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> m a

<span class="co">-- | &quot;set&quot; through on a lens</span>
<span class="ot">(.=)  ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m ()

<span class="co">-- | &quot;lift&quot; a State action through a lens</span>
<span class="ot">zoom  ::</span> <span class="dt">Lens&#39;</span> s t <span class="ot">-&gt;</span> <span class="dt">State</span> t a <span class="ot">-&gt;</span> <span class="dt">State</span> s a</code></pre></div>
<p>So, for example, we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | &quot;get&quot; the registers</span>
use<span class="ot"> psRegs  ::</span> (<span class="dt">HasProgState</span> s, <span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> m (<span class="dt">M.Map</span> <span class="dt">Char</span> <span class="dt">Int</span>)

<span class="co">-- | &quot;set&quot; the PointedList</span>
(psTape <span class="fu">.=</span>)<span class="ot"> ::</span> (<span class="dt">HasProgState</span> s, <span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> <span class="dt">P.PointedList</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> m ()</code></pre></div>
<p>The nice thing about lenses is that they compose, so, for example, we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">at ::</span> k <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (<span class="dt">Map</span> k    v  ) (<span class="dt">Maybe</span> v)

at <span class="ch">&#39;h&#39;</span><span class="ot">  ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">Map</span> <span class="dt">Char</span> <span class="dt">Int</span>) (<span class="dt">Maybe</span> <span class="dt">Int</span>)</code></pre></div>
<p>We can use <code>at 'c'</code> to give us a lens from our registers (<code>Map Char Int</code>) into the specific register <code>'c'</code> as a <code>Maybe Int</code> – it’s <code>Nothing</code> if the item is not in the <code>Map</code>, and <code>Just</code> if it is (with the value).</p>
<p>However, we want to treat all registers as <code>0</code> by default, not as <code>Nothing</code>, so we can use <code>non 0</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">non <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) <span class="dt">Int</span></code></pre></div>
<p><code>non 0</code> is a <code>Lens</code> (actually an <code>Iso</code>, but who’s counting?) into a <code>Maybe Int</code> to treat <code>Nothing</code> as if it was <code>0</code>, and to treat <code>Just x</code> as if it was <code>x</code>.</p>
<p>We can chain <code>at r</code> with <code>non 0</code> to get a lens into a <code>Map Char Int</code>, which we can use to edit a specific item, treating non-present-items as 0.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">         at <span class="ch">&#39;h&#39;</span> <span class="fu">.</span> non <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">Map</span> <span class="dt">Char</span> <span class="dt">Int</span>) <span class="dt">Int</span>

psRegs <span class="fu">.</span> at <span class="ch">&#39;h&#39;</span> <span class="fu">.</span> non <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">HasProgState</span> s <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> s <span class="dt">Int</span></code></pre></div>
<h4 id="interpreting-mem">Interpreting Mem</h4>
<p>With these tools to make life simpler, we can write an interpreter for our <code>Mem</code> commands:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L114-124</span>
interpMem
<span class="ot">    ::</span> (<span class="dt">MonadState</span> s m, <span class="dt">MonadFail</span> m, <span class="dt">HasProgState</span> s)
    <span class="ot">=&gt;</span> <span class="dt">Mem</span> a
    <span class="ot">-&gt;</span> m a
interpMem <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">MGet</span> c   <span class="ot">-&gt;</span> use (psRegs <span class="fu">.</span> at c <span class="fu">.</span> non <span class="dv">0</span>)
    <span class="dt">MSet</span> c x <span class="ot">-&gt;</span> psRegs <span class="fu">.</span> at c <span class="fu">.</span> non <span class="dv">0</span> <span class="fu">.=</span> x
    <span class="dt">MJmp</span> n   <span class="ot">-&gt;</span> <span class="kw">do</span>
      <span class="dt">Just</span> t&#39; <span class="ot">&lt;-</span> P.moveN n <span class="fu">&lt;$&gt;</span> use psTape
      psTape <span class="fu">.=</span> t&#39;
    <span class="dt">MPk</span>      <span class="ot">-&gt;</span> use (psTape <span class="fu">.</span> P.focus)</code></pre></div>
<p>We use <code>MonadFail</code> to explicitly state that we rely on a failed pattern match for control flow. <code>P.moveN :: Int -&gt; P.PointedList a -&gt; Maybe (P.PointedList a)</code> will “shift” a <code>PointedList</code> by a given amount, but will return <code>Nothing</code> if it goes out of bounds. Our program is meant to terminate if we ever go out of bounds, so we can implement this by using a do block pattern match with <code>MonadFail</code>. For instances like <code>MaybeT</code>/<code>Maybe</code>, this means <code>empty</code>/<code>Nothing</code>/short-circuit. So when we <code>P.move</code>, we do-block pattern match on <code>Just t'</code>.</p>
<p>We also use <code>P.focus :: Lens' (P.PointedList a) a</code>, a lens that the <em>pointedlist</em> library provides to the current “focus” of the <code>PointedList</code>.</p>
<p>Note that most of this usage of lens with state is not exactly necessary (we can manually use <code>modify</code>, <code>gets</code>, etc. instead of lenses and operators), but it does make things a bit more convenient to write.</p>
<h4 id="gadt-property">GADT Property</h4>
<p>The GADT-ness of <code>Mem</code> (and <code>Com</code>) works to enforce that the “results” that each primitive expects is the result that we give.</p>
<p>For example, <code>MGet 'c' :: Mem Int</code> requires us to return <code>m Int</code>. This is what <code>use</code> gives us. <code>MSet 'c' 3 :: Mem ()</code> requires us to return <code>m ()</code>, which is what <code>(.=)</code> returns.</p>
<p>We have <code>MPk :: Mem Op</code>, which requires us to return <code>m Op</code>. That’s exactly what <code>use (psTape . P.focus) :: (MonadState s m, HasProgState s) =&gt; m Op</code> gives.</p>
<p>The fact that we can use GADTs to specify the “result type” of each of our primitives is a key part about how <code>Prompt</code> from <em>MonadPrompt</em> works, and how it implements the interpreter pattern.</p>
<p>This is enforced in Haskell’s type system (through the “dependent pattern match”), so GHC will complain to us if we ever return something of the wrong type while handling a given constructor/primitive.</p>
<h3 id="interpreting-com-for-part-a">Interpreting Com for Part A</h3>
<p>Now, Part A requires an environment where:</p>
<ol type="1">
<li><code>CSnd</code> “emits” items into the void, keeping track only of the <em>last</em> emitted item</li>
<li><code>CRcv</code> “catches” the last thing seen by <code>CSnd</code>, keeping track of only the <em>first</em> caught item</li>
</ol>
<p>We can keep track of this using <code>MonadWriter (First Int)</code> to interpret <code>CRcv</code> (if there are two <em>rcv</em>’s, we only care about the first <em>rcv</em>’d thing), and <code>MonadAccum (Last Int)</code> to interpret <code>CSnd</code>. A <code>MonadAccum</code> is just like <code>MonadWriter</code> (where you can “tell” things and accumulate things), but you also have the ability to read the accumulated log at any time. We use <code>Last Int</code> because, if there are two <em>snd</em>’s, we only care about the last <em>snd</em>’d thing.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L130-140</span>
interpComA
<span class="ot">    ::</span> (<span class="dt">MonadAccum</span> (<span class="dt">Last</span> <span class="dt">Int</span>) m, <span class="dt">MonadWriter</span> (<span class="dt">First</span> <span class="dt">Int</span>) m)
    <span class="ot">=&gt;</span> <span class="dt">Com</span> a
    <span class="ot">-&gt;</span> m a
interpComA <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">CSnd</span> x <span class="ot">-&gt;</span>
      add (<span class="dt">Last</span> (<span class="dt">Just</span> x))
    <span class="dt">CRcv</span> x <span class="ot">-&gt;</span> <span class="kw">do</span>
      when (x <span class="fu">/=</span> <span class="dv">0</span>) <span class="fu">$</span>         <span class="co">-- don&#39;t rcv if the register parameter is 0</span>
        tell <span class="fu">.</span> <span class="dt">First</span> <span class="fu">.</span> getLast <span class="fu">=&lt;&lt;</span> look
      return x</code></pre></div>
<p>Note <code>add :: MonadAccum w m =&gt; w -&gt; m ()</code> and <code>look :: MonadAccum w w</code>, the functions to “tell” to a <code>MonadAccum</code> and the function to “get”/“ask” from a <code>MonadAccum</code>.</p>
<h3 id="interpreting-com-for-part-b">Interpreting Com for Part B</h3>
<p>Part B requires an environment where:</p>
<ol type="1">
<li><code>CSnd</code> “emits” items into into some accumulating log of items, and we need to keep track of all of them.</li>
<li><code>CRcv</code> “consumes” items from some external environment, and fails when there are no more items to consume.</li>
</ol>
<p>We can interpret <code>CSnd</code>’s effects using <code>MonadWriter [Int]</code>, to collect all emitted <code>Int</code>s. We can interpret <code>CRcv</code>’s effects using <code>MonadState s</code>, where <code>s</code> contains an <code>[Int]</code> acting as a source of <code>Int</code>s to consume.</p>
<p>We’re going to use a <code>Thread</code> type to keep track of all thread state. We do this so we can merge the contexts of <code>interpMem</code> and <code>interpComB</code>, and really treat them (using type inference) as both working in the same interpretation context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L153-159</span>
<span class="kw">data</span> <span class="dt">Thread</span> <span class="fu">=</span> <span class="dt">T</span> {<span class="ot"> _tState   ::</span> <span class="dt">ProgState</span>
                ,<span class="ot"> _tBuffer  ::</span> [<span class="dt">Int</span>]
                }
makeClassy <span class="ch">&#39;&#39;</span><span class="dt">Thread</span>

<span class="kw">instance</span> <span class="dt">HasProgState</span> <span class="dt">Thread</span> <span class="kw">where</span>
    progState <span class="fu">=</span> tState</code></pre></div>
<p>(We write an instance for <code>HasProgState Thread</code>, so we can use <code>interpMem</code> in a <code>MonadState Thread m</code>, since <code>psRegs :: Lens' Thread (M.Map Char Int)</code>, for example, will refer to the <code>psRegs</code> inside the <code>ProgState</code> in the <code>Thread</code>)</p>
<p>And now, to interpret:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L161-170</span>
interpComB
<span class="ot">    ::</span> (<span class="dt">MonadWriter</span> [<span class="dt">Int</span>] m, <span class="dt">MonadFail</span> m, <span class="dt">MonadState</span> <span class="dt">Thread</span> m)
    <span class="ot">=&gt;</span> <span class="dt">Com</span> a
    <span class="ot">-&gt;</span> m a
interpComB <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">CSnd</span> x <span class="ot">-&gt;</span> tell [x]
    <span class="dt">CRcv</span> _ <span class="ot">-&gt;</span> <span class="kw">do</span>
      x<span class="fu">:</span>xs <span class="ot">&lt;-</span> use tBuffer
      tBuffer <span class="fu">.=</span> xs
      return x</code></pre></div>
<p>Note again the usage of do block pattern matches and <code>MonadFail</code>.</p>
<h3 id="combining-interpreters">Combining Interpreters</h3>
<p>To combine interpreters, we’re going to be using, from <em>type-combinators</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;|&lt;) ::</span> (f a <span class="ot">-&gt;</span> r)
      <span class="ot">-&gt;</span> (g a <span class="ot">-&gt;</span> r)
      <span class="ot">-&gt;</span> ((f <span class="fu">:|:</span> g) a <span class="ot">-&gt;</span> r)</code></pre></div>
<p>Basically, <code>&gt;|&lt;</code> lets us write a “handler” for a <code>:|:</code> by providing a handler for each side. For example, with more concrete types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;|&lt;) ::</span> (<span class="dt">Mem</span> a <span class="ot">-&gt;</span> r)
      <span class="ot">-&gt;</span> (<span class="dt">Com</span> a <span class="ot">-&gt;</span> r)
      <span class="ot">-&gt;</span> ((<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>) a <span class="ot">-&gt;</span> r)</code></pre></div>
<p>We can use this to build an interpreter for <code>Duet</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runPromptM
<span class="ot">    ::</span> <span class="dt">Monad</span> m
    <span class="ot">=&gt;</span> (forall x<span class="fu">.</span> (<span class="dt">Mem</span> x <span class="fu">:|:</span> <span class="dt">Com</span> x) <span class="ot">-&gt;</span> m x)
    <span class="ot">-&gt;</span> <span class="dt">Duet</span> a
    <span class="ot">-&gt;</span> m a</code></pre></div>
<p>By using <code>&gt;|&lt;</code> to generate our compound interpreters. This is how we can create interpreters on <code>Duet</code> by “combining”, in a modular way, interpreters for <code>Mem</code> and <code>Com</code>. This is the essence of the “data types a la carte” technique.</p>
<h2 id="getting-the-results">Getting the Results</h2>
<p>We now just have to pick concrete monads now for us to interpret into.</p>
<h3 id="part-a">Part A</h3>
<p>Our interpreter for Part A is <code>interpMem &gt;|&lt; interpComA</code> – we interpret the <code>Mem</code> primitives the usual way, and interpret the <code>Com</code> primitives the Part A way.</p>
<p>Let’s check what capabilities our interpreter must have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t interpMem <span class="fu">&gt;|&lt;</span> interpComA
interpMem <span class="fu">&gt;|&lt;</span> interpComA
<span class="ot">    ::</span> ( <span class="dt">MonadWriter</span> (<span class="dt">First</span> <span class="dt">Int</span>) m
       , <span class="dt">MonadAccum</span> (<span class="dt">Last</span> <span class="dt">Int</span>) m
       , <span class="dt">MonadFail</span> m
       , <span class="dt">MonadState</span> s m
       , <span class="dt">HasProgState</span> s
       )
    <span class="ot">=&gt;</span> (<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>) a
    <span class="ot">-&gt;</span> m a</code></pre></div>
<p>So it looks like we need to be <code>MonadWriter (First Int)</code>, <code>MonadAccum (Last Int)</code>, <code>MonadFail m</code>, and <code>MonadState s m</code>, where <code>HasProgState s</code>.</p>
<p>Now, we can write such a Monad from scratch, or we can use the <em>transformers</em> library to generate a transformer with all of those instances for us. For the sake of brevity and reducing duplicated code, let’s go that route. We can use:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MaybeT</span> (<span class="dt">StateT</span> <span class="dt">ProgState</span> (<span class="dt">WriterT</span> (<span class="dt">First</span> <span class="dt">Int</span>) (<span class="dt">A.Accum</span> (<span class="dt">Last</span> <span class="dt">Int</span>))))</code></pre></div>
<p>And so we can write our final “step” function in that context:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L142-143</span>
<span class="ot">stepA ::</span> <span class="dt">MaybeT</span> (<span class="dt">StateT</span> <span class="dt">ProgState</span> (<span class="dt">WriterT</span> (<span class="dt">First</span> <span class="dt">Int</span>) (<span class="dt">A.Accum</span> (<span class="dt">Last</span> <span class="dt">Int</span>)))) ()
stepA <span class="fu">=</span> runPromptM (interpMem <span class="fu">&gt;|&lt;</span> interpComA) stepProg</code></pre></div>
<p><code>stepA</code> will make a single step of the tape, according to the interpreters <code>interpMem</code> and <code>interpComA</code>.</p>
<p>Our final answer is then just the result of <em>repeating</em> this over and over again until there’s a failure. We take advantage of the fact that <code>MaybeT</code>’s <code>Alternative</code> instance uses <code>empty</code> for <code>fail</code>, so we can use <code>many :: MaybeT m a -&gt; MaybeT m [a]</code>, which repeats a <code>MaybeT</code> action several times until a failure is encountered. In our case, “failure” is when the tape goes out of bounds.</p>
<p>But, because of laziness, our computation terminates as soon as a valid <code>CRcv</code> is found and a <code>First Int</code> is logged to the <code>Writer</code>, so we don’t actually need to run the computation until it goes out of bounds.</p>
<p>Here is the entirety of running Part A – as you can see, it consists mostly of unwrapping <em>transformers</em> newtype wrappers.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L145-151</span>
<span class="ot">partA ::</span> <span class="dt">P.PointedList</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
partA ops <span class="fu">=</span> getFirst
          <span class="fu">.</span> flip A.evalAccum mempty
          <span class="fu">.</span> execWriterT
          <span class="fu">.</span> flip runStateT (<span class="dt">PS</span> ops M.empty)
          <span class="fu">.</span> runMaybeT
          <span class="fu">$</span> many stepA</code></pre></div>
<h3 id="part-b">Part B</h3>
<p>Our interpreter for Part B is a little simpler:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t interpMem <span class="fu">&gt;|&lt;</span> interpComB
interpMem <span class="fu">&gt;|&lt;</span> interpComB
<span class="ot">    ::</span> ( <span class="dt">MonadWriter</span> [<span class="dt">Int</span>] m
       , <span class="dt">MonadFail</span> m
       , <span class="dt">MonadState</span> <span class="dt">Thread</span> m
       )
    <span class="ot">=&gt;</span> (<span class="dt">Mem</span> <span class="fu">:|:</span> <span class="dt">Com</span>) a
    <span class="ot">-&gt;</span> m a</code></pre></div>
<p>We can really just use:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">WriterT</span> [<span class="dt">Int</span>] (<span class="dt">MaybeT</span> (<span class="dt">State</span> <span class="dt">Thread</span>))</code></pre></div>
<p>Writing our concrete <code>stepB</code> is a little more involved, since we have to juggle the state of each thread separately. We can do this using:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">zoom<span class="ot"> _1 ::</span> <span class="dt">MaybeT</span> (<span class="dt">State</span> s) a <span class="ot">-&gt;</span> <span class="dt">MaybeT</span> (<span class="dt">State</span> (s, t)) a
zoom<span class="ot"> _2 ::</span> <span class="dt">MaybeT</span> (<span class="dt">State</span> t) a <span class="ot">-&gt;</span> <span class="dt">MaybeT</span> (<span class="dt">State</span> (s, t)) a</code></pre></div>
<p>To “lift” our actions on one thread to be actions on a “tuple” of threads. We have, in the end:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L172-181</span>
<span class="ot">stepB ::</span> <span class="dt">MaybeT</span> (<span class="dt">State</span> (<span class="dt">Thread</span>, <span class="dt">Thread</span>)) <span class="dt">Int</span>
stepB <span class="fu">=</span> <span class="kw">do</span>
    outA <span class="ot">&lt;-</span> execWriterT <span class="fu">$</span>
      zoom _1 <span class="fu">.</span> many <span class="fu">$</span> runPromptM (interpMem <span class="fu">&gt;|&lt;</span> interpComB) stepProg
    outB <span class="ot">&lt;-</span> execWriterT <span class="fu">$</span>
      zoom _2 <span class="fu">.</span> many <span class="fu">$</span> runPromptM (interpMem <span class="fu">&gt;|&lt;</span> interpComB) stepProg
    _1 <span class="fu">.</span> tBuffer <span class="fu">.=</span> outB
    _2 <span class="fu">.</span> tBuffer <span class="fu">.=</span> outA
    guard <span class="fu">.</span> not <span class="fu">$</span> null outA <span class="fu">&amp;&amp;</span> null outB
    return <span class="fu">$</span> length outB</code></pre></div>
<p>Our final <code>stepB</code> really doesn’t need a <code>WriterT [Int]</code> – we just use that internally to collect <em>snd</em> outputs. So we use <code>execWriter</code> after “interpreting” our actions (along with <code>many</code>, to repeat our thread steps until they block) to just get the resulting logs.</p>
<p>We then reset the input buffers appropriately (by putting in the collected outputs of the previous threads).</p>
<p>If both threads are blocking (they both have to external outputs to pass on), then we’re done (using <code>guard</code>).</p>
<p>We return the number of items that “Program 1” (the second thread) outputs, because that’s what we need for our answer.</p>
<p>This is one “single pass” of both of our threads. As you can anticipate, we’ll use <code>many</code> again to run these multiple times until both threads block.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L183-191</span>
<span class="ot">partB ::</span> <span class="dt">P.PointedList</span> <span class="dt">Op</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
partB ops <span class="fu">=</span> sum <span class="fu">.</span> concat
          <span class="fu">.</span> flip evalState s0
          <span class="fu">.</span> runMaybeT
          <span class="fu">$</span> many stepB
  <span class="kw">where</span>
    s0 <span class="fu">=</span> ( <span class="dt">T</span> (<span class="dt">PS</span> ops (M.singleton <span class="ch">&#39;p&#39;</span> <span class="dv">0</span>)) []
         , <span class="dt">T</span> (<span class="dt">PS</span> ops (M.singleton <span class="ch">&#39;p&#39;</span> <span class="dv">1</span>)) []
         )</code></pre></div>
<h3 id="examples">Examples</h3>
<p>In the same source code, I’ve included by own puzzle input provided to me from the advent of code website. We can now get actual answers given some sample puzzle input:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L193-196</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    print <span class="fu">$</span> partA (parseProgram testProg)
    print <span class="fu">$</span> partB (parseProgram testProg)</code></pre></div></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Beginner/Intermediate Haskell Projects&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series" title="+Beginner/Intermediate Haskell Projects"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+beginner-intermediate-haskell-projects.html" class="tag-a-series">+Beginner/Intermediate Haskell Projects</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/interpreters-a-la-carte.html';
    this.page.identifier = 'interpreters';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>