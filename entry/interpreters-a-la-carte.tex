\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Interpreters a la Carte (Advent of Code 2017 Duet)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Interpreters a la Carte (Advent of Code 2017 Duet)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/interpreters-a-la-carte.html}{in
Code}}.}

This post is just a fun one exploring a wide range of techniques that I applied
to solve the Day 18 puzzles of this year's great
\href{http://adventofcode.com/2017}{Advent of Code}. The puzzles involved
interpreting an assembly language on an abstract machine. The neat twist is that
Part 1 gave you a description of one abstract machine, and Part 3 gave you a
\emph{different} abstract machine to interpret the same language in. This twist
(one language, but different interpreters/abstract machines) is basically one of
the textbook applications of the \emph{interpreter pattern} in Haskell and
functional programming, so it was fun to implement my solution in that pattern
-- the assembly language source was ``compiled'' to an abstract data type once,
and the difference between Part 1 and Part 2 was just a different choice of
interpreter.

Even more interesting is that the two machines are only ``half different'' --
there's one aspect of the virtual machines that are the same between the two
parts, and aspect that is different. This means that we can apply the ``data
types a la carte'' technique in order to mix and match isolated components of
virtual machine interpreters, and re-use code whenever possible in assembling
our interpreters for our different machines!

This blog post will not necessarily be a focused tutorial on this trick, but
rather an explanation on my solution centered around this pattern, hopefully
providing insight on how I approach and solve non-trivial Haskell problems.
Along the way we'll also use mtl typeclasses and classy lenses.

\section{The Puzzle}\label{the-puzzle}

The puzzle is \href{http://adventofcode.com/2017/day/18}{Advent of Code 2017 Day
18}, and Part 1 is:

\begin{quote}
You discover a tablet containing some strange assembly code labeled simply
``Duet''. Rather than bother the sound card with it, you decide to run the code
yourself. Unfortunately, you don't see any documentation, so you're left to
figure out what the instructions mean on your own.

It seems like the assembly is meant to operate on a set of \emph{registers} that
are each named with a single letter and that can each hold a single integer. You
suppose each register should start with a value of \texttt{0}.

There aren't that many instructions, so it shouldn't be hard to figure out what
they do. Here's what you determine:

\begin{itemize}
\tightlist
\item
  \texttt{snd\ X} \emph{plays a sound} with a frequency equal to the value of
  \texttt{X}.
\item
  \texttt{set\ X\ Y} \emph{sets} register \texttt{X} to the value of \texttt{Y}.
\item
  \texttt{add\ X\ Y} \emph{increases} register \texttt{X} by the value of
  \texttt{Y}.
\item
  \texttt{mul\ X\ Y} sets register \texttt{X} to the result of
  \emph{multiplying} the value contained in register \texttt{X} by the value of
  \texttt{Y}.
\item
  \texttt{mod\ X\ Y} sets register \texttt{X} to the \emph{remainder} of
  dividing the value contained in register \texttt{X} by the value of \texttt{Y}
  (that is, it sets \texttt{X} to the result of \texttt{X} modulo \texttt{Y}).
\item
  \texttt{rcv\ X} \emph{recovers} the frequency of the last sound played, but
  only when the value of \texttt{X} is not zero. (If it is zero, the command
  does nothing.)
\item
  \texttt{jgz\ X\ Y} \emph{jumps} with an offset of the value of \texttt{Y}, but
  only if the value of \texttt{X} is \emph{greater than zero}. (An offset of
  \texttt{2} skips the next instruction, an offset of \texttt{-1} jumps to the
  previous instruction, and so on.)
\end{itemize}

Many of the instructions can take either a register (a single letter) or a
number. The value of a register is the integer it contains; the value of a
number is that number.

After each \emph{jump} instruction, the program continues with the instruction
to which the \emph{jump} jumped. After any other instruction, the program
continues with the next instruction. Continuing (or jumping) off either end of
the program terminates it.

\emph{What is the value of the recovered frequency} (the value of the most
recently played sound) the \emph{first} time a \texttt{rcv} instruction is
executed with a non-zero value?
\end{quote}

Part 2, however, says:

\begin{quote}
As you congratulate yourself for a job well done, you notice that the
documentation has been on the back of the tablet this entire time. While you
actually got most of the instructions correct, there are a few key differences.
This assembly code isn't about sound at all - it's meant to be run \emph{twice
at the same time}.

Each running copy of the program has its own set of registers and follows the
code independently - in fact, the programs don't even necessarily run at the
same speed. To coordinate, they use the \emph{send} (\texttt{snd}) and
\emph{receive} (\texttt{rcv}) instructions:

\begin{itemize}
\tightlist
\item
  \texttt{snd\ X} \emph{sends} the value of \texttt{X} to the other program.
  These values wait in a queue until that program is ready to receive them. Each
  program has its own message queue, so a program can never receive a message it
  sent.
\item
  \texttt{rcv\ X} \emph{receives} the next value and stores it in register
  \texttt{X}. If no values are in the queue, the program \emph{waits for a value
  to be sent to it}. Programs do not continue to the next instruction until they
  have received a value. Values are received in the order they are sent.
\end{itemize}

Each program also has its own \emph{program ID} (one \texttt{0} and the other
\texttt{1}); the register \texttt{p} should begin with this value.

Once both of your programs have terminated (regardless of what caused them to do
so), \emph{how many times did program \texttt{1} send a value}?
\end{quote}

Note that in each of these, ``the program'' is a program (written in the Duet
assembly language), which is different for each user and given to us by the
site.

What's going on here is that both parts execute the same program in two
different virtual machines -- one has ``sound'' and ``recover'', and the other
has ``send'' and ``receive''. We are supposed to run the same program in
\emph{both} of these machines.

However, note that these two machines aren't \emph{completely} different -- they
both have the ability to manipulate memory and read/shift program data. So
really , we want to be able to create a ``modular'' spec and implementation of
these machines, so that we may re-use this memory manipulation aspect when
constructing our machine, without duplicating any code.

\section{Parsing Duet}\label{parsing-duet}

First, let's get the parsing of the actual input program out of the way. We'll
be parsing a program into a list of ``ops'' that we will read as our program.

Our program will be interpreted as a list of \texttt{Op} values, a data type
representing opcodes. There are four categories: ``snd'', ``rcv'', ``jgz'', and
the binary mathematical operations:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L21-26}
\KeywordTok{type} \DataTypeTok{Addr} \FunctionTok{=} \DataTypeTok{Either} \DataTypeTok{Char} \DataTypeTok{Int}

\KeywordTok{data} \DataTypeTok{Op} \FunctionTok{=} \DataTypeTok{OSnd} \DataTypeTok{Addr}
        \FunctionTok{|} \DataTypeTok{ORcv} \DataTypeTok{Char}
        \FunctionTok{|} \DataTypeTok{OJgz} \DataTypeTok{Addr} \DataTypeTok{Addr}
        \FunctionTok{|} \DataTypeTok{OBin}\NormalTok{ (}\DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Int}\NormalTok{) }\DataTypeTok{Char} \DataTypeTok{Addr}
\end{Highlighting}
\end{Shaded}

It's important to remember that ``snd'', ``jgz'', and the binary operations can
all take either numbers or other registers.

Now, parsing a single \texttt{Op} is just a matter of pattern matching on
\texttt{words}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L28-41}
\OtherTok{parseOp ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{Op}
\NormalTok{parseOp inp }\FunctionTok{=} \KeywordTok{case}\NormalTok{ words inp }\KeywordTok{of}
    \StringTok{"snd"}\FunctionTok{:}\NormalTok{c    }\FunctionTok{:}\NormalTok{_   }\OtherTok{->} \DataTypeTok{OSnd}\NormalTok{ (addr c)}
    \StringTok{"set"}\FunctionTok{:}\NormalTok{(x}\FunctionTok{:}\NormalTok{_)}\FunctionTok{:}\NormalTok{y}\FunctionTok{:}\NormalTok{_ }\OtherTok{->} \DataTypeTok{OBin}\NormalTok{ (const id) x (addr y)}
    \StringTok{"add"}\FunctionTok{:}\NormalTok{(x}\FunctionTok{:}\NormalTok{_)}\FunctionTok{:}\NormalTok{y}\FunctionTok{:}\NormalTok{_ }\OtherTok{->} \DataTypeTok{OBin}\NormalTok{ (}\FunctionTok{+}\NormalTok{)        x (addr y)}
    \StringTok{"mul"}\FunctionTok{:}\NormalTok{(x}\FunctionTok{:}\NormalTok{_)}\FunctionTok{:}\NormalTok{y}\FunctionTok{:}\NormalTok{_ }\OtherTok{->} \DataTypeTok{OBin}\NormalTok{ (}\FunctionTok{*}\NormalTok{)        x (addr y)}
    \StringTok{"mod"}\FunctionTok{:}\NormalTok{(x}\FunctionTok{:}\NormalTok{_)}\FunctionTok{:}\NormalTok{y}\FunctionTok{:}\NormalTok{_ }\OtherTok{->} \DataTypeTok{OBin}\NormalTok{ mod        x (addr y)}
    \StringTok{"rcv"}\FunctionTok{:}\NormalTok{(x}\FunctionTok{:}\NormalTok{_)}\FunctionTok{:}\NormalTok{_   }\OtherTok{->} \DataTypeTok{ORcv}\NormalTok{ x}
    \StringTok{"jgz"}\FunctionTok{:}\NormalTok{x    }\FunctionTok{:}\NormalTok{y}\FunctionTok{:}\NormalTok{_ }\OtherTok{->} \DataTypeTok{OJgz}\NormalTok{ (addr x) (addr y)}
\NormalTok{    _               }\OtherTok{->}\NormalTok{ error }\StringTok{"Bad parse"}
  \KeywordTok{where}
\OtherTok{    addr ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{Addr}
\NormalTok{    addr [c] }\FunctionTok{|}\NormalTok{ isAlpha c }\FunctionTok{=} \DataTypeTok{Left}\NormalTok{ c}
\NormalTok{    addr str }\FunctionTok{=} \DataTypeTok{Right}\NormalTok{ (read str)}
\end{Highlighting}
\end{Shaded}

We're going to store our program in a \texttt{PointedList} from the
\emph{\href{http://hackage.haskell.org/package/pointedlist}{pointedlist}}
package, which is a non-empty list with a ``focus'' at a given index, which we
use to represent the program counter/program head/current instruction. Parsing
our program is then just parsing each line in the program string, and collecting
them into a \texttt{PointedList}. We're ready to go!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L43-44}
\OtherTok{parseProgram ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{P.PointedList} \DataTypeTok{Op}
\NormalTok{parseProgram }\FunctionTok{=}\NormalTok{ fromJust }\FunctionTok{.}\NormalTok{ P.fromList }\FunctionTok{.}\NormalTok{ map parseOp }\FunctionTok{.}\NormalTok{ lines}
\end{Highlighting}
\end{Shaded}

\section{Our Virtual Machine}\label{our-virtual-machine}

\subsection{MonadPrompt}\label{monadprompt}

We're going to be using the great
\emph{\href{http://hackage.haskell.org/package/MonadPrompt}{MonadPrompt}}
library to build our representation of our interpreted language. Another common
choice is to use \emph{\href{http://hackage.haskell.org/package/free}{free}},
and a lot of other tutorials go down this route. However, \emph{free} is a bit
more power than you really need for the interpreter pattern, and I always felt
like the implementation of interpreter pattern programs in \emph{free} was a bit
awkward.

\emph{MonadPrompt} lets us construct a language (and a monad) using GADTs to
represent command primitives. For example, to implement something like
\texttt{State\ Int}, you might use this GADT:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{StateCommand}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{Put}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{StateCommand}\NormalTok{ ()}
    \DataTypeTok{Get}\OtherTok{ ::} \DataTypeTok{StateCommand} \DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

Which says that the two ``primitive'' commands of \texttt{State\ Int} are
``putting'' (which requires an \texttt{Int} and produces a \texttt{()} result)
and ``getting'' (which requires no inputs, and produces an \texttt{Int} result).

You can then write \texttt{State} as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{IntState} \FunctionTok{=} \DataTypeTok{Prompt} \DataTypeTok{StateCommand}
\end{Highlighting}
\end{Shaded}

And our primitives can be constructed using:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{prompt ::} \DataTypeTok{StateCommand}\NormalTok{ a }\OtherTok{->} \DataTypeTok{IntState}\NormalTok{ a}

\NormalTok{prompt (}\DataTypeTok{Put} \DecValTok{10}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{IntState}\NormalTok{ ()}
\NormalTok{prompt }\DataTypeTok{Get}\OtherTok{      ::} \DataTypeTok{IntState} \DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

Now, we \emph{interpret} an \texttt{IntState} in a monadic context using
\texttt{runPromptM}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{runPromptM}
\OtherTok{    ::} \DataTypeTok{Monad}\NormalTok{ m                              }\CommentTok{-- m is the monad to interpret in}
    \OtherTok{=>}\NormalTok{ (forall x}\FunctionTok{.} \DataTypeTok{StateCommand}\NormalTok{ x }\OtherTok{->}\NormalTok{ m x)    }\CommentTok{-- a way to interpret each primitive in 'm'}
    \OtherTok{->} \DataTypeTok{IntState}\NormalTok{ a                           }\CommentTok{-- IntState to interpret}
    \OtherTok{->}\NormalTok{ m a                                  }\CommentTok{-- resulting action in 'm'}
\end{Highlighting}
\end{Shaded}

So, if we wanted to use \texttt{IO} and \texttt{IORefs} as the mechanism for
interpreting our \texttt{IntState}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{interpretIO}
\OtherTok{    ::} \DataTypeTok{IORef} \DataTypeTok{Int}
    \OtherTok{->} \DataTypeTok{StateCommand}\NormalTok{ a}
    \OtherTok{->} \DataTypeTok{IO}\NormalTok{ a}
\NormalTok{interpretIO r }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}           \CommentTok{-- using -XLambdaCase}
    \DataTypeTok{Put}\NormalTok{ x }\OtherTok{->}\NormalTok{ writeIORef r x}
    \DataTypeTok{Get}   \OtherTok{->}\NormalTok{ readIORef r}

\OtherTok{runAsIO ::} \DataTypeTok{IntState}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ a}
\NormalTok{runAsIO m s0 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    r }\OtherTok{<-}\NormalTok{ newIORef s0}
\NormalTok{    runPromptM (interpretIO r) m}
\end{Highlighting}
\end{Shaded}

\texttt{interpretIO} is our interpreter, in \texttt{IO}. \texttt{runPromptM}
will interpret each primitive (\texttt{Put} and \texttt{Get}) using
\texttt{interpretIO}, and generate the result for us.

We can also be boring and interpret it using \texttt{State\ Int}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{interpretState ::} \DataTypeTok{StateCommand}\NormalTok{ a }\OtherTok{->} \DataTypeTok{State} \DataTypeTok{Int}\NormalTok{ a}
\NormalTok{interpretState }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{Put}\NormalTok{ x }\OtherTok{->}\NormalTok{ put x}
    \DataTypeTok{Get}   \OtherTok{->}\NormalTok{ get}

\OtherTok{runAsState ::} \DataTypeTok{IntState}\NormalTok{ a }\OtherTok{->} \DataTypeTok{State} \DataTypeTok{Int}\NormalTok{ a}
\NormalTok{runAsState }\FunctionTok{=}\NormalTok{ runPormptM interpretState}
\end{Highlighting}
\end{Shaded}

Basically, an \texttt{IntState\ a} is an abstract representation of a program
(as a Monad), and \texttt{interpretIO} and \texttt{interpretState} are different
ways of \emph{interpreting} that program, in different monadic contexts. To
``run'' or interpret our program in a context, we provide a function
\texttt{forall\ x.\ StateCommand\ x\ -\textgreater{}\ m\ x}, which interprets
each individual primitive command.

\subsection{Duet Commands}\label{duet-commands}

Now let's specify the ``primitives'' of our program. It'll be useful to separate
out the ``memory-based'' primitive commands from the ``communication-based''
primitive commands. This is so that we can write interpreters that operate on
each one individually.

For memory, we can access and modify register values, as well as jump around in
the program tape and read the \texttt{Op} at the current program head:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L46-50}
\KeywordTok{data} \DataTypeTok{Mem}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MGet}\OtherTok{ ::} \DataTypeTok{Char} \OtherTok{->} \DataTypeTok{Mem} \DataTypeTok{Int}
    \DataTypeTok{MSet}\OtherTok{ ::} \DataTypeTok{Char} \OtherTok{->} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Mem}\NormalTok{ ()}
    \DataTypeTok{MJmp}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Mem}\NormalTok{ ()}
    \DataTypeTok{MPk}\OtherTok{  ::} \DataTypeTok{Mem} \DataTypeTok{Op}
\end{Highlighting}
\end{Shaded}

For communication, we must be able to ``snd'' and ``rcv''.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L52-54}
\KeywordTok{data} \DataTypeTok{Com}\OtherTok{ ::} \DataTypeTok{Type} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{CSnd}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Com}\NormalTok{ ()}
    \DataTypeTok{CRcv}\OtherTok{ ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Com} \DataTypeTok{Int}
\end{Highlighting}
\end{Shaded}

Part 1 requires \texttt{CRcv} to take, as an argument, a number, since whether
or not \texttt{CRcv} is a no-op depends on the value of a certain register for
Part 1's virtual machine.

Now, we can leverage the \texttt{:\textbar{}:} type from
\emph{{[}type-combinators{]}{[}{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{ (f }\FunctionTok{:|:}\NormalTok{ g) a }\FunctionTok{=} \DataTypeTok{L}\NormalTok{ (f a)}
                 \FunctionTok{|} \DataTypeTok{R}\NormalTok{ (g a)}
\end{Highlighting}
\end{Shaded}

\texttt{:\textbar{}:} is a ``functor disjunction'' -- a value of type
\texttt{(f\ :\textbar{}:\ g)\ a} is either \texttt{f\ a} or \texttt{g\ a}.
\texttt{:\textbar{}:} is in \emph{base} twice, as \texttt{:+:} in
\emph{GHC.Generics} and as \texttt{Sum} in \emph{Data.Functor.Sum}. However, the
version in \emph{type-combinators} has some nice utility combinators we will be
using and is more fully-featured.

We can use \texttt{:\textbar{}:} to create the type
\texttt{Mem\ :\textbar{}:\ Com}. If \texttt{Mem} and \texttt{Com} represent
``primitives'' in our Duet language, then \texttt{Mem\ :\textbar{}:\ Com}
represents \emph{primitives from \texttt{Mem} and \texttt{Com} together}. It's a
type that contains all of the primitives of \texttt{Mem} and the primitives of
\texttt{Com} -- that is, it contains:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{L}\NormalTok{ (}\DataTypeTok{MGet} \CharTok{'c'}\NormalTok{)}\OtherTok{ ::}\NormalTok{ (}\DataTypeTok{Mem} \FunctionTok{:|:} \DataTypeTok{Com}\NormalTok{) }\DataTypeTok{Int}
\DataTypeTok{L} \DataTypeTok{MPk}\OtherTok{        ::}\NormalTok{ (}\DataTypeTok{Mem} \FunctionTok{:|:} \DataTypeTok{Com}\NormalTok{) }\DataTypeTok{Op}
\DataTypeTok{R}\NormalTok{ (}\DataTypeTok{CSnd} \DecValTok{5}\NormalTok{)}\OtherTok{   ::}\NormalTok{ (}\DataTypeTok{Mem} \FunctionTok{:|:} \DataTypeTok{Com}\NormalTok{) ()}
\end{Highlighting}
\end{Shaded}

etc.

Our final data type then -- a monad that encompasses \emph{all} possible Duet
primitive commands, is:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L56-56}
\KeywordTok{type} \DataTypeTok{Duet} \FunctionTok{=} \DataTypeTok{Prompt}\NormalTok{ (}\DataTypeTok{Mem} \FunctionTok{:|:} \DataTypeTok{Com}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can write some convenient utility primitives to make things easier for us in
the long run:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L58-74}
\OtherTok{dGet ::} \DataTypeTok{Char} \OtherTok{->} \DataTypeTok{Duet} \DataTypeTok{Int}
\NormalTok{dGet }\FunctionTok{=}\NormalTok{ prompt }\FunctionTok{.} \DataTypeTok{L} \FunctionTok{.} \DataTypeTok{MGet}

\OtherTok{dSet ::} \DataTypeTok{Char} \OtherTok{->} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{dSet r }\FunctionTok{=}\NormalTok{ prompt }\FunctionTok{.} \DataTypeTok{L} \FunctionTok{.} \DataTypeTok{MSet}\NormalTok{ r}

\OtherTok{dJmp ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{dJmp }\FunctionTok{=}\NormalTok{ prompt }\FunctionTok{.} \DataTypeTok{L} \FunctionTok{.} \DataTypeTok{MJmp}

\OtherTok{dPk ::} \DataTypeTok{Duet} \DataTypeTok{Op}
\NormalTok{dPk }\FunctionTok{=}\NormalTok{ prompt (}\DataTypeTok{L} \DataTypeTok{MPk}\NormalTok{)}

\OtherTok{dSnd ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{dSnd }\FunctionTok{=}\NormalTok{ prompt }\FunctionTok{.} \DataTypeTok{R} \FunctionTok{.} \DataTypeTok{CSnd}

\OtherTok{dRcv ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Duet} \DataTypeTok{Int}
\NormalTok{dRcv }\FunctionTok{=}\NormalTok{ prompt }\FunctionTok{.} \DataTypeTok{R} \FunctionTok{.} \DataTypeTok{CRcv}
\end{Highlighting}
\end{Shaded}

\subsection{Constructing Duet Programs}\label{constructing-duet-programs}

Armed with our \texttt{Duet} monad, we can now write a real-life \texttt{Duet}
action to represent \emph{one step} of our duet programs:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- source: https://github.com/mstksg/inCode/tree/master/code-samples/interpreters/Duet.hs#L76-97}
\OtherTok{stepProg ::} \DataTypeTok{Duet}\NormalTok{ ()}
\NormalTok{stepProg }\FunctionTok{=}\NormalTok{ dPk }\FunctionTok{>>=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{OSnd}\NormalTok{ x }\OtherTok{->} \KeywordTok{do}
\NormalTok{      dSnd }\FunctionTok{=<<}\NormalTok{ addrVal x}
\NormalTok{      dJmp }\DecValTok{1}
    \DataTypeTok{OBin}\NormalTok{ f x y }\OtherTok{->} \KeywordTok{do}
\NormalTok{      yVal }\OtherTok{<-}\NormalTok{ addrVal y}
\NormalTok{      xVal }\OtherTok{<-}\NormalTok{ dGet    x}
\NormalTok{      dSet x }\FunctionTok{$}\NormalTok{ f xVal yVal}
\NormalTok{      dJmp }\DecValTok{1}
    \DataTypeTok{ORcv}\NormalTok{ x }\OtherTok{->} \KeywordTok{do}
\NormalTok{      y }\OtherTok{<-}\NormalTok{ dRcv }\FunctionTok{=<<}\NormalTok{ dGet x}
\NormalTok{      dSet x y}
\NormalTok{      dJmp }\DecValTok{1}
    \DataTypeTok{OJgz}\NormalTok{ x y }\OtherTok{->} \KeywordTok{do}
\NormalTok{      xVal }\OtherTok{<-}\NormalTok{ addrVal x}
\NormalTok{      dJmp }\FunctionTok{=<<} \KeywordTok{if}\NormalTok{ xVal }\FunctionTok{>} \DecValTok{0}
                 \KeywordTok{then}\NormalTok{ addrVal y}
                 \KeywordTok{else}\NormalTok{ return }\DecValTok{1}
  \KeywordTok{where}
\NormalTok{    addrVal (}\DataTypeTok{Left}\NormalTok{ r ) }\FunctionTok{=}\NormalTok{ dGet r}
\NormalTok{    addrVal (}\DataTypeTok{Right}\NormalTok{ x) }\FunctionTok{=}\NormalTok{ return x}
\end{Highlighting}
\end{Shaded}

This is basically a straightforward interpretation of the ``rules'' of our
language, and what to do when encountering each op code.

The only non-trivial thing is the \texttt{ORcv} branch, where we include the
contents of the register in question, so that our interpreter will know whether
or not to treat it as a no-op.

\section{The Interpreters}\label{the-interpreters}

Now for the fun part!

\end{document}
