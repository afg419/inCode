\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Interpreters a la Carte (Advent of Code 2017 Duet)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Interpreters a la Carte (Advent of Code 2017 Duet)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/interpreters-a-la-carte.html}{in
Code}}.}

This post is just a fun one exploring a wide range of techniques that I applied
to solve the Day 18 puzzles of this year's great
\href{http://adventofcode.com/2017}{Advent of Code}. The puzzles involved
interpreting an assembly language on an abstract machine. The neat twist is that
Part 1 gave you a description of one abstract machine, and Part 2 gave you a
\emph{different} abstract machine to interpret the same language in. This twist
(one language, but different interpreters/abstract machines) is basically one of
the textbook applications of the \emph{interpreter pattern} in Haskell and
functional programming, so it was fun to implement my solution in that pattern
-- the assembly language source was ``compiled'' to an abstract data type once,
and the difference between Part 1 and Part 2 was just a different choice of
interpreter.

Even more interesting is that the two machines are only ``half different'' --
there's one aspect of the virtual machines that are the same between the two
parts, and aspect that is different. This means that we can apply the ``data
types a la carte'' technique in order to mix and match isolated components of
virtual machine interpreters, and re-use code whenever possible in assembling
our interpreters for our different machines!

\section{The Puzzle}\label{the-puzzle}

The puzzle is \href{http://adventofcode.com/2017/day/18}{Advent of Code 2017 Day
18}:

\begin{quote}
You discover a tablet containing some strange assembly code labeled simply
``Duet''. Rather than bother the sound card with it, you decide to run the code
yourself. Unfortunately, you don't see any documentation, so you're left to
figure out what the instructions mean on your own.

It seems like the assembly is meant to operate on a set of \emph{registers} that
are each named with a single letter and that can each hold a single integer. You
suppose each register should start with a value of \texttt{0}.

There aren't that many instructions, so it shouldn't be hard to figure out what
they do. Here's what you determine:

\begin{itemize}
\tightlist
\item
  \texttt{snd\ X} \emph{plays a sound} with a frequency equal to the value of
  \texttt{X}.
\item
  \texttt{set\ X\ Y} \emph{sets} register \texttt{X} to the value of \texttt{Y}.
\item
  \texttt{add\ X\ Y} \emph{increases} register \texttt{X} by the value of
  \texttt{Y}.
\item
  \texttt{mul\ X\ Y} sets register \texttt{X} to the result of
  \emph{multiplying} the value contained in register \texttt{X} by the value of
  \texttt{Y}.
\item
  \texttt{mod\ X\ Y} sets register \texttt{X} to the \emph{remainder} of
  dividing the value contained in register \texttt{X} by the value of \texttt{Y}
  (that is, it sets \texttt{X} to the result of \texttt{X} modulo \texttt{Y}).
\item
  \texttt{rcv\ X} \emph{recovers} the frequency of the last sound played, but
  only when the value of \texttt{X} is not zero. (If it is zero, the command
  does nothing.)
\item
  \texttt{jgz\ X\ Y} \emph{jumps} with an offset of the value of \texttt{Y}, but
  only if the value of \texttt{X} is \emph{greater than zero}. (An offset of
  \texttt{2} skips the next instruction, an offset of \texttt{-1} jumps to the
  previous instruction, and so on.)
\end{itemize}

Many of the instructions can take either a register (a single letter) or a
number. The value of a register is the integer it contains; the value of a
number is that number.

After each \emph{jump} instruction, the program continues with the instruction
to which the \emph{jump} jumped. After any other instruction, the program
continues with the next instruction. Continuing (or jumping) off either end of
the program terminates it.
\end{quote}

\end{document}
