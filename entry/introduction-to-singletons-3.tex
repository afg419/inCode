\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Introduction to Singletons (Part 3)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Introduction to Singletons (Part 3)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-3.html}{in
Code}}.}

Welcome back! This article is part 3 of our journey through the \emph{singleton
design pattern}, and the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library!

This post will be a continuation of
\href{https://blog.jle.im/entry/introduction-to-singletons-1.html}{Part 1} and
\href{https://blog.jle.im/entry/introduction-to-singletons-2.html}{Part 2}, so
if you haven't read those first, now would be a good time to pause and do so and
also work on some of the exercises. Today we will be expanding on the ideas in
those posts by working with more complex relationships between values and
lifting functions on values to functions on types. Like the previous posts, we
will start by writing things ``by hand'', and then jumping into the singletons
library and seeing how the framework gives you tools to work with these ideas in
a smoother way.

Code in this post is built on \emph{GHC 8.4.3} with the
\emph{\href{https://www.stackage.org/lts-12.9}{lts-12.9}} snapshot (so,
singletons-2.4.1).

\hypertarget{review}{%
\section{Review}\label{review}}

In the first post we looked at the \texttt{Door} type, indexed with a phantom
type of kind \texttt{DoorState}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}

\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::}\NormalTok{ \{}\OtherTok{ doorMaterial ::} \DataTypeTok{String}\NormalTok{ \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

This gives us (at least) three distinct types
\texttt{Door\ \textquotesingle{}Opened},
\texttt{Door\ \textquotesingle{}Closed}, and
\texttt{Door\ \textquotesingle{}Locked}, which can be used to represent opened,
closed, and locked doors, respectively.

This scheme gives us a few super-powers:

\begin{itemize}
\item
  The fact that these are three \emph{distinct} types allows us to enforce
  type-safety by prohibiting operations on certain types of doors.

  We saw this in the types of functions like
  \texttt{openDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed},
  which can only work on non-locked and closed doors.
\item
  Because the types are distinct, this allows our functions to be more
  expressive by stating how they change door states, programmatically.

  We saw this to a certain extent in functions like \texttt{openDoor},
  \texttt{closeDoor}, and \texttt{lockDoor}, where the function type signatures
  tell the user how the input and output doors are related. However, we will be
  taking this to a new level in this post.
\item
  But, because these types are all ``derived'' from the same type, we can also
  write functions that work on \emph{all} \texttt{Door}s. We saw this in
  functions like \texttt{lockAnyDoor}, and we also exploit this in our
  definition of \texttt{SomeDoor}.

  Essentially we also get a fourth type ``for free'':
  \texttt{forall\ s.\ Door\ s}, the type that can be used as any door. It's a
  subtype of all three of the above types!\footnote{Some subtle points for those
    more familiar with Haskell's type system: In Haskell, we say that a type
    \texttt{B} is a subtype of type \texttt{A} if, wherever a function expects
    an \texttt{A}, we can give a \texttt{B} instead. Any function that expects a
    \texttt{Door\ \textquotesingle{}Opened} will take a
    \texttt{forall\ s.\ Door\ s} (a type that can be instantiated with any
    \texttt{s}). However, the opposite is not true --- if a Rank-N function
    expects a \texttt{forall\ s.\ Door\ s}, you cannot give it a
    \texttt{Door\ \textquotesingle{}Opened}.}
\end{itemize}

Then we talked about situations where we want to ``not care'' about the door
status in the type system, or when we want to return a door with a state that is
not known statically, and must be determined dynamically at runtime. After going
through many ``analogous'' and equivalent type, we arrived at the existential
wrapper \texttt{SomeDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor ds mat }\FunctionTok{=}\NormalTok{ withSomeSing ds }\FunctionTok{$}\NormalTok{ \textbackslash{}dsSing }\OtherTok{->}
    \DataTypeTok{MkSomeDoor}\NormalTok{ dsSing mat}
\end{Highlighting}
\end{Shaded}

We must be careful to pack the \texttt{Sing\ s} with the \texttt{Door\ s}, so
that we can pattern match at runtime to determine what the original \texttt{s}
was.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{checkOpened ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Bool}
\NormalTok{checkOpened (}\DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ _) }\FunctionTok{=} \DataTypeTok{True}
\NormalTok{checkOpened (}\DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ _) }\FunctionTok{=} \DataTypeTok{False}
\NormalTok{checkOpened (}\DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ _) }\FunctionTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ x }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Opened} \StringTok{"Oak"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ y }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Closed} \StringTok{"Spruce"}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ checkOpened x}
\DataTypeTok{True}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ checkOpened y}
\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

Finally, we talked a bit about the ``unified'' singleton system that the
\emph{singleton} library offers. This included things like \texttt{SingI} to
implicitly pass singletons, and the \texttt{SingKind} kind-class that associates
types with their lifted kinds and lets you reify and reflect with functions like
\texttt{withSomeSing} and \texttt{fromSing}.

\hypertarget{path-to-expressive-relationships}{%
\section{Path to Expressive
Relationships}\label{path-to-expressive-relationships}}

Let's write a function that ``knocks'' on a door in IO:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knock d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

Hm. This doesn't seem right. We can't knock on an opened door..can we? We could
try enforcing this by writing:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knockClosed ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Closed} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockClosed d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}

\OtherTok{knockLocked ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockLocked d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

But, that means that the user must pick between one of two functions to open
their door. This isn't quite what we wanted\ldots{}we want the function to work
only for closed or locked doors, and not opened doors.

There are a couple of ways of doing this --- we're going to look at two possible
ways involving singletons and the \emph{singletons} library. Both of these
methods allow us to write dependently typed functions that are ``type-safe'' in
more expressive ways than before.

\hypertarget{dependently-typed-proofs}{%
\section{Dependently Typed Proofs}\label{dependently-typed-proofs}}

The first way to do this is with a dependently-typed ``proof'' that an operation
is legal.

\emph{Proofs} (in the dependently typed and Curry-Howard sense) are witnesses to
some type-level predicate or proposition.

A value-level predicate in Haskell is (generally) a function of type
\texttt{a\ -\textgreater{}\ Bool}. Given a value of type \texttt{a}, if the
function returns \texttt{True}, then the predicate is satisfied. If it returns
\texttt{False}, it is not.

A type-level predicate is (generally) a type constructor of kind
\texttt{k\ -\textgreater{}\ Type}. Given a type of kind \texttt{k}, if \emph{a
value exists of that type}, then the predicate is satisfied. If no value exists,
it is not. A value that ``proves'' a predicate is called a \emph{witness} or a
\emph{proof}.

We can define a predicate
\texttt{Knockable\ ::\ DoorState\ -\textgreater{}\ Type} as a GADT that only has
values if given \texttt{\textquotesingle{}Closed} and
\texttt{\textquotesingle{}Locked}, but not \texttt{\textquotesingle{}Opened}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Knockable}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{KnockClosed}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Closed}
    \DataTypeTok{KnockLocked}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Locked}
\end{Highlighting}
\end{Shaded}

Now, we have a value of type \texttt{Knockable\ \textquotesingle{}Closed} and
\texttt{Knockable\ \textquotesingle{}Locked} (\texttt{KnockClosed} and
\texttt{KnockLocked}, respectively), but no value of type
\texttt{Knockable\ \textquotesingle{}Opened}. How can we use this?

Well, we can make a version of \texttt{knock} that requires a proof that
\texttt{s} is \texttt{Knockable}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::} \DataTypeTok{Knockable}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knock _ d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

\texttt{knock} can now only be called with \texttt{Closed} and \texttt{Locked}
doors --- do you see why? There is no way to call \texttt{knock} with
\texttt{s\ \textasciitilde{}\ \textquotesingle{}Opened}\ldots{}because there is
no way to pass a value of \texttt{Knockable\ \textquotesingle{}Opened}. No such
value exists! There's no compiler error because it's ``not even wrong''!

This works well if we want to do things at compile-time

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock }\DataTypeTok{KnockClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Birch"}\NormalTok{)}
\DataTypeTok{Knock}\NormalTok{ knock on }\DataTypeTok{Birch}\NormalTok{ door}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

\hypertarget{let-the-compiler-prove-it-for-you}{%
\subsection{Let the compiler prove it for
you}\label{let-the-compiler-prove-it-for-you}}

We can even make it more seamless to use by auto-generating proofs at
compile-time, with a general class like \texttt{Auto}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Provable}\NormalTok{ p a }\KeywordTok{where}
\OtherTok{    auto ::}\NormalTok{ p a}

\KeywordTok{instance} \DataTypeTok{Provable} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Closed} \KeywordTok{where}
\NormalTok{    auto }\FunctionTok{=} \DataTypeTok{KnockClosed}

\KeywordTok{instance} \DataTypeTok{Provable} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Locked} \KeywordTok{where}
\NormalTok{    auto }\FunctionTok{=} \DataTypeTok{KnockLocked}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock auto (}\DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Acacia"}\NormalTok{)}
\DataTypeTok{Knock}\NormalTok{ knock on }\DataTypeTok{Acacia}\NormalTok{ door}\FunctionTok{!}

\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock auto (}\DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Opened} \StringTok{"Jungle"}\NormalTok{)}
\DataTypeTok{COMPILER} \DataTypeTok{ERROR}\FunctionTok{!!} \DataTypeTok{COMPILER} \DataTypeTok{ERROR}\FunctionTok{!!}
\end{Highlighting}
\end{Shaded}

Such a typeclass exists in libraries like
\emph{\href{http://hackage.haskell.org/package/type-combinators}{type-combinators}}
(called \texttt{Known}), and in dependently typed languages like Idris
\texttt{auto} is actually a built-in language keyword that does this
automatically!

\hypertarget{decidable-preducates}{%
\subsection{Decidable Preducates}\label{decidable-preducates}}

However, all of this only works if you know what \texttt{s} is at compile-time.
What if you don't? What if you are retrieving \texttt{s} at runtime (like from a
\texttt{SomeDoor} or \texttt{withSomeSing}), or you are forced to handle all
possible \texttt{s}s?

There's a property of some predicates called ``decidability''. We say that a
predicate is \emph{decidable} if, for any input type, we can say whether or not
the predicate is satisfiable.

We say that a predicate \texttt{p} in Haskell is decidable if we can write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decidePred}
\OtherTok{    ::} \DataTypeTok{Sing}\NormalTok{ a               }\CommentTok{-- ^ given a type}
    \OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (p a)       }\CommentTok{-- ^ return a decision}
\end{Highlighting}
\end{Shaded}

Where:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Decision}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Proved}\NormalTok{ a                  }\CommentTok{-- ^ a value of a exists}
                \FunctionTok{|} \DataTypeTok{Disproved}\NormalTok{ (}\DataTypeTok{Refuted}\NormalTok{ a)     }\CommentTok{-- ^ a value of a cannot exist}


\CommentTok{-- | The data type with no values}
\KeywordTok{data} \DataTypeTok{Void}

\CommentTok{-- | 'a' cannot exist.  Commonly also called `Not`}
\KeywordTok{type} \DataTypeTok{Refuted}\NormalTok{ a }\FunctionTok{=}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Void}
\end{Highlighting}
\end{Shaded}

(These types are all from the \emph{base} and \emph{singletons} library, mostly
in the \emph{Data.Singletons.Decide} module)

\texttt{Decision\ a} is kinda like a \texttt{Maybe\ a}, except instead of
\texttt{Nothing}, we include a proof that the predicate is \emph{not} true.

For those unfamiliar with the \texttt{a\ -\textgreater{}\ Void} idiom (often
called \texttt{Not\ a}, or \texttt{Refuted\ a}),
\texttt{a\ -\textgreater{}\ Void} is a type we use in Haskell to represent the
fact that it is impossible to construct a value of type \texttt{a}. That's
because if you could, then you could give it to an
\texttt{a\ -\textgreater{}\ Void} to get a value of type \texttt{Void}, which is
impossible to have.

It's a lot to handle up-front, so let's look at an example. Is
\texttt{Knockable} a decidable predicate? Yes!

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ s)}
\NormalTok{isKnockable }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Disproved} \FunctionTok{$}\NormalTok{ \textbackslash{}}\KeywordTok{case}            \CommentTok{-- s ~ 'Opened}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockClosed}           \CommentTok{-- s ~ 'Closed}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockLocked}           \CommentTok{-- s ~ 'Locked}
\end{Highlighting}
\end{Shaded}

This definition should seem pretty straightforward for the \texttt{SClosed} and
\texttt{SLocked} branches.
\texttt{isKnockable\ SClosed\ ::\ Decision\ (Knockable\ \textquotesingle{}Closed)},
we give \texttt{Proved\ KnockClosed}, which gives us just that!

However,
\texttt{isKnockable\ SOpened\ ::\ Decision\ (Knockable\ \textquotesingle{}Opened)}.
We can't use \texttt{Proved\ ::\ a\ -\textgreater{}\ Decision\ a}, because no
such value of type \texttt{Knockable\ \textquotesingle{}Opened} exists. So, we
have to say that we \emph{disprove} it: we have to prove to GHC that no such
type could possibly exist. We do this by providing a function of type
\texttt{Refuted\ (Knockable\ \textquotesingle{}Opened)}, or type
\texttt{Knockable\ \textquotesingle{}Opened\ -\textgreater{}\ Void}.

We can write it like this:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{disproveOpened ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Void}
\NormalTok{disproveOpened }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
\end{Highlighting}
\end{Shaded}

And we're good to go!

How does this work?

Well, remember, we have to pattern match on the possible inputs. However, we
can't use any of the ``legal'' patterns:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{disproveOpened ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Void}
\NormalTok{disproveOpened }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{KnockClosed} \OtherTok{->} \FunctionTok{...}    \CommentTok{-- not a valid pattern, since it's `Knockable 'Closed`}
    \DataTypeTok{KnockLocked} \OtherTok{->} \FunctionTok{...}    \CommentTok{-- not a valid pattern, since it's `Knockable 'Locked`}
\end{Highlighting}
\end{Shaded}

If you include either of those patterns, GHC will complain. So, there is no
valid pattern to match on\ldots{} so
\texttt{disproveOpened\ =\ \textbackslash{}case} is enough to write the function
\texttt{Knockable\ \textquotesingle{}Opened\ -\textgreater{}\ Void}.

We can use this decision function, finally, to handle an arbitrary \texttt{Door}
whose status we not know until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knockSomeDoor}
\OtherTok{    ::} \DataTypeTok{SomeDoor}     \CommentTok{-- ^ status not known until you pattern match at runtime}
    \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockSomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=} \KeywordTok{case}\NormalTok{ isKnockable s }\KeywordTok{of}
    \DataTypeTok{Proved}\NormalTok{ k    }\OtherTok{->}\NormalTok{ knock k d}
    \DataTypeTok{Disproved}\NormalTok{ _ }\OtherTok{->}\NormalTok{ putStrLn }\StringTok{"No knocking allowed!"}
\end{Highlighting}
\end{Shaded}

\hypertarget{perspective-on-proofs}{%
\subsection{Perspective on Proofs}\label{perspective-on-proofs}}

We briefly touched on a very simple version of a dependently typed proof, and
how to ``prove'' properties.

If you have heard things about dependently typed programming before, you might
have heard that a lot of it involves ``proving properties about your programs''
and ``forcing you to provide proofs for all of your actions''. The idea of a
``proof'' might seem a bit scary and ``mathematical'' to those coming from a
software development world.

However, as we just saw, working with proofs and decisions of proofs can be as
simple as a couple lines of GADTs and dependent pattern matches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Knockable}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{KnockClosed}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Closed}
    \DataTypeTok{KnockLocked}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Locked}

\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ s)}
\NormalTok{isKnockable }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Disproved} \FunctionTok{$}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockClosed}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockLocked}
\end{Highlighting}
\end{Shaded}

\texttt{Knockable} is our \emph{predicate}, values of type \texttt{Knockable\ s}
are our \emph{proofs} (or witnesses), and \texttt{isKnockable} is our
\emph{decision function}. So, when we see a function like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::} \DataTypeTok{Knockable}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

We can read the type signature as: ``Knocking requires both a \texttt{Door\ s}
and a \emph{proof} that the door's status is \texttt{Knockable}''. It makes it
impossible for us to run \texttt{knock} on a status that is not
\texttt{Knockable}, like, say, \texttt{\textquotesingle{}Opened}.

In this light, the role of a proof is like a ``key'' that a type (like
\texttt{\textquotesingle{}Closed}) must provide to ``unlock'' functions like
\texttt{knock}.\footnote{Sorry to mix up similar metaphors like this! Definitely
  not intentional :)} A \emph{decision function} is a function to generate these
proofs (or prove that they are impossible) for given types.

A lot of people think of proofs as ``compiler tricks'', or things that exist
only to appease the compiler. And, in a sense, this is true. Compilers of
languages that encourage heavy usage of proofs (like Agda, Coq, Idris) actually
implement something called \emph{proof erasure}. That is, values like
\texttt{KnockClosed} and \texttt{KnockLocked} might never exist at runtime,
since they never actually \emph{do} anything at runtime. They only exist as ways
to limit or enable specific programs from compiling, and serve no purpose after
compilation. GHC Haskell does not implement proof erasure at the time of this
post (Current GHC version 8.4), but if proofs like this become commonplace, you
might be reading this during a time where GHC Haskell erases proofs like
\texttt{Knockable} witnesses :)

\hypertarget{singletons-and-proofs}{%
\subsection{Singletons and Proofs}\label{singletons-and-proofs}}

Proofs might not play a role at run-time, but generating them with types
requires being able to pattern match and work with \emph{types} at run-time.
Because of this, singletons play an important role in working with proofs in
Haskell.

After all, remember the type of our decision function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

Decision functions should be able to fully exploit the structure of any types
they are scrutinizing in order to make their decision.

In this light, the \emph{singletons} library provides many tools for working
with proofs and decisions. In fact, the entire \emph{Data.Singletons.Decide}
module is dedicated to working with proofs and decisions. It provides the
\texttt{Decision} data type and \texttt{Refuted} type synonym, both featured
above.

It also re-exports a particularly useful predicate from \emph{base},
\emph{propositional equality}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\OtherTok{ (:~:) ::}\NormalTok{ k }\OtherTok{->}\NormalTok{ k }\OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{Refl}\OtherTok{ ::}\NormalTok{ a }\FunctionTok{:~:}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Like how \texttt{Knockable} is a predicate that a given status is ``knockable'',
\texttt{\textquotesingle{}Blah\ :\textasciitilde{}:} is a predicate that a given
type is \emph{equal to} \texttt{\textquotesingle{}Blah}. A value of type
\texttt{Knockable\ s} is a proof that \texttt{s} is knockable, and a value of
type \texttt{\textquotesingle{}Blah\ :\textasciitilde{}:\ a} is a proof that
\texttt{a} is \emph{equal to} \texttt{\textquotesingle{}Blah}.

If you are having trouble seeing how, note the constructors that it allows.
Remember that we limit \texttt{Knockable\ s} to only having ``knockable''
\texttt{s} by only allowing two constructors, so we can only construct valid
values. The same thing happens here --
\texttt{\textquotesingle{}Blah\ :\textasciitilde{}:} only has \emph{one single
constructor}:
\texttt{Refl\ ::\ \textquotesingle{}Blah\ :\textasciitilde{}:\ \textquotesingle{}Blah}.
The only valid constructor is one where the left hand side is equal to the right
hand side.

It also offers the ``kindclass'' \texttt{SDecide}, which provides \emph{decision
functions} for the \texttt{a\ :\textasciitilde{}:} predicate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SDecide}\NormalTok{ k }\KeywordTok{where}
\OtherTok{    (%~) ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k) }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{b ::}\NormalTok{ k) }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Sing}\NormalTok{ (a }\FunctionTok{:~:}\NormalTok{ b))}
\end{Highlighting}
\end{Shaded}

For example, \texttt{Bool} is an instance of \texttt{SDecide}, so we have a
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DataTypeTok{STrue} \FunctionTok{%~}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ b }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ ('}\DataTypeTok{True} \FunctionTok{:~:}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

Which is a decision function to check if \texttt{b} is equal to
\texttt{\textquotesingle{}True}.

\hypertarget{type-level-functions}{%
\section{Type Level Functions}\label{type-level-functions}}

Hi

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
