\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Introduction to Singletons (Part 3)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Introduction to Singletons (Part 3)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-3.html}{in
Code}}.}

Welcome back! This article is part 3 of our journey through the \emph{singleton
design pattern}, and the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library!

This post will be a continuation of
\href{https://blog.jle.im/entry/introduction-to-singletons-1.html}{Part 1} and
\href{https://blog.jle.im/entry/introduction-to-singletons-2.html}{Part 2}, so
if you haven't read those first, now would be a good time to pause and do so and
also work on some of the exercises. Today we will be expanding on the ideas in
those posts by working with more complex relationships between values and
lifting functions on values to functions on types. Like the previous posts, we
will start by writing things ``by hand'', and then jumping into the singletons
library and seeing how the framework gives you tools to work with these ideas in
a smoother way.

Code in this post is built on \emph{GHC 8.4.3} with the
\emph{\href{https://www.stackage.org/lts-12.9}{lts-12.9}} snapshot (so,
singletons-2.4.1).

\hypertarget{review}{%
\section{Review}\label{review}}

In the first post we looked at the \texttt{Door} type, indexed with a phantom
type of kind \texttt{DoorState}.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data DoorState = Opened | Closed | Locked}
\NormalTok{    deriving (Show, Eq)}
\NormalTok{  |])}

\KeywordTok{data} \DataTypeTok{Door}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{UnsafeMkDoor}\OtherTok{ ::}\NormalTok{ \{}\OtherTok{ doorMaterial ::} \DataTypeTok{String}\NormalTok{ \} }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s}
\end{Highlighting}
\end{Shaded}

This gives us (at least) three distinct types
\texttt{Door\ \textquotesingle{}Opened},
\texttt{Door\ \textquotesingle{}Closed}, and
\texttt{Door\ \textquotesingle{}Locked}, which can be used to represent opened,
closed, and locked doors, respectively.

This scheme gives us a few super-powers:

\begin{itemize}
\item
  The fact that these are three \emph{distinct} types allows us to enforce
  type-safety by prohibiting operations on certain types of doors.

  We saw this in the types of functions like
  \texttt{openDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed},
  which can only work on non-locked and closed doors.
\item
  Because the types are distinct, this allows our functions to be more
  expressive by stating how they change door states, programmatically.

  We saw this to a certain extent in functions like \texttt{openDoor},
  \texttt{closeDoor}, and \texttt{lockDoor}, where the function type signatures
  tell the user how the input and output doors are related. However, we will be
  taking this to a new level in this post.
\item
  But, because these types are all ``derived'' from the same type, we can also
  write functions that work on \emph{all} \texttt{Door}s. We saw this in
  functions like \texttt{lockAnyDoor}, and we also exploit this in our
  definition of \texttt{SomeDoor}.

  Essentially we also get a fourth type ``for free'':
  \texttt{forall\ s.\ Door\ s}, the type that can be used as any door. It's a
  subtype of all three of the above types!\footnote{Some subtle points for those
    more familiar with Haskell's type system: In Haskell, we say that a type
    \texttt{B} is a subtype of type \texttt{A} if, wherever a function expects
    an \texttt{A}, we can give a \texttt{B} instead. Any function that expects a
    \texttt{Door\ \textquotesingle{}Opened} will take a
    \texttt{forall\ s.\ Door\ s} (a type that can be instantiated with any
    \texttt{s}). However, the opposite is not true --- if a Rank-N function
    expects a \texttt{forall\ s.\ Door\ s}, you cannot give it a
    \texttt{Door\ \textquotesingle{}Opened}.}
\end{itemize}

Then we talked about situations where we want to ``not care'' about the door
status in the type system, or when we want to return a door with a state that is
not known statically, and must be determined dynamically at runtime. After going
through many ``analogous'' and equivalent type, we arrived at the existential
wrapper \texttt{SomeDoor}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{SomeDoor}\OtherTok{ ::} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{MkSomeDoor}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{SomeDoor}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{mkSomeDoor ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{SomeDoor}
\NormalTok{mkSomeDoor ds mat }\FunctionTok{=}\NormalTok{ withSomeSing ds }\FunctionTok{$}\NormalTok{ \textbackslash{}dsSing }\OtherTok{->}
    \DataTypeTok{MkSomeDoor}\NormalTok{ dsSing mat}
\end{Highlighting}
\end{Shaded}

We must be careful to pack the \texttt{Sing\ s} with the \texttt{Door\ s}, so
that we can pattern match at runtime to determine what the original \texttt{s}
was.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{checkOpened ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{Bool}
\NormalTok{checkOpened (}\DataTypeTok{MkSomeDoor} \DataTypeTok{SOpened}\NormalTok{ _) }\FunctionTok{=} \DataTypeTok{True}
\NormalTok{checkOpened (}\DataTypeTok{MkSomeDoor} \DataTypeTok{SClosed}\NormalTok{ _) }\FunctionTok{=} \DataTypeTok{False}
\NormalTok{checkOpened (}\DataTypeTok{MkSomeDoor} \DataTypeTok{SLocked}\NormalTok{ _) }\FunctionTok{=} \DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ x }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Opened} \StringTok{"Oak"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ y }\FunctionTok{=}\NormalTok{ mkSomeDoor }\DataTypeTok{Closed} \StringTok{"Spruce"}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ checkOpened x}
\DataTypeTok{True}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ checkOpened y}
\DataTypeTok{False}
\end{Highlighting}
\end{Shaded}

Finally, we talked a bit about the ``unified'' singleton system that the
\emph{singleton} library offers. This included things like \texttt{SingI} to
implicitly pass singletons, and the \texttt{SingKind} kind-class that associates
types with their lifted kinds and lets you reify and reflect with functions like
\texttt{withSomeSing} and \texttt{fromSing}.

\hypertarget{more-expressive-restrictions}{%
\section{More Expressive Restrictions}\label{more-expressive-restrictions}}

Let's write a function that ``knocks'' on a door in IO:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knock d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

Hm. This doesn't seem right. We can't knock on an opened door..can we? We could
try enforcing this by writing:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knockClosed ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Closed} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockClosed d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}

\OtherTok{knockLocked ::} \DataTypeTok{Door}\NormalTok{ '}\DataTypeTok{Locked} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockLocked d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

But, that means that the user must pick between one of two functions to open
their door. This isn't quite what we wanted\ldots{}we want the function to work
only for closed or locked doors, and not opened doors.

There are a couple of ways of doing this --- we're going to look at two possible
ways involving singletons and the \emph{singletons} library. Both of these
methods allow us to write dependently typed functions that are ``type-safe'' in
more expressive ways than before.

\hypertarget{dependently-typed-proofs}{%
\subsection{Dependently Typed Proofs}\label{dependently-typed-proofs}}

The first way to do this is with a dependently-typed ``proof'' that an operation
is legal.

\emph{Proofs} (in the dependently typed and Curry-Howard sense) are witnesses to
some type-level predicate or proposition.

A value-level predicate in Haskell is (generally) a function of type
\texttt{a\ -\textgreater{}\ Bool}. Given a value of type \texttt{a}, if the
function returns \texttt{True}, then the predicate is satisfied. If it returns
\texttt{False}, it is not.

A type-level predicate is (generally) a type constructor of kind
\texttt{k\ -\textgreater{}\ Type}. Given a type of kind \texttt{k}, if \emph{a
value exists of that type}, then the predicate is satisfied. If no value exists,
it is not. A value that ``proves'' a predicate is called a \emph{witness} or a
\emph{proof}.

We can define a predicate
\texttt{Knockable\ ::\ DoorState\ -\textgreater{}\ Type} as a GADT that only has
values if given \texttt{\textquotesingle{}Closed} and
\texttt{\textquotesingle{}Locked}, but not \texttt{\textquotesingle{}Opened}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Knockable}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{KnockClosed}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Closed}
    \DataTypeTok{KnockLocked}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Locked}
\end{Highlighting}
\end{Shaded}

Now, we have a value of type \texttt{Knockable\ \textquotesingle{}Closed} and
\texttt{Knockable\ \textquotesingle{}Locked} (\texttt{KnockClosed} and
\texttt{KnockLocked}, respectively), but no value of type
\texttt{Knockable\ \textquotesingle{}Opened}. How can we use this?

Well, we can make a version of \texttt{knock} that requires a proof that
\texttt{s} is \texttt{Knockable}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::} \DataTypeTok{Knockable}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knock _ d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

\texttt{knock} can now only be called with \texttt{Closed} and \texttt{Locked}
doors --- do you see why? There is no way to call \texttt{knock} with
\texttt{s\ \textasciitilde{}\ \textquotesingle{}Opened}\ldots{}because there is
no way to pass a value of \texttt{Knockable\ \textquotesingle{}Opened}. No such
value exists! There's no compiler error because it's ``not even wrong''!

This works well if we want to do things at compile-time

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock }\DataTypeTok{KnockClosed}\NormalTok{ (}\DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Birch"}\NormalTok{)}
\DataTypeTok{Knock}\NormalTok{ knock on }\DataTypeTok{Birch}\NormalTok{ door}\FunctionTok{!}
\end{Highlighting}
\end{Shaded}

\hypertarget{let-the-compiler-prove-it-for-you}{%
\subsubsection{Let the compiler prove it for
you}\label{let-the-compiler-prove-it-for-you}}

We can even make it more seamless to use by auto-generating proofs at
compile-time, with a general class like \texttt{Auto}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Provable}\NormalTok{ p a }\KeywordTok{where}
\OtherTok{    auto ::}\NormalTok{ p a}

\KeywordTok{instance} \DataTypeTok{Provable} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Closed} \KeywordTok{where}
\NormalTok{    auto }\FunctionTok{=} \DataTypeTok{KnockClosed}

\KeywordTok{instance} \DataTypeTok{Provable} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Locked} \KeywordTok{where}
\NormalTok{    auto }\FunctionTok{=} \DataTypeTok{KnockLocked}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock auto (}\DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Acacia"}\NormalTok{)}
\DataTypeTok{Knock}\NormalTok{ knock on }\DataTypeTok{Acacia}\NormalTok{ door}\FunctionTok{!}

\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock auto (}\DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Opened} \StringTok{"Jungle"}\NormalTok{)}
\DataTypeTok{COMPILER} \DataTypeTok{ERROR}\FunctionTok{!!} \DataTypeTok{COMPILER} \DataTypeTok{ERROR}\FunctionTok{!!}
\end{Highlighting}
\end{Shaded}

Such a typeclass exists in libraries like
\emph{\href{http://hackage.haskell.org/package/type-combinators}{type-combinators}}
(called \texttt{Known}), and in dependently typed languages like Idris,
\texttt{auto} is actually a built-in language keyword that does this
automatically!

\hypertarget{decidable-predicates}{%
\subsubsection{Decidable Predicates}\label{decidable-predicates}}

However, all of this only works if you know what \texttt{s} is at compile-time.
What if you don't? What if you are retrieving \texttt{s} at runtime (like from a
\texttt{SomeDoor} or \texttt{withSomeSing}), or you are forced to handle all
possible \texttt{s}s?

To do this, we're going to take advantage of a property of some predicates
called ``decidability''. We say that a predicate is \emph{decidable} if, for any
input type, we can say whether or not the predicate is satisfiable.

We say that a predicate \texttt{p} in Haskell is decidable if we can write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decidePred}
\OtherTok{    ::} \DataTypeTok{Sing}\NormalTok{ a               }\CommentTok{-- ^ given a type}
    \OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (p a)       }\CommentTok{-- ^ return a decision}
\end{Highlighting}
\end{Shaded}

Where:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Decision}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Proved}\NormalTok{ a                  }\CommentTok{-- ^ a value of a exists}
                \FunctionTok{|} \DataTypeTok{Disproved}\NormalTok{ (}\DataTypeTok{Refuted}\NormalTok{ a)     }\CommentTok{-- ^ a value of a cannot exist}

\CommentTok{-- | The data type with no values}
\KeywordTok{data} \DataTypeTok{Void}

\CommentTok{-- | 'a' cannot exist.  Commonly also called `Not`}
\KeywordTok{type} \DataTypeTok{Refuted}\NormalTok{ a }\FunctionTok{=}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Void}
\end{Highlighting}
\end{Shaded}

\texttt{Decision\ a} is kinda like a \texttt{Maybe\ a}, except instead of
\texttt{Nothing}, we include a proof that the predicate is \emph{not} true.

For those unfamiliar with the \texttt{a\ -\textgreater{}\ Void} idiom (often
called \texttt{Not\ a}, or \texttt{Refuted\ a}),
\texttt{a\ -\textgreater{}\ Void} is a type we use in Haskell to represent the
fact that it is impossible to construct a value of type \texttt{a}. That's
because if you could, then you could give it to an
\texttt{a\ -\textgreater{}\ Void} to get a value of type \texttt{Void}, which is
impossible to have.

It's a lot to handle all at once, so let's look at an example. Is
\texttt{Knockable} a decidable predicate? Yes!

We need to write a function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ s)}
\end{Highlighting}
\end{Shaded}

I recommend taking a moment and trying to implement this yourself. Remember to
enable \texttt{-Wall} to make sure you're handling all potential pattern
matching cases.

Are you ready? Here's a solution:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ s)}
\NormalTok{isKnockable }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Disproved} \FunctionTok{$}\NormalTok{ \textbackslash{}}\KeywordTok{case}            \CommentTok{-- s ~ 'Opened}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockClosed}           \CommentTok{-- s ~ 'Closed}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockLocked}           \CommentTok{-- s ~ 'Locked}
\end{Highlighting}
\end{Shaded}

This definition should seem pretty straightforward for the \texttt{SClosed} and
\texttt{SLocked} branches.
\texttt{isKnockable\ SClosed\ ::\ Decision\ (Knockable\ \textquotesingle{}Closed)},
we give \texttt{Proved\ KnockClosed}, which gives us just that!

However,
\texttt{isKnockable\ SOpened\ ::\ Decision\ (Knockable\ \textquotesingle{}Opened)}.
We can't use \texttt{Proved\ ::\ a\ -\textgreater{}\ Decision\ a}, because no
such value of type \texttt{Knockable\ \textquotesingle{}Opened} exists. So, we
have to say that we \emph{disprove} it: we have to prove to GHC that no such
type could possibly exist. We do this by providing a function of type
\texttt{Refuted\ (Knockable\ \textquotesingle{}Opened)}, or type
\texttt{Knockable\ \textquotesingle{}Opened\ -\textgreater{}\ Void}.

We can write it like this:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{disproveOpened ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Void}
\NormalTok{disproveOpened k }\FunctionTok{=} \KeywordTok{case}\NormalTok{ k }\KeywordTok{of}\NormalTok{ \{\}             }\CommentTok{-- empty pattern match}
\end{Highlighting}
\end{Shaded}

And we're good to go!

How does this work?

Well, remember, we have to pattern match on the possible inputs. However, we
can't use any of the ``legal'' patterns:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{disproveOpened ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Opened} \OtherTok{->} \DataTypeTok{Void}
\NormalTok{disproveOpened k }\FunctionTok{=} \KeywordTok{case}\NormalTok{ k }\KeywordTok{of}
    \DataTypeTok{KnockClosed} \OtherTok{->} \FunctionTok{...}    \CommentTok{-- not a valid pattern, since it's `Knockable 'Closed`}
    \DataTypeTok{KnockLocked} \OtherTok{->} \FunctionTok{...}    \CommentTok{-- not a valid pattern, since it's `Knockable 'Locked`}
\end{Highlighting}
\end{Shaded}

If you include either of those patterns, GHC will complain. So, there is no
valid pattern to match on\ldots{} so
\texttt{disproveOpened\ =\ \textbackslash{}case} is enough to write the function
\texttt{Knockable\ \textquotesingle{}Opened\ -\textgreater{}\ Void}.

We can use this decision function, finally, to handle an arbitrary \texttt{Door}
whose status we not know until runtime:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knockSomeDoor}
\OtherTok{    ::} \DataTypeTok{SomeDoor}     \CommentTok{-- ^ status not known until you pattern match at runtime}
    \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockSomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=} \KeywordTok{case}\NormalTok{ isKnockable s }\KeywordTok{of}
    \DataTypeTok{Proved}\NormalTok{ k    }\OtherTok{->}\NormalTok{ knock k d}
    \DataTypeTok{Disproved}\NormalTok{ _ }\OtherTok{->}\NormalTok{ putStrLn }\StringTok{"No knocking allowed!"}
\end{Highlighting}
\end{Shaded}

\hypertarget{perspective-on-proofs}{%
\subsubsection{Perspective on Proofs}\label{perspective-on-proofs}}

We briefly touched on a very simple version of a dependently typed proof, and
how to ``prove'' properties.

If you have heard things about dependently typed programming before, you might
have heard that a lot of it involves ``proving properties about your programs''
and ``forcing you to provide proofs for all of your actions''. The idea of a
``proof'' might seem a bit scary and ``mathematical'' to those coming from a
software development world.

However, as we just saw, working with proofs and decisions of proofs can be as
simple as a couple lines of GADTs and dependent pattern matches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Knockable}\OtherTok{ ::} \DataTypeTok{DoorState} \OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{KnockClosed}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Closed}
    \DataTypeTok{KnockLocked}\OtherTok{ ::} \DataTypeTok{Knockable}\NormalTok{ '}\DataTypeTok{Locked}

\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ s)}
\NormalTok{isKnockable }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{Disproved} \FunctionTok{$}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockClosed}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{Proved} \DataTypeTok{KnockLocked}
\end{Highlighting}
\end{Shaded}

\texttt{Knockable} is our \emph{predicate}, values of type \texttt{Knockable\ s}
are our \emph{proofs} (or witnesses), and \texttt{isKnockable} is our
\emph{decision function}. So, when we see a function like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::} \DataTypeTok{Knockable}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

We can read the type signature as: ``Knocking requires both a \texttt{Door\ s}
and a \emph{proof} that the door's status is \texttt{Knockable}''. It makes it
impossible for us to run \texttt{knock} on a status that is not
\texttt{Knockable}, like, say, \texttt{\textquotesingle{}Opened}.

In this light, the role of a proof is like a ``key'' that a type (like
\texttt{\textquotesingle{}Closed}) must provide to ``unlock'' functions like
\texttt{knock}.\footnote{Sorry to mix up similar metaphors like this! Definitely
  not intentional :)} A \emph{decision function} is a function to generate these
proofs (or prove that they are impossible) for given types.

Proofs are often thought of as ``compiler tricks'', or things that exist only to
appease the compiler. Compilers of languages that encourage heavy usage of
proofs (like Agda, Coq, Idris) actually implement something called \emph{proof
erasure}. That is, values like \texttt{KnockClosed} and \texttt{KnockLocked}
might never exist at runtime, since they never actually \emph{do} anything at
runtime. They only exist as ways to limit or enable specific programs from
compiling, and serve no purpose after compilation. GHC Haskell does not
implement proof erasure at the time of this post (current GHC version 8.6), but
if proofs like this become commonplace, you might be reading this during a time
where GHC Haskell erases proofs like \texttt{Knockable} witnesses :)

\hypertarget{the-role-of-singletons}{%
\subsubsection{The Role of Singletons}\label{the-role-of-singletons}}

Proofs themselves might not play a role at run-time, but generating/deciding
them with types requires being able to pattern match and work with \emph{types}
at run-time. Because of this, singletons play an important practical role in
working with proofs in Haskell.

After all, remember the type of our decision function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{isKnockable ::} \DataTypeTok{Sing}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (}\DataTypeTok{Knockable}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

The \texttt{Sing} allows \texttt{isKnockable} to pattern match and inspect the
\emph{type} \texttt{a} to create your proof.

In this light, the \emph{singletons} library provides many tools for working
with proofs and decisions. In fact, the entire \emph{Data.Singletons.Decide}
module is dedicated to working with proofs and decisions. It provides the
\texttt{Decision} data type and \texttt{Refuted} type synonym, both featured
above.

It also re-exports a particularly useful predicate from \emph{base},
\emph{propositional equality}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\OtherTok{ (:~:) ::}\NormalTok{ k }\OtherTok{->}\NormalTok{ k }\OtherTok{->} \DataTypeTok{Type} \KeywordTok{where}
    \DataTypeTok{Refl}\OtherTok{ ::}\NormalTok{ a }\FunctionTok{:~:}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

Like how \texttt{Knockable} is a predicate that a given status is ``knockable'',
\texttt{\textquotesingle{}Blah\ :\textasciitilde{}:} is a predicate that a given
type is \emph{equal to} \texttt{\textquotesingle{}Blah}. A value of type
\texttt{Knockable\ s} is a proof that \texttt{s} is knockable, and a value of
type \texttt{\textquotesingle{}Blah\ :\textasciitilde{}:\ a} is a proof that
\texttt{a} is \emph{equal to} \texttt{\textquotesingle{}Blah}.

If you are having trouble seeing how, note the constructors that it allows.
Remember that we limit \texttt{Knockable\ s} to only having ``knockable''
\texttt{s} by only allowing two constructors, so we can only construct valid
values. The same thing happens here --
\texttt{\textquotesingle{}Blah\ :\textasciitilde{}:} only has \emph{one single
constructor}:
\texttt{Refl\ ::\ \textquotesingle{}Blah\ :\textasciitilde{}:\ \textquotesingle{}Blah}.
The only valid constructor is one where the left hand side is equal to the right
hand side.

It also offers the ``kindclass'' \texttt{SDecide}, which provides \emph{decision
functions} for the \texttt{a\ :\textasciitilde{}:} predicate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{SDecide}\NormalTok{ k }\KeywordTok{where}
\OtherTok{    (%~) ::} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{a ::}\NormalTok{ k)}
         \OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\OtherTok{b ::}\NormalTok{ k)}
         \OtherTok{->} \DataTypeTok{Decision}\NormalTok{ (a }\FunctionTok{:~:}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

For example, \texttt{Bool} is an instance of \texttt{SDecide}, so we have a
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DataTypeTok{STrue} \FunctionTok{%~}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Sing}\NormalTok{ b }\OtherTok{->} \DataTypeTok{Decision}\NormalTok{ ('}\DataTypeTok{True} \FunctionTok{:~:}\NormalTok{ b)}
\end{Highlighting}
\end{Shaded}

which is a decision function to check if \texttt{b} is equal to
\texttt{\textquotesingle{}True}. You can sort of imagine \texttt{SDecide} as a
type-level \texttt{Eq} typeclass, but for ``type equality''.

\hypertarget{type-level-functions}{%
\subsection{Type Level Functions}\label{type-level-functions}}

Dependently typed proofs are useful because they are constructed to exploit the
``structure'' of the types you create. Essentially, we create a data type
(predicate) in a way so that it is impossible to create an ``invalid'' proof.
And, often, if we write our proofs in a clever enough way, we can actually use
and combine proofs to generate new proofs.

Personally I find this to be the source of a lot of the ``fun'' of dependently
typed programming --- our proofs become first class values, and if we define
them in a nice enough way, we can use manipulate them to create new proofs.
That's because they're just first-class values!

However, a full exploration of this is well beyond the scope of this post. This
type of stuff is covered in introductions to dependently typed programming
proper. However, this is a singletons post, so I'm just here to give a taste of
it to the extent that it is related to singletons :)

We're now going to look at a method that is less ``structural''. In practice,
carefully constructing predicates and proofs (ones more complicated than the one
we just looked at) requires some up-front cost in thinking about how to best
express your predicate, and is sometimes not straightforward. Here is another
way to express a similar \texttt{knock} that is slightly more mechanical.

Something we can do is define a type that expresses knockable-or-not-knockable,
as a value:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{$}\NormalTok{(singletons [d|}
\NormalTok{  data Pass = Obstruct | Allow}
\NormalTok{  |])}
\end{Highlighting}
\end{Shaded}

And we can write a \emph{type-level function} (implemented as \emph{type
family}) from \texttt{DoorState} to a \texttt{Pass}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{PassState}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Pass} \KeywordTok{where}
    \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Opened} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Obstruct}
    \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Closed} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Allow}
    \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Locked} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Allow}
\end{Highlighting}
\end{Shaded}

We've briefly touched on type families before (in talking about
\texttt{SingKind}), but as a quick review, type families act a bit like
type-level functions. They take types as input arguments and return types in
return.

Like type synonyms, type families can't be partially applied. They only ever
make sense in ``fully applied'' form, with all arguments given syntactically.

We can inspect how type families are applied by using the \texttt{:kind!}
command in ghci:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Opened}
\NormalTok{'}\DataTypeTok{Obstruct}
\NormalTok{ghci}\FunctionTok{>} \FunctionTok{:}\NormalTok{kind}\FunctionTok{!} \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Closed}
\NormalTok{'}\DataTypeTok{Allow}
\end{Highlighting}
\end{Shaded}

Armed with this type family, we can write a new version of \texttt{knock}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knock ::}\NormalTok{ (}\DataTypeTok{PassState}\NormalTok{ s }\FunctionTok{~}\NormalTok{ '}\DataTypeTok{Allow}\NormalTok{) }\OtherTok{=>} \DataTypeTok{Door}\NormalTok{ s }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knock d }\FunctionTok{=}\NormalTok{ putStrLn }\FunctionTok{$} \StringTok{"Knock knock on "} \FunctionTok{++}\NormalTok{ doorMaterial d }\FunctionTok{++} \StringTok{" door!"}
\end{Highlighting}
\end{Shaded}

\texttt{a\ \textasciitilde{}\ b} is a constraint for \emph{type equality}. This
constraint means that calling \texttt{knock} requires that \texttt{PassState\ s}
being \emph{equal} to \texttt{\textquotesingle{}Allow}. So, if attempt to call
\texttt{knock} with a \texttt{\textquotesingle{}Locked} door,
\texttt{PassState\ \textquotesingle{}Locked} is
\texttt{\textquotesingle{}Allow}, so the constraint is satisfied and everyone is
happy. If we attempt to call \texttt{knock} with an
\texttt{\textquotesingle{}Opened} door,
\texttt{PassState\ \textquotesingle{}Opened} is
\texttt{\textquotesingle{}Obstruct}, so the constraint is not satisfied and
everyone is sad.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door1 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Closed} \StringTok{"Oak"}
\NormalTok{ghci}\FunctionTok{>} \KeywordTok{let}\NormalTok{ door2 }\FunctionTok{=} \DataTypeTok{UnsafeMkDoor} \FunctionTok{@}\NormalTok{'}\DataTypeTok{Opened} \StringTok{"Spruce"}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock door1}
\DataTypeTok{Knock}\NormalTok{ knock on }\DataTypeTok{Oak}\NormalTok{ door}\FunctionTok{!}
\NormalTok{ghci}\FunctionTok{>}\NormalTok{ knock door2}
\DataTypeTok{COMPILE} \DataTypeTok{ERROR}\FunctionTok{!}
\CommentTok{--     â€¢ Couldn't match type â€˜'Allowâ€™ with â€˜'Obstructâ€™}
\CommentTok{--             arising from a use of â€˜knockâ€™}
\end{Highlighting}
\end{Shaded}

(Note that we could have just used \texttt{Bool} instead of defining a
\texttt{Pass} type, and defining something like a \texttt{Knockable} type
family, and test on
\texttt{Knockable\ s\ \textasciitilde{}\ \textquotesingle{}True}. We're just
going through a new type for the sake of example, and it can be useful because a
type like \texttt{Pass} might potentially have even more constructors!)

\hypertarget{deciding-at-runtime}{%
\subsubsection{Deciding at Runtime}\label{deciding-at-runtime}}

One nice thing about this way is that the compiler will provide the proof for
us. However, how can we run into the same issue as before --- what happens if we
don't know \texttt{s} until runtime? How do we prove to the compiler that
\texttt{Passable\ s} is \texttt{\textquotesingle{}Allow}?

Remember that type families take \emph{types} as inputs, so we can't write:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{knockSomeDoor ::} \DataTypeTok{SomeDoor} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockSomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=} \KeywordTok{case} \DataTypeTok{PassState}\NormalTok{ s }\KeywordTok{of}
                                  \CommentTok{-- ...}
\end{Highlighting}
\end{Shaded}

because \texttt{s}, a value, can't be given to \texttt{PassState}.

What we really want to do is pass \texttt{s}, the singleton representing a type,
to \texttt{PassState}, the type family. And then, we want to match on the
\emph{resulting type}, so we can decide what to do based on the result.

If you think about this predicament long enough, you might begin to see a
solution. Essentially, we want a function that takes a \emph{singleton} of
\texttt{s}, and return a \emph{singleton} of \texttt{PassState\ s}.

In practice, we need to \emph{mirror} the type-level function \emph{at the value
level}. We need to write a function of type
\texttt{Sing\ s\ -\textgreater{}\ Sing\ (PassState\ s)}: given a singleton of a
type, return a singleton of the type family applied to the type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type}\NormalTok{ family }\DataTypeTok{PassState}\NormalTok{ (}\OtherTok{s ::} \DataTypeTok{DoorState}\NormalTok{)}\OtherTok{ ::} \DataTypeTok{Pass} \KeywordTok{where}
    \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Opened} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Obstruct}
    \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Closed} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Allow}
    \DataTypeTok{PassState}\NormalTok{ '}\DataTypeTok{Locked} \FunctionTok{=}\NormalTok{ '}\DataTypeTok{Allow}

\OtherTok{sPassState ::} \DataTypeTok{Sing}\NormalTok{ s }\OtherTok{->} \DataTypeTok{Sing}\NormalTok{ (}\DataTypeTok{PassState}\NormalTok{ s)}
\NormalTok{sPassState }\FunctionTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{SOpened} \OtherTok{->} \DataTypeTok{SObstruct}
    \DataTypeTok{SClosed} \OtherTok{->} \DataTypeTok{SAllow}
    \DataTypeTok{SLocked} \OtherTok{->} \DataTypeTok{SAllw}
\end{Highlighting}
\end{Shaded}

We have to be very careful with how we define \texttt{sPassState}, because GHC
isn't too smart. It'll reject any definition that isn't structurally identical
to the type family it's mirroring.

With our new tool, we can now write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{knockSomeDoor}
\OtherTok{    ::} \DataTypeTok{SomeDoor}     \CommentTok{-- ^ status not known until you pattern match at runtime}
    \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{knockSomeDoor (}\DataTypeTok{MkSomeDoor}\NormalTok{ s d) }\FunctionTok{=} \KeywordTok{case}\NormalTok{ sPassState s }\KeywordTok{of}
    \DataTypeTok{SAllow} \OtherTok{->}\NormalTok{ knock d                           }\CommentTok{-- ^ `PassState s ~ 'Allow`}
\NormalTok{    _      }\OtherTok{->}\NormalTok{ putStrLn }\StringTok{"No knocking allowed!"}   \CommentTok{-- ^ `PassState s ~ 'Obstruct`}
\end{Highlighting}
\end{Shaded}

First we use \texttt{sPassState\ s} to check the ``pass state'' of the
\texttt{s}. Then, we match on the \texttt{Pass}: if it's \texttt{Allow}, like
the type signature of \texttt{knock} requires, we can run \texttt{knock}. If
not, then we cannot!

\hypertarget{a-comparison}{%
\subsection{A Comparison}\label{a-comparison}}

\hypertarget{type-level-functions-as-relationships}{%
\section{Type-Level Functions as
Relationships}\label{type-level-functions-as-relationships}}

\hypertarget{lets-fold}{%
\subsection{Let's Fold}\label{lets-fold}}

\hypertarget{the-problem-with-higher-order-functions}{%
\subsection{The Problem with Higher Order
Functions}\label{the-problem-with-higher-order-functions}}

\hypertarget{next-steps}{%
\section{Next Steps}\label{next-steps}}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
