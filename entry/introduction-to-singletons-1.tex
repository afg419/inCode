\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Introduction to Singletons (Part 1) \% Justin Le \% December 22, 2017

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/introduction-to-singletons-1.html}{in
Code}}.}

Real dependent types are coming to Haskell soon! Until then, we have the great
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library
:)

If you've ever run into dependently typed programming in Haskell, you've
probably encountered mentions of singletons (and the \emph{singletons} library).
This series of articles will be my attempt at giving you the story of the
library, the problems it solves, the power that it gives to you, and how you can
integrate it into your code today!{[}\^{}origin{]} (Also, after
\href{https://blog.jle.im/entry/verified-instances-in-haskell.html}{my previous
April Fools post}, people have been asking me for an actual non-joke singletons
post)

This post (Part 1) will go over first using the singleton pattern for
\emph{reflection}, then introducing how the singletons library helps us. Part 2
will discuss using the library for \emph{reification}, to get types that depend
on values at runtime. Part 3 will go into the basics singleton's
\emph{defunctionalization} system and how we can promote value-level functions
to type-level functions, and Part 4 will delve into deeper applications of
defunctionalization.

I definitely am writing this post with the hope that it will be obsolete in a
year or two. When dependent types come to Haskell, singletons will be nothing
more than a painful historical note. But for now, singletons might be the best
way to get your foot into the door and experience the thrill and benefits of
dependently typed programming \emph{today}!

\subsection{Prerequisites}

These posts will assume no knowledge of dependent types, and, for now, only
basic to intermediate Haskell knowledge (Types, kinds, typeclasses, data types,
functions). The material in this post \emph{overlaps} with my
\href{https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html}{dependently
typed neural networks} series, but the concepts are introduced in different
contexts.

All code is built on \emph{GHC 8.2.2} and with the
\emph{\href{https://www.stackage.org/lts-10.0}{lts-10.0}} snapshot (so,
singletons-2.3.1). However, there are negligible changes in the GHC type system
between GHC 8.0 and 8.2 (the only difference is in the libraries, more or less),
so everything should work on GHC 8.0 as well!

The content in the first section of this post, describing the singleton design
pattern, uses the following extensions:

\begin{itemize}
\tightlist
\item
  DataKinds
\item
  GADTs
\item
  KindSignatures
\item
  RankNTypes
\end{itemize}

With some optional "convenience extensions"

\begin{itemize}
\tightlist
\item
  LambdaCase
\item
  TypeApplications
\end{itemize}

And the second section, introducing the \emph{singletons} library itself, uses,
additionally:

\begin{itemize}
\tightlist
\item
  TemplateHaskell
\item
  TypeFamilies
\end{itemize}

These extension will be explained when they are used or become relevant.

\section{The Phantom of the Types}

\emph{(The code for this pre-singletons section is available
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs}{on
github})}

Let's start with a very common Haskell trick that most learn early in their
Haskelling journey: the \href{https://wiki.haskell.org/Phantom_type}{phantom
type}.

Phantom types in Haskell are a very simple way to add a layer of "type safety"
for your types and DSL's. It helps you restrict what values functions can take
and encode pre- and post-conditions directly into your types.

For example, in

\texttt{haskell\ data\ Foo\ a\ =\ MkFoo}

The \texttt{a} parameter is \emph{phantom}, because nothing of type \texttt{a}
in the data type...it just exists as a dummy parameter for the \texttt{Foo}
type. We can use \texttt{MkFoo} without ever requiring something of type
\texttt{a}:

\texttt{haskell\ ghci\textgreater{}\ :t\ MkFoo\ ::\ Foo\ Int\ Foo\ Int\ ghci\textgreater{}\ :t\ MkFoo\ ::\ Foo\ Bool\ Foo\ Bool\ ghci\textgreater{}\ :t\ MkFoo\ ::\ Foo\ Either\ \ \ \ \ \ \ \ -\/-\ requires\ -XPolyKinds\ Foo\ Either\ ghci\textgreater{}\ :t\ MkFoo\ ::\ Foo\ Monad\ \ \ \ \ \ \ \ \ -\/-\ requires\ -XConstraintKinds\ Foo\ Monad}

One use case of phantom type parameters is to prohibit certain functions on
different types of values and let you be more descriptive with how your
functions work together (like in
\href{https://ren.zone/articles/safe-money}{safe-money}). One "hello world" use
case of phantom type parameters is to tag data as "sanitized" or "unsanitized"
(\texttt{UserString\ \textquotesingle{}Santitized} type vs.
\texttt{UserString\ \textquotesingle{}Unsanitized}) or paths as absolute or
relative (\texttt{Path\ \textquotesingle{}Absolute} vs.
\texttt{Path\ \textquotesingle{}Relative}). For a simple example, let's check
out a simple DSL for a type-safe door:

```haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L12-15
data DoorState = Opened \textbar{} Closed \textbar{} Locked deriving (Show, Eq)

data Door (s :: DoorState) = UnsafeMkDoor \{ doorMaterial :: String \} ```

A couple things going on here:

\begin{enumerate}
\item
  Our type we are going to be playing with is a \texttt{Door}, which contains a
  single field \texttt{doorMaterial} describing, say, the material that the door
  is made out of. (\texttt{UnsafeMkDoor\ "Oak"} would be an oak door)
\item
  We're using the \texttt{DataKinds} extension to create both the \emph{type}
  \texttt{DoorState} as well as the \emph{kind} \texttt{DoorState}.

  Normally,
  \texttt{data\ DoorState\ =\ Opened\ \textbar{}\ Closed\ \textbar{}\ Locked} in
  Haskell defines the type \texttt{DoorState} and the value constructors
  \texttt{Opened}, \texttt{Closed}, and \texttt{Locked}.

  However, with \texttt{DataKinds}, that statement also defines a new
  \emph{kind} \texttt{DoorState}, with \emph{type} constructors
  \texttt{\textquotesingle{}Opened}, \texttt{\textquotesingle{}Closed}, and
  \texttt{\textquotesingle{}Locked}. (note the \texttt{\textquotesingle{}}
  ticks!){[}\^{}ticks{]}

  \texttt{haskell\ ghci\textgreater{}\ :k\ \textquotesingle{}Opened\ DoorState\ ghci\textgreater{}\ :k\ \textquotesingle{}Locked\ DoorState}
\end{enumerate}

~

\begin{enumerate}
\item
  We're defining the \texttt{Door} type with a \emph{phantom parameter}
  \texttt{s}. It's a phantom type because we don't actually have any
  \emph{values} of type \texttt{s} in our data type{[}\^{}kind{]} ...the
  \texttt{s} is only just there as a dummy parameter for the type.

  We can use \texttt{UnsafeMkDoor} without ever using anything of type
  \texttt{s}. In reality, a real \texttt{Door} type would be a bit more
  complicated (and the direct \texttt{UnsafeMkDoor} constructor would be
  hidden).

  \texttt{haskell\ ghci\textgreater{}\ :t\ UnsafeMkDoor\ "Birch"\ ::\ Door\ \textquotesingle{}Opened\ Door\ \textquotesingle{}Opened\ ghci\textgreater{}\ :t\ UnsafeMkDoor\ "Iron"\ ::\ Door\ \textquotesingle{}Locked\ Door\ \textquotesingle{}Locked}

  We can also use the \emph{TypeApplications} extension to write this in a bit
  more convenient way -\/-

  \texttt{haskell\ ghci\textgreater{}\ :t\ UnsafeMkDoor\ @\textquotesingle{}Opened\ "Birch"\ Door\ \textquotesingle{}Opened\ ghci\textgreater{}\ :t\ UnsafeMkDoor\ @\textquotesingle{}Locked\ "Iron"\ Door\ \textquotesingle{}Locked}
\end{enumerate}

Alternatively, we can define \texttt{Door} using
\href{https://en.wikibooks.org/wiki/Haskell/GADT\#Syntax}{\emph{GADT} syntax}
(which requires the \texttt{GADTs} extension){[}\^{}gadtnote{]}.

\texttt{haskell\ data\ Door\ ::\ DoorState\ -\textgreater{}\ Type\ where\ \ \ \ \ UnsafeMkDoor\ ::\ \{\ doorMaterial\ ::\ String\ \}\ -\textgreater{}\ Door\ s}

This is defining the exact same type in the alternate "GADT syntax" style of
data type declaration -\/- here, we define types by giving the type of its
constructors, \texttt{UnsafeMkDoor\ ::\ String\ -\textgreater{}\ Door\ s}.

\texttt{Door} here is an \textbf{indexed data type}, which is sometimes called a
"type family" in the dependently typed programming world (which is not to be
confused with type families in \emph{GHC Haskell}, \texttt{-XTypeFamilies},
which is a language mechanism that is related but definitely not the same).

\subsection{Phantoms in Action}

At first, this seems a bit silly. Why even have the extra type parameter if you
don't ever use it?

Well, right off the bat, we can write functions that expect only a certain type
of \texttt{Door}, and return a specific type of \texttt{Door}:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L17-18\ closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Closed\ closeDoor\ (UnsafeMkDoor\ m)\ =\ UnsafeMkDoor\ m}

So, the \texttt{closeDoor} function will \emph{only} take a
\texttt{Door\ \textquotesingle{}Opened} (an opened door). And it will return a
\texttt{Door\ \textquotesingle{}Closed} (a closed door).

\texttt{haskell\ ghci\textgreater{}\ let\ myDoor\ =\ UnsafeMkDoor\ @\textquotesingle{}Opened\ "Spruce"\ ghci\textgreater{}\ :t\ myDoor\ Door\ \textquotesingle{}Opened\ ghci\textgreater{}\ :t\ closeDoor\ myDoor\ Door\ \textquotesingle{}Closed\ ghci\textgreater{}\ let\ yourDoor\ =\ UnsafeMkDoor\ @\textquotesingle{}Closed\ "Acacia"\ ghci\textgreater{}\ :t\ closeDoor\ yourDoor\ TYPE\ ERROR!\ \ TYPE\ ERROR!}

You can think of this as a nice way of catching \emph{logic errors} at
compile-time. If your door type did not have its status in the type, the
\texttt{closeDoor} could have been given a closed or locked door, and you'd have
to handle and reject it at \emph{runtime}.

By adding the state of the door into its type, we can encode our pre-conditions
and post-conditions directly into the type. And any opportunity to move runtime
errors to compile-time errors should be celebrated with a party!

This would also stop you from doing silly things like closing a door twice in a
row:

\texttt{haskell\ ghci\textgreater{}\ :t\ closeDoor\ .\ closeDoor\ TYPE\ ERROR!\ \ TYPE\ ERROR!\ \ TYPE\ ERROR!}

Do you see why?

With a couple of state transitions, we can write compositions that are
type-checked to all be legal:

```haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L20-24
lockDoor :: Door 'Closed -\textgreater{} Door 'Locked lockDoor (UnsafeMkDoor m)
= UnsafeMkDoor m

openDoor :: Door 'Closed -\textgreater{} Door 'Opened openDoor (UnsafeMkDoor m)
= (UnsafeMkDoor m) ```

\texttt{haskell\ ghci\textgreater{}\ :t\ closeDoor\ .\ openDoor\ Door\ \textquotesingle{}Closed\ -\textgreater{}\ Door\ \textquotesingle{}Closed\ ghci\textgreater{}\ :t\ lockDoor\ .\ closeDoor\ .\ openDoor\ Door\ \textquotesingle{}Closed\ -\textgreater{}\ Door\ \textquotesingle{}Locked\ ghci\textgreater{}\ :t\ lockDoor\ .\ openDoor\ TYPE\ ERROR!\ \ TYPE\ ERROR!\ \ TYPE\ ERROR!}

Because of the type of \texttt{lockDoor}, you \emph{cannot} lock an opened door!
Don't even try! You'd have to close it first.

\texttt{haskell\ ghci\textgreater{}\ let\ myDoor\ =\ UnsafeMkDoor\ @\textquotesingle{}Opened\ "Spruce"\ ghci\textgreater{}\ :t\ myDoor\ Door\ \textquotesingle{}Opened\ ghci\textgreater{}\ :t\ lockDoor\ Door\ \textquotesingle{}Closed\ -\textgreater{}\ Door\ \textquotesingle{}Closed\ ghci\textgreater{}\ :t\ lockDoor\ myDoor\ TYPE\ ERROR!\ \ TYPE\ ERROR!\ \ TYPE\ ERROR!\ ghci\textgreater{}\ :t\ closeDoor\ myDoor\ Door\ \textquotesingle{}Closed\ ghci\textgreater{}\ :t\ lockDoor\ (closeDoor\ myDoor)\ Door\ \textquotesingle{}Locked}

\texttt{lockDoor} expects a \texttt{Door\ \textquotesingle{}Closed}, so if you
give it a \texttt{Door\ \textquotesingle{}Opened}, that's a static compile-time
type error. But, \texttt{closeDoor} takes a
\texttt{Door\ \textquotesingle{}Opened} and returns a
\texttt{Door\ \textquotesingle{}Closed} -\/- so \emph{that} is something that
you can call \texttt{lockDoor} with!

\subsection{The Phantom Menace}

However, in standard Haskell, we quickly run into some practical problems if we
program with phantom types this way.

For example, how could we write a function to get the state of a door?

\texttt{haskell\ doorStatus\ ::\ Door\ s\ -\textgreater{}\ DoorState\ doorStatos\ \_\ =\ -\/-\ ?}

(It can be done with an ad-hoc typeclass, but it's not simple, and it's prone to
implementation bugs)

And, perhaps even more important, how can you create a \texttt{Door} with a
given state that isn't known until runtime? If we know the type of our doors at
compile-time, we can just explicitly write
\texttt{UnsafeMkDoor\ "Iron"\ ::\ Door\ \textquotesingle{}Opened} or
\texttt{UnsafeMkDoor\ @\textquotesingle{}Opened\ "Iron"}. But what if we wanted
to make a door based on a \texttt{DoorState} \emph{value}? Something we might
not get until runtime?

\texttt{haskell\ mkDoor\ ::\ DoorState\ -\textgreater{}\ String\ -\textgreater{}\ Door\ s\ mkDoor\ Opened\ =\ -\/-\ ?\ mkDoor\ Closed\ =\ -\/-\ ?\ mkDoor\ Locked\ =\ -\/-\ ?}

Ah hah, you say. That's easy!

\texttt{haskell\ mkDoor\ ::\ DoorState\ -\textgreater{}\ String\ -\textgreater{}\ Door\ s\ mkDoor\ Opened\ =\ UnsafeMkDoor\ mkDoor\ Closed\ =\ UnsafeMkDoor\ mkDoor\ Locked\ =\ UnsafeMkDoor}

Unfortunately, that's not how types work in Haskell. Remember that for a
polymorphic type
\texttt{forall\ s.\ DoorState\ -\textgreater{}\ String\ -\textgreater{}\ Door\ s},
the \emph{caller} picks the type variable.

\texttt{haskell\ ghci\textgreater{}\ :t\ mkDoor\ Opened\ "Acacia"\ ::\ Door\ \textquotesingle{}Closed\ Door\ \textquotesingle{}Closed}

Oops!

\subsection{The Fundamental Issue in Haskell}

We've hit upon a fundamental issue in Haskell's type system: \textbf{type
erasure}. In Haskell, types only exist \emph{at compile-time}, for help with
type-checking. They are completely erased at runtime.

This is usually what we want. It's great for performance, and you can bypass
things like the ad-hoc runtime type checking that you have to deal with in
dynamic languages like python.

But in our case, it makes functions like \texttt{doorState} fundamentally
impossible. Or, does it?

\section{The Singleton Pattern}

A singleton in Haskell is a type (of kind \texttt{Type} -\/- that is,
\texttt{*}) that has exactly one inhabitant. In practice (and when talking about
the design pattern), it refers to a parameterized type that, for each pick of
parameter, gives a type with exactly one inhabitant. It is written so that
pattern matching on the \emph{constructor} of that value reveals the unique type
parameter.

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L26-29\ data\ SingDS\ ::\ DoorState\ -\textgreater{}\ Type\ where\ \ \ \ \ SOpened\ ::\ SingDS\ \textquotesingle{}Opened\ \ \ \ \ SClosed\ ::\ SingDS\ \textquotesingle{}Closed\ \ \ \ \ SLocked\ ::\ SingDS\ \textquotesingle{}Locked}

Here we're using \emph{GADT syntax} again (but to make an actual GADT). (Also
note that \texttt{Type} is a synonym for the \texttt{*} kind, exported from the
\emph{Data.Kind} module) So, if we use \texttt{SOpened}, we will get a
\texttt{SingDS\ \textquotesingle{}Opened}. And if we have a
\texttt{SingDS\ \textquotesingle{}Opened}, we know that it was constructed using
\texttt{SOpened}. Essentially, this gives us three values:

\texttt{haskell\ SOpened\ ::\ SingDS\ \textquotesingle{}Opened\ SClosed\ ::\ SingDS\ \textquotesingle{}Closed\ SLocked\ ::\ SingDS\ \textquotesingle{}Locked}

\subsection{The Power of the Pattern Match}

The power of singletons is that we can now \emph{pattern match} on types,
essentially.

```haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L17-35
closeDoor :: Door 'Opened -\textgreater{} Door 'Closed

lockDoor :: Door 'Closed -\textgreater{} Door 'Locked

lockAnyDoor :: SingDS s -\textgreater{} Door s -\textgreater{} Door 'Locked
lockAnyDoor sng door = case sng of SOpened -\textgreater{} lockDoor (closeDoor
door) -\/- in this branch, s is 'Opened SClosed -\textgreater{} lockDoor door
-\/- in this branch, s is 'Closed SLocked -\textgreater{} door -\/- in this
branch, s is 'Locked ```

\texttt{lockAnyDoor} is a function that can take a door of any state (a
\texttt{Door\ s} of any \texttt{s}) and \emph{lock} it using a composition of
\texttt{lockDoor} or \texttt{closeDoor} as necessary.

If we have \texttt{lockAnyDoor} take a \texttt{SingDS\ s} as its input (and,
importantly, make sure that the \texttt{s} in \texttt{SingDS\ s} is the same
\texttt{s} in the \texttt{Door\ s}), we can \emph{pattern match} on the
\texttt{SingDS\ s} to \emph{reveal} what \texttt{s} is, to the type checker.
This is known as a \textbf{dependent pattern match}.

\begin{itemize}
\item
  If \texttt{SingDS\ s}'s pattern match goes down the
  \texttt{SOpened\ -\textgreater{}} case, then we \emph{know} that
  \texttt{s\ \textasciitilde{}\ \textquotesingle{}Opened}{[}\^{}eq{]}. We know
  that \texttt{s} must be \texttt{\textquotesingle{}Opened}, because
  \texttt{SOpened\ ::\ SingDS\ \textquotesingle{}Opened}, so there really isn't
  anything else the \texttt{s} in \texttt{SingDS\ s} could be!

  So, if we know that \texttt{s\ \textasciitilde{}\ \textquotesingle{}Opened},
  that means that the \texttt{Door\ s} is
  \texttt{Door\ \textquotesingle{}Opened}. So because
  \texttt{door\ ::\ Door\textquotesingle{}\ Opened}, we have to
  \texttt{closeDoor} it to get a \texttt{Door\textquotesingle{}\ Closed}, and
  then \texttt{lockDoor} it to get a \texttt{Door\ \textquotesingle{}Locked}

  We say that \texttt{SOpened} is a \emph{runtime witness} to \texttt{s} being
  \texttt{\textquotesingle{}Opened}.

  \textless{}!-\/- Note that \texttt{lockDoor\ .\ closeDoor} will \emph{only}
  compile if given a
  \texttt{Door\ -\/-\textgreater{}\ \textless{}!-\/-\ \textquotesingle{}Opened},
  but because of our dependent pattern match, we \emph{know} we have a
  -\/-\textgreater{} \textless{}!-\/- \texttt{Door\ \textquotesingle{}Opened}.
  -\/-\textgreater{}
\item
  Same for the \texttt{SClosed\ -\textgreater{}} branch -\/- since
  \texttt{SClosed\ ::\ SingDS\ \textquotesingle{}Closed}, then
  \texttt{s\ \textasciitilde{}\ \textquotesingle{}Closed}, so our
  \texttt{Door\ s} must be a \texttt{Door\ \textquotesingle{}Closed}. This
  allows us to simply take our \texttt{door\ ::\ Door\ \textquotesingle{}Closed}
  and use \texttt{lockDoor} to get a \texttt{Door\ \textquotesingle{}Locked}

  \textless{}!-\/- just write \texttt{SClosed\ -\textgreater{}\ lockDoor}.
  -\/-\textgreater{}

  \textless{}!-\/- Again,
  \texttt{lockDoor\ ::\ Door\ \textquotesingle{}Closed\ -\textgreater{}\ Door\ \textquotesingle{}Locked},
  so it would only work if -\/-\textgreater{} \textless{}!-\/- given a
  \texttt{Door\ \textquotesingle{}Closed} -\/- which we know we have, because of
  the dependent -\/-\textgreater{} \textless{}!-\/- pattern match.
  -\/-\textgreater{}
\item
  For the \texttt{SLocked\ -\textgreater{}} branch,
  \texttt{SLocked\ ::\ SingDS\ \textquotesingle{}Locked}, so
  \texttt{s\ \textasciitilde{}\ \textquotesingle{}Locked}, so our
  \texttt{Door\ s} is a \texttt{Door\ \textquotesingle{}Locked}. Our door is
  "already" locked, so we can just use the
  \texttt{door\ ::\ Door\ \textquotesingle{}Locked} that we got!

  \textless{}!-\/- use
  \texttt{id\ ::\ Door\ \textquotesingle{}Locked\ -\textgreater{}\ Door\ \textquotesingle{}Locked}.
  -\/-\textgreater{}

  \textless{}!-\/- Note that
  \texttt{id\ ::\ Door\ \textquotesingle{}Locked\ -\textgreater{}\ Door\ \textquotesingle{}Locked}
  would not work for any other -\/-\textgreater{} \textless{}!-\/- branch, and
  would be a compile-time error. \texttt{id} only works if you know your
  -\/-\textgreater{} \textless{}!-\/- input is already
  \texttt{Door\ \textquotesingle{}Locked}...which we know because of the
  dependent -\/-\textgreater{} \textless{}!-\/- pattern match.
  -\/-\textgreater{}
\end{itemize}

Essentially, our singletons give us \emph{runtime values} that can be used as
\emph{witnesses} for types and type variables. These values exist at runtime, so
they "bypass" type erasure. Types themselves are directly erased, but we can
hold on to them using these runtime tokens when we need them.

Note that we can also write \texttt{lockAnyDoor} using the \emph{LambdaCase}
extension syntactic sugar, which I think offers a lot of extra insight:

\texttt{haskell\ lockAnyDoor\ ::\ SingDS\ s\ -\textgreater{}\ (Door\ s\ -\textgreater{}\ Door\ \textquotesingle{}Locked)\ lockAnyDoor\ =\ \textbackslash{}case\ \ \ \ \ SOpened\ -\textgreater{}\ lockDoor\ .\ closeDoor\ \ -\/-\ in\ this\ branch,\ s\ is\ \textquotesingle{}Opened\ \ \ \ \ SClosed\ -\textgreater{}\ lockDoor\ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ in\ this\ branch,\ s\ is\ \textquotesingle{}Closed\ \ \ \ \ SLocked\ -\textgreater{}\ id\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ in\ this\ branch,\ s\ is\ \textquotesingle{}Locked}

Here, we can see \texttt{lockAnyDoor\ sng} as a partially applied function that
returns a \texttt{Door\ s\ -\textgreater{}\ Door\ \textquotesingle{}Locked} For
any \texttt{SingDS\ s} you give to \texttt{lockAnyDoor}, \texttt{lockAnyDoor}
returns a "locker function"
(\texttt{Door\ s\ -\textgreater{}\ Door\ \textquotesingle{}Locked}) that is
custom-made for your \texttt{SingDS}:

\begin{itemize}
\item
  \texttt{lockAnyDoor\ SOpened} will return a
  \texttt{Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Locked}.
  Here, it has to give
  \texttt{lockDoor\ .\ closeDoor\ ::\ Door\ \textquotesingle{}Opened\ -\textgreater{}\ Door\ \textquotesingle{}Locked}.
\item
  \texttt{lockAnyDoor\ SClosed} will return a
  \texttt{Door\ \textquotesingle{}Closed\ -\textgreater{}\ Door\ \textquotesingle{}Locked}
  -\/- namely
  \texttt{lockDoor\ ::\ Door\ \textquotesingle{}Closed\ -\textgreater{}\ Door\ \textquotesingle{}Locked}.
\item
  \texttt{lockAnyDoor\ SLocked} will return a
  \texttt{Door\ \textquotesingle{}Locked\ -\textgreater{}\ Door\ \textquotesingle{}Locked},
  which will just be
  \texttt{id\ ::\ Door\ \textquotesingle{}Locked\ -\textgreater{}\ Door\ \textquotesingle{}Locked}
\end{itemize}

Note that all of these functions will \emph{only} typecheck under the branch
they fit in. If we gave \texttt{lockDoor} for the \texttt{SOpened} branch, or
\texttt{id} for the \texttt{SClosed} branch, that'll be a compile-time error!

\subsubsection{Reflection}

Writing \texttt{doorStatus} is now pretty simple -\/-

\texttt{haskell\ doorStatus\ ::\ SingDS\ s\ -\textgreater{}\ Door\ s\ -\textgreater{}\ DoorState\ doorStatus\ SOpened\ \_\ =\ Opened\ doorStatus\ SClosed\ \_\ =\ Closed\ doorStatus\ SLocked\ \_\ =\ Locked}

The benefit of the singleton again relies on the fact that the \texttt{s} in
\texttt{SingDS\ s} is the same as the \texttt{s} in \texttt{Door\ s}, so if the
user gives a \texttt{SingDS\ s}, it \emph{has} to match the \texttt{s} in the
\texttt{Door\ s} they give.

Since we don't even care about the \texttt{door}, we could also just write:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L37-40\ fromSingDS\ ::\ SingDS\ s\ -\textgreater{}\ DoorState\ fromSingDS\ SOpened\ =\ Opened\ fromSingDS\ SClosed\ =\ Closed\ fromSingDS\ SLocked\ =\ Locked}

Which we can use to write a nicer \texttt{doorStatus}

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L42-43\ doorStatus\ ::\ SingDS\ s\ -\textgreater{}\ Door\ s\ -\textgreater{}\ DoorState\ doorStatus\ s\ \_\ =\ fromSingDS\ s}

This process -\/- of turning a type variable (like \texttt{s}) into a dynamic
runtime value is known as \textbf{reflection}. We move a value from the
\emph{type level} to the \emph{term level}.

\subsection{Recovering Implicit Passing}

One downside is that we are required to manually pass in our witness. Wouldn't
it be nice if we could have it be passed implicitly? We can actually leverage
typeclasses to give us this ability:

```haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L45-53
class SingDSI s where singDS :: SingDS s

instance SingDSI 'Opened where singDS = SOpened instance SingDSI 'Closed where
singDS = SClosed instance SingDSI 'Locked where singDS = SLocked ```

(Note that \emph{it's impossible} to write our \texttt{SingDSI} instances
improperly! GHC checks to make sure that this is \emph{correct})

And so now we can do:

```haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L55-59
lockAnyDoor\_ :: SingDSI s =\textgreater{} Door s -\textgreater{} Door 'Locked
lockAnyDoor\_ = lockAnyDoor singDS

doorStatus\_ :: SingDSI s =\textgreater{} Door s -\textgreater{} DoorState
doorStatus\_ = doorStatus singDS ```

Here, type inference will tell GHC that you want \texttt{singDS\ ::\ SingDS\ s},
and it will pull out the proper singleton for the door you want to check!

Now, we can call \texttt{lockAnyDoor\_} \emph{without passing in} a singleton,
explicitly!

\texttt{haskell\ ghci\textgreater{}\ let\ myDoor\ =\ UnsafeMkDoor\ @\textquotesingle{}Opened\ "Birch"\ ghci\textgreater{}\ :t\ lockAnyDoor\ SOpened\ myDoor\ -\/-\ our\ original\ method!\ Door\ \textquotesingle{}Locked\ ghci\textgreater{}\ :t\ lockAnyDoor\ singDS\ myDoor\ \ -\/-\ the\ power\ of\ type\ inference!\ Door\ \textquotesingle{}Locked\ ghci\textgreater{}\ :t\ lockAnyDoor\_\ myDoor\ \ \ \ \ \ \ \ -\/-\ no\ explicit\ singleton\ being\ passed!\ Door\ \textquotesingle{}Locked}

\subsubsection{The Same Power}

In Haskell, a constraint \texttt{SingDSI\ s\ =\textgreater{}} is essentially the
same as passing in \texttt{SingDS\ s} explicitly. Either way, you are passing in
a runtime witness that your function can use. You can think of
\texttt{SingDSI\ s\ =\textgreater{}} as passing it in \emph{implicitly}, and
\texttt{SingDS\ s\ -\textgreater{}} as passing it in \emph{explicitly}.

So, it's important to remember that \texttt{lockAnyDoor} and
\texttt{lockAnyDoor\_} are the "same function", with the same power. They are
just written in different styles -\/- \texttt{lockAnyDoor} is written in
explicit style, and \texttt{lockAnyDoor\_} is written in implicit style.

\subsubsection{Going backwards}

Going from \texttt{SingDSI\ s\ =\textgreater{}} to
\texttt{SingDS\ s\ -\textgreater{}} (implicit to explicit) is very easy -\/-
just use \texttt{singDS} to get a \texttt{SingDS\ s} if you have a
\texttt{SingDSI\ s} constraint available. This is what we did for
\texttt{lockAnyDoor\_} and \texttt{doorStatus\_}.

Going from \texttt{SingDS\ s\ -\textgreater{}} to
\texttt{SingDSI\ s\ =\textgreater{}} (explicit to implicit) in Haskell is
actually a little trickier. The typical way to do this is with a CPS-like
utility function:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L61-65\ withSingDSI\ ::\ SingDS\ s\ -\textgreater{}\ (SingDSI\ s\ =\textgreater{}\ r)\ -\textgreater{}\ r\ withSingDSI\ sng\ x\ =\ case\ sng\ of\ \ \ \ \ SOpened\ -\textgreater{}\ x\ \ \ \ \ SClosed\ -\textgreater{}\ x\ \ \ \ \ SLocked\ -\textgreater{}\ x}

\texttt{withSingDSI} takes a \texttt{SingDS\ s}, and a value (of type
\texttt{r}) that requires a \texttt{SingDSI\ s} instance to be created. And it
creates that value for you!

To use \texttt{x}, you must have a \texttt{SingDSI\ s} instance available. This
all works because in each branch, \texttt{s} is now a \emph{specific},
monomorphic, "concrete" \texttt{s}, and GHC knows that such an instance exists
for every branch.

\begin{itemize}
\tightlist
\item
  In the \texttt{SOpened} branch,
  \texttt{s\ \textasciitilde{}\ \textquotesingle{}Opened}. We explicitly wrote
  an instance of \texttt{SingDSI} for \texttt{\textquotesingle{}Opened}, so GHC
  \emph{knows} that there is a \texttt{SingDSI\ \textquotesingle{}Opened}
  instance in existence, allowing you to use/create \texttt{x}.
\item
  In the \texttt{SClosed} branch,
  \texttt{s\ \textasciitilde{}\ \textquotesingle{}Closed}, so GHC knows that
  there is a \texttt{SingDSI\ \textquotesingle{}Closed} instance (because we
  wrote one explicitly!), and gives \emph{that} to you -\/- and so you are
  allowed to use/create \texttt{x}.
\item
  In the \texttt{SLocked} branch,
  \texttt{s\ \textasciitilde{}\ \textquotesingle{}Locked}, and because we wrote
  a \texttt{SingDSI\ \textquotesingle{}Locked} explicitly, we \emph{know} that a
  \texttt{SingDSI\ s} instance is available, so we can use/create \texttt{x}.
\end{itemize}

Now, we can run our implicit functions (like \texttt{lockAnyDoor\_}) by giving
them explicit inputs:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L67-68\ lockAnyDoor\_\_\ ::\ SingDS\ s\ -\textgreater{}\ Door\ s\ -\textgreater{}\ Door\ \textquotesingle{}Locked\ lockAnyDoor\_\_\ s\ d\ =\ withSingDSI\ s\ (lockAnyDoor\_\ d)}

And the cycle begins anew.

One interesting thing to point out -\/- note that the type of
\texttt{withSingDSI} is very similar to the type of another common combinator:

\texttt{haskell\ withSingDSI\ ::\ SingDS\ s\ -\textgreater{}\ (SingDSI\ s\ =\textgreater{}\ r)\ -\textgreater{}\ r\ flip\ \ (\$)\ \ \ ::\ \ \ \ \ \ \ \ a\ -\textgreater{}\ (\ \ \ \ \ \ \ \ a\ -\textgreater{}\ r)\ -\textgreater{}\ r}

Which is a bit of a testament to what we said earlier about how a
\texttt{SingDSI\ s\ =\textgreater{}\ ..)} is the same as
\texttt{SingDS\ s\ -\textgreater{}\ ..}. \texttt{flip\ (\$)} takes a value and a
function and applies the function to that value. \texttt{withSingDSI} takes a
value and "something like a function" and applies the "something like a
function" to that value.

\subsection{Fun with Witnesses}

We can write a nice version of \texttt{mkDoor} using singletons:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs\#L70-71\ mkDoor\ ::\ SingDS\ s\ -\textgreater{}\ String\ -\textgreater{}\ Door\ s\ mkDoor\ \_\ =\ UnsafeMkDoor}

We take advantage of the fact that \texttt{SingDS\ s} "locks in" the \texttt{s}
type variable for \texttt{Door\ s}. We can call it now with values of
\texttt{SingDS}:

\texttt{haskell\ ghci\textgreater{}\ :t\ mkDoor\ SOpened\ "Oak"\ Door\ \textquotesingle{}Opened\ ghci\textgreater{}\ :t\ mkDoor\ SLocked\ "Spruce"\ Door\ \textquotesingle{}Locked}

Now we can't do something silly like pass in \texttt{SLocked} to get a
\texttt{Door\ \textquotesingle{}Opened}.

\section{The Singletons Library}

\emph{(The code for this post-singletons section is available
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs}{on
github})}

Now that we understand some of the benefits of singletons as they relate to
phantom types, we can appreciate what the singletons \emph{library} has to
offer: a fully unified, coherent system for working with singletons of almost
\emph{all} Haskell types!

First, there's Template Haskell for generating our singletons given our type:

```haskell data DoorState = Opened \textbar{} Closed \textbar{} Locked deriving
(Show, Eq)

genSingletons {[}''DoorState{]}

-\/- or -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs\#L17-20
\$(singletons {[}d\textbar{} data DoorState = Opened \textbar{} Closed
\textbar{} Locked deriving (Show, Eq) \textbar{}{]}) ```

This generates, for us:

\texttt{haskell\ -\/-\ not\ the\ actual\ code,\ but\ essentially\ what\ happens\ data\ Sing\ ::\ DoorState\ -\textgreater{}\ Type\ where\ \ \ \ \ SOpened\ ::\ Sing\ \textquotesingle{}Opened\ \ \ \ \ SClosed\ ::\ Sing\ \textquotesingle{}Closed\ \ \ \ \ SLocked\ ::\ Sing\ \textquotesingle{}Locked}

\texttt{Sing} is a poly-kinded type constructor (a "data family").
\texttt{STrue\ ::\ Sing\ \textquotesingle{}True} is the singleton for
\texttt{\textquotesingle{}True},
\texttt{SJust\ SOpened\ ::\ Sing\ (\textquotesingle{}Just\ \textquotesingle{}Opened)}
is the singleton for \texttt{\textquotesingle{}Just\ \textquotesingle{}Opened},
etc.

It also generates us instances for \texttt{SingI}, a poly-kinded typeclass:

\texttt{haskell\ instance\ SingI\ \textquotesingle{}Opened\ where\ \ \ \ \ sing\ =\ SOpened\ instance\ SingI\ \textquotesingle{}Closed\ where\ \ \ \ \ sing\ =\ SClosed\ instance\ SingI\ \textquotesingle{}Locked\ where\ \ \ \ \ sing\ =\ SLocked}

Which is basically our \texttt{SingDSI} typeclass, except we have instances for
singletons of all kinds! (heh) There's a \texttt{SingI} instance for
\texttt{\textquotesingle{}True}, a \texttt{SingI} instance for \texttt{10}, a
\texttt{SingI} instance for
\texttt{\textquotesingle{}Just\ \textquotesingle{}Opened}, etc.:

\texttt{haskell\ ghci\textgreater{}\ sing\ ::\ Sing\ \textquotesingle{}True\ STrue\ ghci\textgreater{}\ sing\ ::\ Sing\ (\textquotesingle{}Just\ \textquotesingle{}Opened)\ SJust\ SOpened}

We also have \texttt{withSingI}, which is equivalent to our \texttt{withSingDSI}
function earlier.

\texttt{haskell\ withSingI\ ::\ Sing\ s\ -\textgreater{}\ (forall\ r.\ SingI\ s\ =\textgreater{}\ r)\ -\textgreater{}\ r}

Note that if you have singletons for a kind \texttt{k}, you also have instances
for kind \texttt{Maybe\ k}, as well. And also for \texttt{{[}k{]}}, even! The
fact that we have a unified way of working with and manipulating singletons of
so many different types is a major advantage of using the \emph{singletons}
library to manage your singletons instead of writing them yourself.

\texttt{haskell\ ghci\textgreater{}\ :t\ SOpened\ \textasciigrave{}SCons\textasciigrave{}\ SClosed\ \textasciigrave{}SCons\textasciigrave{}\ SLocked\ \textasciigrave{}SCons\textasciigrave{}\ SNil\ Sing\ \textquotesingle{}{[}\ \textquotesingle{}Opened,\ \textquotesingle{}Closed,\ \textquotesingle{}Locked\ {]}\ -\/-\ \textquotesingle{}SCons\ is\ the\ singleton\ for\ \textasciigrave{}:\textasciigrave{}\ (cons),\ -\/-\ and\ \textquotesingle{}SNil\ is\ the\ singleton\ for\ \textasciigrave{}{[}{]}\textasciigrave{}\ (nil)}

(Remember that, because of \texttt{DataKinds}, \texttt{Maybe} is a kind
constructor, who has two type constructors, the type
\texttt{\textquotesingle{}Nothing} and the type constructor
\texttt{\textquotesingle{}Just\ ::\ k\ -\textgreater{}\ Maybe\ k})

Singletons for all kinds integrate together seamlessly, and you have mechanisms
to generate them for your own type and roll it all into the system!

\subsection{Extra Goodies}

In addition to generating singletons for our libraries, it gives us convenient
functions for working with the different "manifestations" of our types.

Recall that \texttt{DoorState} has four different things associated with it now:

\begin{enumerate}
\item
  The \emph{type} \texttt{DoorState}, whose value constructors are
  \texttt{Opened}, \texttt{Closed}, and \texttt{Locked}.
\item
  The \emph{kind} \texttt{DoorState}, whose type constructors are
  \texttt{\textquotesingle{}Opened}, \texttt{\textquotesingle{}Closed}, and
  \texttt{\textquotesingle{}Locked}
\item
  The singletons for \texttt{\textquotesingle{}Opened},
  \texttt{\textquotesingle{}Closed}, and \texttt{\textquotesingle{}Locked}:

  \texttt{haskell\ SOpened\ ::\ Sing\ \textquotesingle{}Opened\ SClosed\ ::\ Sing\ \textquotesingle{}Closed\ SLocked\ ::\ Sing\ \textquotesingle{}Locked}
\item
  The \texttt{SingI} instances for \texttt{\textquotesingle{}Opened},
  \texttt{\textquotesingle{}Closed}, and
  \texttt{\textquotesingle{}Locked\textquotesingle{}}
\end{enumerate}

Kind of confusing, and in the future, when we have real dependent types, we can
combine all of these manifestations into the \emph{one} thing. But for now, we
do have to deal with converting between them, and for that, \emph{singletons}
generates for us
\texttt{fromSing\ ::\ Sing\ (s\ ::\ DoorState)\ -\textgreater{}\ DoorState}.
\texttt{fromSing} takes us from singletons to term-level values
(\emph{reflection}):

\texttt{haskell\ ghci\textgreater{}\ fromSing\ SOpened\ Opened}

It does this by defining a type class (actually, a "kind class"),
\texttt{SingKind}, associating each type to the corresponding
datakinds-generated kind. The \texttt{SingKind} instance for \texttt{DoorState}
links the \emph{type} \texttt{DoorState} to the \emph{kind} \texttt{DoorState}.

The library also defines a neat type synonym,
\texttt{type\ SDoorState\ =\ Sing}, so you can do
\texttt{SDoorState\ \textquotesingle{}Opened} instead of
\texttt{Sing\ \textquotesingle{}Opened}, if you wish.

There are definitely more useful utility functions, but we will investigate
these later on in the series! For now, you can look at the
\href{http://hackage.haskell.org/package/singletons/docs/Data-Singletons.html}{documentation}
for the library to see more interesting utility functions!

\section{The Singularity}

In this post, at shortcomings in the usage of phantom types, and then saw how
singletons could help us with these. Then, we looked at how the
\emph{singletons} \textbf{library} makes using this pattern extremely easy and
smooth to integrate into your existing code.

You can see all of the "manual singletons" code in this post
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs}{here},
and then see the code re-implemented using the \emph{singletons} library
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs}{here}.

However, remember the question that I asked earlier, about creating a
\texttt{Door} with a given state that we don't know until runtime? So far, we
are only able to create \texttt{Door} and \texttt{SingDS} from types we
\emph{know} at compile-time. There is no way we have yet to convert a
\texttt{DoorState} from the value level to the type level -\/- so it seems that
there is no way to "load" a \texttt{Door\ s} with an \texttt{s} that depends on,
say, a file's contents, or user input. The fundamental issue is still \emph{type
erasure}.

In Part 2, we will delve into how to overcome this and break through from the
barrier of the dynamic "unsafe" runtime to the world of safe, typed, verified
code, and see how the \emph{singletons} library gives us great tools for this.
Afterwards, in Part 3, we will learn to express more complicated relationships
with types and type-level functions using defunctionalization and the tools from
the \emph{singletons} library, and finally break into the world of actual
"type-level programming".

As always, let me know in the comments if you have any questions! You can also
usually find me idling on the freenode \texttt{\#haskell} channel, as well, as
\emph{jle`}. The \emph{singletons}
\href{https://github.com/goldfirere/singletons/issues}{issue tracker} is also
very active. Happy haskelling!

For further reading, check out the
\href{https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf}{original
singletons paper}! It's very readable and goes over many of the same techniques
in this blog post, just written with a different perspective and tone :)

\section{Exercises}

Click on the links in the corner of the text boxes for solutions! (or just check
out
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs}{the
source file})

These should be written in the singletons library style, with \texttt{Sing}
instead of \texttt{SingDS} and \texttt{SingI} instead of \texttt{SingDSI}.
Review the
\href{https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs}{singletons
file} for a comparison, if you are still unfamiliar.

\begin{enumerate}
\item
  Write a function to unlock a door, but only if the user enters an odd number
  (as a password).

  \texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs\#L60-60\ unlockDoor\ ::\ Int\ -\textgreater{}\ Door\ \textquotesingle{}Locked\ -\textgreater{}\ Maybe\ (Door\ \textquotesingle{}Closed)}

  It should return a closed door in \texttt{Just} if the caller gives an odd
  number, or \texttt{Nothing} otherwise.
\item
  Write a function that can open any door, taking a password, in "implicit Sing"
  style:

  \texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs\#L65-65\ openAnyDoor\ ::\ SingI\ s\ =\textgreater{}\ Int\ -\textgreater{}\ Door\ s\ -\textgreater{}\ Maybe\ (Door\ \textquotesingle{}Opened)}

  This should be written in terms of \texttt{unlockDoor} and \texttt{openDoor}
  (see above) -\/- that is, you \textbf{should not} use \texttt{UnsafeMkDoor}
  directly for \texttt{openAnyDoor}.

  If the door is already unlocked or opened, it should ignore the \texttt{Int}
  input.
\end{enumerate}

\end{document}
