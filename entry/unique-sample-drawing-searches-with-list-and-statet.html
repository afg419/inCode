<!DOCTYPE HTML>
<html><head><title>Unique sample drawing &amp; searches with List and StateT --- &quot;Send more money&quot; Â· in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Nothing too crazy today, just a cute (basic/intermediate) haskell trick as a response to Mark Dominus&#39;s excellent Universe of Discourse post on Easy exhaustive search with the list monad intended for people new or unfamiliar with haskell demonstrating the common &quot;list monad as a constraint solver&quot; approach that is standard fare for learning Haskell. I myself have literally done an entire series of blog posts on this usage. Mark&#39;s use case however incorporates a bit of an extra pattern not typically discussed. The list monad is good for taking &quot;independent samples&quot; of things (looking at different samples from a list): ~~~haskell ghci&gt; do x &lt;- &quot;abc&quot; y &lt;- &quot;abc&quot; z &lt;- &quot;abc&quot; return [x,y,z] [&quot;aaa&quot;,&quot;aab&quot;,&quot;aac&quot;,&quot;aba&quot;,&quot;abb&quot; ... ] ~~~ However, what if you wanted to instead &quot;draw&quot; from a pool, and represent different drawings? Traditionally, the answer was something like: ~~~haskell ghci&gt; do x &lt;- &quot;abc&quot; y &lt;- filter (/= x) &quot;abc&quot; z &lt;- filter (/= y) . filter (/= x) $ &quot;abc&quot; return [x,y,z] &quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] ~~~ This is a little bit awkward...and it definitely gets a lot worse ($O(n^2)$) when you have more items. Also, it relies on an Eq constraint --- what if our thing doesn&#39;t have an Eq instance? And this also falls apart when our list contains duplicate items. If we had used &quot;aabc&quot; instead of &quot;abc&quot;, the result would be the same --- despite having more &#39;a&#39;s to pick from!"><meta property="og:type" content="article"><meta property="og:title" content="Unique sample drawing &amp; searches with List and StateT --- &quot;Send more money&quot;"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Unique sample drawing &amp; searches with List and StateT --- &quot;Send more money&quot;</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2015-04-24T11:05:56Z" pubdate="" class="pubdate">Friday April 24, 2015</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/send-more-money.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/unique-sample-drawing-searches-with-list-and-statet.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Nothing too crazy today, just a cute (basic/intermediate) haskell trick as a response to Mark Dominus's excellent <a href="http://blog.plover.com">Universe of Discourse</a> post on <a href="http://blog.plover.com/prog/haskell/monad-search.html">Easy exhaustive search with the list monad</a> intended for people new or unfamiliar with haskell demonstrating the common &quot;list monad as a constraint solver&quot; approach that is standard fare for learning Haskell. I myself have literally done <a href="http://blog.jle.im/entries/series/+monadplus-success-failure-monads">an entire series of blog posts</a> on this usage.</p>
<p>Mark's use case however incorporates a bit of an extra pattern not typically discussed. The list monad is good for taking &quot;independent samples&quot; of things (looking at different samples from a list):</p>
<p>~~~haskell ghci&gt; do x &lt;- &quot;abc&quot; y &lt;- &quot;abc&quot; z &lt;- &quot;abc&quot; return [x,y,z] [&quot;aaa&quot;,&quot;aab&quot;,&quot;aac&quot;,&quot;aba&quot;,&quot;abb&quot; ... ] ~~~</p>
<p>However, what if you wanted to instead &quot;draw&quot; from a pool, and represent different drawings? Traditionally, the answer was something like:</p>
<p>~~~haskell ghci&gt; do x &lt;- &quot;abc&quot; y &lt;- filter (/= x) &quot;abc&quot; z &lt;- filter (/= y) . filter (/= x) $ &quot;abc&quot; return [x,y,z] &quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] ~~~</p>
<p>This is a little bit awkward...and it definitely gets a lot worse ($O(n^2)$) when you have more items. Also, it relies on an <code>Eq</code> constraint --- what if our thing doesn't have an <code>Eq</code> instance? And this also falls apart when our list contains duplicate items. If we had used <code>&quot;aabc&quot;</code> instead of <code>&quot;abc&quot;</code>, the result would be the same --- despite having more <code>'a'</code>s to pick from!</p>
<p><strong>Important note:</strong> After writing this article, I found out that Douglas Auclair in <a href="https://wiki.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf">11th issue of the Monad Reader</a> solved this exact same problem with pretty much the exact same approach. (Oops!) If you want to do further reading, check it out! :D</p>
<h2>StateT</h2>
<p>There's a type in the <em>transformers</em> library that provides a very useful monad instance:</p>
<p>~~~haskell data StateT s m a = StateT (s -&gt; m (a, s)) ~~~</p>
<p>A <code>StateT s m a</code> is a function that takes an initial state <code>s</code> and returns a result <code>a</code> with a modified state...in the context of <code>m</code>.</p>
<p>Specialize for <code>m ~ []</code> and we get</p>
<p>~~~haskell data StateT s [] a = StateT (s -&gt; [(a, s)]) ~~~</p>
<p>Which is basically describing a function from a initial state to a list of <em>ways you can modify the state</em>, and different results from each one. It returns a list of &quot;all ways you can mutate this state&quot;.</p>
<p>For example,</p>
<p>~~~haskell foo :: StateT Int [] Bool foo = StateT $ \x -&gt; [(even x, x+1), (odd x, x-1), (x &gt; 0, negate x)] ~~~</p>
<p>So <code>foo</code> takes a number, <code>x</code>, and says, &quot;here are three ways we might proceed from having this number. We can return whether or not it's even, in which case the new state is <code>x+1</code>...we can return whether or not it's odd, in which case the new state is <code>x-1</code>....or we can return whether or not it's positive, in which case the new state is <code>negate x</code>&quot;</p>
<p>What the monad instance does is that it allows you to &quot;chain&quot; forks, and go along different forks, and gather together &quot;all possible forks&quot; you could have taken. At the end, it outputs all possible forks. So if you did <code>foo &gt;&gt; foo</code>, there'd be nine results --- one result for when you took the first route (the <code>x+1</code>) twice, one for when you took the first and then the second (<code>x-1</code>), one for when you took the first and the third....and the second and the first...etc., etc.</p>
<h3>MonadPlus</h3>
<p>One other tool we have at our disposal is <code>guard</code>:</p>
<p>~~~haskell guard :: Bool -&gt; StateT Int [] () ~~~~</p>
<p>which is a <code>StateT</code> action that says &quot;kill this current branch if given <code>False</code>, or go on if given <code>True</code>&quot;</p>
<h2>The Problem</h2>
<p>The problem, as stated, was to find distinct digits for each letter to solve:</p>
<p>~~~ S E N D + M O R E ----------- M O N E Y ~~~</p>
<p>So <code>SEND</code> is a four-digit number, <code>MORE</code> is a four-digit number, and <code>MONEY</code> is a five-digit number that is the sum of the two. The first digit of <code>MONEY</code> has to be the first digit of <code>MORE</code>, the last digit of <code>MORE</code> has to be the second digit of <code>SEND</code>, etc.</p>
<p>The previous approach was done using the entire &quot;pick from all possibilities...except for the ones already chosen&quot;, using <code>(/=)</code> and filtering over all of the things seen vs all of the things to pick from.</p>
<p>However, we can abstract over &quot;picking dependently from a sample&quot; by defining a function called <code>select</code>, which really should be in the base libraries but isn't for some reason:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L7-L9 select :: [a] -&gt; [(a, [a])] select [] = [] select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) &lt;- select xs] ~~~</p>
<p>(Implementation thanks to Cale, who has fought valiantly yet fruitlessly to get this into base for many years.)</p>
<p><code>select</code> will take a list <code>[a]</code> and return a list of different &quot;selected&quot; <code>a</code>s, with the rest of the list, too:</p>
<p>~~~haskell ghci&gt; select &quot;abcd&quot; [('a',&quot;bcd&quot;),('b',&quot;acd&quot;),('c',&quot;abd&quot;),('d',&quot;abc&quot;)] ~~~</p>
<p>But, hey...does the type signature of <code>select</code> look like anything familiar?</p>
<p>It looks <em>exactly</em> like something that <code>StateT</code> is supposed to describe! Give an initial state (<code>[a]</code>), and returns a list of all possible ways to &quot;mutate&quot; that state (by removing one element from the state), and a result from each mutation (the removed element).</p>
<p>~~~haskell StateT select :: StateT [a] [] a ~~~</p>
<p>And armed with this...we have all we need</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L3-L35 import Control.Monad (guard, mfilter) import Control.Monad.Trans.State import Data.List (foldl')</p>
<p>asNumber :: [Int] -&gt; Int asNumber = foldl' (\t o -&gt; t*10 + o) 0</p>
<p>main :: IO () main = print . flip evalStateT [0..9] $ do s &lt;- StateT select e &lt;- StateT select n &lt;- StateT select d &lt;- StateT select m &lt;- StateT select o &lt;- StateT select r &lt;- StateT select y &lt;- StateT select guard $ s /= 0 &amp;&amp; m /= 0 let send = asNumber [s,e,n,d] more = asNumber [m,o,r,e] money = asNumber [m,o,n,e,y] guard $ send + more == money return (send, more, money) ~~~</p>
<p>Remember, <code>StateT</code> here operates with an underlying state of <code>[Int]</code>, a list of numbers not yet picked. <code>StateT select</code> picks one of these numbers, and modifies the state to now only include the items that were not picked. So every time you sequence <code>StateT select</code>, <code>select</code> draws from a smaller and smaller pool of numbers, and makes the state list smaller and smaller. What sequencing <code>StateT</code> does is allow us to explore <em>all</em> of the possible ways we could pick and modify state, all at once. Using <code>guard</code>, we then &quot;close off&quot; and kill off the paths that don't end up how we'd like.</p>
<p><code>asNumber</code> takes a list like <code>[1,2,3]</code> and turns it into the number <code>123</code>; credit to the source blog.</p>
<p>And, to test it out...</p>
<p>~~~bash $ ghc -O2 send-more-money.hs $ ./send-more-money</p>
<h1>[(9567,1085,10652)]</h1>
<p>~~~</p>
<p>It returns the one and only solution, <code>SEND = 9567</code>, <code>MORE = 1085</code>, and <code>MONEY = 10652</code>.[^perf]</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Aside</strong></p>
<p>We can make things a little bit more efficient with minimal cost in expressiveness. But not that it matters...the original version runs fast already.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/send-more-money.hs#L38-L59 select' :: [a] -&gt; [(a,[a])] select' = go [] where go xs [] = [] go xs (y:ys) = (y,xs++ys) : go (y:xs) ys</p>
<p>main' :: IO () main' = print . flip evalStateT [0..9] $ do s &lt;- mfilter (/= 0) $ StateT select' m &lt;- mfilter (/= 0) $ StateT select' e &lt;- StateT select' n &lt;- StateT select' d &lt;- StateT select' o &lt;- StateT select' r &lt;- StateT select' y &lt;- StateT select' let send = asNumber [s,e,n,d] more = asNumber [m,o,r,e] money = asNumber [m,o,n,e,y] guard $ send + more == money return (send, more, money) ~~~</p>
<p>This is a more performant version of <code>select</code> <a href="http://chimera.labs.oreilly.com/books/1230000000929/pr01.html">courtesy of Simon Marlow</a> that doesn't preserve the order of the &quot;rest of the elements&quot;.</p>
<p>Also, we use <code>mfilter</code> to &quot;eliminate bad <code>s</code> and <code>m</code>s&quot; right off the bat, before having to pick any more things. <code>mfilter</code> can be thought of as &quot;killing the fork immediately&quot; if the action doesn't satisfy the predicate. If the <code>s</code> picked doesn't match <code>(/= 0)</code>, then the entire branch/fork is immediately ruled invalid. &lt;/div&gt;</p>
<p>By the way, isn't it neat that it does all of this in &quot;constant space&quot;? It just keeps track of the output list, but the actual search processes is in constant space. You don't need to keep track of all <code>10!</code> combinations in memory at once. Hooray laziness!</p>
<h2>Other Applications</h2>
<p>Using <code>select</code> and <code>StateT</code>, we can do a lot of things involving picking from a sample, or permutations. Anything that you used to awkwardly do by using filter not-equal-to's can work now. You can do things like drawing from a deck:</p>
<p>~~~haskell pokerGame :: [Ordering] pokerGame = flip evalStateT [0..51] $ do p2Hand &lt;- replicateM 5 (StateT select) p1Hand &lt;- replicateM 5 (StateT select) return $ pokerCompare p1Hand p2Hand ~~~</p>
<p>Which would draw five distinct cards from a deck of <code>[0..51]</code>, and return who won for each draw (assuming you had a suitable <code>pokerCompare :: [Card] -&gt; [Card] -&gt; Ordering</code>). Note that if you use <code>runStateT</code>, you'd get the results (the winner), <em>as well as</em> the leftover cards in the deck for each path!</p>
<p>&lt;!-- I used to have an example here about simulating russian roulette --&gt;</p>
<p>&lt;!-- But this doesn't really work in a useful way...because the paths all &quot;stop&quot; --&gt; &lt;!-- after the first shot. In reality, you are just as likely to be shot on the --&gt; &lt;!-- first pull as you are on the second. But as this simulation runs, it &quot;stops&quot; --&gt; &lt;!-- after the first shot...so <code>1</code> will only show up once. --&gt;</p>
<p>You can even combine the two sorts of drawings --- sampling independently (like rolling dice) using <code>lift</code>, and drawing from an underlying deck. For example, you might encode some game logic from a board game like monopoly:</p>
<p>~~~haskell combo = flip evalStateT initialDeck $ do roll &lt;- lift [1..6] draw &lt;- StateT select ... ~~~</p>
<p>Whenever you want a dice roll, use <code>lift [1..6]</code>...and whenever you want to draw from the deck, use <code>StateT select</code>.</p>
<p>What you get in the end, remember, is a list of &quot;all possible paths&quot;. You'll get a list of every possible result from all of your different rolling and drawing choices.</p>
<p>Happy Haskelling!</p></div><footer><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/monads.html" class="tag-a-tag">#monads</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/auto-a-todo-gui-application-with-auto-on.html">Auto: A Todo GUI application with Auto (on GHCJS, etc.)</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html">Fixed-Length Vector Types in Haskell, 2015</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html';
    this.page.identifier = 'send-more-money';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>