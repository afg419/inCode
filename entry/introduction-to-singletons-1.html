<!DOCTYPE HTML>
<html><head><title>Dependent Types in Haskell: Introduction to Singletons (Part 1) · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Real dependent types are coming to Haskell soon! Until then, we have the great singletons library :) If you’ve ever run into dependently typed programming in Haskell, you’ve probably encountered mentions of singletons (and the singletons library). This series of articles will be my attempt at giving you the story of the library, the problems it solves, the power that it gives to you, and how you can integrate it into your code today! (Also, after my previous April Fools post, people have been asking me for an actual non-joke singletons post.)"><meta property="og:type" content="article"><meta property="og:title" content="Dependent Types in Haskell: Introduction to Singletons (Part 1)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/introduction-to-singletons-1.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/introduction-to-singletons-1.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Dependent Types in Haskell: Introduction to Singletons (Part 1)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/singletons-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/introduction-to-singletons-1.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/introduction-to-singletons-1.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Real dependent types are coming to Haskell soon! Until then, we have the great <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library :)</p>
<p>If you’ve ever run into dependently typed programming in Haskell, you’ve probably encountered mentions of singletons (and the <em>singletons</em> library). This series of articles will be my attempt at giving you the story of the library, the problems it solves, the power that it gives to you, and how you can integrate it into your code today!<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> (Also, after <a href="https://blog.jle.im/entry/verified-instances-in-haskell.html">my previous April Fools post</a>, people have been asking me for an actual non-joke singletons post.)</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>These posts will assume no knowledge of dependent types, and, for now, only basic to intermediate Haskell knowledge. (Types, kinds, typeclasses, data types, functions) The material in this post greatly <em>overlaps</em> with my <a href="https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html">dependently typed neural networks</a> series, but some of the concepts are introduced in different contexts.</p>
<p>All code is built on <em>GHC 8.2.1</em> and with the <em><a href="https://www.stackage.org/nightly-2017-11-27">nightly-2017-11-27</a></em> snapshot (so, singletons-2.3.1). However, there are negligible changes in the GHC type system between GHC 8.0 and 8.2 (the only difference is in the libraries, more or less), so everything should work on GHC 8.0 as well!</p>
<p>The content in the first section of this post, describing the singleton design pattern, uses the following extensions:</p>
<ul>
<li>DataKinds</li>
<li>GADTs</li>
<li>KindSignatures</li>
<li>RankNTypes</li>
<li>TypeApplications</li>
<li>TypeInType</li>
</ul>
<p>And the second section, introducing the library itself, uses, on top of these:</p>
<ul>
<li>TypeFamilies</li>
<li>TemplateHaskell</li>
</ul>
<p>These extension will be explained when they are used or become relevant.</p>
<h2 id="the-phantom-of-the-types">The Phantom of the Types</h2>
<p>Let’s start with a very common Haskell trick that most learn early in their Haskelling journey: the <a href="https://wiki.haskell.org/Phantom_type">phantom type</a>.</p>
<p>Phantom types in Haskell are a very easy way to add a layer of “type safety” for your types and DSL’s. It helps you restrict what values functions can take and encode pre- and post-conditions directly into your types.</p>
<p>For example, in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> a <span class="fu">=</span> <span class="dt">MkFoo</span></code></pre></div>
<p>The <code>a</code> parameter is phantom, because nothing of type <code>a</code> in the data type…it just exists as a dummy parameter for the <code>Foo</code> type. We can use <code>MkFoo</code> without ever requiring something of type <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkFoo</span><span class="ot"> ::</span> <span class="dt">Foo</span> <span class="dt">Int</span>
<span class="dt">Foo</span> <span class="dt">Int</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MkFoo</span><span class="ot"> ::</span> <span class="dt">Foo</span> <span class="dt">Bool</span>
<span class="dt">Foo</span> <span class="dt">Bool</span></code></pre></div>
<p>A common use case of phantom type parameters is to tag data as “sanitized” or “unsanitized”, for instance. For a simple example, let’s check out a simple DSL for a type-safe door:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L13-16</span>
<span class="kw">data</span> <span class="dt">DoorState</span> <span class="fu">=</span> <span class="dt">Opened</span> <span class="fu">|</span> <span class="dt">Closed</span> <span class="fu">|</span> <span class="dt">Locked</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="kw">data</span> <span class="dt">Door</span> (<span class="ot">s ::</span> <span class="dt">DoorState</span>) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="dt">String</span></code></pre></div>
<p>A couple things going on here:</p>
<ol type="1">
<li><p>Our type we are going to be playing with is a <code>Door</code>, which contains a single field describing, say, the material that the door is made out of. (<code>UnsafeMkDoor &quot;Oak&quot;</code> would be an oak door)</p></li>
<li><p>We’re using the <code>DataKinds</code> extension to create both the <em>type</em> <code>DoorState</code> as well as the <em>kind</em> <code>DoorState</code>.</p>
<p>Normally, <code>data DoorState = Opened | Closed | Locked</code> in Haskell defines the type <code>DoorState</code> and the value constructors <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>.</p>
<p>However, with <code>DataKinds</code>, that statement also defines a new <em>kind</em> <code>DoorState</code>, with <em>type</em> constructors <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>. (note the <code>'</code> ticks!)<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="ch">&#39;Opened</span>
<span class="dt">DoorState</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>k <span class="ch">&#39;Locked</span>
<span class="dt">DoorState</span></code></pre></div></li>
</ol>
<ol start="3" type="1">
<li><p>We’re defining the <code>Door</code> type with a <em>phantom parameter</em> <code>s</code>. It’s a phantom type because we don’t actually have any <em>values</em> of type <code>s</code> in our data type…the <code>s</code> is only just there as a dummy parameter for the type.</p>
<p>We can use <code>UnsafeMkDoor</code> without ever using anything of type <code>s</code>. In reality, a real <code>Door</code> type would be a bit more complicated (and the direct <code>UnsafeMkDoor</code> constructor would be hidden).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Birch&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Opened</span>
<span class="dt">Door</span> <span class="ch">&#39;Opened</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Iron&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
<span class="dt">Door</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p>We can also use the <em>TypeApplications</em> extension to write this in a bit more convenient way –</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span><span class="ch">&#39;Opened &quot;Birch&quot;</span>
<span class="dt">Door</span> <span class="ch">&#39;Opened</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">UnsafeMkDoor</span> <span class="fu">@</span><span class="ch">&#39;Locked &quot;Iron&quot;</span>
<span class="dt">Door</span> <span class="ch">&#39;Locked</span></code></pre></div></li>
</ol>
<p>We’ll take a <code>Door s</code> to mean the type of a door with that current status. So a <code>Door 'Opened</code> is the type of an opened door, a <code>Door 'Closed</code> is the type of a closed (and unlocked) door, etc. The <code>String</code> that the <code>Door</code> contains represents its material (oak, birch, spruce, etc.).</p>
<p>Alternatively, we can define <code>Door</code> using <a href="https://en.wikibooks.org/wiki/Haskell/GADT#Syntax"><em>GADT</em> syntax</a> (which requires the <code>GADTs</code> extension).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Door</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">UnsafeMkDoor</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s</code></pre></div>
<p>This is defining the exact same type in the alternate “GADT syntax” style of data type declaration – here, we define types by giving the type of its constructors.</p>
<h3 id="phantoms-in-action">Phantoms in Action</h3>
<p>At first, this seems a bit silly. Why even have the extra type parameter if you don’t ever use it?</p>
<p>Well, right off the bat, we can write functions that expect only a certain type of <code>Door</code>, and return a specific type of <code>Door</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L18-19</span>
<span class="ot">closeDoor ::</span> <span class="dt">Door</span> <span class="ch">&#39;Opened -&gt; Door &#39;</span><span class="dt">Closed</span>
closeDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> m</code></pre></div>
<p>So, the <code>closeDoor</code> function will <em>only</em> take a <code>Door 'Opened</code> (an opened door). And it will return a <code>Door 'Closed</code> (a closed door).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">let</span> myDoor <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Spruce&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Opened</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor myDoor
<span class="dt">Door</span> <span class="ch">&#39;Closed</span>
ghci<span class="fu">&gt;</span> <span class="kw">let</span> yourDoor <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> <span class="st">&quot;Acacia&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Closed</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor yourDoor
<span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span></code></pre></div>
<p>You can think of this as a nice way of catching <em>logic errors</em> at compile-time. If your door type did not have its status in the type, the <code>closeDoor</code> could have been given a closed or locked door, and you’d have to reject it at runtime!</p>
<p>By adding the state of the door into its type, we can encode our pre-conditions and post-conditions directly into the type. And any opportunity to move runtime errors to compile-time errors should be celebrated with a little party!</p>
<p>This would also stop you from doing silly things like closing a door twice in a row:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor <span class="fu">.</span> closeDoor
<span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span>  <span class="dt">TYPE</span> <span class="dt">ERROR</span><span class="fu">!</span></code></pre></div>
<p>Do you see why?</p>
<p>With a couple of state transitions, we can write compositions that are typechecked to all be legal:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L21-25</span>
<span class="ot">lockDoor ::</span> <span class="dt">Door</span> <span class="ch">&#39;Closed -&gt; Door &#39;</span><span class="dt">Locked</span>
lockDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span> m

<span class="ot">openDoor ::</span> <span class="dt">Door</span> <span class="ch">&#39;Closed -&gt; Door &#39;</span><span class="dt">Opened</span>
openDoor (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> (<span class="dt">UnsafeMkDoor</span> m)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t closeDoor <span class="fu">.</span> openDoor
<span class="dt">Door</span> <span class="ch">&#39;Closed -&gt; Door &#39;</span><span class="dt">Closed</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t lockDoor <span class="fu">.</span> closeDoor <span class="fu">.</span> openDoor
<span class="dt">Door</span> <span class="ch">&#39;Closed -&gt; Door &#39;</span><span class="dt">Locked</span></code></pre></div>
<h3 id="the-phantom-menace">The Phantom Menace</h3>
<p>However, in standard Haskell, we quickly run into some practical problems if we program with phantom types this way.</p>
<p>For example, how could we write a function to get the state of a door?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">doorStatus ::</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span>
doorStatos _ <span class="fu">=</span> <span class="co">-- ?</span></code></pre></div>
<p>(It can be done with an ad-hoc typeclass, but it’s not simple, and it’s prone to implementation bugs)</p>
<p>And, perhaps even more important, how can you create a <code>Door</code> with a given state that isn’t known until runtime? If we know the type of our doors at compile-time, we can just explicitly write <code>UnsafeMkDoor &quot;Iron&quot; :: Door 'Opened</code> or <code>UnsafeMkDoor @'Opened &quot;Iron&quot;</code>. But what if we wanted to make a door based on a <code>DoorState</code> input?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s
mkDoor <span class="dt">Opened</span> <span class="fu">=</span> <span class="co">-- ?</span>
mkDoor <span class="dt">Closed</span> <span class="fu">=</span> <span class="co">-- ?</span>
mkDoor <span class="dt">Locked</span> <span class="fu">=</span> <span class="co">-- ?</span></code></pre></div>
<p>Ah hah, you say. That’s easy!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s
mkDoor <span class="dt">Opened</span> <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span>
mkDoor <span class="dt">Closed</span> <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span>
mkDoor <span class="dt">Locked</span> <span class="fu">=</span> <span class="dt">UnsafeMkDoor</span></code></pre></div>
<p>Unfortunately, that’s not how types work in Haskell. Remember that for a polymorphic type <code>forall s. DoorState -&gt; String -&gt; Door s</code>, the <em>caller</em> picks the type variable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mkDoor <span class="dt">Opened</span> <span class="st">&quot;Acacia&quot;</span><span class="ot"> ::</span> <span class="dt">Door</span> <span class="ch">&#39;Closed</span>
<span class="dt">Door</span> <span class="ch">&#39;Closed</span></code></pre></div>
<p>Oops!</p>
<h3 id="the-fundamental-issue-in-haskell">The Fundamental Issue in Haskell</h3>
<p>We’ve hit upon a fundamental issue in Haskell’s type system: <strong>type erasure</strong>. In Haskell, types only exist <em>at compiletime</em>, for help with typechecking. They are completely erased at runtime.</p>
<p>This is usually what we want. It’s great for performance, and you can bypass things like the ad-hoc runtime type checking that you have to deal with in dynamic languages like python.</p>
<p>But in our case, it makes functions like <code>doorState</code> fundamentally impossible. Or, does it?</p>
<h2 id="the-singleton-pattern">The Singleton Pattern</h2>
<p>A singleton in Haskell is a type that, for each instantiation its type variables, has exactly one inhabitant, and whose constructor (when pattern matched on) reveals its type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L27-30</span>
<span class="kw">data</span> <span class="dt">SingDS</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SingDS</span> <span class="ch">&#39;Opened</span>
    <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SingDS</span> <span class="ch">&#39;Closed</span>
    <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SingDS</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p>Here we’re using <em>GADT syntax</em> again. (Also note that <code>Type</code> a synonym for the <code>*</code> kind, exported from the <em>Data.Kind</em> module) Notice that, if we use <code>SOpened</code>, we will get a <code>SingDS 'Opened</code>. And if we have a <code>SingDS 'Opened</code>, we know that it was constructed using <code>SOpened</code>. Essentially, this gives us three values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">SingDS</span> <span class="ch">&#39;Opened</span>
<span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">SingDS</span> <span class="ch">&#39;Closed</span>
<span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">SingDS</span> <span class="ch">&#39;Locked</span></code></pre></div>
<h3 id="the-power-of-the-pattern-match">The Power of the Pattern Match</h3>
<p>The power of singletons is that we can now <em>pattern match</em> on types, essentially.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L32-39</span>
<span class="ot">doorStatus ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span>
doorStatus <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="co">-- in this branch, `s` is `&#39;Opened`</span>
        \_ <span class="ot">-&gt;</span> <span class="dt">Opened</span>
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="co">-- in this branch, `s` is `&#39;Closed`</span>
        \_ <span class="ot">-&gt;</span> <span class="dt">Closed</span>
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="co">-- in this branch, `s` is `&#39;Locked`</span>
        \_ <span class="ot">-&gt;</span> <span class="dt">Locked</span></code></pre></div>
<p>(using <em>LambdaCase</em> syntax)</p>
<p>We can rewrite <code>doorStats</code> to take an additional <code>SingDS</code>, which we can use to figure out what <code>s</code> is. When we pattern match on it, we reveal what <code>s</code> is. Essentially, the gain the ability to “pattern match” on the <code>s</code> type variable.</p>
<p>The singleton property of <code>SingDS</code> ensures us that whatever <code>s</code> the <code>SingDS</code> has is the <em>same</em> <code>s</code> that the <code>Door</code> has.</p>
<p>Not only do <em>we</em> know what <code>s</code> is, but GHC can also take advantage of it. In the scope of the case statement branch, GHC <em>knows</em> what <code>s</code> must be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L18-45</span>
<span class="ot">closeDoor ::</span> <span class="dt">Door</span> <span class="ch">&#39;Opened -&gt; Door &#39;</span><span class="dt">Closed</span>

<span class="ot">lockDoor ::</span> <span class="dt">Door</span> <span class="ch">&#39;Closed -&gt; Door &#39;</span><span class="dt">Locked</span>

<span class="ot">lockAnyDoor ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> (<span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked)</span>
lockAnyDoor <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> lockDoor <span class="fu">.</span> closeDoor
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> lockDoor
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> id</code></pre></div>
<p>Note that <code>lockDoor . closeDoor :: Door 'Opened -&gt; Door 'Locked</code>. GHC will only allow you to compile that if it <em>knew</em> that the input is <code>Door 'Opened</code>…and, because of the GADT pattern match, it does!</p>
<p>Similar for the <code>SLocked -&gt; id</code> branch — <code>id</code> is only a valid response if <code>s</code> is <code>'Locked</code> (and so <code>id :: Door 'Locked -&gt; Door 'Locked</code>). But, because we pattern matched on <code>SLocked</code>, GHC knows that this is legal!</p>
<p>We say that <code>SOpened</code> is a “runtime witness” to <code>s</code> being <code>'Opened</code>.</p>
<h3 id="recovering-implicit-passing">Recovering Implicit Passing</h3>
<p>One downside is that we are required to manually pass in our witness. Wouldn’t it be nice if we could have it be passed implicitly? We can do something with typeclasses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L47-55</span>
<span class="kw">class</span> <span class="dt">SingDSI</span> s <span class="kw">where</span>
<span class="ot">    singDS ::</span> <span class="dt">SingDS</span> s

<span class="kw">instance</span> <span class="dt">SingDSI</span> <span class="ch">&#39;Opened where</span>
    singDS <span class="fu">=</span> <span class="dt">SOpened</span>
<span class="kw">instance</span> <span class="dt">SingDSI</span> <span class="ch">&#39;Closed where</span>
    singDS <span class="fu">=</span> <span class="dt">SClosed</span>
<span class="kw">instance</span> <span class="dt">SingDSI</span> <span class="ch">&#39;Locked where</span>
    singDS <span class="fu">=</span> <span class="dt">SLocked</span></code></pre></div>
<p>And so now we can do:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L57-61</span>
<span class="ot">doorStatus_ ::</span> <span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">DoorState</span>
doorStatus_ <span class="fu">=</span> doorStatus singDS

<span class="ot">lockAnyDoor_ ::</span> <span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnyDoor_ <span class="fu">=</span> lockAnyDoor singDS</code></pre></div>
<p>Here, type inference will tell GHC that you want <code>singDS :: SingDS s</code>, and it will pull out the proper singleton for the door you want to check!</p>
<p>(By the way, If you program Haskell regularly, it should slightly bug you that it’s super easy to write a bad instance of <code>SingDSI</code>. More about this later.)</p>
<h4 id="the-same-power">The Same Power</h4>
<p>In Haskell, a constraint <code>SingDSI s =&gt;</code> is essentially the same as passing in <code>SingDS s</code> explicitly. Either way, you are passing in a runtime witness that your function can use. You can think of <code>SingDSI s =&gt;</code> as passing it in <em>implicitly</em>, and <code>SingDS s -&gt;</code> as passing it in <em>explicitly</em>.</p>
<p>Earlier, I disparaged the “ad-hoc typeclass” approach. But, here, the typeclass isn’t quite ad-hoc; it’s basically exactly carrying around an implicit witness of <code>s</code> that we can grab at any time.</p>
<p>So, it’s important to remember that <code>doorStatus</code> and <code>doorStatus_</code> are the “same function”, with the same power. They are just written in different styles – <code>doorStatus</code> is written in explicit style, and <code>doorStatus_</code> is written in implicit style.</p>
<h4 id="going-backwards">Going backwards</h4>
<p>Going from <code>SingDSI s =&gt;</code> to <code>SingDS s -&gt;</code> (implicit to explicit) is very easy – just use <code>singDS</code> to get a <code>SingDS s</code> if you have a <code>SingDSI s</code> constraint available.</p>
<p>Going from <code>SingDS s -&gt;</code> to <code>SingDSI s =&gt;</code> (explicit to implicit) in Haskell is actually a little trickier. The typical way to do this is with a CPS-like utility function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L63-67</span>
<span class="ot">withSingDSI ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> (<span class="dt">SingDSI</span> s <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r
withSingDSI s x <span class="fu">=</span> <span class="kw">case</span> s <span class="kw">of</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> x
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> x
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> x</code></pre></div>
<p><code>withSingDSI</code> takes a <code>SingDS s</code>, and a value (of type <code>r</code>) that requires a <code>SingDSI s</code> instance to be created. And it creates that value for you!</p>
<p>It works because in each branch, <code>s</code> is now a <em>specific</em>, monomorphic, “concrete” <code>s</code>, and GHC knows that such an instance exists for every branch. In the <code>SOpened</code> branch, <code>s ~ 'Opened</code>,<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> so GHC knows that there is a <code>SingDSI 'Opened</code> instance, and gives it to you. In the <code>SCloed</code> branch, <code>s ~ 'Closed</code>, so GHC knows that there is a <code>SingDSI 'Closed</code> instance, and gives <em>that</em> to you, etc.</p>
<p>So now, we can run our implicit functions (like <code>lockAnyDoor_</code>) by giving them explicit inputs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L69-70</span>
<span class="ot">lockAnyDoor__ ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnyDoor__ s d <span class="fu">=</span> withSingDSI s (lockAnyDoor_ d)</code></pre></div>
<h3 id="fun-with-witnesses">Fun with Witnesses</h3>
<p>We can write a nice version of <code>mkDoor</code> using singletons:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L72-76</span>
<span class="ot">mkDoor ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s
mkDoor <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="dt">UnsafeMkDoor</span>
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="dt">UnsafeMkDoor</span>
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="dt">UnsafeMkDoor</span></code></pre></div>
<p>So we can call it values of <code>SingDS</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mkDoor <span class="dt">SOpened</span> <span class="st">&quot;Oak&quot;</span>
<span class="dt">Door</span> <span class="ch">&#39;Opened</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mkDoor <span class="dt">SLocked</span> <span class="st">&quot;Spruce&quot;</span>
<span class="dt">Door</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p>And now we can’t do something silly like pass in <code>SLocked</code> to get a <code>Door 'Opened</code>!</p>
<p>However, this is still a step away from a <code>Door</code> whose status can vary at runtime.</p>
<h2 id="ditching-the-phantom">Ditching the Phantom</h2>
<p>Now, sometimes we don’t actually care about the state of the door, and we don’t <em>want</em> the state of the door in its type. Our <code>closeAnyDoor</code> function earlier was an example.</p>
<p>We have a couple of options here — we can create a new type <code>SomeDoor</code>, that doesn’t have the opened/closed status in its type, but rather as a runtime value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">UnsafeMkSomeDoor</span> <span class="dt">DoorState</span> <span class="dt">String</span></code></pre></div>
<p>Now, we could have actually been using this type the entire time, if we didn’t care about type safety. In the real world and in real applications, we might have actually written <code>SomeDoor</code> before we ever thought about <code>Door</code> with a phantom type. It’s definitely the more typical Haskell thing.</p>
<p>We can “construct” this from a normal <code>Door</code>, using the smart constructor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromDoor ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
fromDoor <span class="dt">SOpened</span> (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Opened</span> m
formDoor <span class="dt">SClosed</span> (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Closed</span> m
formDoor <span class="dt">SLocked</span> (<span class="dt">UnsafeMkDoor</span> m) <span class="fu">=</span> <span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Locked</span> m</code></pre></div>
<h3 id="somedoor-to-door">SomeDoor to Door</h3>
<p>Now, <code>SomeDoor</code> is great. But isn’t it annoying that we might potentially have to write the same function for both <code>Door</code> and <code>SomeDoor</code>, because they have different implementations. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">closeSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeDoor</span>
closeSomeDoor (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Opened</span> m) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Closed</span> m)
closeSomeDoor (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Closed</span> m) <span class="fu">=</span> <span class="dt">Nothing</span>
closeSomeDoor (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Locked</span> m) <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<p>Wouldn’t it be nice if we can re-use our original <code>closeDoor</code>? This is a toy example, and in real life, closing a door might have some complicated runtime logic, and it’d be annoying to re-implement it for both <code>SomeDoor</code> and <code>Door</code>.</p>
<p>One thing we can do is write a function to convert a <code>SomeDoor</code> into a <code>Door</code>, so we can re-use our original <code>closeDoor</code>.</p>
<h4 id="converting-into-an-existential">Converting into an existential</h4>
<p>Going from <code>SomeDoor</code> to <code>Door s</code> is slightly trickier in Haskell than going the other way around. One trick we often use is a CPS-style existential type.</p>
<p>The essential concept is that normal Haskell type variables are universally qualified, meaning that the <em>caller</em> can pick how to instantiate <code>s</code>. However, we want a function where the <em>function</em> can pick the <code>s</code>, and the caller must handle whatever <code>s</code> is given by the function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r
withSomeDoor (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Opened</span> m) f <span class="fu">=</span> f <span class="dt">SOpened</span> (<span class="dt">UnsafeMkDoor</span> m)
withSomeDoor (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Closed</span> m) f <span class="fu">=</span> f <span class="dt">SClosed</span> (<span class="dt">UnsafeMkDoor</span> m)
withSomeDoor (<span class="dt">UnsafeMkSomeDoor</span> <span class="dt">Locked</span> m) f <span class="fu">=</span> f <span class="dt">SLocked</span> (<span class="dt">UnsafeMkDoor</span> m)</code></pre></div>
<p>Notice the funky CPS-like type signature of <code>withSomeDoor</code>. To use <code>withSomeDoor</code> and access the <code>Door</code>, you have to pass in a function to handle <em>any possible <code>s</code></em>. And, as you can see, the function passed in might be given an <code>SOpened</code>, an <code>SClosed</code>, or an <code>SLocked</code>. It has to be able to handle all three!</p>
<p>Here, we call <code>s</code> <em>existentially quantified</em>. The <code>withSomeDoor</code> function gets to pick which <code>s</code> to give <code>f</code>. So, the <code>s</code> type variable is chosen by the <em>function</em>, and not by the caller.</p>
<p>So we can implement <code>closeSomeDoor</code> (and even a <code>lockAnySomeDoor</code>) using this conversion function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">closeSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="ch">&#39;Closed)</span>
closeSomeDoor sd <span class="fu">=</span> withSomeDoor sd <span class="fu">$</span> \<span class="kw">case</span>
    <span class="dt">SOpened</span> <span class="ot">-&gt;</span> \d <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> closeDoor d
    <span class="dt">SClosed</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="dt">SLocked</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">lockAnySomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnySomeDoor sd <span class="fu">=</span> withSomeDoor sd <span class="fu">$</span> \s d <span class="ot">-&gt;</span>
    lockAnyDoor s d</code></pre></div>
<h4 id="the-existential-datatype">The Existential Datatype</h4>
<p>However, there’s another path we can take. With the power of singletons, we can actually implement <code>SomeDoor</code> <em>in terms of</em> <code>Door</code>, using an existential data type!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- using existential constructor syntax</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> forall s<span class="fu">.</span> <span class="dt">MkSomeDoor</span> (<span class="dt">SingDS</span> s) (<span class="dt">Door</span> s)

<span class="co">-- or, using GADT syntax</span>
<span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L78-79</span>
<span class="kw">data</span> <span class="dt">SomeDoor</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">MkSomeDoor</span><span class="ot"> ::</span> <span class="dt">SingDS</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span></code></pre></div>
<p><code>MkSomeDoor</code> is a constructor for an existential data type, meaning that the data type “hides” a type variable <code>s</code>.</p>
<p>Hopefully you can see the similarities between our original <code>SomeDoor</code> and this one. The key difference is that original <code>SomeDoor</code> contains a <code>DoorState</code>, and this new <code>SomeDoor</code> contains a <code>SingDS</code> (a <em>singleton</em> for the <code>DoorState</code>).</p>
<p>In Haskell, existential data types are pretty nice, syntactically, to work with. For a comparison, let’s re-implement our previous functions with our new data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L81-88</span>
<span class="ot">closeSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="ch">&#39;Closed)</span>
closeSomeDoor <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> d <span class="ot">-&gt;</span> <span class="dt">Just</span> (closeDoor d)
    <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

<span class="ot">lockAnySomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked</span>
lockAnySomeDoor (<span class="dt">MkSomeDoor</span> s d) <span class="fu">=</span> lockAnyDoor s d</code></pre></div>
<p>It’s important to remember that our original separate-implementation <code>SomeDoor</code> is, functionally, identical to the new code-reusing <code>SomeDoor</code>. The reason why they are the same is that <em>having an existentially quantified singleton is the same as having a value of the corresponding type.</em> Having an existentially quantified <code>SingDS s</code> is <em>the same as</em> having a value of type <code>DoorState</code>.</p>
<p>If they’re identical, why use a <code>SingDS</code> or the new <code>SomeDoor</code> at all? One main reason (besides allowing code-reuse) is that <em>using the singleton lets us recover the type</em>. Essentially, a <code>SingDS s</code> not only contains whether it is Opened/Closed/Locked…it contains it in a way that GHC can use to bring it all back to the type level.</p>
<p>Basically, <code>SingDS</code> allows us to re-use our original <code>Door s</code> implementation, because we store both the <code>Door</code>…<em>and</em> the <code>s</code> at the type level. It also lets GHC <em>check</em> our implementations, to help ensure that they are correct, because you maintain the <code>s</code> at the type level.</p>
<h4 id="some-lingo">Some Lingo</h4>
<p>In the language of dependently typed programming, we call <code>SomeDoor</code> a <strong>dependent sum</strong>, because you can imagine it basically as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeDoor</span> <span class="fu">=</span> <span class="dt">SDOpened</span> (<span class="dt">SingDS</span> <span class="ch">&#39;Opened) (Door &#39;</span><span class="dt">Opened</span>)
              <span class="fu">|</span> <span class="dt">SDClosed</span> (<span class="dt">SingDS</span> <span class="ch">&#39;Closed) (Door &#39;</span><span class="dt">Closed</span>)
              <span class="fu">|</span> <span class="dt">SDLocked</span> (<span class="dt">SingDS</span> <span class="ch">&#39;Locked) (Door &#39;</span><span class="dt">Locked</span>)</code></pre></div>
<p>A three-way sum between a <code>Door 'Opened</code>, a <code>Door 'Closed</code>, and a <code>Door 'Locked</code>, essentially. If you have a <code>SomeDoor</code>, it’s <em>either</em> an opened door, a closed door, or a locked door. Try looking at this new <code>SomeDoor</code> until you realize that this type is the same type as the previous <code>SomeDoor</code>!</p>
<p>You might also see <code>SomeDoor</code> called a <strong>dependent pair</strong>, because it’s basically an existentially quantified tuple of the type (the <code>s</code>, witnessed by the <code>SingDS s</code>) with a value (the <code>Door s</code>).</p>
<h3 id="types-at-runtime">Types at Runtime</h3>
<p>With this last tool, we finally have enough to build a function to “make” a door with the status unknown until runtime:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L90-94</span>
<span class="ot">mkSomeDoor ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span>
mkSomeDoor <span class="fu">=</span> \<span class="kw">case</span>
    <span class="dt">Opened</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> <span class="fu">.</span> mkDoor <span class="dt">SOpened</span>
    <span class="dt">Closed</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> <span class="fu">.</span> mkDoor <span class="dt">SClosed</span>
    <span class="dt">Locked</span> <span class="ot">-&gt;</span> <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> <span class="fu">.</span> mkDoor <span class="dt">SLocked</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">let</span> mySomeDoor <span class="fu">=</span> mkSomeDoor <span class="dt">Opened</span> <span class="st">&quot;Birch&quot;</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t mySomeDoor
<span class="dt">SomeDoor</span>
ghci<span class="fu">&gt;</span> putStrLn <span class="fu">$</span> <span class="kw">case</span> mySomeDoor <span class="kw">of</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SOpened</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was opened!&quot;</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SClosed</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was closed!&quot;</span>
        <span class="dt">MkSomeDoor</span> <span class="dt">SLocked</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;mySomeDoor was locked!&quot;</span>
mySomeDoor was opened<span class="fu">!</span></code></pre></div>
<p>Using <code>mkSomeDoor</code>, we can truly pass in a <code>DoorState</code> that we generate at runtime (from IO, or a user prompt, or a configuration file, maybe), and create a <code>Door</code> based on it.</p>
<p>Take <em>that</em>, type erasure! :D</p>
<h2 id="the-singletons-library">The Singletons Library</h2>
<p>Now that we understand some of the benefits of singletons as they relate to phantom types, we can appreciate what the singletons <em>library</em> has to offer: a fully unified, coherent system for working with singletons of almost <em>all</em> Haskell types!</p>
<p>First, there’s Template Haskell for generating our singletons given our type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DoorState</span> <span class="fu">=</span> <span class="dt">Opened</span> <span class="fu">|</span> <span class="dt">Closed</span> <span class="fu">|</span> <span class="dt">Locked</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

genSingletons [<span class="ch">&#39;&#39;</span><span class="dt">DoorState</span>]

<span class="co">-- or</span>
<span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L17-20</span>
<span class="fu">$</span>(singletons [d|
  data DoorState = Opened | Closed | Locked
    deriving (Show, Eq)
  |])</code></pre></div>
<p>This generates, for us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- not the actual code, but essentially what happens</span>
<span class="kw">data</span> <span class="dt">Sing</span><span class="ot"> ::</span> <span class="dt">DoorState</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SOpened</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Opened</span>
    <span class="dt">SClosed</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Closed</span>
    <span class="dt">SLocked</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="ch">&#39;Locked</span></code></pre></div>
<p><code>Sing</code> is a poly-kinded type constructor (a “data family”). <code>STrue :: Sing 'True</code> is the singleton for <code>'True</code>, <code>SJust SOpened :: Sing ('Just 'Opened)</code> is the singleton for <code>'Just 'Opened</code>, etc.</p>
<p>It also generates us instances for <code>SingI</code>, a poly-kinded typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">SingI</span> <span class="ch">&#39;Opened where</span>
    sing <span class="fu">=</span> <span class="dt">SOpened</span>
<span class="kw">instance</span> <span class="dt">SingI</span> <span class="ch">&#39;Closed where</span>
    sing <span class="fu">=</span> <span class="dt">SClosed</span>
<span class="kw">instance</span> <span class="dt">SingI</span> <span class="ch">&#39;Locked where</span>
    sing <span class="fu">=</span> <span class="dt">SLocked</span></code></pre></div>
<p>Which is basically our <code>SingDSI</code> typeclass, except we have instances for singletons of all kinds! (heh) There’s a <code>SingI</code> instance for <code>'True</code>, a <code>SingI</code> instance for <code>10</code>, a <code>SingI</code> instance for <code>'Just 'Opened</code>, etc.:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span><span class="ot"> sing ::</span> <span class="dt">Sing</span> <span class="ch">&#39;True</span>
<span class="dt">STrue</span>
ghci<span class="fu">&gt;</span><span class="ot"> sing ::</span> <span class="dt">Sing</span> (<span class="ch">&#39;Just &#39;</span><span class="dt">Opened</span>)
<span class="dt">SJust</span> <span class="dt">SOpened</span></code></pre></div>
<p>The great thing about the library is that these types and instances are generated, that they’re correct (note that I could have implemented <code>SingDSI</code> incorrectly earlier, bu using the library guarantees that I don’t), and that they all work together smoothly.</p>
<p>We also have <code>withSingI</code>, which is equivalent to our <code>withSingDSI</code> function earlier.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSingI ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> (forall r<span class="fu">.</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div>
<p>Note that if you have singletons for a kind <code>k</code>, you also have instances for kind <code>Maybe k</code>, as well. And also for <code>[k]</code>, even! This is a major advantage of using the <em>singletons</em> library to manage your singletons instead of writing them yourself.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">SOpened</span> <span class="ot">`SCons`</span> <span class="dt">SClosed</span> <span class="ot">`SCons`</span> <span class="dt">SLocked</span> <span class="ot">`SCons`</span> <span class="dt">SNil</span>
<span class="dt">Sing</span> <span class="ch">&#39;[ &#39;</span><span class="dt">Opened</span>, <span class="ch">&#39;Closed, &#39;</span><span class="dt">Locked</span> ]</code></pre></div>
<p>(Remember that, because of <code>DataKinds</code>, <code>Maybe</code> is a kind constructor, who has two type constructors, the type <code>'Nothing</code> and the type constructor <code>'Just :: k -&gt; Maybe k</code>)</p>
<p>Singletons for all integrate together seamlessly, and you have mechanisms to generate them for your own type and roll it all into the system!</p>
<h3 id="extra-goodies">Extra Goodies</h3>
<p>In addition to generating singletons for our libraries, it gives us convenient functions for working with the different “manifestations” of our types.</p>
<p>Recall that <code>DoorState</code> has four different things associated with it now:</p>
<ol type="1">
<li>The <em>type</em> <code>DoorState</code>, whose value constructors are <code>Opened</code>, <code>Closed</code>, and <code>Locked</code>.</li>
<li>The <em>kind</em> <code>DoorState</code>, whose type constructors are <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code></li>
<li>The singletons for <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked</code>.</li>
<li>The <code>SingI</code> instances for <code>'Opened</code>, <code>'Closed</code>, and <code>'Locked'</code></li>
</ol>
<p>Kind of confusing, and in the future, when we have real dependent types, we can hopefully combine all of these manifestations into the same thing. But for now, we do have to deal with converting between them, and for that, we have, generated for us:</p>
<ul>
<li><p><code>fromSing :: Sing (s :: DoorState) -&gt; DoorState</code> takes us from singletons to values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> fromSing <span class="dt">SOpened</span>
<span class="dt">Opened</span></code></pre></div></li>
<li><p><code>toSing :: DoorState -&gt; SomeSing DoorState</code> takes us from values to their (existentially quantified) singletons</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">let</span> s <span class="fu">=</span> toSing <span class="dt">Opened</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>t s
<span class="ot">s ::</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>
ghci<span class="fu">&gt;</span> putStrLn <span class="fu">$</span> <span class="kw">case</span> s <span class="kw">of</span>
        <span class="dt">SomeSing</span> <span class="dt">SOpened</span> <span class="ot">-&gt;</span> <span class="st">&quot;Opened.&quot;</span>
        <span class="dt">SomeSing</span> <span class="dt">SClosed</span> <span class="ot">-&gt;</span> <span class="st">&quot;SClosed.&quot;</span>
        <span class="dt">SomeSing</span> <span class="dt">SLocked</span> <span class="ot">-&gt;</span> <span class="st">&quot;SLocked.&quot;</span>
<span class="st">&quot;Opened.&quot;</span></code></pre></div>
<p><code>SomeSing</code> is like <code>SomeDoor</code> in that it is an existentially quantified singleton:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> <span class="dt">DoorState</span>

<span class="co">-- or, more accurately, since `SomeSing` is polykinded</span>
<span class="kw">data</span> <span class="dt">SomeSing</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">SomeSing</span><span class="ot"> ::</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k) <span class="ot">-&gt;</span> <span class="dt">SomeSing</span> k</code></pre></div></li>
</ul>
<p>It does this by defining a type class (actually, a “kind class”), <code>SingKind</code>, associating each type to the corresponding datakinds-generated kind. The <code>SingKind</code> instance for <code>DoorState</code> links the type <code>DoorState</code> to the kind <code>DoorState</code>.</p>
<p>The library also defines a neat type synonym, <code>type SDoorState = Sing</code>, so you can do <code>SDoorState 'Opened</code> instead of <code>Sing 'Opened</code>, if you wish.</p>
<p>There are definitely more useful utility functions, but we will investigate these later on in the series! For now, you can look at the <a href="http://hackage.haskell.org/package/singletons/docs/Data-Singletons.html">documentation</a> for the library to see more interesting utility functions!</p>
<h2 id="the-singularity">The Singularity</h2>
<p>In this post, at shortcomings in the usage of phantom types, and then saw how singletons could help us with these. Then, we looked at how the <em>singletons</em> <strong>library</strong> makes using this pattern extremely easy and smooth to integrate into your existing code.</p>
<p>You can see all of the “manual singletons” code in this post <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs">here</a>, and then see the code re-implemented using the <em>singletons</em> library <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs">here</a>.</p>
<p>However, full expressively with phantom types is still out of our reach. If we want to express more complicated relationships and to be able to treat phantom types (and <em>types</em>, in general) as first-class values, and delve into the frighteningly beautiful world of “type-level programming”, we are going to have to dig a bit deeper. Come back for the next post to see how! Singletons will be our tool, and we’ll also see how the singletons library is a very clean unification of a lot of concepts.</p>
<p>As always, let me know in the comments if you have any questions! You can also usually find me idling on the freenode <code>#haskell</code> channel, as well, as <em>jle`</em>. The <em>singletons</em> <a href="https://github.com/goldfirere/singletons/issues">issue tracker</a> is also very active. Happy haskelling!</p>
<h2 id="exercises">Exercises</h2>
<p>Click on the links in the corner of the text boxes for solutions!</p>
<p>These should be written in the singletons library style, with <code>Sing</code> instead of <code>SingDS</code> and <code>SingI</code> instead of <code>SingDSI</code>. Review the <a href="https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs">singletons file</a> for a comparison, if you are still unfamiliar.</p>
<ol type="1">
<li><p>Write a function to unlock a door, but only if the user enters an odd number (as a password).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L85-85</span>
<span class="ot">unlockDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> <span class="ch">&#39;Locked -&gt; Maybe (Door &#39;</span><span class="dt">Closed</span>)</code></pre></div>
<p>It should return a closed door in <code>Just</code> if the caller gives an odd number, or <code>Nothing</code> otherwise.</p></li>
<li><p>Write a function that can open any door, taking a password.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L90-90</span>
<span class="ot">openAnyDoor ::</span> <span class="dt">SingI</span> s <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="ch">&#39;Opened)</span></code></pre></div>
<p>This should be written in terms of <code>unlockDoor</code> and <code>openDoor</code>.</p>
<p>If the door is already unlocked or opened, it should ignore the <code>Int</code> input.</p></li>
<li><p>Implement <code>withSomeDoor</code> for our “new” existentially quantified <code>SomeDoor</code> type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L103-103</span>
<span class="ot">withSomeDoor ::</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">Sing</span> s <span class="ot">-&gt;</span> <span class="dt">Door</span> s <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</code></pre></div></li>
<li><p>Implement <code>openAnySomeDoor</code>, which should work like <code>lockAnySomeDoor</code>, just wrapping an application of <code>openAnyDoor</code> inside a <code>SomeDoor</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L99-99</span>
<span class="ot">openAnySomeDoor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">SomeDoor</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Door</span> <span class="ch">&#39;Opened)</span></code></pre></div>
<p>Note that because we wrote <code>openAnyDoor</code> in “implicit style”, we might have to convert between <code>SingI s =&gt;</code> and <code>Sing s -&gt;</code> style, using <code>withSingI</code>.</p></li>
</ol>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This series will be based on <a href="http://talks.jle.im/lambdaconf-2017/singletons/">a talk</a> I gave over the summer, and will expand on it eventually.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>The <code>'</code> ticks are technically optional, but I find that it’s good style, at this point in Haskell, to use them whenever you can. It’ll prevent a lot of confusion, trust me!<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><code>~</code> here refers to “type equality”, or the constraint that the types on both sides are equal. <code>s ~ 'Opened</code> can be read as “<code>s</code> is <code>'Opened</code>”.<a href="#fnref3">↩</a></p></li>
</ol>
</section></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Dependent Types in Haskell&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series" title="+Practical Dependent Types in Haskell"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html" class="tag-a-series">+Practical Dependent Types in Haskell</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/introduction-to-singletons-1.html';
    this.page.identifier = 'singletons-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>