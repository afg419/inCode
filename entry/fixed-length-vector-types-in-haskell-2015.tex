\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Fixed-Length Vector Types in Haskell, 2015 \% Justin Le \% May 5, 2015

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html}{in
Code}}.}

\textbf{\emph{Update}}: This post was written by me when I was just starting to
learn about type-level things in Haskell, and reflects my own inexperience at
the time of writing it. I have
\href{https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html}{released
an update}, which presents what I hope to be an introduction that is more
grounded in modern Haskell and dependent type idioms.

\section{Original Article (written in 2015)}

Fixed-length vector types (vector types that indicate the length of the vector
in the type itself) are one of the more straightforward applications of the
"super-Haskell" GHC type extensions. There's a lot of magic you can do with
GHC's advanced type mechanisms, but I think fixed length vectors are a good
first step to beginning to understand several extensions, including
(potentially):

\begin{itemize}
\tightlist
\item
  ConstraintKinds
\item
  DataKinds
\item
  GADTs
\item
  KindSignatures
\item
  TypeFamilies
\item
  TypeOperators
\item
  OverloadedLists
\end{itemize}

And using type system plugins. (And of course the usual
\texttt{UndecidableInstances} etc.) We'll be discussing two different ways to
implement this -\/-\/- using type-level nats, and using the \emph{GHC.TypeLits}
model to actually be able to use numeric literals in your types. These things
are seen in the wild like with the popular
\emph{\href{http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html}{linear}}
package's \texttt{V} type.

There are a few great tutorials/writeups on this topic, but many of them are
from the time before we had some of these extensions, or only discuss a few. I
hope to provide a nice comprehensive look about the tools available today to
really approach this topic. That being said, I am no expert myself, so I would
appreciate any tips/edits/suggestions for things that I've missed or done
not-the-best :) This post has a lot of open questions that I'm sure people who
know more about this than me can answer.

Most of the code in this article can be
\href{https://github.com/mstksg/inCode/blob/master/code-samples/fixvec}{downloaded
and tried out}, so follow along if you want!

\section{The Idea}

The basic idea is we'll have a type:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell Vec n a
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which is a vector with items of type \texttt{a}, whose length is somehow encoded
in the \texttt{n}. We'll then discuss ways to do useful operations on this, as
if it were a list.

\texttt{n} can really only be a certain "kind" of thing -\/-\/- a type that
encodes a length. We can represent this by giving it a "kind signature":

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Vec :: Nat
-\textgreater{} * -\textgreater{} *
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Which says that our \texttt{Vec} type constructor takes two arguments: something
of kind \texttt{Nat} (so it can't be any type...it has to be a type of kind
\texttt{Nat}), something of kind \texttt{*} (the "normal" kind, of things that
have values, like \texttt{Int}, \texttt{Maybe\ Bool}, etc.), and returns
something of kind \texttt{*} (our vector itself).

\section{Using DataKinds for Type-Level Nats}

(The code in this section for this type is
\href{https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs}{available
online}, if you wanted to play along!)

There are a couple of ways to find something for that \texttt{n} \texttt{Nat}
kind, and one way is to use the simple inductive \texttt{Nat}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L26-L27
data Nat = Z \textbar{} S Nat deriving Show
\textasciitilde{}\textasciitilde{}\textasciitilde{}

You might have seen this type before...it gives us value-level natural numbers,
where \texttt{Z} is zero, \texttt{S\ Z} is one, \texttt{S\ (S\ Z)} is two,
\texttt{S\ (S\ (S\ Z))} is three, etc. So if we had something of type
\texttt{Nat}, it could represent any natural number. This declaration gives you:

\begin{itemize}
\tightlist
\item
  A type \texttt{Nat}
\item
  A value constructor \texttt{Z\ ::\ Nat}
\item
  A value constructor \texttt{S\ ::\ Nat\ -\textgreater{}\ Nat}
\end{itemize}

However, with the \emph{DataKinds} extension, when you define this, you also
define some extra fancy things. You also define a \emph{kind} \texttt{Nat}! More
specifically, you get:

\begin{itemize}
\tightlist
\item
  A kind \texttt{Nat}
\item
  A type \texttt{Z\ ::\ Nat} (\texttt{Z}, of \emph{kind} \texttt{Nat})
\item
  A type constructor \texttt{S\ ::\ Nat\ -\textgreater{}\ Nat} (\texttt{S},
  which takes something of kind \texttt{Nat}, and returns a new thing of kind
  \texttt{Nat})
\end{itemize}

(Note that, to be principled, GHC would prefer us to use
\texttt{\textquotesingle{}Z} and \texttt{\textquotesingle{}S} when we are
referring to the \emph{types}, and this is how it'll print them out in error
messages. But we're going to run with this for now...mostly for aesthetic
reasons)

We can check this out in GHCi:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
:set -XDataKinds ghci\textgreater{} data Nat = Z \textbar{} S Nat
ghci\textgreater{} :k Z Nat ghci\textgreater{} :k S Z Nat ghci\textgreater{} :k
S (S Z) Nat \textasciitilde{}\textasciitilde{}\textasciitilde{}

So now we have a \emph{type} that can encode numbers. Something of type
\texttt{Z} represents zero...something of type \texttt{S\ Z} represents
1...something of type \texttt{S\ (S\ Z)} represents two.

Note that you can't ever have anything like \texttt{S\ Bool}...that doesn't
work, because \texttt{Bool} is of kind \texttt{*}, but \texttt{S} expects only
\texttt{Nat}s.

Now we can make our \texttt{Vec} data type, with the \emph{GADTs} extension, or
"generalized algebraic data types":

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L37-L44
data Vec :: Nat -\textgreater{} * -\textgreater{} * where Nil :: Vec Z a (:\#)
:: a -\textgreater{} Vec n a -\textgreater{} Vec (S n) a

infixr 5 :\#

deriving instance Show a =\textgreater{} Show (Vec n a) deriving instance Eq a
=\textgreater{} Eq (Vec n a) \textasciitilde{}\textasciitilde{}\textasciitilde{}

If you've never seen GADTs before, think of it as a way of declaring a type by
giving the type of your constructors instead of just the normal boring form.
It's nothing too crazy...it's basically like defining \texttt{Maybe} as:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Maybe :: *
-\textgreater{} * where Nothing :: Maybe a Just :: a -\textgreater{} Maybe a
\textasciitilde{}\textasciitilde{}\textasciitilde{}

instead of

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Maybe a =
Nothing \textbar{} Just a \textasciitilde{}\textasciitilde{}\textasciitilde{}

In both cases, they create constructors of type \texttt{Nothing\ ::\ Maybe\ a}
and \texttt{Just\ ::\ a\ -\textgreater{}\ Maybe\ a} anyway...so the GADT form
just gives us a way to state it explicitly.

Oh, we also used the \emph{KindSignatures} extension to be able to give a kind
signature to \texttt{Vec}...this is important because we want to make sure the
first argument has to be a \texttt{Nat}. That is, we can't have anything silly
like \texttt{Vec\ Bool\ Int}. We also have to put a separate
\emph{StandaloneDeriving}-extension standalone deriving clause instead of just
having \texttt{deriving\ Show} because \texttt{Vec} isn't a type that can be
expressed in "normal Haskell".

Note that our type is basically like a list:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data {[}{]} :: *
-\textgreater{} * where {[}{]} :: {[}a{]} (:) :: a -\textgreater{} {[}a{]}
-\textgreater{} {[}a{]} \textasciitilde{}\textasciitilde{}\textasciitilde{}

Except now our type constructor actually has a new \texttt{Nat}

This means that, because of type erasure, everything "runtime" on our new type
is basically going to be identical to \texttt{{[}{]}} (not considering compiler
tricks). In-memory, this new type is essentially exactly \texttt{{[}{]}}, but
its type has an extra tag that is erased at compile-time.

Okay, let's define some useful methods:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L93-L97
headV :: Vec (S n) a -\textgreater{} a headV (x :\# \_) = x

tailV :: Vec (S n) a -\textgreater{} Vec n a tailV (\_ :\# xs) = xs
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Ah, the classic \texttt{head}/\texttt{tail} duo from the days pre-dating
Haskell. \texttt{head} and \texttt{tail} are somewhat of a sore spot or wart in
Haskell's list API{[}\^{}htgone{]}, because they're \emph{partial functions}.
You tell people all about how Haskell is great because it can prevent run-time
errors by ensuring completeness and having the type system enforce null-pointer
checks...but then you go ahead and put unsafe functions that throw errors for
empty lists anyways in Prelude.

But here...this will never happen! We can only use \texttt{headV} and
\texttt{tailV} on non-empty lists...it won't typecheck for empty lists. Do you
see why?

It's because all empty lists are of type \texttt{Vec\ Z\ a}. But \texttt{headV}
and \texttt{tailV} only take things of \emph{type} \texttt{Vec\ (S\ n)\ a}, for
any \texttt{Nat} \texttt{n}. So, if you ever try to use it on an empty list, it
won't even compile! No more pesky runtime bugs. \texttt{headV} and
\texttt{tailV} are safe and will never crash at runtime!

Note that the return type of \texttt{tailV} is a vector of a length one less
than the given vector.
\texttt{tailV\ ::\ Vec\ (S\ Z)\ a\ -\textgreater{}\ Vec\ Z\ a}, for
instance...or
\texttt{tailV\ ::\ Vec\ (S\ (S\ Z))\ a\ -\textgreater{}\ Vec\ (S\ Z)\ a}. Just
like we want!

If you tried implementing this yourself, you might notice that you actually get
an \emph{error} from GHC if you even \emph{try} to handle the \texttt{Nil} case
for \texttt{tailV} or \texttt{headV}. GHC will know when you've handled all
possible cases, and get mad at you if you try to handle a case that doesn't even
make sense!

\subsection{Type families and appending}

We can also "append" vectors. But we need a way to add \texttt{Nat}s together
first. For that, we can use a type family, using the \emph{TypeFamilies}
extension (with \texttt{TypeOperators}):

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L29-L31
type family (x :: Nat) + (y :: Nat) where 'Z + y = y 'S x + y = 'S (x + y)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

A "type family" is like a type level function. Compare this to defining
\texttt{(+)} on the value level to the \texttt{Nat} \emph{data} type:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L33-L35
(+\#) :: Nat -\textgreater{} Nat -\textgreater{} Nat -\/- types! Z +\# y = y S x
+\# y = S (x +\# y) \textasciitilde{}\textasciitilde{}\textasciitilde{}

Basically, we're defining a new type-level function \texttt{(+)} on two types
\texttt{x} and \texttt{y}, both of kind \texttt{Nat}...and the result is their
"sum". Convince yourself that this "addition" is actually addition. Now, let's
use it for \texttt{appendV}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L99-L101
appendV :: Vec n a -\textgreater{} Vec m a -\textgreater{} Vec (n + m) a appendV
Nil ys = ys appendV (x :\# xs) ys = x :\# appendV xs ys
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
let v1 = 1 :\# 2 :\# 3 :\# Nil ghci\textgreater{} let v2 = 0 :\# 1 :\# Nil
ghci\textgreater{} v1 \texttt{appendV} v2 1 :\# 2 :\# 3 :\# 0 :\# 1 :\# Nil
ghci\textgreater{} :t v1 \texttt{appendV} v2 v1 \texttt{appendV} v2 :: Vec (S (S
(S (S (S Z))) Int \textasciitilde{}\textasciitilde{}\textasciitilde{}

\subsection{Generating}

It'd be nice to have type-safe methods of \emph{generating} these things,
too...functions like \texttt{iterate}, or \texttt{enumFrom}. One of the ways to
do this is by using a typeclass. (Available in a
\href{https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs}{separate
file} to try out).

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs\#L7-L8
class Unfoldable v where unfold :: (b -\textgreater{} (a, b)) -\textgreater{} b
-\textgreater{} v a \textasciitilde{}\textasciitilde{}\textasciitilde{}

We're going to call \texttt{v} an \texttt{Unfoldable} if you can build a
\texttt{v} from an "unfolding function" and an "initial state". Run the function
on the initial value and get the first item and a new state. Run the function on
the new state and get the second item and the next state.

The list instance should make it more clear:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs\#L11-L13
instance Unfoldable {[}{]} where unfold f x0 = let (y, x1) = f x0 in y : unfold
f x1 \textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
take 5 \$ unfold (\textbackslash{}x -\textgreater{} (x \texttt{mod} 3 == 2,
x\^{}2 - 1)) 2 {[}True, False, True, False, True{]}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Note that we can have an instance for any fixed-length vector type...where the
thing "cuts off" after it's filled the entire vector:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L46-L51
instance Unfoldable (Vec Z) where unfold \_ \_ = Nil

instance Unfoldable (Vec n) =\textgreater{} Unfoldable (Vec (S n)) where unfold
f x0 = let (y, x1) = f x0 in y :\# unfold f x1
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Take a moment to think about what these instances are doing.

You can create a \texttt{Vec\ Z\ a} from an unfolding function pretty easily,
because the only thing with type \texttt{Vec\ Z\ a} is \texttt{Nil}. So just
ignore the function/initial state and return \texttt{Nil}.

The instance for \texttt{Vec\ (S\ n)} is slightly more involved. To make a
\texttt{Vec\ (S\ n)\ a}, you need an \texttt{a} and a \texttt{Vec\ n\ a}. You
can get the \texttt{a} from the unfolding function...but where will you get the
\texttt{Vec\ n\ a} from? Well, you can use \texttt{unfold} to make a
\texttt{Vec\ n\ a}! But that only makes sense if \texttt{Vec\ n} is an
\texttt{Unfoldable}.

So, that's why in the instance for \texttt{Vec\ (S\ n)}, we constrain that
\texttt{Vec\ n} must also be an \texttt{Unfoldable}. We make our result by using
our function to create an \texttt{a} and \texttt{unfold} to create a
\texttt{Vec\ n\ a} (provided \texttt{Vec\ n} is an \texttt{Unfoldable}).

Note that this style of declaration looks a lot like induction. We define our
instance for zero...and then we say, "if \texttt{n} is an instance, then so is
\texttt{S\ n}". Induction!

Let's see this in action.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs\#L15-L24
replicateU :: Unfoldable v =\textgreater{} a -\textgreater{} v a replicateU =
unfold (\textbackslash{}x -\textgreater{} (x, x))

iterateU :: Unfoldable v =\textgreater{} (a -\textgreater{} a) -\textgreater{} a
-\textgreater{} v a iterateU f = unfold (\textbackslash{}x -\textgreater{} (x, f
x))

fromListMaybes :: Unfoldable v =\textgreater{} {[}a{]} -\textgreater{} v (Maybe
a) fromListMaybes = unfold \$ \textbackslash{}l -\textgreater{} case l of {[}{]}
-\textgreater{} (Nothing, {[}{]}) x:xs -\textgreater{} (Just x , xs)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
replicateU 'a' :: Vec (S (S (S Z))) Char 'a' :\# 'a' :\# 'a' :\# Nil
ghci\textgreater{} replicateU 'a' :: Vec Z Char Nil ghci\textgreater{} iterateU
succ 1 :: Vec (S (S (S (S Z)))) Int 1 :\# 2 :\# 3 :\# 4 :\# Nil
ghci\textgreater{} fromListMaybes {[}1,2{]} :: Vec (S (S (S Z))) (Maybe Int)
Just 1 :\# Just 2 :\# Nothing :\# Nil ghci\textgreater{} tailV (iterateU succ 1
:: Vec (S Z) Int) Nil \textasciitilde{}\textasciitilde{}\textasciitilde{}

Note that \texttt{replicateU} doesn't need to take in an \texttt{Int} parameter,
like the on in Prelude, to say how many items to have. It just replicates enough
to fill the entire vector we want!

\subsection{Common Typeclasses}

We can go in and implement common typeclasses, too. All the ones you'd expect.

We can actually use the \emph{DeriveFunctor} extension to write a
\texttt{Functor} instance, but let's write one on our own just for learning
purposes:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L53-L55
instance Functor (Vec n) where fmap \_ Nil = Nil fmap f (x :\# xs) = f x :\#
fmap f xs \textasciitilde{}\textasciitilde{}\textasciitilde{}

For \texttt{Applicative}, it isn't so simple. The Applicative instance is going
to be the "ZipList" instance...so we have to be able to make a \texttt{pure}
that depends on the type, and a \texttt{(\textless{}*\textgreater{})} that
depends on the type, too.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L57-L63
instance Applicative (Vec Z) where pure \_ = Nil Nil \textless{}*\textgreater{}
\_ = Nil

instance Applicative (Vec n) =\textgreater{} Applicative (Vec (S n)) where pure
x = x :\# pure x (f :\# fs) \textless{}\emph{\textgreater{} (x :\# xs) = f x :\#
(fs \textless{}}\textgreater{} xs)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

For \texttt{Vec\ Z}, it's just \texttt{Nil}. For \texttt{Vec\ (S\ n)}...for
pure, you need \texttt{x\ :\#} something...and that something has to be a
\texttt{Vec\ n\ a}. That's just \texttt{pure} for \texttt{Vec\ n}! Remember, we
can't assume that \texttt{Vec\ n} is an \texttt{Applicative} just because
\texttt{Vec\ (S\ n)} is. So we need to add a constraint, that \texttt{Vec\ n} an
Applicative. Induction, again!

For \texttt{(\textless{}*\textgreater{})}, we can get the first item easily,
it's just \texttt{f\ x}. But for the next item, we need a \texttt{Vec\ n\ a}.
Luckily...we have exactly that with the \texttt{(\textless{}*\textgreater{})}
for \texttt{Vec\ n}!

Remember, at the end, we're saying "We have an \texttt{Applicative} instance for
\emph{any} type \texttt{Vec\ n}". The instance for \texttt{Vec\ Z} has
\texttt{pure\ \_\ =\ Nil}. The instance for \texttt{Vec\ (S\ Z)} has
\texttt{pure\ x\ =\ x\ :\#\ Nil}. The instance for \texttt{Vec\ (S\ (S\ Z))} has
\texttt{pure\ x\ =\ x\ :\#\ x\ :\#\ Nil}, etc. etc.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
fmap (*2) (1 :\# 2 :\# 3 :\# Nil) 2 :\# 4 :\# 6 :\# Nil ghci\textgreater{} pure
10 :: Vec (S (S Z)) Int 10 :\# 10 :\# Nil -\/- like replicateV!
ghci\textgreater{} liftA2 (+) (1 :\# 2 :\# 3 :\# Nil) (100 :\# 201 :\# 302 :\#
Nil) 101 :\# 203 :\# 305 :\# Nil
\textasciitilde{}\textasciitilde{}\textasciitilde{}

I'll leave the \texttt{Monad} instance as an exercise, but it's in the source
files for this post. \texttt{join} for this instance should be a "diagonal"
-\/-\/- the first item of the first vector, the second item of the second
vector, the third item of the third vector, etc.

We can define \texttt{Foldable} and \texttt{Traversable} the same way. Like for
\texttt{Functor}, GHC can derive these with \emph{DeriveFoldable} and
\emph{DeriveTraversable}...but we'll do it again here just to demonstrate.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L65-L75
instance Foldable (Vec Z) where foldMap \_ Nil = mempty

instance Foldable (Vec n) =\textgreater{} Foldable (Vec (S n)) where foldMap f
(x :\# xs) = f x \textless{}\textgreater{} foldMap f xs

instance Traversable (Vec Z) where traverse \_ Nil = pure Nil

instance Traversable (Vec n) =\textgreater{} Traversable (Vec (S n)) where
traverse f (x :\# xs) = liftA2 (:\#) (f x) (traverse f xs)
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Note that we can only use \texttt{foldMap\ f\ xs} on \texttt{xs\ ::\ Vec\ n\ a},
if \texttt{Vec\ n} is a \texttt{Foldable}. So that's why we add that constraint.

Again,
\texttt{liftA2\ (:\#)\ ::\ Applicative\ f\ =\textgreater{}\ f\ a\ -\textgreater{}\ f\ (Vec\ n\ a)\ -\textgreater{}\ f\ (Vec\ (S\ n)\ a)}...so
this only makes sense if \texttt{traverse\ f\ s} gives us a \texttt{Vec\ n\ a}.
So we have to add that as a constraint.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
toList \$ 1 :\# 2 :\# 3 :\# Nil {[}1,2,3{]} ghci\textgreater{} traverse Identity
\$ 1 :\# 2 :\# 3 :\# Nil Identity (1 :\# 2 :\# 3 :\# Nil) ghci\textgreater{}
sequence\_ \$ putStrLn "hello" :\# putStrLn "world" :\# Nil "hello" "world"
ghci\textgreater{} sequence \$ Just 1 :\# Just 2 :\# Nil Just (1 :\# 2 :\# Nil)
ghci\textgreater{} sequence \$ Just 1 :\# Nothing :\# Nil Nothing
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\texttt{Traversable} of course opens a whole lot of doors. For example, we can
write a "safe \texttt{fromList}":

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs\#L26-L27
fromListU :: (Unfoldable v, Traversable v) =\textgreater{} {[}a{]}
-\textgreater{} Maybe (v a) fromListU = sequence . fromListMaybes
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
fromListU {[}1,2,3{]} :: Maybe (Vec (S Z) Int) Just (1 :\# Nil)
ghci\textgreater{} fromListU {[}1,2,3{]} :: Maybe (Vec (S (S (S Z))) Int) Just
(1 :\# 2 :\# 3 :\# Nil) ghci\textgreater{} fromListU {[}1,2,3{]} :: Maybe (Vec
(S (S (S (S Z)))) Int) Nothing
\textasciitilde{}\textasciitilde{}\textasciitilde{}

And, if you're on GHC 7.8+, you have access to the \emph{OverloadedLists}
language extension, where you can interpret list literals as if they were other
structures.

We've already already implemented both \texttt{fromList} and \texttt{toList}, in
a way, already, so this should be a breeze. The only trick you might see is that
the \texttt{IsList} typeclass asks for a type family to return the \emph{type of
the element in the container} from the container type.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L86-L91
instance (Unfoldable (Vec n), Traversable (Vec n)) =\textgreater{} L.IsList (Vec
n a) where type Item (Vec n a) = a fromList xs = case fromListU xs of Nothing
-\textgreater{} error "Demanded vector from a list that was too short." Just ys
-\textgreater{} ys toList = Data.Foldable.toList
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
:set -XOverloadedLists ghci\textgreater{} {[}1,2,3{]} :: Vec (S (S Z)) Int 1 :\#
2 :\# Nil ghci\textgreater{} {[}1,2,3{]} :: Vec (S (S (S (S Z)))) Int ***
Exception: Demanded vector from a list that was too short. ghci\textgreater{}
{[}1,3..{]} :: Vec (S (S (S (S Z)))) Int 1 :\# 3 :\# 5 :\# 7 :\# Nil
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Neat! All of the benefits of list literals that \emph{OverloadedLists} offers is
now available to us.{[}\^{}impossible{]} Unfortunately, you now open yourself up
to runtime errors, so...it's actually a really bad idea for safety purposes
unless you stick to only using it with infinite lists or are very disciplined.
(Unless you really want to use list syntax, \texttt{fromListU} is probably a
safer choice for finite lists!)

\subsection{Indexing}

It'd be nice to be able to index into these, of course. For type-safe indexing,
we can take advantage of a trick using the \texttt{Proxy} type.

Many might remember having to get a \texttt{TypeRep} for a \texttt{Typeable}
instance by doing something like \texttt{typeOf\ (undefined\ ::\ IO\ Double)}.
That's because
\texttt{typeOf\ ::\ Typeable\ a\ =\textgreater{}\ a\ -\textgreater{}\ TypeRep}.
If you wanted to get the \texttt{typeRep} for an \texttt{IO\ Double} using
\texttt{typeOf}, you have to pass in an \texttt{IO\ Double}. But if you don't
have one at hand, you can just use \texttt{undefined} with a type annotation.
It's a bit of a dirty hack, but it works because \texttt{typeOf} doesn't care
about the first argument's value...just its type.

These days, we like to be a bit less embarrassing and use something called
\texttt{Proxy}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell data Proxy a = Proxy
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\texttt{Proxy\ a} is a bit like \texttt{()}. It only has one constructor, and
doesn't take any arguments. But we can use the type signature to "pass in types"
to functions, as "arguments".

We have a couple of options here. One is to make a typeclass for type level nats
to turn them into an \texttt{Integer} or a value-level \texttt{Nat}, and then do
an "unsafe indexing" after verifying, through types, that the index is smaller
than the length.

However, this is a little bit silly because we're just doing an unsafe indexing
in the end anyway, so the compiler can't help us at all. Wouldn't it be nice if
we could get the compiler on our side and write a \emph{real} safe index?

There are many ways to approach this problem, but one way is to make a specific
\texttt{Index} typeclass: (or make another typeclass like \texttt{Take}, and
write \texttt{index} in terms of it)

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L77-L78
class Index (n :: Nat) v where index :: Proxy n -\textgreater{} v a
-\textgreater{} a \textasciitilde{}\textasciitilde{}\textasciitilde{}

Here, we can say that \texttt{n} and \texttt{v} are instances of
\texttt{Index\ n\ v} if and only if you can safely (totally) index into
\texttt{v\ a} at index \texttt{n}. That is, if every value of type \texttt{v\ a}
ever has an index at \texttt{n}, a \texttt{Nat}. (By the way, we need
\emph{MultiParamTypeClasses} to be able to make a type class with two
parameters)

So, \texttt{n\ \textasciitilde{}\ S\ Z} and
\texttt{v\ \textasciitilde{}\ Vec\ (S\ (S\ Z))\ a} has an instance, because you
can get the \$n = 1\$ element (the second element) from \emph{any} value of type
\texttt{Vec\ (S\ (S\ Z))\ a} (a length-two vector).

But \texttt{n\ \textasciitilde{}\ S\ Z} and
\texttt{v\ \textasciitilde{}\ Vec\ (S\ Z)\ a} does \emph{not}. There are
actually \emph{no} length-1 vectors that have a \$1\$ index (second element).

Note that we use the \texttt{Proxy} trick we discussed, so that we can indicate
somehow what index we really want. It is a trick that basically allows us to
pass a \emph{type} (\texttt{S\ Z}, \texttt{S\ (S\ Z)}, etc.) as a "value".

Let's write our instances -\/-\/- but only the instances that \emph{make sense}.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs\#L80-L84
instance Index Z (Vec (S n)) where index \_ (x :\# \_) = x

instance forall n m. Index n (Vec m) =\textgreater{} Index (S n) (Vec (S m))
where index \_ (\_ :\# xs) = index (Proxy :: Proxy n) xs
\textasciitilde{}\textasciitilde{}\textasciitilde{}

The first case instance makes sense. We can definitely index at index \texttt{Z}
(zero) of \emph{any} \texttt{Vec\ (S\ n)\ a} -\/-\/- the only thing we can't
index \texttt{Z} into is \texttt{Vec\ Z\ a}. So, if our vector is of length 1 or
higher, we can index at position 0.

The second case says that, if we can index into \texttt{n} of a
\texttt{Vec\ m\ a}, then of course we can index into an \texttt{S\ n} of a
\texttt{Vec\ (S\ m)\ a}. To index into \texttt{S\ n} of a
\texttt{Vec\ (S\ m)\ a}, all we need to do is index into \texttt{n} of the
\texttt{Vec\ m\ a} tail!

We have to use the \emph{ScopedTypeVariables} extension to enable us to use,
with the \texttt{forall} statement, the \texttt{n} in our instance when we are
writing our type for \texttt{Proxy}. If we didn't, the \texttt{n} in
\texttt{Proxy\ n} in our \texttt{index} definition would be considered unrelated
by GHC to the \texttt{n} in the instance statement,
\texttt{Index\ (S\ n)\ (Vec\ (S\ m))}. (This is the only reason we need the
\texttt{forall})

In any case, note the similarity of this algorithm to the actual indexing
function on lists:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell 0 !! (x:\_ ) = x n !!
(\_:xs) = (n - 1) !! xs \textasciitilde{}\textasciitilde{}\textasciitilde{}

trying it out...

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
index (Proxy :: Proxy (S (S Z))) (1 :\# 2 :\# 3 :\# Nil) 3 ghci\textgreater{}
index (Proxy :: Proxy (S (S Z))) (1 :\# 2 :\# Nil) *** Compile error!
\textasciitilde{}\textasciitilde{}\textasciitilde{}

It's an error, but remember, it's a \emph{compiler} error, that happens before
any code is ever even run! No more indexing errors at runtime! Kiss your days of
hunting segfault errors in C goodbye!

\textless{}div class="note"\textgreater{} \textbf{Aside}

This is something I haven't really been able to find a good answer too. But
notice that we actually could have written a "bad" instance of the second
instance of \texttt{Index}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell instance Index (S n)
(Vec (S m)) where index \_ (x :\# \_) = x
\textasciitilde{}\textasciitilde{}\textasciitilde{}

And this compiles fine...but gives the wrong behavior, or at least the behavior
we don't want!

Does anybody know a way to state the type of \texttt{Index} or \texttt{index} in
a way that implementations like this are impossible?

There's a "fundamental" problem here, it seems, because we can't really demand
or specify anything by the return type, like we could in the other examples. In
the other examples, we sort of restricted the implementation by choosing our
return type carefully...but for here, it's just \texttt{a}. I'd love to hear if
anyone has any thoughts on this. \textless{}/div\textgreater{}

You might notice that it's a bit of a plain to write
\texttt{S\ (S\ (S\ (S\ Z)))}, etc., especially for large numbers. And I wouldn't
even think about writing it for the hundreds.

We'll "fix" this in the next section. However, even before this, you actually
can generate these "automatically" with template haskell, using techniques from
\href{http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf}{Functional Pearls:
Implicit Configurations}, and the
\href{http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html}{linear}
package does just this. (This path slipped my mind before I posted because I
didn't really consider template Haskell, and I think I'll edit in a section here
soon). With this in mind, I still don't really consider Template Haskell an
optimal or clean approach :)

\section{Using TypeLits and Type Checker Plugins}

(This next section uses code that is
\href{https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs}{also
available online}, as well!)

Using a custom \texttt{Nat} kind and \emph{DataKinds} is nice and all, but it's
a bit of a hassle to express large numbers like 100, 1000, etc. However, as of
GHC 7.8, we've had the ability to actually \emph{use} numeric (integer) literals
in our types. Instead of writing \texttt{S\ (S\ Z)}, we can write \texttt{2}.

GHC can't yet quite work with that well by default. It has trouble proving
statements about variables, like
\texttt{(n\ +\ 1)\ \textasciitilde{}\ (1\ +\ n)} (that \texttt{n\ +\ 1} is "the
same as" \texttt{1\ +\ n}). Fortunately for us, since GHC 7.10, we have a way to
"extend" the type checker with custom plugins that \emph{can} prove things like
this for us. (Note that this \texttt{+} is the one from
\texttt{GHC.TypeLits}...not the one we defined earlier.)

The
\emph{\href{https://hackage.haskell.org/package/ghc-typelits-natnormalise}{ghc-typelits-natnormalise}}
package is a package providing such a plugin. We can have GHC use it to extend
its type checking by passing in \texttt{-fplugin\ GHC.TypeLits.Normalise} when
we execute our code, or by adding a pragma:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L14-L14
\{-\# OPTIONS\_GHC -fplugin GHC.TypeLits.Normalise \#-\}
\textasciitilde{}\textasciitilde{}\textasciitilde{}

to the top of our file, along with our \texttt{LANGUAGE} pragmas. (Assuming, of
course, a GHC 7.10+)

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
:set -XDataKinds -XTypeOperators -XTypeFamilies ghci\textgreater{} import
GHC.TypeLits ghci\textgreater{} Proxy :: ((n + 1) \textasciitilde{} (1 + n))
=\textgreater{} Proxy n *** Compile error: Cannot match \texttt{1\ +\ n} with
\texttt{n\ +\ 1} ghci\textgreater{} :set -fplugin GHC.TypeLits.Normalise
ghci\textgreater{} Proxy :: ((n + 1) \textasciitilde{} (1 + n)) =\textgreater{}
Proxy n Proxy -\/- success! \textasciitilde{}\textasciitilde{}\textasciitilde{}

GHC now uses the plugin to prove that the two are really equivalent.

If you wanted to play along or try out the code samples, I recommend you use a
sandbox:

\textasciitilde{}\textasciitilde{}\textasciitilde{}bash

\section{in directory of your choice}

\$ cabal sandbox init \$ cabal install ghc-typelits-natnormalise \$ cabal exec
bash

\section{now the package is in scope, when you use ghci or runghc}

\textasciitilde{}\textasciitilde{}\textasciitilde{}

With that in mind, let's start restating everything in terms of \emph{TypeLits}
and see what it gains us.

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L33-L40
data Vec :: Nat -\textgreater{} * -\textgreater{} * where Nil :: Vec 0 a (:\#)
:: a -\textgreater{} Vec (n - 1) a -\textgreater{} Vec n a

infixr 5 :\#

deriving instance Show a =\textgreater{} Show (Vec n a) deriving instance Eq a
=\textgreater{} Eq (Vec n a) \textasciitilde{}\textasciitilde{}\textasciitilde{}

A little nicer, right? \texttt{Nil} is a \texttt{Vec\ 0\ a}, and
\texttt{x\ :\#\ xs} is an element with a \texttt{Vec\ (n\ -\ 1)\ a}, which
overall is a \texttt{Vec\ n\ a}. Let's go over everything again to see how it'd
look in the new regime. (Note that the kind of the type number literals is also
called \texttt{Nat}...unrelated to our \texttt{Nat} we used before.)

\section{A new look}

First of all, we're going to have to define \emph{TypeLit} comparison operators,
as they aren't built in in a useful way.

We have the type family (remember those?) \texttt{CmpNat\ x\ y}, which returns
an \texttt{Ordering} (\texttt{LT}, \texttt{EQ}, or \texttt{GT}) type (of kind
\texttt{Ordering}, using \emph{DataKinds}...lifting a type and its value
constructors to a kind and its types), which is provided and defined for us by
GHC in \texttt{GHC.TypeLits}.

So defining a \texttt{x\ \textgreater{}\ y} constraint is pretty
straightforward:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L31-L31
type x \textgreater{} y = CmpNat x y \textasciitilde{} 'GT
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Note that we need the \emph{ConstraintKinds} extension for this to work, as
\texttt{1\ \textgreater{}\ 2} is now a \emph{constraint}, of kind
\texttt{Constraint}.

Given this, let's do our favorite list functions, \texttt{headV} and
\texttt{tailV}:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L89-L93
headV :: (n \textgreater{} 0) =\textgreater{} Vec n a -\textgreater{} a headV (x
:\# \_) = x

tailV :: (n \textgreater{} 0) =\textgreater{} Vec n a -\textgreater{} Vec (n -
1) a tailV (\_ :\# xs) = xs \textasciitilde{}\textasciitilde{}\textasciitilde{}

Magnificent!

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
headV (Nil :: Vec 0 ()) -\/- Error! Cannot unite 'EQ with 'GT
\textasciitilde{}\textasciitilde{}\textasciitilde{}

Neat! The error, remember, is at \emph{compile time}, and not at runtime. If we
ever tried to do an unsafe head, our code wouldn't even \emph{compile}! The
error message comes from the fact that we need \$n \textgreater{} 0\$, but we
have \$n = 0\$ instead. We have \texttt{EQ}, but we need \texttt{GT}.

There is one problem here, though -\/-\/- GHC gives us a warning for not pattern
matching on \texttt{Nil}. But, if we do try to pattern match on \texttt{Nil}, we
get a type error, like the same one we got when using our custom type nats. I
think this is probably something that a plugin or sufficiently smart
\texttt{CmpNat} might be able to handle...but I'm not totally sure. Right now,
the best thing I can think of is just to do a wildcard match,
\texttt{headV\ \_\ =\ error\ "What?"}, knowing that that case will never be
reached if your program compiles successfully.

Moving on, we see that we don't even have to do any extra work to define our own
type family \texttt{x\ +\ y}...because \texttt{GHC.TypeLits} already defines it
for us! So, we can instantly write....

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L95-L97
appendV :: Vec n a -\textgreater{} Vec m a -\textgreater{} Vec (n + m) a appendV
Nil ys = ys appendV (x :\# xs) ys = x :\# appendV xs ys
\textasciitilde{}\textasciitilde{}\textasciitilde{}

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
let v1 = 1 :\# 2 :\# 3 :\# Nil ghci\textgreater{} let v2 = iterateU succ 0 ::
Vec 2 Int ghci\textgreater{} v1 \texttt{appendV} v2 1 :\# 2 :\# 3 :\# 0 :\# 1
:\# Nil ghci\textgreater{} :t v1 \texttt{appendV} v2 :: Vec 5 Int v1
\texttt{appendV} v2 :: Vec 5 Int
\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}

And our list generating typeclasses -\/-\/-

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L42-L47
instance Unfoldable (Vec 0) where unfold \_ \_ = Nil

instance (Unfoldable (Vec (n - 1)), n \textgreater{} 0) =\textgreater{}
Unfoldable (Vec n) where unfold f x0 = let (y, x1) = f x0 in y :\# unfold f x1
\textasciitilde{}\textasciitilde{}\textasciitilde{}

The translation is pretty mechanical, but I think that this new formulation
looks...really nice, and really powerful. "If you can build a list from \$n -
1\$ and \$n \textgreater{} 0\$, then you can build a list for \$n\$!

Note that because our definitions of \texttt{replicateU}, \texttt{iterateU}, and
\texttt{fromListMaybes} was polymorphic over all \texttt{Unfoldable}, we can
actually re-use them from before:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
iterateU succ 1 :: Vec 3 int 1 :\# 2 :\# 3 :\# Nil ghci\textgreater{} iterateU
succ 1 :: Vec 10 Int 1 :\# 2 :\# 3 :\# 4 :\# 5 :\# 6 :\# 7 :\# 8 :\# 9 :\# 10
:\# Nil ghci\textgreater{} replicateU 'a' :: Vec 4 Char 'a' :\# 'a' :\# 'a' :\#
'a' :\# Nil \textasciitilde{}\textasciitilde{}\textasciitilde{}

The actual types are much nicer, too -\/-\/- we can write \texttt{Vec\ 10\ Int}
instead of
\texttt{Vec\ (S\ (S\ (S\ (S\ (S\ (S\ (S\ (S\ (S\ (S\ Z))))))))))\ Int} without
resorting to template haskell.

Going through all of our other typeclasses/functions and making the
adjustments... (remembering that we can also derive \texttt{Functor},
\texttt{Traversable}, and \texttt{Foldable} using GHC)

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs\#L49-L87
instance Functor (Vec n) where fmap \_ Nil = Nil fmap f (x :\# xs) = f x :\#
fmap f xs

instance Applicative (Vec 0) where pure \_ = Nil Nil \textless{}*\textgreater{}
\_ = Nil

instance (Applicative (Vec (n - 1)), n \textgreater{} 0) =\textgreater{}
Applicative (Vec n) where pure x = x :\# pure x (f :\# fs)
\textless{}\emph{\textgreater{} (x :\# xs) = f x :\# (fs
\textless{}}\textgreater{} xs)

instance Foldable (Vec 0) where foldMap \_ Nil = mempty

instance (Foldable (Vec (n - 1)), n \textgreater{} 0) =\textgreater{} Foldable
(Vec n) where foldMap f (x :\# xs) = f x \textless{}\textgreater{} foldMap f xs

instance Traversable (Vec 0) where traverse \_ Nil = pure Nil

instance (Traversable (Vec (n - 1)), n \textgreater{} 0) =\textgreater{}
Traversable (Vec n) where traverse f (x :\# xs) = liftA2 (:\#) (f x) (traverse f
xs)

class Index (n :: Nat) v where index :: Proxy n -\textgreater{} v a
-\textgreater{} a

instance (m \textgreater{} 0) =\textgreater{} Index 0 (Vec m) where index \_ (x
:\# \_) = x

instance forall n m. (Index (n - 1) (Vec (m - 1)), n \textgreater{} 0, m
\textgreater{} 0) =\textgreater{} Index n (Vec m) where index \_ (\_ :\# xs) =
index (Proxy :: Proxy (n - 1)) xs

instance (Unfoldable (Vec n), Traversable (Vec n)) =\textgreater{} L.IsList (Vec
n a) where type Item (Vec n a) = a fromList xs = case fromListU xs of Nothing
-\textgreater{} error "Demanded vector from a list that was too short." Just ys
-\textgreater{} ys toList = Data.Foldable.toList
\textasciitilde{}\textasciitilde{}\textasciitilde{}

(Remember, we use the \texttt{forall} here with \emph{ScopedTypeVariables} to be
able to say that the \texttt{n} in the type signature is the same \texttt{n}
that is in the type of \texttt{Proxy})

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell ghci\textgreater{}
fromListU {[}1,2,3,4{]} :: Vec 10 Int Nothing ghci\textgreater{} fromListU
{[}1,2,3,4{]} :: Vec 3 Int Just (1 :\# 2 :\# 3 :\# Nil) ghci\textgreater{} index
(Proxy :: Proxy 2) (1 :\# 2 :\# 3 :\# Nil) 3 ghci\textgreater{} index (Proxy ::
Proxy 2) (1 :\# 2 :\# Nil) *** Type Error: Couldn't match 'EQ with 'GT
ghci\textgreater{} :set -XOverloadedLists ghci\textgreater{} {[}1,2,3{]} :: Vec
2 Int 1 :\# 2 :\# Nil ghci\textgreater{} {[}1,2,3{]} :: Vec 4 Int *** Exception:
Demanded vector from a list that was too short. ghci\textgreater{} {[}1,3..{]}
:: Vec 5 Int 1 :\# 3 :\# 5 :\# 7 :\# 9 :\# Nil
\textasciitilde{}\textasciitilde{}\textasciitilde{}

I think, overall, this formulation gives a much nicer interface. Being able to
just write \$10\$ is pretty powerful. The usage with \emph{OverloadedLists} is
pretty clean, too, especially when you can do things like
\texttt{{[}1,3..{]}\ ::\ Vec\ 10\ Int} and take full advantage of list syntax
and succinct vector types. (Minding your runtime errors, of course)

However, you do again get the problem that GHC is not able to do real
completeness checking and asks for the \texttt{Nil} cases still of
everything...but adding a \texttt{Nil} case will cause a type error. The only
solution is to add a \texttt{\_} wildcard chase, but...again, this isn't quite
satisfactory.{[}\^{}thsolve{]} If anybody has a way to get around this, I'd love
to know :)

\section{Alternative Underlying Representations}

Recall that our \texttt{Vec} was basically identically the normal list type,
with an extra field in the type. Due to type erasure, the two are represented
exactly the same in memory. So we have \$O(n)\$ appends, \$O(n)\$ indexing, etc.
Our type is essentially equal to

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell newtype Vec :: Nat
-\textgreater{} * -\textgreater{} * where VecList :: {[}a{]} -\textgreater{} Vec
n a \textasciitilde{}\textasciitilde{}\textasciitilde{}

For this type, though, we'd need to use "smart constructors" and extractors
instead of \texttt{1\ :\#\ 2\ :\#\ Nil} etc.

We could, however, chose a more efficient type, like \texttt{Vector} from the
\emph{\href{http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html\#t:Vector}{vector}}
package:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell newtype Vec :: Nat
-\textgreater{} * -\textgreater{} * where VecVector :: Vector a -\textgreater{}
Vec n a \textasciitilde{}\textasciitilde{}\textasciitilde{}

And, if you made sure to wrap everything with smart constructors, you now have
\emph{type safe} \$O(1)\$ random indexing!

(This is representation is similar to the one used by the
\emph{\href{http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html}{linear}}
package.)

\section{More Operations}

One really weird quirk with this is that many functions you'd normally write
using pattern matching you'd now might start writing using typeclasses. One
example would be our implementation of indexing, using an \texttt{IndexV}
typeclass.

A bunch of one-shot typeclasses is sort of unideal, as typeclasses are sort of
ugly and non-first-class. Ideally you'd only have a few typeclasses for as
generic an interface as possible, and then be able to do everything from those.
Sometimes this just isn't practical. I did mention one way around it, which was
to make a typeclass to "reify" or turn your type into actual data, and then
manipulate your data in an "unsafe" way knowing that the type checker checked
that the data matched.

We'll demonstrate with \texttt{SomeNat} from \texttt{GHC.TypeLits}, but you can
also make our own for our inductive \texttt{Nat} type we used in the first half,
too.

If we use our "wrapped \texttt{Vector} approach", we can just do:

\textasciitilde{}\textasciitilde{}\textasciitilde{}haskell newtype Vec :: Nat
-\textgreater{} * -\textgreater{} * where Vec :: Vector a -\textgreater{} Vec n
a

index :: (KnownNat n, m \textgreater{} n) =\textgreater{} Proxy n
-\textgreater{} Vec m a -\textgreater{} a index p (Vec v) = v ! fromInteger
(natVal p) \textasciitilde{}\textasciitilde{}\textasciitilde{}

That is, \texttt{index} internally uses \texttt{(!)}, an unsafe operator...but
only after we assure properly that it's safe to use by stating
\texttt{m\ \textgreater{}\ n} in the constraint. We can be sure that GHC will
catch any instance where someone tries to index into a \texttt{Vec\ m\ a} whose
\texttt{m} is \emph{not} greater than the index desired.

The rest is up to you, though -\/-\/- to prove that indexing into a number
smaller than \texttt{m} will always provide an answer. We have to make sure our
smart constructors are okay and that \texttt{(!)} behaves like we think it does.

\section{Singletons}

Another answer to these sort of ad-hoc typeclasses is to use techniques
involving singletons. Going all into how to use singletons to work with these is
an article on its own...luckily, this article has already been written as
\href{https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell}{Part
1: Dependent Types in Haskell} by Hiromi ISHII. A major advantage is that you
replace typeclasses with type families and more parameterized types. You'll have
to work with an understanding of how singletons work, and accept using some
template haskell to generate singleton types for your data types (or write them
yourself!). But it's a powerful way to bring something like dependent types into
Haskell, and there's already a lot of infrastructure of support on it on hackage
and in the haskell dev ecosystem in general. I recommend looking at the linked
article!

\section{Conclusion}

Hopefully you'll see that we are able to apply the full type-safety of the
Haskell compiler to our programs regarding lists by encoding the length of the
list in its type and limiting its operations by specifically typed functions and
choice of instances. I also hope that you've been able to become familiar with
seeing a lot of GHC's basic type extensions in real applications :)

Feel free to
\href{https://github.com/mstksg/inCode/blob/master/code-samples/fixvec}{download
and run} any of the samples

Please let me know if I got anything wrong, or if there are any techniques that
I should mention here that are out and in the wild today :)

\end{document}
