\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Hamiltonian Dynamics in Haskell \% Justin Le \% November 27, 2017

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.html}{in
Code}}.}

As promised in my
\href{https://blog.jle.im/entry/introducing-the-hamilton-library.html}{\emph{hamilton}
introduction post} (published almost exactly one year ago!), I'm going to go
over implementing of the
\emph{\href{http://hackage.haskell.org/package/hamilton}{hamilton}} library
using

\begin{enumerate}
\tightlist
\item
  \emph{DataKinds} (with \emph{TypeLits}) to enforce sizes of vectors and
  matrices and help guide us write our code
\item
  Statically-sized linear algebra with
  \emph{\href{http://hackage.haskell.org/package/hmatrix}{hmatrix}}
\item
  Automatic differentiation with
  \emph{\href{http://hackage.haskell.org/package/ad}{ad}}
\item
  Statically-sized vectors with
  \emph{\href{http://hackage.haskell.org/package/vector-sized}{vector-sized}}
\end{enumerate}

This post will be a bit heavy in some mathematics and Haskell concepts. The
expected audience is intermediate Haskell programmers. Note that this is
\emph{not} a post on dependent types, because dependent types (types that depend
on runtime values) are not explicitly used.

The mathematics and physics are "extra" flavor text and could potentially be
skipped, but you'll get the most out of this article if you have basic
familiarity with:

\begin{enumerate}
\tightlist
\item
  Basic concepts of multivariable calculus (like partial and total derivatives).
\item
  Concepts of linear algebra (like dot products, matrix multiplication, and
  matrix inverses)
\end{enumerate}

No physics knowledge is assumed, but knowing a little bit of first semester
physics would help you gain a bit more of an appreciation for the end result!

The
\href{https://blog.jle.im/entry/introducing-the-hamilton-library.html}{hamilton
library introduction} should be considered a "soft prerequisite" for this post,
as it presents motivations, visual demonstrations, and general overviews of the
methods presented here!

\section{The Goal}

At the end of this, we should be able to have Haskell \emph{automatically
generate} \textbf{equations of motions} for any arbitrary system described in
arbitrary coordinate systems, and simulate that system.

Normally, we'd describe a system using particles' x and y coordinates, but our
goal is to be able to describe our particles' positions using any coordinate
system we want (polar, distance-along-a-curved-rail, pendulum-angles, etc.) and
have Haskell automatically generate equations of motions and time progressions
of those coordinates.

Read \href{https://blog.jle.im/entry/introducing-the-hamilton-library.html}{my
hamilton library introduction} for more information and examples!

\section{Hamiltonian Mechanics}

As mentioned in the previous post, Hamiltonian mechanics is a re-imagining of
dynamics and mechanics (think "the world post-\$F = m a\$") that not only opened
up new doors to solving problems in classical, but also ended up being the right
angle of viewing the world to unlock statistical mechanics and thermodynamics,
and later even quantum mechanics.

Hamiltonian mechanics lets you parameterize your system's "position" in
arbitrary ways (like the angle of rotation, for pendulum problems) and then
posits that the full state of the system exists in something called \emph{phase
space}, and that the system's dynamics is its motion through phase space that is
dictated by the geometry of the \emph{Hamiltonian} of that phase space.

The system's \emph{Hamiltonian} is a \$\textbackslash{}mathbb\{R\}\^{}\{2n\}
\textbackslash{}rightarrow \textbackslash{}mathbb\{R\}\$ function from a point
in \$\textbackslash{}mathbb\{R\}\^{}\{2n\}\$ phase space (where \$n\$ is the
number of coordinates parameterizing your system) to a scalar in
\$\textbackslash{}mathbb\{R\}\$. For a time-independent system, the picture of
the dynamics is pretty simple: the system moves along the \emph{contour lines}
of the \emph{Hamiltonian} -\/- the lines of equal "height".

\includegraphics{/img/entries/hamilton/contour-lines.jpg}

In the example above, if we imagine that phase space is the 2D location, then
the \emph{Hamiltonian} is the mountain. And for a system dropped anywhere on the
mountain, its motion would be along the contour lines. For example, if a system
started somewhere along the 10 contour line, it would begin to oscillate the
entire phase space along the 10 contour line.{[}\^{}time-dependent{]}

\emph{Every} \href{https://www.youtube.com/watch?v=izGwDsrQ1eQ}{smooth}
\$\textbackslash{}mathbb\{R\}\^{}\{2n\} \textbackslash{}rightarrow
\textbackslash{}mathbb\{R\}\$ function on phase space can be used as a
Hamiltonian to describe the physics of some system. So, given any "mountain
range" on phase space, any "elevation map" or real-valued function on phase
space, you can treat it as a description of the dynamics of some physical
system.

The \emph{trick}, then, to using Hamiltonian dynamics to model your system, is:

\begin{enumerate}
\item
  Finding the phase space to describe your system. This can be done based on any
  continuous parameterization of your system ("generalized coordinates"), like
  angles of pendulums and so on.
\item
  Finding the Hamiltonian on that phase space to describe your system.
\end{enumerate}

And then Hamilton's dynamics will give you the rest! All you do is "follow the
contour lines" on that Hamiltonian!

\subsection{Phase Space}

Hamiltonian dynamics are about systems moving around in phase space. It seems
that phase space is the "room where it happens", so to speak, so let's dig
deeper into what it is. \emph{Phase space} is a \$2n\$-dimensional space
parameterized by:

\begin{enumerate}
\tightlist
\item
  All of the current values of the \$n\$ parameters ("generalized coordinates")
\item
  All of the current "generalized momenta" of those \$n\$ parameters
\end{enumerate}

So if you were parameterizing your pendulum system by, say, the angle of the
pendulum, then a point in phase space would be the current angle of the pendulum
along with the current "generalized momentum" associated with the angle of the
pendulum. What exactly \emph{is} generalized momentum? We'll go over calculating
it eventually, but what does it represent...\emph{physically}?

The deeper answer involves the underlying Lie algebra of the Lie group
associated with the generalized coordinates, but going into that would make this
a completely different post. What I \emph{can} say is that the generalized
momenta associated with ("conjugate to") certain sets of familiar coordinates
yield things that we typically call "momenta":

\begin{enumerate}
\item
  The momentum conjugate to normal Cartesian coordinates is just our normal
  run-of-the-mill \emph{linear momentum} (in the \$\textbackslash{}mathbf\{p\} =
  m \textbackslash{}mathbf\{v\}\$) from first semester physics.
\item
  The momentum conjugate to the angle \$\textbackslash{}theta\$ in polar
  coordinates is \emph{angular momentum} (\$L = m r\^{}2
  \textbackslash{}dot\{\textbackslash{}theta\}\$) from first semester physics.
\item
  The momentum conjugate to the radial coordinate \$r\$ in polar coordinates is
  also just boring old linear momentum \$p\_r = m \textbackslash{}dot\{r\}\$,
  which makes sense because purely radial motion is just linear motion.
\end{enumerate}

So, it's our normal momentum (for linear and polar coordinates)
\emph{generalized} to arbitrary coordinates.

\subsection{Hamiltonian Dynamics}

I've explained Hamiltonian dynamics for time-independent Hamiltonians as "follow
the contour lines". If you remember your basic multi-variable calculus course,
you'll know that the line of "steepest ascent" is the gradient. If we call the
Hamiltonian
\$\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})\$
(where \$\textbackslash{}mathbf\{q\}\$ is the vector of positions and
\$\textbackslash{}mathbf\{p\}\$ is the vector of momenta), then the direction of
steepest ascent is

\$\$ \textbackslash{}left \textbackslash{}langle
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
\textbackslash{}mathbf\{q\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\}),
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
\textbackslash{}mathbf\{p\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
\textbackslash{}right \textbackslash{}rangle \$\$

But we want to move along the \emph{contour lines}...and these are the lines
\emph{perpendicular} to the direction of steepest descent. The vector
perpendicular to \$\textbackslash{}langle x, y \textbackslash{}rangle\$ is
\$\textbackslash{}langle y, -x \textbackslash{}rangle\$,{[}\^{}perp{]} so we
just derived the actual Hamiltonian equations of motion: just move in the
direction perpendicular to the steepest ascent! That is, to have things move on
contour lines, \$\textbackslash{}dot\{q\}\$ and \$\textbackslash{}dot\{p\}\_q\$
\emph{should} be:

\$\$ \textbackslash{}begin\{aligned\} \textbackslash{}dot\{q\} \& =
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
p\emph{q\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
\textbackslash{} \textbackslash{}dot\{p\}}q \& = -
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial q\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
\textbackslash{}end\{aligned\} \$\$

This is a conclusion with one generalized coordinate \$q\$, but we can
generalize this to systems with multiple coordinates as well, as long as this
holds for \emph{every} \$q\$ and the momentum conjugate to it (\$p\emph{q\$).
(For the rest of this post, \$\textbackslash{}mathbf\{q\}\$ refers to the vector
of coordinates, \$q\$ refers to a single specific coordinate, and \$p}q\$ refers
to the momentum conjugate to that coordinate).

Essentially, these give you "updating functions" for \$q\$ and \$p\emph{q\$ -\/-
given
\$\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})\$,
you have a way to "update" the particle's position in phase space. Just take the
partial derivatives of \$\textbackslash{}mathcal\{H\}\$ at every step in time!
To update \$q\$, nudge it by
\$\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial p}q\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})\$.
To update \$p\_q\$, nudge it by
\$-\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial q\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})\$!

This picture is appealing to me in a visceral way because it sort of seems like
the system is "surfing" along the Hamiltonian's contour lines. It's being
"pushed" \emph{faster} when the Hamiltonian is steeper, and slower when it's
more shallow. I can apply all my intuition as a surfer{[}\^{}surfer{]} to
Hamiltonian mechanics!

\section{Hamiltonian Dynamics and Physical Systems}

Earlier I mentioned that the two steps for applying Hamiltonian mechanics to
your system was figuring out your system's conjugate momenta and the appropriate
Hamiltonian. To explain this, I'm going to make a couple of simplifying
assumptions that make the job easier for the purposes of this article:

\begin{enumerate}
\tightlist
\item
  Your coordinates and potential energy are time-independent.
\item
  Your potential energy function only depends on \emph{positions}, and not
  \emph{velocities}. (So nothing like friction or wind resistance or magnetic
  field vector potentials)
\end{enumerate}

With these assumptions, I'm going to skip over discussing the
\href{https://en.wikipedia.org/wiki/Lagrangian_mechanics}{Lagrangian} of the
system, which is the traditional way to do this. You can think of this section
as me presenting derived conclusions and skipping the derivations.

\subsection{Conjugate Momenta}

For systems with velocity-independent potential energies, it can be shown that
the momentum conjugate to coordinate \$q\$ is

\$\$ p\_q =
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
\textbackslash{}dot\{q\}\} KE(\textbackslash{}mathbf\{q\},
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}) \$\$

Where
\$KE(\textbackslash{}mathbf\{q\},\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\})\$
is the kinetic energy of the system, which is a function on the coordinates
\$\textbackslash{}mathbf\{q\}\$ and their rates of change,
\$\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\$. For example, for normal
Cartesian coordinates in one dimension, \$KE(x, \textbackslash{}dot\{x\}) =
\textbackslash{}frac\{1\}\{2\} m \textbackslash{}dot\{x\}\^{}2\$. So the
momentum conjugate to \$x\$ is:

\$\$ p\_x =
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
\textbackslash{}dot\{x\}\} \textbackslash{}left{[}
\textbackslash{}frac\{1\}\{2\} m \textbackslash{}dot\{x\}\^{}2
\textbackslash{}right{]} = m \textbackslash{}dot\{x\} \$\$

Just linear momentum, like I claimed before.

Let's generalize this to arbitrary coordinates. In general, for \emph{Cartesian}
coordinates, the kinetic energy will always be

\$\$ KE(\textbackslash{}mathbf\{x\},
\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\}) =
\textbackslash{}frac\{1\}\{2\} \textbackslash{}left{[} m\emph{1
\textbackslash{}dot\{x\}}1\^{}2 + m\emph{2 \textbackslash{}dot\{x\}}2\^{}2 +
m\emph{3 \textbackslash{}dot\{x\}}3\^{}2 + \textbackslash{}dots
\textbackslash{}right{]} \$\$

Where \$m\$ is the inertia associated with each coordinate...for example, if
\$\textbackslash{}langle x\emph{1, x}2 \textbackslash{}rangle\$ describes the
location of an object of mass \$m\$, then \$m\emph{1 = m}2 = m\$.

To give us nice notation and make things more convenient, we'll write this as a
quadratic form over an inertia matrix:

\$\$ KE(\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\}) =
\textbackslash{}frac\{1\}\{2\}
\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\}\^{}T \textbackslash{}hat\{M\}
\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\} \$\$

Where \$\textbackslash{}hat\{M\}\$ is the
\href{https://en.wikipedia.org/wiki/Diagonal_matrix}{diagonal matrix} whose
entries are the masses of each coordinate, and
\$\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\}\$ is the column vector of
all of the (Cartesian) coordinates, \$\textbackslash{}left{[}
\textbackslash{}dot\{x\}\emph{1\textbackslash{},
\textbackslash{}dot\{x\}}2\textbackslash{},
\textbackslash{}dot\{x\}\_3\textbackslash{}, \textbackslash{}dots
\textbackslash{}right{]}\^{}T\$.

Now! How to generalize this to arbitrary coordinates? Well, if we have \$n\$
generalized coordinates \$\textbackslash{}mathbf\{q\}\$ mapping to
\$m\$-dimensional Cartesian coordinates, we can specify them as
\$\textbackslash{}mathbf\{x\} = f(\textbackslash{}mathbf\{q\})\$, where \$f :
\textbackslash{}mathbb\{R\}\^{}n \textbackslash{}rightarrow
\textbackslash{}mathbb\{R\}\^{}m\$, taking the vector of generalized coordinates
and returning a vector for the position in Cartesian space. For example, for
polar coordinates, \$f(r, \textbackslash{}theta) = \textbackslash{}left
\textbackslash{}langle r \textbackslash{}cos(\textbackslash{}theta), r
\textbackslash{}sin(\textbackslash{}theta) \textbackslash{}right
\textbackslash{}rangle\$, because, for polar coordinates, \$x = r
\textbackslash{}cos(\textbackslash{}theta)\$ and \$y = r
\textbackslash{}sin(\textbackslash{}theta)\$.

So we can get \$\textbackslash{}mathbf\{x\}\$ from
\$\textbackslash{}mathbf\{q\}\$ with \$f\$, but how can we get
\$\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\}\$, the vector of rate of
changes? Well, if \$x\emph{1 = f}1(q\emph{1, q}2, q\emph{3
\textbackslash{}dots)\$, then the \$\textbackslash{}dot\{x\}}1\$ is the
\href{https://en.wikipedia.org/wiki/Total_derivative}{total derivative} of
\$x\_1\$ with respect to time:

\$\$ \textbackslash{}dot\{x\}\emph{1 =
\textbackslash{}frac\{\textbackslash{}partial f}1\}\{\textbackslash{}partial
q\emph{1\} \textbackslash{}dot\{q\}}1 +
\textbackslash{}frac\{\textbackslash{}partial
f\emph{1\}\{\textbackslash{}partial q}2\} \textbackslash{}dot\{q\}\emph{2 +
\textbackslash{}frac\{\textbackslash{}partial f}1\}\{\textbackslash{}partial
q\emph{3\} \textbackslash{}dot\{q\}}3 + \textbackslash{}dots \$\$

Or, in short:

\$\$ \textbackslash{}dot\{x\}\emph{i = \textbackslash{}sum}\{j = 1\}\^{}n
\textbackslash{}frac\{\textbackslash{}partial
f\emph{i\}\{\textbackslash{}partial q}j\} \textbackslash{}dot\{q\}\_j \$\$

But, hey, this looks a lot like a matrix-vector multiplication! If we make
\$\textbackslash{}hat\{J\}\emph{f\$, an \$m \textbackslash{}times n\$ matrix of
partial derivatives of \$f\$ (\$\textbackslash{}hat\{J\}}\{fij\} =
\textbackslash{}frac\{\textbackslash{}partial
f\emph{i\}\{\textbackslash{}partial q}j\}\$) at a given point (typically called
the
\href{https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant}{Jacobian
matrix of f}, then we have a nice expression for
\$\textbackslash{}dot\{\textbackslash{}mathbf\{x\}\}\$:

\$\$ \textbackslash{}dot\{\textbackslash{}mathbf\{x\}\} =
\textbackslash{}hat\{J\}\_f \textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}
\$\$

And we can plug it in (remembering that \$(A B)\^{}T = B\^{}T A\^{}T\$) to our
kinetic energy equation to get:

\$\$
KE(\textbackslash{}mathbf\{q\},\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\})
= \textbackslash{}frac\{1\}\{2\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\^{}T
\textbackslash{}hat\{J\}\emph{f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{J\}}f \textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}
\$\$

And for the final step, we differentiate with respect to the
\$\textbackslash{}dot\{q\}\$s (which is just the gradient
\$\textbackslash{}nabla\_\{\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\}\$)
to get \$\textbackslash{}mathbf\{p\}\$, the vector of conjugate momenta:

\$\$ \textbackslash{}mathbf\{p\} =
\textbackslash{}nabla\emph{\{\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\}
\textbackslash{}left{[} \textbackslash{}frac\{1\}\{2\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\^{}T
\textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{J\}\emph{f
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} \textbackslash{}right{]} =
\textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{J\}\_f \textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}
\$\$

Now, we're going to be using \$\textbackslash{}hat\{J\}\emph{f\^{}T
\textbackslash{}hat\{M\} \textbackslash{}hat\{J\}}f\$ a lot, so let's give it a
name, \$\textbackslash{}hat\{K\}\$. \$\textbackslash{}hat\{K\}\$ represents some
sort of coordinate-aware inertia term for our system. If the masses are all
positive and \$\textbackslash{}hat\{J\}\emph{f\$ is
full-rank{[}\^{}full-rank{]}, then \$\textbackslash{}hat\{K\}\$ is a symmetric,
positive-definite, invertible matrix (by construction). It's important to also
remember that it's an explicit function of \$\textbackslash{}mathbf\{q\}\$,
because \$\textbackslash{}hat\{J\}}f\$ is a matrix of partial derivatives at a
given \$\textbackslash{}mathbf\{q\}\$. We now have a simple expression for the
vector of conjugate momenta (\$\textbackslash{}mathbf\{p\} =
\textbackslash{}hat\{K\} \textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\$),
and also for kinetic energy (\$KE = \textbackslash{}frac\{1\}\{2\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\^{}T \textbackslash{}hat\{K\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\$).

It's going to be important for us to also be able to go backwards (to get
\$\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\$ from
\$\textbackslash{}mathbf\{p\}\$). Luckily, because we wrote the whole thing as a
matrix operation, going backwards is easy -\/- just take the matrix inverse,
which we know exists!

\$\$ \textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} =
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\} \$\$

The power of linear algebra!

\subsection{Hamiltonians of Physical Systems}

Ok, that's step one. How about step two -\/- finding the Hamiltonian for your
system?

The \emph{real} Hamiltonian is actually the
\href{https://en.wikipedia.org/wiki/Poisson_bracket}{Poisson bracket} of the
system's \href{https://en.wikipedia.org/wiki/Lagrangian_mechanics}{Lagrangian},
but I did some of the work for you for the case of time-independent coordinates
where the potential energy depends \emph{only} on positions (so, no friction,
wind resistance, time, etc.). In such a case, the Hamiltonian of a system is
precisely the system's total
\href{https://en.wikipedia.org/wiki/Mechanical_energy}{mechanical energy}, or
its kinetic energy plus the potential energy:

\$\$
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
= KE(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\}) +
PE(\textbackslash{}mathbf\{q\}) \$\$

Which makes a lot of intuitive sense, because you might recall that total
mechanical energy is always conserved for certain types of systems.
Incidentally, Hamiltonian dynamics makes sure that the value of the system's
Hamiltonian stays the same (because it moves along contour lines). So, the
system's Hamiltonian always stays the same, and so its total mechanical energy
stays the same, as well! Energy is conserved because the Hamiltonian stays the
same!

Anyway, we want to build our system's Hamiltonian from properties of the
coordinate system, so plugging in our expression for \$KE\$, we get
\$\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\})
= \textbackslash{}frac\{1\}\{2\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\^{}T \textbackslash{}hat\{K\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} +
PE(\textbackslash{}mathbf\{q\})\$.

Oh, but oops, the Hamiltonian has to be a function of
\$\textbackslash{}mathbf\{p\}\$, not of
\$\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\$. Let's remember that
\$\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} =
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\}\$ and find the
final form of our Hamiltonian (after a bit of simplification, remembering that
the inverse of a symmetric matrix is also symmetric):

\$\$
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
= \textbackslash{}frac\{1\}\{2\} \textbackslash{}mathbf\{p\}\^{}T
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\} +
PE(\textbackslash{}mathbf\{q\}) \$\$

\subsection{Hamiltonian Equations}

We got our Hamiltonian! Now just to find our updating functions (the partial
derivatives of the Hamiltonian), and we're done with the math.

Because we are assuming the case (with loss of generality) \$PE\$ doesn't depend
on \$\textbackslash{}mathbf\{p\}\$, the partial derivatives of
\$\textbackslash{}mathcal\{H\}\$ with respect to \$\textbackslash{}mathbf\{p\}\$
is:

\$\$ \textbackslash{}nabla\_\{\textbackslash{}mathbf\{p\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
= \textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\} \$\$

We already can calculate \$\textbackslash{}hat\{K\}\^{}\{-1\}\$, so this wound
up being easy peasy. But finding the partial derivatives with respect to
\$\textbackslash{}mathbf\{q\}\$ is a little trickier. The gradient is a linear
operator, so we can break that down to just finding the gradient of the \$KE\$
term \$\textbackslash{}frac\{1\}\{2\} \textbackslash{}mathbf\{p\}\^{}T
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\}\$. Because
\$\textbackslash{}mathbf\{p\}\$ is an independent input to
\$\textbackslash{}mathcal\{H\}\$, we can just look at the gradient of
\$\textbackslash{}hat\{K\}\^{}\{-1\}\$. We can simplify that even more by
realizing that for any invertible matrix \$A\$,
\$\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial q\}
A\^{}\{-1\} = - A\^{}\{-1\} \textbackslash{}left{[}
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial q\} A
\textbackslash{}right{]} A\^{}\{-1\}\$, so now we just need to find the partial
derivatives of \$\textbackslash{}hat\{K\}\$, or
\$\textbackslash{}hat\{J\}\emph{f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{J\}}f\}\$. \$\textbackslash{}hat\{M\}\$ is a constant term,
so, using the good ol' product rule over
\$\textbackslash{}hat\{J\}\emph{f\^{}T\$ and \$\textbackslash{}hat\{J\}}f\$, we
see that, after some simplification:

\$\$ \textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
q\emph{i\} \textbackslash{}left{[} \textbackslash{}hat\{J\}}f\^{}T
\textbackslash{}hat\{M\} \textbackslash{}hat\{J\}\emph{f
\textbackslash{}right{]} = 2 \textbackslash{}hat\{J\}}f\^{}T
\textbackslash{}hat\{M\} \textbackslash{}left{[}
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
q\emph{i\} \textbackslash{}hat\{J\}}f \textbackslash{}right{]} \$\$

\$\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
q\emph{i\} \textbackslash{}hat\{J\}}f\$ (an \$m \textbackslash{}times n\$
matrix, like \$\textbackslash{}hat\{J\}\emph{f\$) represents the }second
derivatives* of \$f\$ -\/- the derivative (with respect to \$q*i\$) of the
derivatives.

The collection of "second-order derivatives of \$f\$" is known as the
\href{https://en.wikipedia.org/wiki/Hessian_matrix\#Vector-valued_functions}{Hessian
Tensor} (a vector-valued generalization of the Hessian matrix), which we will
denote as \$\textbackslash{}hat\{H\}\_f\$.{[}\^{}edwardk{]} We can write this in
a nicer way by abusing matrix multiplication notation to get

\$\$ \textbackslash{}nabla\emph{\{\textbackslash{}mathbf\{q\}\}
\textbackslash{}left{[} \textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{J\}\emph{f \textbackslash{}right{]} = 2
\textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{H\}\_f \$\$

if we use \$\textbackslash{}hat\{H\}\emph{f\$ as an \$n \textbackslash{}times m
\textbackslash{}times n\$ tensor, whose \$n\$ components are the each the \$m
\textbackslash{}times n\$ matrices corresponding to
\$\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial q}i\}
\textbackslash{}hat\{J\}\_f\$

And with that, we have our final expression for
\$\textbackslash{}nabla\_\{\textbackslash{}mathbf\{q\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})\$:

\$\$ \textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
q\emph{i\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
= - \textbackslash{}mathbf\{p\}\^{}T \textbackslash{}hat\{K\}\^{}\{-1\}
\textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\} \textbackslash{}left{[}
\textbackslash{}frac\{\textbackslash{}partial\}\{\textbackslash{}partial
q\emph{i\} \textbackslash{}hat\{J\}}f \textbackslash{}right{]}
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\} +
\textbackslash{}nabla\_\{\textbackslash{}mathbf\{q\}\}
PE(\textbackslash{}mathbf\{q\}) \$\$

Or, to use our abuse of notation:

\$\$ \textbackslash{}nabla\emph{\{\textbackslash{}mathbf\{q\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
= - \textbackslash{}mathbf\{p\}\^{}T \textbackslash{}hat\{K\}\^{}\{-1\}
\textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{H\}\emph{f \textbackslash{}hat\{K\}\^{}\{-1\}
\textbackslash{}mathbf\{p\} +
\textbackslash{}nabla}\{\textbackslash{}mathbf\{q\}\}
PE(\textbackslash{}mathbf\{q\}) \$\$

And, finally, we have everything we need -\/- we can now construct our equations
of motion! To progress through phase space (\$\textbackslash{}langle
\textbackslash{}mathbf\{q\},
\textbackslash{}mathbf\{p\}\textbackslash{}rangle\$):

\$\$ \textbackslash{}begin\{aligned\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} \& =
\textbackslash{}nabla\emph{\{\textbackslash{}mathbf\{p}q\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
\&\& = \textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\}
\textbackslash{} \textbackslash{}dot\{\textbackslash{}mathbf\{p\}\} \& = -
\textbackslash{}nabla\emph{\{\textbackslash{}mathbf\{q\}\}
\textbackslash{}mathcal\{H\}(\textbackslash{}mathbf\{q\},\textbackslash{}mathbf\{p\})
\&\& = \textbackslash{}mathbf\{p\}\^{}T \textbackslash{}hat\{K\}\^{}\{-1\}
\textbackslash{}hat\{J\}}f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{H\}\emph{f \textbackslash{}hat\{K\}\^{}\{-1\}
\textbackslash{}mathbf\{p\} -
\textbackslash{}nabla}\{\textbackslash{}mathbf\{q\}\}
PE(\textbackslash{}mathbf\{q\}) \textbackslash{}end\{aligned\} \$\$

That's it. We're done. Have a nice day, thanks for reading!

\section{The Haskell}

Just kidding, now it's time for the fun stuff :)

Our final goal is to be able to simulate a \emph{system of discrete particles}
through \emph{arbitrary generalized coordinates}.

To simplify the math, we always assume that, whatever generalized coordinates
you are using (\$\textbackslash{}mathbb\{R\}\^{}n\$), your system "actually"
exists in some real flat Cartesian coordinate system
(\$\textbackslash{}mathbb\{R\}\^{}m\$). This allows us to take advantage of all
of that math we derived in the previous section.

So, in order to fully describe the system, we need:

\begin{enumerate}
\tightlist
\item
  Each of their masses (or inertias) in their underlying \$m\$ Cartesian
  coordinates, which we'll call \$\textbackslash{}mathbf\{m\}\$.
\item
  A function \$f : \textbackslash{}mathbb\{R\}\^{}n \textbackslash{}rightarrow
  \textbackslash{}mathbb\{R\}\^{}m\$ to convert the generalized coordinates
  (\$\textbackslash{}mathbb\{R\^{}n\}\$) to Cartesian coordinates
  (\$\textbackslash{}mathbb\{R\}\^{}m\$)
\item
  The potential energy function \$U : \textbackslash{}mathbb\{R\}\^{}n
  \textbackslash{}rightarrow \textbackslash{}mathbb\{R\}\$ in the generalized
  coordinates (\$\textbackslash{}mathbb\{R\^{}n\}\$)
\end{enumerate}

From these alone, we can derive the equations of motion for the particles in
phase space as a system of first-order ODEs using the process described above.
Then, given an initial phase space position, we can do numeric integration to
simulate our system's motion through phase space. To "surf the Hamiltonian waves
in phase space", so to speak.

But, to be explicit, we also are going to need some derivatives for these
functions/vectors, too. If you've been following along, the full enumeration of
functions and vectors we need is:

\$\$ \textbackslash{}begin\{aligned\} \textbackslash{}mathbf\{m\} \& :
\textbackslash{}mathbb\{R\}\^{}m \textbackslash{} f \& :
\textbackslash{}mathbb\{R\}\^{}n \textbackslash{}rightarrow
\textbackslash{}mathbb\{R\}\^{}m \textbackslash{}
\textbackslash{}hat\{J\}\emph{f \& : \textbackslash{}mathbb\{R\}\^{}n
\textbackslash{}rightarrow \textbackslash{}mathbb\{R\}\^{}\{m
\textbackslash{}times n\} \textbackslash{} \textbackslash{}hat\{H\}}f \& :
\textbackslash{}mathbb\{R\}\^{}n \textbackslash{}rightarrow
\textbackslash{}mathbb\{R\}\^{}\{n \textbackslash{}times m \textbackslash{}times
n\} \textbackslash{} U \& : \textbackslash{}mathbb\{R\}\^{}n
\textbackslash{}rightarrow \textbackslash{}mathbb\{R\} \textbackslash{}
\textbackslash{}nabla\_\{\textbackslash{}mathbf\{q\}\} U \& :
\textbackslash{}mathbb\{R\}\^{}n \textbackslash{}rightarrow
\textbackslash{}mathbb\{R\}\^{}n \textbackslash{}end\{aligned\} \$\$

But, as we'll see, with libraries like
\emph{\href{http://hackage.haskell.org/package/ad}{ad}} in Haskell, we can
really just ask the user for \$\textbackslash{}mathbf\{m\}\$, \$f\$, and \$U\$
-\/- all of the derivatives can be computed automatically.

\subsection{Our Data Structures}

We can couple together all of these functions in a data type that fully
describes the physics of our systems (the "shape" of the Hamiltonian):

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L25-32\ data\ System\ m\ n\ =\ System\ \ \ \ \ \{\ sysInertia\ \ \ \ \ \ \ ::\ R\ m\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ \textquotesingle{}m\textquotesingle{}\ vector\ \ \ \ \ ,\ sysCoords\ \ \ \ \ \ \ \ ::\ R\ n\ -\textgreater{}\ R\ m\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ f\ \ \ \ \ ,\ sysJacobian\ \ \ \ \ \ ::\ R\ n\ -\textgreater{}\ L\ m\ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ J\_f\ \ \ \ \ ,\ sysHessian\ \ \ \ \ \ \ ::\ R\ n\ -\textgreater{}\ V.Vector\ n\ (L\ m\ n)\ \ \ -\/-\ \^{}\ H\_f\ \ \ \ \ ,\ sysPotential\ \ \ \ \ ::\ R\ n\ -\textgreater{}\ Double\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ U\ \ \ \ \ ,\ sysPotentialGrad\ ::\ R\ n\ -\textgreater{}\ R\ n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ grad\ U\ \ \ \ \ \}}

\texttt{R\ n} and \texttt{L\ m\ n} are from the
\emph{\href{http://hackage.haskell.org/package/hmatrix}{hmatrix}} library; an
\texttt{R\ n} represents an n-vector (For example, an \texttt{R\ 4} is a
4-vector), and an \texttt{L\ m\ n} represents an \texttt{m\ x\ n} matrix (For
example, an \texttt{L\ 5\ 3} is a 5x3 matrix).

A \texttt{System\ m\ n} will describe a system parameterized by \texttt{n}
generalized coordinates, taking place in an underlying \texttt{m}-dimensional
Cartesian space.

It'll also be convenient to have a data type to describe the state of our system
in terms of its generalized positions (\$\textbackslash{}mathbf\{q\}\$) and
generalized velocities (the rates of changes of these positions,
\$\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\}\$), which is sometimes
called "configuration space":

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L35-39\ data\ Config\ n\ =\ Config\ \ \ \ \ \{\ confPositions\ \ ::\ R\ n\ \ \ \ \ ,\ confVelocities\ ::\ R\ n\ \ \ \ \ \}\ \ \ deriving\ Show}

And, more importantly, remember that Hamiltonian dynamics is all about surfing
around on that phase space (generalized positions
\$\textbackslash{}mathbf\{q\}\$ and their conjugate momenta,
\$\textbackslash{}mathbf\{p\_q\}\$). So let's make a type to describe the state
of our system in phase space:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L42-46\ data\ Phase\ n\ =\ Phase\ \ \ \ \ \{\ phasePositions\ ::\ R\ n\ \ \ \ \ ,\ phaseMomenta\ \ \ ::\ R\ n\ \ \ \ \ \}\ \ \ deriving\ Show}

\subsection{Getting comfortable with our data types}

First of all, assuming we can construct a \texttt{System} in a sound way, let's
imagine some useful functions.

We can write a function \texttt{underlyingPosition}, which allows you to give a
position in generalized coordinates, and returns the position in the "underlying
coordinate system":

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L51-55\ underlyingPosition\ \ \ \ \ ::\ System\ m\ n\ \ \ \ \ -\textgreater{}\ R\ n\ \ \ \ \ -\textgreater{}\ R\ m\ underlyingPosition\ =\ sysCoords}

Note that the types in our function helps us know exactly what the function is
doing -\/-\/- and also helps us implement it correctly. If we have a
\texttt{System} in \texttt{n} dimensions, over an underlying
\texttt{m}-dimensional Cartesian space, then we would need to convert an
\texttt{R\ n} (an n-dimensional vector of all of the positions) into an
\texttt{R\ m} (a vector in the underlying Cartesian space).

Simple enough, but let's maybe try to calculate something more complicated: the
\emph{momenta} of a system, given its positions and velocities (configuration).

We remember that we have a nice formula for that, up above:

\$\$ \textbackslash{}mathbf\{p\} = \textbackslash{}hat\{J\}\emph{f\^{}T
\textbackslash{}hat\{M\} \textbackslash{}hat\{J\}}f
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} \$\$

We can translate that directly into Haskell code:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L59-67\ momenta\ \ \ \ \ ::\ (KnownNat\ n,\ KnownNat\ m)\ \ \ \ \ =\textgreater{}\ System\ m\ n\ \ \ \ \ -\textgreater{}\ Config\ n\ \ \ \ \ -\textgreater{}\ R\ n\ momenta\ s\ (Config\ q\ v)\ =\ tr\ j\ \#\textgreater{}\ mHat\ \#\textgreater{}\ j\ \#\textgreater{}\ v\ \ \ where\ \ \ \ \ j\ \ \ \ =\ sysJacobian\ s\ q\ \ \ \ \ mHat\ =\ diag\ (sysInertia\ s)}

Note that, because our vectors have their size indexed in their type, this is
pretty simple to write and ensure that the shapes "line up". In fact, GHC can
even help you write this function by telling you what values can go in what
locations. Being able to get rid of a large class of bugs and clean up your
implementation space is nice, too!

(Note that \emph{hmatrix} requires a \texttt{KnownNat} constraint on the size
parameters of our vectors for some functions, so we add this as a constraint on
our end.)

With this, we can write a function to convert any state in configuration space
to its coordinates in phase space:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L70-75\ toPhase\ \ \ \ \ ::\ (KnownNat\ n,\ KnownNat\ m)\ \ \ \ \ =\textgreater{}\ System\ m\ n\ \ \ \ \ -\textgreater{}\ Config\ n\ \ \ \ \ -\textgreater{}\ Phase\ n\ toPhase\ s\ c\ =\ Phase\ (confPositions\ c)\ (momenta\ s\ c)}

This function is important, because "configuration space" is how we actually
directly observe our system -\/- in terms of positions and velocities, and not
in terms of positions and momenta (and sometimes conjugate momenta might not
even have meaningful physical interpretations). So, having \texttt{toPhase} lets
us "initialize" our system in terms of direct observables, and then convert it
to its phase space representation, which is something that Hamiltonian mechanics
can work with.

\subsection{Automatic Differentiation}

Now, creating a \texttt{System} "from scratch" is not much fun, because you
would have to manually differentiate your coordinate systems and potentials to
generate your Jacobians and gradients.

Here's where the magic comes in -\/- we can have Haskell generate our Jacobians
and gradients \emph{automatically}, using the amazing
\href{http://hackage.haskell.org/package/ad}{ad} library! We can just use the
appropriately named \texttt{grad}, \texttt{jacobian}, and \texttt{hessianF}
functions.

\subsubsection{Quick Intro to AD}

At the simplest level, if we have a function from some number to some other
number, we can use \texttt{diff} to get its derivative:

\texttt{haskell\ myFunc\ \ \ \ \ \ ::\ RealFloat\ a\ =\textgreater{}\ a\ -\textgreater{}\ a\ diff\ myFunc\ ::\ RealFloat\ a\ =\textgreater{}\ a\ -\textgreater{}\ a}

If we have a function a function from a sized vector to a scalar, we can use
\texttt{grad} to get its gradient:

```haskell -\/- import qualified Data.Vector.Sized as V

myFunc :: RealFloat a =\textgreater{} V.Vector n a -\textgreater{} a grad myFunc
:: RealFloat a =\textgreater{} V.Vector n a -\textgreater{} V.Vector n a ```

Where each of the components in the resulting vector corresponds to the rate of
change of the output according to variations in that component.

We're using \textbf{statically sized vector} type from the
\href{http://hackage.haskell.org/package/vector-sized}{vector-sized} package (in
the
\href{http://hackage.haskell.org/package/vector-sized/docs/Data-Vector-Sized.html}{Data.Vector.Sized}
module), where \texttt{V.Vector\ n\ a} is a \texttt{n}-vector of \texttt{a}s
-\/- for example, a \texttt{V.Vector\ 3\ Double} is a vector of 3
\texttt{Double}s.

We have to use \texttt{Vector} (instead of \texttt{R}, from \emph{hmatrix})
because automatic differentiation for gradients requires \emph{some Functor} to
work. An \texttt{R\ 5} is essentially a \texttt{V.Vector\ 5\ Double}, except the
latter can contain other, non-Double things -\/- and therefore can be used by
\emph{ad} to do its magic.

If we have a function from a sized vector to a (differently) sized vector, we
can use the \texttt{jacobian} function to get its jacobian!

\texttt{haskell\ myFunc\ \ \ \ \ \ \ \ \ \ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ n\ a\ -\textgreater{}\ V.Vector\ m\ a\ jacobian\ myFunc\ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ n\ a\ -\textgreater{}\ V.Vector\ m\ (V.Vector\ n\ a)}

Again note the usage of sized vector types, and the fact that our \$m
\textbackslash{}times n\$ matrix is represented by a \texttt{m}-vector of
\texttt{n}-vectors.

Finally, we can get our Hessian Tensor by using
\texttt{hessianF}:{[}\^{}hessianf{]}

\texttt{haskell\ myFunc\ \ \ \ \ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ n\ a\ -\textgreater{}\ V.Vector\ m\ a\ hessianF\ myFunc\ \ \ \ \ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ n\ a\ -\textgreater{}\ V.Vector\ m\ (V.Vector\ n\ (V.Vector\ n\ a))}

\subsubsection{Conversion between vector-sized and hmatrix}

So some ugly things -\/- we need to write some functions to convert between
\emph{vector-sized} sized vectors and \emph{hmatrix} vectors and matrices. These
are fundamentally unsafe to write (but safe to use, after written properly):

```haskell -\/- import qualified Data.Vector.Generic.Sized as VG -\/- source:
https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L78-87
vec2r :: KnownNat n =\textgreater{} V.Vector n Double -\textgreater{} R n vec2r
= fromJust . create . VG.fromSized . VG.convert

r2vec :: KnownNat n =\textgreater{} R n -\textgreater{} V.Vector n Double r2vec
= VG.convert . fromJust . VG.toSized . extract

vec2l :: (KnownNat m, KnownNat n) =\textgreater{} V.Vector m (V.Vector n Double)
-\textgreater{} L m n vec2l = fromJust . (\textbackslash{}rs -\textgreater{}
withRows rs exactDims) . toList . fmap vec2r ```

These are necessary because \emph{ad} requires our vectors to be
\emph{Functors}, but \texttt{R} and \texttt{L} from \emph{hmatrix} are not your
typical Hask Functors. One nice thing is that because they both use
\emph{TypeLits} to get their sized parameters, we can get type-safe conversions
that preserve their size information!

Also, even though \emph{ad} gives our Hessian as an \$m \textbackslash{}times n
\textbackslash{}times n\$ tensor, we really want it as a n-vector of \$m
\textbackslash{}times n\$ matrices -\/- that's how we interpreted it in our
original math. So we just need to write an function to convert what \emph{ad}
gives us to the form we expect. It's mostly just fiddling around with the
internals of \emph{hmatrix} in a rather inelegant way. (Again, unsafe to write,
but safe to use once you do)

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L90-93\ rehessian\ ::\ (KnownNat\ m,\ KnownNat\ n)\ =\textgreater{}\ V.Vector\ m\ (L\ n\ n)\ -\textgreater{}\ V.Vector\ n\ (L\ m\ n)\ rehessian\ =\ fmap\ (fromJust\ .\ (\textbackslash{}rs\ -\textgreater{}\ withRows\ rs\ exactDims)\ .\ toList)\ \ \ \ \ \ \ \ \ \ \ .\ sequenceA\ \ \ \ \ \ \ \ \ \ \ .\ fmap\ (fromJust\ .\ V.fromList\ .\ toRows)}

\subsubsection{Using AD to Auto-Derive Systems}

Now to make a \texttt{System} using just the mass vector, the coordinate
conversion function, and the potential energy function:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L97-113\ mkSystem\ \ \ \ \ ::\ (KnownNat\ m,\ KnownNat\ n)\ \ \ \ \ =\textgreater{}\ R\ m\ \ \ \ \ -\textgreater{}\ (forall\ a.\ RealFloat\ a\ =\textgreater{}\ V.Vector\ n\ a\ -\textgreater{}\ V.Vector\ m\ a)\ \ \ \ \ -\textgreater{}\ (forall\ a.\ RealFloat\ a\ =\textgreater{}\ V.Vector\ n\ a\ -\textgreater{}\ a)\ \ \ \ \ -\textgreater{}\ System\ m\ n\ mkSystem\ m\ f\ u\ =\ System\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \textless{}\ convert\ from\ \textbar{}\ actual\ thing\ \textbar{}\ convert\ to\ \textgreater{}\ \ \ \ \ \{\ sysInertia\ \ \ \ \ \ \ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\ \ \ \ \ ,\ sysCoords\ \ \ \ \ \ \ \ =\ \ \ \ \ \ vec2r\ .\ \ \ \ \ \ \ \ \ \ \ \ f\ .\ r2vec\ \ \ \ \ ,\ sysJacobian\ \ \ \ \ \ =\ \ \ \ \ \ vec2l\ .\ \ \ jacobian\ f\ .\ r2vec\ \ \ \ \ ,\ sysHessian\ \ \ \ \ \ \ =\ rehessian\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .\ fmap\ vec2l\ .\ \ \ hessianF\ f\ .\ r2vec\ \ \ \ \ ,\ sysPotential\ \ \ \ \ =\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ u\ .\ r2vec\ \ \ \ \ ,\ sysPotentialGrad\ =\ \ \ \ \ \ vec2r\ .\ \ \ \ \ \ \ grad\ u\ .\ r2vec\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ \textless{}\ convert\ from\ \textbar{}\ actual\ thing\ \textbar{}\ convert\ to\ \textgreater{}\ \ \ \ \ \}}

Now, I hesitate to call this "trivial"...but, I think it really is a
straightforward direct translation of the definitions, minus some boilerplate
conversions back and forth using \texttt{r2vec}, \texttt{vec2r}, and
\texttt{vec2l}!

\begin{enumerate}
\tightlist
\item
  The vector of masses is just \texttt{m}
\item
  The coordinate function is just \texttt{f}
\item
  The Jacobian of the coordinate function is just \texttt{jacobian\ f}
\item
  The Hessian Tensor of the coordinate function is just \texttt{hessianF\ f}
\item
  The potential energy function is just \texttt{u}
\item
  The gradient of the potential energy function is just \texttt{grad\ u}
\end{enumerate}

The \emph{ad} library automatically generated all of these for us and created a
perfectly well-formed \texttt{System} with all of its gradients and Jacobians
and Hessians by giving only the coordinate function and the potential energy
function, and in such a clean and concise way!

\subsection{Equations of Motion}

At this point, we're ready to write our final equations of motion, which we
found to be given by:

\$\$ \textbackslash{}begin\{aligned\}
\textbackslash{}dot\{\textbackslash{}mathbf\{q\}\} \& =
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\} \textbackslash{}
\textbackslash{}dot\{\textbackslash{}mathbf\{p\}\} \& =
\textbackslash{}mathbf\{p\}\^{}T \textbackslash{}hat\{K\}\^{}\{-1\}
\textbackslash{}hat\{J\}\emph{f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}left{[} \textbackslash{}nabla}\{\textbackslash{}mathbf\{q\}\}
\textbackslash{}hat\{J\}\emph{f \textbackslash{}right{]}
\textbackslash{}hat\{K\}\^{}\{-1\} \textbackslash{}mathbf\{p\} -
\textbackslash{}nabla}\{\textbackslash{}mathbf\{q\}\}
PE(\textbackslash{}mathbf\{q\}) \textbackslash{}end\{aligned\} \$\$

These equations aren't particularly beautiful, but it's straightforward to
translate them into Haskell (using \$\textbackslash{}hat\{K\} =
\textbackslash{}hat\{J\}\emph{f\^{}T \textbackslash{}hat\{M\}
\textbackslash{}hat\{J\}}f\$):

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L116-133\ hamilEqns\ \ \ \ \ ::\ (KnownNat\ n,\ KnownNat\ m)\ \ \ \ \ =\textgreater{}\ System\ m\ n\ \ \ \ \ -\textgreater{}\ Phase\ n\ \ \ \ \ -\textgreater{}\ (R\ n,\ R\ n)\ \ \ \ \ \ \ -\/-\ dq/dt\ and\ dp/dt\ hamilEqns\ s\ (Phase\ q\ p)\ =\ (dqdt,\ dpdt)\ \ \ where\ \ \ \ \ j\ \ \ \ \ \ \ =\ sysJacobian\ s\ q\ \ \ \ \ trj\ \ \ \ \ =\ tr\ j\ \ \ \ \ mHat\ \ \ \ =\ diag\ (sysInertia\ s)\ \ \ \ \ kHat\ \ \ \ =\ trj\ \textless{}\textgreater{}\ mHat\ \textless{}\textgreater{}\ j\ \ \ \ \ kHatInv\ =\ inv\ kHat\ \ \ \ \ dqdt\ \ \ \ =\ kHatInv\ \#\textgreater{}\ p\ \ \ \ \ dpdt\ \ \ \ =\ vec2r\ bigUglyThing\ -\ sysPotentialGrad\ s\ q\ \ \ \ \ \ \ where\ \ \ \ \ \ \ \ \ bigUglyThing\ =\ \ \ \ \ \ \ \ \ \ \ fmap\ (\textbackslash{}j2\ -\textgreater{}\ -p\ \textless{}.\textgreater{}\ kHatInv\ \#\textgreater{}\ trj\ \#\textgreater{}\ mHat\ \#\textgreater{}\ j2\ \#\textgreater{}\ kHatInv\ \#\textgreater{}\ p)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (sysHessian\ s\ q)}

Of course, there is no way to get around the big ugly math term in
\$\textbackslash{}dot\{p\}\_q\$, but at least it is a direct reading of the
math!

\emph{But!!} I'd much rather write this scary Haskell than that scary math,
because \emph{ghc typechecks our math}! When writing out those equations, we
really had no idea if we were writing it correctly, and if the matrix and vector
and tensor dimensions line up. If it even \emph{made sense} to multiply and
transpose the quantities we had.

However, when writing \texttt{hamilEqns}, we let GHC \emph{hold our hand for
us}. If any of our math is wrong, GHC will verify it for us! If any dimensions
don't match up, or any transpositions don't make sense, we'll know immediately.
And if we're ever lost, we can leave a
\emph{\href{https://wiki.haskell.org/GHC/Typed_holes}{typed hole}} -\/- then GHC
will tell you all of the values in scope that can \emph{fit} in that hole! Even
if you don't completely understand the math, this helps you implement it in a
somewhat confident way.

It's admittedly difficult to convey how helpful these sized vector types are
without working through trying to implement them yourself, so feel free to give
it a try when you get the chance! :D

\subsection{Numerical Integration}

The result of \texttt{hamilEqns} gives the rate of change of the components of
our \texttt{Phase\ n}. The rest of the processes then is just to "step"
\texttt{Phase\ n}. Gradually update it, following these rate of changes!

This process is known as
\href{https://en.wikipedia.org/wiki/Numerical_integration}{numerical
integration}. The "best" way to do it is quite a big field, so for this article
we're going to be using the extremely extremely simple
\href{https://en.wikipedia.org/wiki/Euler_method}{Euler method} to progress our
system through time.

Disclaimer -\/- The Euler method is typically a \textbf{very very bad} choice
for numerical integration (even though, as popularized in the movie \emph{Hidden
Figures}, it was good enough to
\href{http://www.latimes.com/science/sciencenow/la-sci-sn-hidden-figures-katherine-johnson-20170109-story.html}{send
humans to space?}). We are just choosing it for this article because it's very
simple, conceptually!

The basic idea is that you pick a time-step, \$\textbackslash{}Delta t\$, and
update each coordinate as:

\$\$ x(t + \textbackslash{}Delta t) = x(t) + \textbackslash{}dot\{x\}(t)
\textbackslash{}Delta t \$\$

Which makes sense visually if we imagine \$\textbackslash{}dot\{x\}\$ as the
"slope" of \$x\$ -\/- it just means to follow the slope another
\$\textbackslash{}Delta t\$ steps. If the slope stays constant, this method is
perfectly accurate. The inaccuracy, of course, happens when the slope changes
drastically within that \$\textbackslash{}Delta t\$ (and also from the fact that
small errors cause errors in the new calculations of
\$\textbackslash{}dot\{x\}\$, and so compound over time)

You can understand this symbolically, as well, by remembering that the
derivative can be approximated by \$\textbackslash{}dot\{x\}(t)
\textbackslash{}approx \textbackslash{}frac\{x(t + \textbackslash{}Delta t) -
x(t)\}\{\textbackslash{}Delta t\}\$ for small \$\textbackslash{}Delta t\$, and
so we can do a little bit of symbolic manipulation to get \$x(t +
\textbackslash{}Delta t) \textbackslash{}approx \textbackslash{}dot\{x\}(t)
\textbackslash{}Delta t + x(t)\$.

We can directly translate this into Haskell: (using
\texttt{konst\ ::\ KnownNat\ n\ =\textgreater{}\ Double\ -\textgreater{}\ R\ n},
making a constant vector, and \texttt{*}, the component-wise product of two
vectors)

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L136-144\ stepEuler\ \ \ \ \ ::\ (KnownNat\ n,\ KnownNat\ m)\ \ \ \ \ =\textgreater{}\ System\ m\ n\ \ \ \ \ \ \ -\/-\ \^{}\ the\ system\ \ \ \ \ -\textgreater{}\ Double\ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ dt\ \ \ \ \ -\textgreater{}\ Phase\ n\ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ q(t)\ and\ p(t)\ \ \ \ \ -\textgreater{}\ Phase\ n\ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ q(t\ +\ dt)\ and\ p(t\ +\ dt)\ stepEuler\ s\ dt\ ph@(Phase\ q\ p)\ =\ Phase\ (q\ +\ konst\ dt\ *\ dq)\ (p\ +\ konst\ dt\ *\ dp)\ \ \ where\ \ \ \ \ (dq,\ dp)\ =\ hamilEqns\ s\ ph}

And repeatedly evolve this system as a lazy list:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L147-155\ runSystem\ \ \ \ \ ::\ (KnownNat\ n,\ KnownNat\ m)\ \ \ \ \ =\textgreater{}\ System\ m\ n\ \ \ \ \ \ \ -\/-\ \^{}\ the\ system\ \ \ \ \ -\textgreater{}\ Double\ \ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ dt\ \ \ \ \ -\textgreater{}\ Phase\ n\ \ \ \ \ \ \ \ \ \ -\/-\ \^{}\ initial\ phase\ \ \ \ \ -\textgreater{}\ {[}Phase\ n{]}\ \ \ \ \ \ \ \ -\/-\ \^{}\ progression\ of\ the\ system\ using\ Euler\ integration\ runSystem\ s\ dt\ =\ go\ \ \ where\ \ \ \ \ go\ p0\ =\ p0\ :\ go\ (stepEuler\ s\ dt\ p0)}

\section{Running with it}

And...that's it! Granted, in real life, we would be using a less naive
integration method, but this is essentially the entire process!

Let's generate the boring system, a 5kg particle in 2D Cartesian Coordinates
under gravity -\/-

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L158-164\ simpleSystem\ ::\ System\ 2\ 2\ simpleSystem\ =\ mkSystem\ (vec2\ 5\ 5)\ id\ pot\ \ \ where\ \ \ \ \ -\/-\ potential\ energy\ of\ a\ gravity\ field\ \ \ \ \ -\/-\ U(x,y)\ =\ 9.8\ *\ y\ \ \ \ \ pot\ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ 2\ a\ -\textgreater{}\ a\ \ \ \ \ pot\ xy\ =\ 9.8\ *\ (xy\ \textasciigrave{}V.index\textasciigrave{}\ 1)}

If we initialize the particle at position \$\textbackslash{}mathbf\{q\}\emph{0 =
\textbackslash{}langle 0, 0 \textbackslash{}rangle\$ and velocity
\$\textbackslash{}mathbf\{v\}}0 = \textbackslash{}langle 1, 3
\textbackslash{}rangle\$ (that is, \$v\emph{x = 1\$ and \$v}y = 3\$), we should
see something that travels at a constant velocity in x and something that starts
moving "upwards" (in positive y) and eventually reaches a peak and moves
downwards.

We can make our initial configuration:

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L168-172\ simpleConfig0\ ::\ Config\ 2\ simpleConfig0\ =\ Config\ \ \ \ \ \{\ confPositions\ \ =\ vec2\ 0\ 0\ \ \ \ \ ,\ confVelocities\ =\ vec2\ 1\ 3\ \ \ \ \ \}}

And then...let it run!

\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L174-178\ simpleMain\ ::\ IO\ ()\ simpleMain\ =\ \ \ \ \ mapM\_\ (disp\ 2\ .\ phasePositions)\ \ -\/-\ position\ with\ 2\ digits\ of\ precision\ \ \ .\ take\ 25\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\ 25\ steps\ \ \ \$\ runSystem\ simpleSystem\ 0.1\ (toPhase\ simpleSystem\ simpleConfig0)}

We get:

\texttt{haskell\ ghci\textgreater{}\ :l\ Hamilton.hs\ ghci\textgreater{}\ simpleMain\ 0\ \ \ \ \ 0\ 0.10\ \ 0.30\ 0.20\ \ 0.58\ 0.30\ \ 0.84\ 0.40\ \ 1.08\ 0.50\ \ 1.30\ 0.60\ \ 1.51\ 0.70\ \ 1.69\ 0.80\ \ 1.85\ 0.90\ \ 1.99\ 1.00\ \ 2.12\ 1.10\ \ 2.22\ 1.20\ \ 2.31\ 1.30\ \ 2.37\ 1.40\ \ 2.42\ 1.50\ \ 2.44\ 1.60\ \ 2.45\ 1.70\ \ 2.43\ 1.80\ \ 2.40\ 1.90\ \ 2.35\ 2.00\ \ 2.28\ 2.10\ \ 2.18\ 2.20\ \ 2.07\ 2.30\ \ 1.94\ 2.40\ \ 1.79}

Exactly what we'd expect! The \texttt{x} positions increase steadily, and the
\texttt{y} positions increase, slow down, and start decreasing.

We can try a slightly more complicated example that validates (and justifies)
all of the work we've done -\/- let's simulate a simple pendulum. The state of a
pendulum is characterized by one coordinate \$\textbackslash{}theta\$, which
refers to the angular (clockwise) from the equilibrium "hanging straight down"
position. \$\textbackslash{}theta = 0\$ corresponds to 6 o' clock,
\$\textbackslash{}theta = \textbackslash{}pi/2\$ corresponds to 9 o' clock,
\$\textbackslash{}theta = - \textbackslash{}pi / 2\$ corresponds to 3 o' clock,
etc. For a pendulum of length \$l\$, we can translate that as
\$\textbackslash{}langle x, y \textbackslash{}rangle = \textbackslash{}langle -
l sin(\textbackslash{}theta), - l cos(\textbackslash{}theta)
\textbackslash{}rangle\$.

Let's set up that system! We'll put it under normal gravity potential, again
(\$U(x,y) = 9.8 y\$). Our initial position \$\textbackslash{}theta\emph{0\$ will
be at equilibrium, and our initial angular velocity \$v}\{\textbackslash{}theta
0\}\$ will be 0.1 radians/sec (clockwise), as we try to induce harmonic motion:

``\texttt{haskell\ -\/-\ source:\ https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs\#L181-210\ -\/-\ \textbar{}\ A\ pendulum\ system,\ parameterized\ by\ its\ angle\ clockwise\ from\ -\/-\ equilibrium\ pendulum\ ::\ System\ 2\ 1\ pendulum\ =\ mkSystem\ (vec2\ 5\ 5)\ coords\ pot\ \ \ \ \ \ -\/-\ 5kg\ particle\ \ \ where\ \ \ \ \ -\/-\ \textless{}x,y\textgreater{}\ =\ \textless{}-0.5\ sin(theta),\ -0.5\ cos(theta)\textgreater{}\ \ \ \ \ -\/-\ pendulum\ of\ length\ 0.25\ \ \ \ \ coords\ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ 1\ a\ -\textgreater{}\ V.Vector\ 2\ a\ \ \ \ \ coords\ (V.head-\textgreater{}theta)\ =\ fromJust\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .\ V.fromList\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$\ {[}-\ 0.25\ *\ sin\ theta,\ -\ 0.25\ *\ cos\ theta{]}\ \ \ \ \ -\/-\ potential\ energy\ of\ gravity\ field\ \ \ \ \ -\/-\ U(x,y)\ =\ 9.8\ *\ y\ \ \ \ \ pot\ ::\ RealFloat\ a\ =\textgreater{}\ V.Vector\ 1\ a\ -\textgreater{}\ a\ \ \ \ \ pot\ q\ =\ 9.8\ *\ (coords\ q}V.index`
1)

pendulumConfig0 :: Config 1 pendulumConfig0 = Config \{ confPositions = 0 ,
confVelocities = 0.1 \}

pendulumMain :: IO () pendulumMain = mapM\_ (disp 3 . phasePositions) -\/-
position with 2 digits of precision . take 25 -\/- 25 steps \$ runSystem
pendulum 0.1 (toPhase pendulum pendulumConfig0) ```

This pendulum should wobble back and forth, ever so slightly, around
equilibrium.

\texttt{haskell\ ghci\textgreater{}\ :l\ Hamilton.hs\ ghci\textgreater{}\ pendulumMain\ 0\ 0.010\ 0.020\ 0.029\ 0.037\ 0.042\ 0.045\ 0.044\ 0.040\ 0.032\ 0.021\ 0.007\ -0.008\ -0.023\ -0.038\ -0.051\ -0.061\ -0.068\ -0.069\ -0.065\ -0.056\ -0.041\ -0.022\ -0.000\ 0.023}

We see our \$\textbackslash{}theta\$ coordinate increasing, then turning around
and decreasing, swinging the other way past equilibrium, and then turning around
and heading back!{[}\^{}phantom{]}

We \emph{automatically generated equations of motion for a pendulum}. Sweet!

\section{Wrap-Up}

We traveled through the world of physics, math, Haskell, and back again to
achieve something that would have initially seemed like a crazy thought
experiment. But, utilizing Hamiltonian mechanics, we have a system that can
automatically generate equations of motion given your coordinate system and a
potential energy function. We also learned how to leverage typed vectors for
more correct code and a smoother development process.

See my
\href{https://blog.jle.im/entry/introducing-the-hamilton-library.html}{previous
post} for even crazier examples -\/- involving multiple objects, double
pendulums, and more. And check out my
\href{http://hackage.haskell.org/package/hamilton}{hamilton} library on hackage,
which includes demos for exotic interesting systems, rendered graphically on
your terminal.

I realize that this was a lot, so if you have any questions or suggestions for
clarifications, feel free to leave a comment, drop me a
\href{https://twitter.com/mstk}{tweet}, or find me on the freenode
\emph{\#haskell} channel (where I usually idle as \emph{jle`}!)

\end{document}
