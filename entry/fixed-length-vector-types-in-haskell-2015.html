<!DOCTYPE HTML>
<html><head><title>Fixed-Length Vector Types in Haskell, 2015 Â· in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Update: This post was written by me when I was just starting to learn about type-level things in Haskell, and reflects my own inexperience at the time of writing it. I have released an update, which presents what I hope to be an introduction that is more grounded in modern Haskell and dependent type idioms."><meta property="og:type" content="article"><meta property="og:title" content="Fixed-Length Vector Types in Haskell, 2015"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Fixed-Length Vector Types in Haskell, 2015</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2015-05-05T11:16:07Z" pubdate="" class="pubdate">Tuesday May 5, 2015</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/fixvec.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/fixed-length-vector-types-in-haskell-2015.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@reference.html" class="tag-a-category" title="@REFERENCE">Reference</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p><strong><em>Update</em></strong>: This post was written by me when I was just starting to learn about type-level things in Haskell, and reflects my own inexperience at the time of writing it. I have <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">released an update</a>, which presents what I hope to be an introduction that is more grounded in modern Haskell and dependent type idioms.</p>
<h2>Original Article (written in 2015)</h2>
<p>Fixed-length vector types (vector types that indicate the length of the vector in the type itself) are one of the more straightforward applications of the &quot;super-Haskell&quot; GHC type extensions. There's a lot of magic you can do with GHC's advanced type mechanisms, but I think fixed length vectors are a good first step to beginning to understand several extensions, including (potentially):</p>
<ul>
<li>ConstraintKinds</li>
<li>DataKinds</li>
<li>GADTs</li>
<li>KindSignatures</li>
<li>TypeFamilies</li>
<li>TypeOperators</li>
<li>OverloadedLists</li>
</ul>
<p>And using type system plugins. (And of course the usual <code>UndecidableInstances</code> etc.) We'll be discussing two different ways to implement this --- using type-level nats, and using the <em>GHC.TypeLits</em> model to actually be able to use numeric literals in your types. These things are seen in the wild like with the popular <em><a href="http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html">linear</a></em> package's <code>V</code> type.</p>
<p>There are a few great tutorials/writeups on this topic, but many of them are from the time before we had some of these extensions, or only discuss a few. I hope to provide a nice comprehensive look about the tools available today to really approach this topic. That being said, I am no expert myself, so I would appreciate any tips/edits/suggestions for things that I've missed or done not-the-best :) This post has a lot of open questions that I'm sure people who know more about this than me can answer.</p>
<p>Most of the code in this article can be <a href="https://github.com/mstksg/inCode/blob/master/code-samples/fixvec">downloaded and tried out</a>, so follow along if you want!</p>
<h2>The Idea</h2>
<p>The basic idea is we'll have a type:</p>
<p>~~~haskell Vec n a ~~~</p>
<p>Which is a vector with items of type <code>a</code>, whose length is somehow encoded in the <code>n</code>. We'll then discuss ways to do useful operations on this, as if it were a list.</p>
<p><code>n</code> can really only be a certain &quot;kind&quot; of thing --- a type that encodes a length. We can represent this by giving it a &quot;kind signature&quot;:</p>
<p>~~~haskell data Vec :: Nat -&gt; * -&gt; * ~~~</p>
<p>Which says that our <code>Vec</code> type constructor takes two arguments: something of kind <code>Nat</code> (so it can't be any type...it has to be a type of kind <code>Nat</code>), something of kind <code>*</code> (the &quot;normal&quot; kind, of things that have values, like <code>Int</code>, <code>Maybe Bool</code>, etc.), and returns something of kind <code>*</code> (our vector itself).</p>
<h2>Using DataKinds for Type-Level Nats</h2>
<p>(The code in this section for this type is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs">available online</a>, if you wanted to play along!)</p>
<p>There are a couple of ways to find something for that <code>n</code> <code>Nat</code> kind, and one way is to use the simple inductive <code>Nat</code>:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L26-27 data Nat = Z | S Nat deriving Show ~~~</p>
<p>You might have seen this type before...it gives us value-level natural numbers, where <code>Z</code> is zero, <code>S Z</code> is one, <code>S (S Z)</code> is two, <code>S (S (S Z))</code> is three, etc. So if we had something of type <code>Nat</code>, it could represent any natural number. This declaration gives you:</p>
<ul>
<li>A type <code>Nat</code></li>
<li>A value constructor <code>Z :: Nat</code></li>
<li>A value constructor <code>S :: Nat -&gt; Nat</code></li>
</ul>
<p>However, with the <em>DataKinds</em> extension, when you define this, you also define some extra fancy things. You also define a <em>kind</em> <code>Nat</code>! More specifically, you get:</p>
<ul>
<li>A kind <code>Nat</code></li>
<li>A type <code>Z :: Nat</code> (<code>Z</code>, of <em>kind</em> <code>Nat</code>)</li>
<li>A type constructor <code>S :: Nat -&gt; Nat</code> (<code>S</code>, which takes something of kind <code>Nat</code>, and returns a new thing of kind <code>Nat</code>)</li>
</ul>
<p>(Note that, to be principled, GHC would prefer us to use <code>'Z</code> and <code>'S</code> when we are referring to the <em>types</em>, and this is how it'll print them out in error messages. But we're going to run with this for now...mostly for aesthetic reasons)</p>
<p>We can check this out in GHCi:</p>
<p>~~~haskell ghci&gt; :set -XDataKinds ghci&gt; data Nat = Z | S Nat ghci&gt; :k Z Nat ghci&gt; :k S Z Nat ghci&gt; :k S (S Z) Nat ~~~</p>
<p>So now we have a <em>type</em> that can encode numbers. Something of type <code>Z</code> represents zero...something of type <code>S Z</code> represents 1...something of type <code>S (S Z)</code> represents two.</p>
<p>Note that you can't ever have anything like <code>S Bool</code>...that doesn't work, because <code>Bool</code> is of kind <code>*</code>, but <code>S</code> expects only <code>Nat</code>s.</p>
<p>Now we can make our <code>Vec</code> data type, with the <em>GADTs</em> extension, or &quot;generalized algebraic data types&quot;:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L37-44 data Vec :: Nat -&gt; * -&gt; * where Nil :: Vec Z a (:#) :: a -&gt; Vec n a -&gt; Vec (S n) a</p>
<p>infixr 5 :#</p>
<p>deriving instance Show a =&gt; Show (Vec n a) deriving instance Eq a =&gt; Eq (Vec n a) ~~~</p>
<p>If you've never seen GADTs before, think of it as a way of declaring a type by giving the type of your constructors instead of just the normal boring form. It's nothing too crazy...it's basically like defining <code>Maybe</code> as:</p>
<p>~~~haskell data Maybe :: * -&gt; * where Nothing :: Maybe a Just :: a -&gt; Maybe a ~~~</p>
<p>instead of</p>
<p>~~~haskell data Maybe a = Nothing | Just a ~~~</p>
<p>In both cases, they create constructors of type <code>Nothing :: Maybe a</code> and <code>Just :: a -&gt; Maybe a</code> anyway...so the GADT form just gives us a way to state it explicitly.</p>
<p>Oh, we also used the <em>KindSignatures</em> extension to be able to give a kind signature to <code>Vec</code>...this is important because we want to make sure the first argument has to be a <code>Nat</code>. That is, we can't have anything silly like <code>Vec Bool Int</code>. We also have to put a separate <em>StandaloneDeriving</em>-extension standalone deriving clause instead of just having <code>deriving Show</code> because <code>Vec</code> isn't a type that can be expressed in &quot;normal Haskell&quot;.</p>
<p>Note that our type is basically like a list:</p>
<p>~~~haskell data [] :: * -&gt; * where [] :: [a] (:) :: a -&gt; [a] -&gt; [a] ~~~</p>
<p>Except now our type constructor actually has a new <code>Nat</code></p>
<p>This means that, because of type erasure, everything &quot;runtime&quot; on our new type is basically going to be identical to <code>[]</code> (not considering compiler tricks). In-memory, this new type is essentially exactly <code>[]</code>, but its type has an extra tag that is erased at compile-time.</p>
<p>Okay, let's define some useful methods:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L93-97 headV :: Vec (S n) a -&gt; a headV (x :# _) = x</p>
<p>tailV :: Vec (S n) a -&gt; Vec n a tailV (_ :# xs) = xs ~~~</p>
<p>Ah, the classic <code>head</code>/<code>tail</code> duo from the days pre-dating Haskell. <code>head</code> and <code>tail</code> are somewhat of a sore spot or wart in Haskell's list API[^htgone], because they're <em>partial functions</em>. You tell people all about how Haskell is great because it can prevent run-time errors by ensuring completeness and having the type system enforce null-pointer checks...but then you go ahead and put unsafe functions that throw errors for empty lists anyways in Prelude.</p>
<p>But here...this will never happen! We can only use <code>headV</code> and <code>tailV</code> on non-empty lists...it won't typecheck for empty lists. Do you see why?</p>
<p>It's because all empty lists are of type <code>Vec Z a</code>. But <code>headV</code> and <code>tailV</code> only take things of <em>type</em> <code>Vec (S n) a</code>, for any <code>Nat</code> <code>n</code>. So, if you ever try to use it on an empty list, it won't even compile! No more pesky runtime bugs. <code>headV</code> and <code>tailV</code> are safe and will never crash at runtime!</p>
<p>Note that the return type of <code>tailV</code> is a vector of a length one less than the given vector. <code>tailV :: Vec (S Z) a -&gt; Vec Z a</code>, for instance...or <code>tailV :: Vec (S (S Z)) a -&gt; Vec (S Z) a</code>. Just like we want!</p>
<p>If you tried implementing this yourself, you might notice that you actually get an <em>error</em> from GHC if you even <em>try</em> to handle the <code>Nil</code> case for <code>tailV</code> or <code>headV</code>. GHC will know when you've handled all possible cases, and get mad at you if you try to handle a case that doesn't even make sense!</p>
<h3>Type families and appending</h3>
<p>We can also &quot;append&quot; vectors. But we need a way to add <code>Nat</code>s together first. For that, we can use a type family, using the <em>TypeFamilies</em> extension (with <code>TypeOperators</code>):</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L29-31 type family (x :: Nat) + (y :: Nat) where 'Z + y = y 'S x + y = 'S (x + y) ~~~</p>
<p>A &quot;type family&quot; is like a type level function. Compare this to defining <code>(+)</code> on the value level to the <code>Nat</code> <em>data</em> type:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L33-35 (+#) :: Nat -&gt; Nat -&gt; Nat -- types! Z +# y = y S x +# y = S (x +# y) ~~~</p>
<p>Basically, we're defining a new type-level function <code>(+)</code> on two types <code>x</code> and <code>y</code>, both of kind <code>Nat</code>...and the result is their &quot;sum&quot;. Convince yourself that this &quot;addition&quot; is actually addition. Now, let's use it for <code>appendV</code>:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L99-101 appendV :: Vec n a -&gt; Vec m a -&gt; Vec (n + m) a appendV Nil ys = ys appendV (x :# xs) ys = x :# appendV xs ys ~~~</p>
<p>~~~haskell ghci&gt; let v1 = 1 :# 2 :# 3 :# Nil ghci&gt; let v2 = 0 :# 1 :# Nil ghci&gt; v1 <code>appendV</code> v2 1 :# 2 :# 3 :# 0 :# 1 :# Nil ghci&gt; :t v1 <code>appendV</code> v2 v1 <code>appendV</code> v2 :: Vec (S (S (S (S (S Z))) Int ~~~</p>
<h3>Generating</h3>
<p>It'd be nice to have type-safe methods of <em>generating</em> these things, too...functions like <code>iterate</code>, or <code>enumFrom</code>. One of the ways to do this is by using a typeclass. (Available in a <a href="https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs">separate file</a> to try out).</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L7-8 class Unfoldable v where unfold :: (b -&gt; (a, b)) -&gt; b -&gt; v a ~~~</p>
<p>We're going to call <code>v</code> an <code>Unfoldable</code> if you can build a <code>v</code> from an &quot;unfolding function&quot; and an &quot;initial state&quot;. Run the function on the initial value and get the first item and a new state. Run the function on the new state and get the second item and the next state.</p>
<p>The list instance should make it more clear:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L11-13 instance Unfoldable [] where unfold f x0 = let (y, x1) = f x0 in y : unfold f x1 ~~~</p>
<p>~~~haskell ghci&gt; take 5 $ unfold (\x -&gt; (x <code>mod</code> 3 == 2, x^2 - 1)) 2 [True, False, True, False, True] ~~~</p>
<p>Note that we can have an instance for any fixed-length vector type...where the thing &quot;cuts off&quot; after it's filled the entire vector:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L46-51 instance Unfoldable (Vec Z) where unfold _ _ = Nil</p>
<p>instance Unfoldable (Vec n) =&gt; Unfoldable (Vec (S n)) where unfold f x0 = let (y, x1) = f x0 in y :# unfold f x1 ~~~</p>
<p>Take a moment to think about what these instances are doing.</p>
<p>You can create a <code>Vec Z a</code> from an unfolding function pretty easily, because the only thing with type <code>Vec Z a</code> is <code>Nil</code>. So just ignore the function/initial state and return <code>Nil</code>.</p>
<p>The instance for <code>Vec (S n)</code> is slightly more involved. To make a <code>Vec (S n) a</code>, you need an <code>a</code> and a <code>Vec n a</code>. You can get the <code>a</code> from the unfolding function...but where will you get the <code>Vec n a</code> from? Well, you can use <code>unfold</code> to make a <code>Vec n a</code>! But that only makes sense if <code>Vec n</code> is an <code>Unfoldable</code>.</p>
<p>So, that's why in the instance for <code>Vec (S n)</code>, we constrain that <code>Vec n</code> must also be an <code>Unfoldable</code>. We make our result by using our function to create an <code>a</code> and <code>unfold</code> to create a <code>Vec n a</code> (provided <code>Vec n</code> is an <code>Unfoldable</code>).</p>
<p>Note that this style of declaration looks a lot like induction. We define our instance for zero...and then we say, &quot;if <code>n</code> is an instance, then so is <code>S n</code>&quot;. Induction!</p>
<p>Let's see this in action.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L15-24 replicateU :: Unfoldable v =&gt; a -&gt; v a replicateU = unfold (\x -&gt; (x, x))</p>
<p>iterateU :: Unfoldable v =&gt; (a -&gt; a) -&gt; a -&gt; v a iterateU f = unfold (\x -&gt; (x, f x))</p>
<p>fromListMaybes :: Unfoldable v =&gt; [a] -&gt; v (Maybe a) fromListMaybes = unfold $ \l -&gt; case l of [] -&gt; (Nothing, []) x:xs -&gt; (Just x , xs) ~~~</p>
<p>~~~haskell ghci&gt; replicateU 'a' :: Vec (S (S (S Z))) Char 'a' :# 'a' :# 'a' :# Nil ghci&gt; replicateU 'a' :: Vec Z Char Nil ghci&gt; iterateU succ 1 :: Vec (S (S (S (S Z)))) Int 1 :# 2 :# 3 :# 4 :# Nil ghci&gt; fromListMaybes [1,2] :: Vec (S (S (S Z))) (Maybe Int) Just 1 :# Just 2 :# Nothing :# Nil ghci&gt; tailV (iterateU succ 1 :: Vec (S Z) Int) Nil ~~~</p>
<p>Note that <code>replicateU</code> doesn't need to take in an <code>Int</code> parameter, like the on in Prelude, to say how many items to have. It just replicates enough to fill the entire vector we want!</p>
<h3>Common Typeclasses</h3>
<p>We can go in and implement common typeclasses, too. All the ones you'd expect.</p>
<p>We can actually use the <em>DeriveFunctor</em> extension to write a <code>Functor</code> instance, but let's write one on our own just for learning purposes:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L53-55 instance Functor (Vec n) where fmap _ Nil = Nil fmap f (x :# xs) = f x :# fmap f xs ~~~</p>
<p>For <code>Applicative</code>, it isn't so simple. The Applicative instance is going to be the &quot;ZipList&quot; instance...so we have to be able to make a <code>pure</code> that depends on the type, and a <code>(&lt;*&gt;)</code> that depends on the type, too.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L57-63 instance Applicative (Vec Z) where pure _ = Nil Nil &lt;*&gt; _ = Nil</p>
<p>instance Applicative (Vec n) =&gt; Applicative (Vec (S n)) where pure x = x :# pure x (f :# fs) &lt;<em>&gt; (x :# xs) = f x :# (fs &lt;</em>&gt; xs) ~~~</p>
<p>For <code>Vec Z</code>, it's just <code>Nil</code>. For <code>Vec (S n)</code>...for pure, you need <code>x :#</code> something...and that something has to be a <code>Vec n a</code>. That's just <code>pure</code> for <code>Vec n</code>! Remember, we can't assume that <code>Vec n</code> is an <code>Applicative</code> just because <code>Vec (S n)</code> is. So we need to add a constraint, that <code>Vec n</code> an Applicative. Induction, again!</p>
<p>For <code>(&lt;*&gt;)</code>, we can get the first item easily, it's just <code>f x</code>. But for the next item, we need a <code>Vec n a</code>. Luckily...we have exactly that with the <code>(&lt;*&gt;)</code> for <code>Vec n</code>!</p>
<p>Remember, at the end, we're saying &quot;We have an <code>Applicative</code> instance for <em>any</em> type <code>Vec n</code>&quot;. The instance for <code>Vec Z</code> has <code>pure _ = Nil</code>. The instance for <code>Vec (S Z)</code> has <code>pure x = x :# Nil</code>. The instance for <code>Vec (S (S Z))</code> has <code>pure x = x :# x :# Nil</code>, etc. etc.</p>
<p>~~~haskell ghci&gt; fmap (*2) (1 :# 2 :# 3 :# Nil) 2 :# 4 :# 6 :# Nil ghci&gt; pure 10 :: Vec (S (S Z)) Int 10 :# 10 :# Nil -- like replicateV! ghci&gt; liftA2 (+) (1 :# 2 :# 3 :# Nil) (100 :# 201 :# 302 :# Nil) 101 :# 203 :# 305 :# Nil ~~~</p>
<p>I'll leave the <code>Monad</code> instance as an exercise, but it's in the source files for this post. <code>join</code> for this instance should be a &quot;diagonal&quot; --- the first item of the first vector, the second item of the second vector, the third item of the third vector, etc.</p>
<p>We can define <code>Foldable</code> and <code>Traversable</code> the same way. Like for <code>Functor</code>, GHC can derive these with <em>DeriveFoldable</em> and <em>DeriveTraversable</em>...but we'll do it again here just to demonstrate.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L65-75 instance Foldable (Vec Z) where foldMap _ Nil = mempty</p>
<p>instance Foldable (Vec n) =&gt; Foldable (Vec (S n)) where foldMap f (x :# xs) = f x &lt;&gt; foldMap f xs</p>
<p>instance Traversable (Vec Z) where traverse _ Nil = pure Nil</p>
<p>instance Traversable (Vec n) =&gt; Traversable (Vec (S n)) where traverse f (x :# xs) = liftA2 (:#) (f x) (traverse f xs) ~~~</p>
<p>Note that we can only use <code>foldMap f xs</code> on <code>xs :: Vec n a</code>, if <code>Vec n</code> is a <code>Foldable</code>. So that's why we add that constraint.</p>
<p>Again, <code>liftA2 (:#) :: Applicative f =&gt; f a -&gt; f (Vec n a) -&gt; f (Vec (S n) a)</code>...so this only makes sense if <code>traverse f s</code> gives us a <code>Vec n a</code>. So we have to add that as a constraint.</p>
<p>~~~haskell ghci&gt; toList $ 1 :# 2 :# 3 :# Nil [1,2,3] ghci&gt; traverse Identity $ 1 :# 2 :# 3 :# Nil Identity (1 :# 2 :# 3 :# Nil) ghci&gt; sequence_ $ putStrLn &quot;hello&quot; :# putStrLn &quot;world&quot; :# Nil &quot;hello&quot; &quot;world&quot; ghci&gt; sequence $ Just 1 :# Just 2 :# Nil Just (1 :# 2 :# Nil) ghci&gt; sequence $ Just 1 :# Nothing :# Nil Nothing ~~~</p>
<p><code>Traversable</code> of course opens a whole lot of doors. For example, we can write a &quot;safe <code>fromList</code>&quot;:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/Unfoldable.hs#L26-27 fromListU :: (Unfoldable v, Traversable v) =&gt; [a] -&gt; Maybe (v a) fromListU = sequence . fromListMaybes ~~~</p>
<p>~~~haskell ghci&gt; fromListU [1,2,3] :: Maybe (Vec (S Z) Int) Just (1 :# Nil) ghci&gt; fromListU [1,2,3] :: Maybe (Vec (S (S (S Z))) Int) Just (1 :# 2 :# 3 :# Nil) ghci&gt; fromListU [1,2,3] :: Maybe (Vec (S (S (S (S Z)))) Int) Nothing ~~~</p>
<p>And, if you're on GHC 7.8+, you have access to the <em>OverloadedLists</em> language extension, where you can interpret list literals as if they were other structures.</p>
<p>We've already already implemented both <code>fromList</code> and <code>toList</code>, in a way, already, so this should be a breeze. The only trick you might see is that the <code>IsList</code> typeclass asks for a type family to return the <em>type of the element in the container</em> from the container type.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L86-91 instance (Unfoldable (Vec n), Traversable (Vec n)) =&gt; L.IsList (Vec n a) where type Item (Vec n a) = a fromList xs = case fromListU xs of Nothing -&gt; error &quot;Demanded vector from a list that was too short.&quot; Just ys -&gt; ys toList = Data.Foldable.toList ~~~</p>
<p>~~~haskell ghci&gt; :set -XOverloadedLists ghci&gt; [1,2,3] :: Vec (S (S Z)) Int 1 :# 2 :# Nil ghci&gt; [1,2,3] :: Vec (S (S (S (S Z)))) Int *** Exception: Demanded vector from a list that was too short. ghci&gt; [1,3..] :: Vec (S (S (S (S Z)))) Int 1 :# 3 :# 5 :# 7 :# Nil ~~~</p>
<p>Neat! All of the benefits of list literals that <em>OverloadedLists</em> offers is now available to us.[^impossible] Unfortunately, you now open yourself up to runtime errors, so...it's actually a really bad idea for safety purposes unless you stick to only using it with infinite lists or are very disciplined. (Unless you really want to use list syntax, <code>fromListU</code> is probably a safer choice for finite lists!)</p>
<h3>Indexing</h3>
<p>It'd be nice to be able to index into these, of course. For type-safe indexing, we can take advantage of a trick using the <code>Proxy</code> type.</p>
<p>Many might remember having to get a <code>TypeRep</code> for a <code>Typeable</code> instance by doing something like <code>typeOf (undefined :: IO Double)</code>. That's because <code>typeOf :: Typeable a =&gt; a -&gt; TypeRep</code>. If you wanted to get the <code>typeRep</code> for an <code>IO Double</code> using <code>typeOf</code>, you have to pass in an <code>IO Double</code>. But if you don't have one at hand, you can just use <code>undefined</code> with a type annotation. It's a bit of a dirty hack, but it works because <code>typeOf</code> doesn't care about the first argument's value...just its type.</p>
<p>These days, we like to be a bit less embarrassing and use something called <code>Proxy</code>:</p>
<p>~~~haskell data Proxy a = Proxy ~~~</p>
<p><code>Proxy a</code> is a bit like <code>()</code>. It only has one constructor, and doesn't take any arguments. But we can use the type signature to &quot;pass in types&quot; to functions, as &quot;arguments&quot;.</p>
<p>We have a couple of options here. One is to make a typeclass for type level nats to turn them into an <code>Integer</code> or a value-level <code>Nat</code>, and then do an &quot;unsafe indexing&quot; after verifying, through types, that the index is smaller than the length.</p>
<p>However, this is a little bit silly because we're just doing an unsafe indexing in the end anyway, so the compiler can't help us at all. Wouldn't it be nice if we could get the compiler on our side and write a <em>real</em> safe index?</p>
<p>There are many ways to approach this problem, but one way is to make a specific <code>Index</code> typeclass: (or make another typeclass like <code>Take</code>, and write <code>index</code> in terms of it)</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L77-78 class Index (n :: Nat) v where index :: Proxy n -&gt; v a -&gt; a ~~~</p>
<p>Here, we can say that <code>n</code> and <code>v</code> are instances of <code>Index n v</code> if and only if you can safely (totally) index into <code>v a</code> at index <code>n</code>. That is, if every value of type <code>v a</code> ever has an index at <code>n</code>, a <code>Nat</code>. (By the way, we need <em>MultiParamTypeClasses</em> to be able to make a type class with two parameters)</p>
<p>So, <code>n ~ S Z</code> and <code>v ~ Vec (S (S Z)) a</code> has an instance, because you can get the $n = 1$ element (the second element) from <em>any</em> value of type <code>Vec (S (S Z)) a</code> (a length-two vector).</p>
<p>But <code>n ~ S Z</code> and <code>v ~ Vec (S Z) a</code> does <em>not</em>. There are actually <em>no</em> length-1 vectors that have a $1$ index (second element).</p>
<p>Note that we use the <code>Proxy</code> trick we discussed, so that we can indicate somehow what index we really want. It is a trick that basically allows us to pass a <em>type</em> (<code>S Z</code>, <code>S (S Z)</code>, etc.) as a &quot;value&quot;.</p>
<p>Let's write our instances --- but only the instances that <em>make sense</em>.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeNats.hs#L80-84 instance Index Z (Vec (S n)) where index _ (x :# _) = x</p>
<p>instance forall n m. Index n (Vec m) =&gt; Index (S n) (Vec (S m)) where index _ (_ :# xs) = index (Proxy :: Proxy n) xs ~~~</p>
<p>The first case instance makes sense. We can definitely index at index <code>Z</code> (zero) of <em>any</em> <code>Vec (S n) a</code> --- the only thing we can't index <code>Z</code> into is <code>Vec Z a</code>. So, if our vector is of length 1 or higher, we can index at position 0.</p>
<p>The second case says that, if we can index into <code>n</code> of a <code>Vec m a</code>, then of course we can index into an <code>S n</code> of a <code>Vec (S m) a</code>. To index into <code>S n</code> of a <code>Vec (S m) a</code>, all we need to do is index into <code>n</code> of the <code>Vec m a</code> tail!</p>
<p>We have to use the <em>ScopedTypeVariables</em> extension to enable us to use, with the <code>forall</code> statement, the <code>n</code> in our instance when we are writing our type for <code>Proxy</code>. If we didn't, the <code>n</code> in <code>Proxy n</code> in our <code>index</code> definition would be considered unrelated by GHC to the <code>n</code> in the instance statement, <code>Index (S n) (Vec (S m))</code>. (This is the only reason we need the <code>forall</code>)</p>
<p>In any case, note the similarity of this algorithm to the actual indexing function on lists:</p>
<p>~~~haskell 0 !! (x:_ ) = x n !! (_:xs) = (n - 1) !! xs ~~~</p>
<p>trying it out...</p>
<p>~~~haskell ghci&gt; index (Proxy :: Proxy (S (S Z))) (1 :# 2 :# 3 :# Nil) 3 ghci&gt; index (Proxy :: Proxy (S (S Z))) (1 :# 2 :# Nil) *** Compile error! ~~~</p>
<p>It's an error, but remember, it's a <em>compiler</em> error, that happens before any code is ever even run! No more indexing errors at runtime! Kiss your days of hunting segfault errors in C goodbye!</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Aside</strong></p>
<p>This is something I haven't really been able to find a good answer too. But notice that we actually could have written a &quot;bad&quot; instance of the second instance of <code>Index</code>:</p>
<p>~~~haskell instance Index (S n) (Vec (S m)) where index _ (x :# _) = x ~~~</p>
<p>And this compiles fine...but gives the wrong behavior, or at least the behavior we don't want!</p>
<p>Does anybody know a way to state the type of <code>Index</code> or <code>index</code> in a way that implementations like this are impossible?</p>
<p>There's a &quot;fundamental&quot; problem here, it seems, because we can't really demand or specify anything by the return type, like we could in the other examples. In the other examples, we sort of restricted the implementation by choosing our return type carefully...but for here, it's just <code>a</code>. I'd love to hear if anyone has any thoughts on this. &lt;/div&gt;</p>
<p>You might notice that it's a bit of a plain to write <code>S (S (S (S Z)))</code>, etc., especially for large numbers. And I wouldn't even think about writing it for the hundreds.</p>
<p>We'll &quot;fix&quot; this in the next section. However, even before this, you actually can generate these &quot;automatically&quot; with template haskell, using techniques from <a href="http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf">Functional Pearls: Implicit Configurations</a>, and the <a href="http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html">linear</a> package does just this. (This path slipped my mind before I posted because I didn't really consider template Haskell, and I think I'll edit in a section here soon). With this in mind, I still don't really consider Template Haskell an optimal or clean approach :)</p>
<h2>Using TypeLits and Type Checker Plugins</h2>
<p>(This next section uses code that is <a href="https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs">also available online</a>, as well!)</p>
<p>Using a custom <code>Nat</code> kind and <em>DataKinds</em> is nice and all, but it's a bit of a hassle to express large numbers like 100, 1000, etc. However, as of GHC 7.8, we've had the ability to actually <em>use</em> numeric (integer) literals in our types. Instead of writing <code>S (S Z)</code>, we can write <code>2</code>.</p>
<p>GHC can't yet quite work with that well by default. It has trouble proving statements about variables, like <code>(n + 1) ~ (1 + n)</code> (that <code>n + 1</code> is &quot;the same as&quot; <code>1 + n</code>). Fortunately for us, since GHC 7.10, we have a way to &quot;extend&quot; the type checker with custom plugins that <em>can</em> prove things like this for us. (Note that this <code>+</code> is the one from <code>GHC.TypeLits</code>...not the one we defined earlier.)</p>
<p>The <em><a href="https://hackage.haskell.org/package/ghc-typelits-natnormalise">ghc-typelits-natnormalise</a></em> package is a package providing such a plugin. We can have GHC use it to extend its type checking by passing in <code>-fplugin GHC.TypeLits.Normalise</code> when we execute our code, or by adding a pragma:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L14-14 {-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-} ~~~</p>
<p>to the top of our file, along with our <code>LANGUAGE</code> pragmas. (Assuming, of course, a GHC 7.10+)</p>
<p>~~~haskell ghci&gt; :set -XDataKinds -XTypeOperators -XTypeFamilies ghci&gt; import GHC.TypeLits ghci&gt; Proxy :: ((n + 1) ~ (1 + n)) =&gt; Proxy n *** Compile error: Cannot match <code>1 + n</code> with <code>n + 1</code> ghci&gt; :set -fplugin GHC.TypeLits.Normalise ghci&gt; Proxy :: ((n + 1) ~ (1 + n)) =&gt; Proxy n Proxy -- success! ~~~</p>
<p>GHC now uses the plugin to prove that the two are really equivalent.</p>
<p>If you wanted to play along or try out the code samples, I recommend you use a sandbox:</p>
<p>~~~bash</p>
<h1>in directory of your choice</h1>
<p>$ cabal sandbox init $ cabal install ghc-typelits-natnormalise $ cabal exec bash</p>
<h1>now the package is in scope, when you use ghci or runghc</h1>
<p>~~~</p>
<p>With that in mind, let's start restating everything in terms of <em>TypeLits</em> and see what it gains us.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L33-40 data Vec :: Nat -&gt; * -&gt; * where Nil :: Vec 0 a (:#) :: a -&gt; Vec (n - 1) a -&gt; Vec n a</p>
<p>infixr 5 :#</p>
<p>deriving instance Show a =&gt; Show (Vec n a) deriving instance Eq a =&gt; Eq (Vec n a) ~~~</p>
<p>A little nicer, right? <code>Nil</code> is a <code>Vec 0 a</code>, and <code>x :# xs</code> is an element with a <code>Vec (n - 1) a</code>, which overall is a <code>Vec n a</code>. Let's go over everything again to see how it'd look in the new regime. (Note that the kind of the type number literals is also called <code>Nat</code>...unrelated to our <code>Nat</code> we used before.)</p>
<h2>A new look</h2>
<p>First of all, we're going to have to define <em>TypeLit</em> comparison operators, as they aren't built in in a useful way.</p>
<p>We have the type family (remember those?) <code>CmpNat x y</code>, which returns an <code>Ordering</code> (<code>LT</code>, <code>EQ</code>, or <code>GT</code>) type (of kind <code>Ordering</code>, using <em>DataKinds</em>...lifting a type and its value constructors to a kind and its types), which is provided and defined for us by GHC in <code>GHC.TypeLits</code>.</p>
<p>So defining a <code>x &gt; y</code> constraint is pretty straightforward:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L31-31 type x &gt; y = CmpNat x y ~ 'GT ~~~</p>
<p>Note that we need the <em>ConstraintKinds</em> extension for this to work, as <code>1 &gt; 2</code> is now a <em>constraint</em>, of kind <code>Constraint</code>.</p>
<p>Given this, let's do our favorite list functions, <code>headV</code> and <code>tailV</code>:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L89-93 headV :: (n &gt; 0) =&gt; Vec n a -&gt; a headV (x :# _) = x</p>
<p>tailV :: (n &gt; 0) =&gt; Vec n a -&gt; Vec (n - 1) a tailV (_ :# xs) = xs ~~~</p>
<p>Magnificent!</p>
<p>~~~haskell ghci&gt; headV (Nil :: Vec 0 ()) -- Error! Cannot unite 'EQ with 'GT ~~~</p>
<p>Neat! The error, remember, is at <em>compile time</em>, and not at runtime. If we ever tried to do an unsafe head, our code wouldn't even <em>compile</em>! The error message comes from the fact that we need $n &gt; 0$, but we have $n = 0$ instead. We have <code>EQ</code>, but we need <code>GT</code>.</p>
<p>There is one problem here, though --- GHC gives us a warning for not pattern matching on <code>Nil</code>. But, if we do try to pattern match on <code>Nil</code>, we get a type error, like the same one we got when using our custom type nats. I think this is probably something that a plugin or sufficiently smart <code>CmpNat</code> might be able to handle...but I'm not totally sure. Right now, the best thing I can think of is just to do a wildcard match, <code>headV _ = error &quot;What?&quot;</code>, knowing that that case will never be reached if your program compiles successfully.</p>
<p>Moving on, we see that we don't even have to do any extra work to define our own type family <code>x + y</code>...because <code>GHC.TypeLits</code> already defines it for us! So, we can instantly write....</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L95-97 appendV :: Vec n a -&gt; Vec m a -&gt; Vec (n + m) a appendV Nil ys = ys appendV (x :# xs) ys = x :# appendV xs ys ~~~</p>
<p>~~~haskell ghci&gt; let v1 = 1 :# 2 :# 3 :# Nil ghci&gt; let v2 = iterateU succ 0 :: Vec 2 Int ghci&gt; v1 <code>appendV</code> v2 1 :# 2 :# 3 :# 0 :# 1 :# Nil ghci&gt; :t v1 <code>appendV</code> v2 :: Vec 5 Int v1 <code>appendV</code> v2 :: Vec 5 Int ~~~~</p>
<p>And our list generating typeclasses ---</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L42-47 instance Unfoldable (Vec 0) where unfold _ _ = Nil</p>
<p>instance (Unfoldable (Vec (n - 1)), n &gt; 0) =&gt; Unfoldable (Vec n) where unfold f x0 = let (y, x1) = f x0 in y :# unfold f x1 ~~~</p>
<p>The translation is pretty mechanical, but I think that this new formulation looks...really nice, and really powerful. &quot;If you can build a list from $n - 1$ and $n &gt; 0$, then you can build a list for $n$!</p>
<p>Note that because our definitions of <code>replicateU</code>, <code>iterateU</code>, and <code>fromListMaybes</code> was polymorphic over all <code>Unfoldable</code>, we can actually re-use them from before:</p>
<p>~~~haskell ghci&gt; iterateU succ 1 :: Vec 3 int 1 :# 2 :# 3 :# Nil ghci&gt; iterateU succ 1 :: Vec 10 Int 1 :# 2 :# 3 :# 4 :# 5 :# 6 :# 7 :# 8 :# 9 :# 10 :# Nil ghci&gt; replicateU 'a' :: Vec 4 Char 'a' :# 'a' :# 'a' :# 'a' :# Nil ~~~</p>
<p>The actual types are much nicer, too --- we can write <code>Vec 10 Int</code> instead of <code>Vec (S (S (S (S (S (S (S (S (S (S Z)))))))))) Int</code> without resorting to template haskell.</p>
<p>Going through all of our other typeclasses/functions and making the adjustments... (remembering that we can also derive <code>Functor</code>, <code>Traversable</code>, and <code>Foldable</code> using GHC)</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec/FVTypeLits.hs#L49-87 instance Functor (Vec n) where fmap _ Nil = Nil fmap f (x :# xs) = f x :# fmap f xs</p>
<p>instance Applicative (Vec 0) where pure _ = Nil Nil &lt;*&gt; _ = Nil</p>
<p>instance (Applicative (Vec (n - 1)), n &gt; 0) =&gt; Applicative (Vec n) where pure x = x :# pure x (f :# fs) &lt;<em>&gt; (x :# xs) = f x :# (fs &lt;</em>&gt; xs)</p>
<p>instance Foldable (Vec 0) where foldMap _ Nil = mempty</p>
<p>instance (Foldable (Vec (n - 1)), n &gt; 0) =&gt; Foldable (Vec n) where foldMap f (x :# xs) = f x &lt;&gt; foldMap f xs</p>
<p>instance Traversable (Vec 0) where traverse _ Nil = pure Nil</p>
<p>instance (Traversable (Vec (n - 1)), n &gt; 0) =&gt; Traversable (Vec n) where traverse f (x :# xs) = liftA2 (:#) (f x) (traverse f xs)</p>
<p>class Index (n :: Nat) v where index :: Proxy n -&gt; v a -&gt; a</p>
<p>instance (m &gt; 0) =&gt; Index 0 (Vec m) where index _ (x :# _) = x</p>
<p>instance forall n m. (Index (n - 1) (Vec (m - 1)), n &gt; 0, m &gt; 0) =&gt; Index n (Vec m) where index _ (_ :# xs) = index (Proxy :: Proxy (n - 1)) xs</p>
<p>instance (Unfoldable (Vec n), Traversable (Vec n)) =&gt; L.IsList (Vec n a) where type Item (Vec n a) = a fromList xs = case fromListU xs of Nothing -&gt; error &quot;Demanded vector from a list that was too short.&quot; Just ys -&gt; ys toList = Data.Foldable.toList ~~~</p>
<p>(Remember, we use the <code>forall</code> here with <em>ScopedTypeVariables</em> to be able to say that the <code>n</code> in the type signature is the same <code>n</code> that is in the type of <code>Proxy</code>)</p>
<p>~~~haskell ghci&gt; fromListU [1,2,3,4] :: Vec 10 Int Nothing ghci&gt; fromListU [1,2,3,4] :: Vec 3 Int Just (1 :# 2 :# 3 :# Nil) ghci&gt; index (Proxy :: Proxy 2) (1 :# 2 :# 3 :# Nil) 3 ghci&gt; index (Proxy :: Proxy 2) (1 :# 2 :# Nil) *** Type Error: Couldn't match 'EQ with 'GT ghci&gt; :set -XOverloadedLists ghci&gt; [1,2,3] :: Vec 2 Int 1 :# 2 :# Nil ghci&gt; [1,2,3] :: Vec 4 Int *** Exception: Demanded vector from a list that was too short. ghci&gt; [1,3..] :: Vec 5 Int 1 :# 3 :# 5 :# 7 :# 9 :# Nil ~~~</p>
<p>I think, overall, this formulation gives a much nicer interface. Being able to just write $10$ is pretty powerful. The usage with <em>OverloadedLists</em> is pretty clean, too, especially when you can do things like <code>[1,3..] :: Vec 10 Int</code> and take full advantage of list syntax and succinct vector types. (Minding your runtime errors, of course)</p>
<p>However, you do again get the problem that GHC is not able to do real completeness checking and asks for the <code>Nil</code> cases still of everything...but adding a <code>Nil</code> case will cause a type error. The only solution is to add a <code>_</code> wildcard chase, but...again, this isn't quite satisfactory.[^thsolve] If anybody has a way to get around this, I'd love to know :)</p>
<h2>Alternative Underlying Representations</h2>
<p>Recall that our <code>Vec</code> was basically identically the normal list type, with an extra field in the type. Due to type erasure, the two are represented exactly the same in memory. So we have $O(n)$ appends, $O(n)$ indexing, etc. Our type is essentially equal to</p>
<p>~~~haskell newtype Vec :: Nat -&gt; * -&gt; * where VecList :: [a] -&gt; Vec n a ~~~</p>
<p>For this type, though, we'd need to use &quot;smart constructors&quot; and extractors instead of <code>1 :# 2 :# Nil</code> etc.</p>
<p>We could, however, chose a more efficient type, like <code>Vector</code> from the <em><a href="http://hackage.haskell.org/package/vector-0.10.12.2/docs/Data-Vector.html#t:Vector">vector</a></em> package:</p>
<p>~~~haskell newtype Vec :: Nat -&gt; * -&gt; * where VecVector :: Vector a -&gt; Vec n a ~~~</p>
<p>And, if you made sure to wrap everything with smart constructors, you now have <em>type safe</em> $O(1)$ random indexing!</p>
<p>(This is representation is similar to the one used by the <em><a href="http://hackage.haskell.org/package/linear-1.18.0.1/docs/Linear-V.html">linear</a></em> package.)</p>
<h2>More Operations</h2>
<p>One really weird quirk with this is that many functions you'd normally write using pattern matching you'd now might start writing using typeclasses. One example would be our implementation of indexing, using an <code>IndexV</code> typeclass.</p>
<p>A bunch of one-shot typeclasses is sort of unideal, as typeclasses are sort of ugly and non-first-class. Ideally you'd only have a few typeclasses for as generic an interface as possible, and then be able to do everything from those. Sometimes this just isn't practical. I did mention one way around it, which was to make a typeclass to &quot;reify&quot; or turn your type into actual data, and then manipulate your data in an &quot;unsafe&quot; way knowing that the type checker checked that the data matched.</p>
<p>We'll demonstrate with <code>SomeNat</code> from <code>GHC.TypeLits</code>, but you can also make our own for our inductive <code>Nat</code> type we used in the first half, too.</p>
<p>If we use our &quot;wrapped <code>Vector</code> approach&quot;, we can just do:</p>
<p>~~~haskell newtype Vec :: Nat -&gt; * -&gt; * where Vec :: Vector a -&gt; Vec n a</p>
<p>index :: (KnownNat n, m &gt; n) =&gt; Proxy n -&gt; Vec m a -&gt; a index p (Vec v) = v ! fromInteger (natVal p) ~~~</p>
<p>That is, <code>index</code> internally uses <code>(!)</code>, an unsafe operator...but only after we assure properly that it's safe to use by stating <code>m &gt; n</code> in the constraint. We can be sure that GHC will catch any instance where someone tries to index into a <code>Vec m a</code> whose <code>m</code> is <em>not</em> greater than the index desired.</p>
<p>The rest is up to you, though --- to prove that indexing into a number smaller than <code>m</code> will always provide an answer. We have to make sure our smart constructors are okay and that <code>(!)</code> behaves like we think it does.</p>
<h2>Singletons</h2>
<p>Another answer to these sort of ad-hoc typeclasses is to use techniques involving singletons. Going all into how to use singletons to work with these is an article on its own...luckily, this article has already been written as <a href="https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell">Part 1: Dependent Types in Haskell</a> by Hiromi ISHII. A major advantage is that you replace typeclasses with type families and more parameterized types. You'll have to work with an understanding of how singletons work, and accept using some template haskell to generate singleton types for your data types (or write them yourself!). But it's a powerful way to bring something like dependent types into Haskell, and there's already a lot of infrastructure of support on it on hackage and in the haskell dev ecosystem in general. I recommend looking at the linked article!</p>
<h2>Conclusion</h2>
<p>Hopefully you'll see that we are able to apply the full type-safety of the Haskell compiler to our programs regarding lists by encoding the length of the list in its type and limiting its operations by specifically typed functions and choice of instances. I also hope that you've been able to become familiar with seeing a lot of GHC's basic type extensions in real applications :)</p>
<p>Feel free to <a href="https://github.com/mstksg/inCode/blob/master/code-samples/fixvec">download and run</a> any of the samples</p>
<p>Please let me know if I got anything wrong, or if there are any techniques that I should mention here that are out and in the wild today :)</p></div><footer><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@reference.html" class="tag-a-category">@REFERENCE</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/unique-sample-drawing-searches-with-list-and-statet.html">Unique sample drawing &amp; searches with List and StateT --- &quot;Send more money&quot;</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/mtl-is-not-a-monad-transformer-library.html">mtl is Not a Monad Transformer Library</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html';
    this.page.identifier = 'fixvec';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>