<!DOCTYPE HTML>
<html><head><title>The List MonadPlus --- Practical Fun with Monads (Part 2 of 3) Â· in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Part two of an exploration of a very useful design pattern in Haskell known as MonadPlus, a part of an effort to make &quot;practical&quot; monads less of a mystery and fun to the good peoples of this earth. When we last left off on the MonadPlus introduction, we understood that there are times when you want to chain functions on objects in a way that &quot;resembles&quot; a failure/success process. We did this by exploring the most simple of all MonadPlus&#39;s: a simple &quot;dumb&quot; container for a value is either in a success or a failure. We looked at how the MonadPlus design pattern really &quot;behaved&quot;. This time we&#39;re going to look at another MonadPlus --- the List. By the end of this series we&#39;re going to be using nothing but the list&#39;s MonadPlus properties to solve this classic logic problem: A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can&#39;t leave the wolf alone with the goat, or the wolf will eat the goat. He can&#39;t leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters? Let&#39;s get to it!"><meta property="og:type" content="article"><meta property="og:title" content="The List MonadPlus --- Practical Fun with Monads (Part 2 of 3)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">The List MonadPlus --- Practical Fun with Monads (Part 2 of 3)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2013-12-18T11:08:38Z" pubdate="" class="pubdate">Wednesday December 18, 2013</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/monad-plus-2.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/the-list-monadplus-practical-fun-with-monads-part.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Part two of an exploration of a very useful design pattern in Haskell known as MonadPlus, a part of an effort to make &quot;practical&quot; monads less of a mystery and fun to the good peoples of this earth.</p>
<p>When we last left off on the <a href="http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus">MonadPlus introduction</a>, we understood that there are times when you want to chain functions on objects in a way that &quot;resembles&quot; a failure/success process. We did this by exploring the most simple of all MonadPlus's: a simple &quot;dumb&quot; container for a value is either in a success or a failure. We looked at how the MonadPlus design pattern really &quot;behaved&quot;.</p>
<p>This time we're going to look at another MonadPlus --- the List. By the end of this series we're going to be using nothing but the list's MonadPlus properties to solve this classic logic problem:</p>
<blockquote>
<p>A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can't leave the wolf alone with the goat, or the wolf will eat the goat. He can't leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?</p>
</blockquote>
<p>Let's get to it!</p>
<h3>MonadWhat? A review</h3>
<p>Let's take a quick review! Remember, a monad is just an object where you have defined a way to chain functions inside it. You'll find that you can be creative this &quot;chaining&quot; behavior, and for any given type of object you can definitely define more than one way to &quot;chain&quot; functions on that type of object. One &quot;design pattern&quot; of chaining is MonadPlus, where we use this chaining to model success/failure.</p>
<ul>
<li><code>mzero</code> means &quot;failure&quot;, and chaining anything onto a failure will still be a failure.</li>
<li><code>return x</code> means &quot;succeed with <code>x</code>&quot;, and will return a &quot;successful&quot; result with a value of <code>x</code>.</li>
</ul>
<p>You can read through the <a href="http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus">previous article</a> for examples of seeing these principles in action and in real code.</p>
<p>Without further ado, let us start on the list monad.</p>
<h2>Starting on the List Monad</h2>
<p>Now, when I say &quot;list monad&quot;, I mean &quot;one way that you can implement chaining operations on a list&quot;. To be more precise, I should say &quot;haskell's default choice of chaining method on lists&quot;. Technically, <strong>there is no &quot;the list monad&quot;</strong>...there is &quot;a way we can make the List data structure a monad&quot;.</p>
<p>And what's one way we can do this? You could probably take a wild guess. Yup, we can model lists as a MonadPlus --- we can model chaining in a way that revolves around successes and failures.</p>
<p>So, how can a list model success/failure? Does that even make sense?</p>
<p>Let's take a look at last article's <code>halve</code> function:</p>
<p>~~~haskell -- the built in function <code>guard</code>, to refresh your memory guard :: MonadPlus m =&gt; Bool -&gt; m () guard True = return () guard False = mzero</p>
<p>-- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L30-L33 halve :: Int -&gt; Maybe Int halve n = do guard $ even n return $ n <code>div</code> 2 ~~~</p>
<p>~~~haskell ghci&gt; halve 6 Just 3 ghci&gt; halve 7 Nothing ghci&gt; halve 8 &gt;&gt;= halve Just 2 ghci&gt; halve 7 &gt;&gt;= halve Nothing ~~~</p>
<p>Here, our success/fail mechanism was built into the Maybe container. Remember, first, it fails automatically if <code>n</code> is not even; then, it auto-succeeds with <code>n `div` 2</code> (which only works if it has not already failed). But note that we didn't actually really &quot;need&quot; Maybe here...we could have used anything that had an <code>mzero</code> (insta-fail, which is used in <code>guard</code>) and a <code>return</code> (auto-succeed).</p>
<p>Let's see what happens when we replace our Maybe container with a list:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L35-L38 halve' :: Int -&gt; [Int] halve' n = do guard $ even n return $ n <code>div</code> 2 ~~~</p>
<p>This is...the exact same function body. We didn't do anything but change the type signature. But because you believe me when I say that List is a MonadPlus...this should work, right? <code>guard</code> should work for <em>any</em> MonadPlus, because every MonadPlus has an <code>mzero</code> (fail). <code>return</code> should work for any MonadPlus, too --- it wouldn't be a MonadPlus without <code>return</code> implemented! (Remember, typeclasses are similar to interfaces in OOP) We don't know exactly what failing and succeeding actually <em>looks</em> like in a list yet...but if you know it's a MonadPlus (which List is, in the standard library), you know that it <em>has</em> these concepts defined somewhere.</p>
<p>So, how is list a meaningful MonadPlus? Simple: a &quot;failure&quot; is an empty list. A &quot;success&quot; is a non-empty list.</p>
<p>Watch:</p>
<p>~~~haskell ghci&gt; halve' 6 [3] ghci&gt; halve' 7 [] ghci&gt; halve' 8 &gt;&gt;= halve' [2] ghci&gt; halve' 7 &gt;&gt;= halve' [] ghci&gt; halve' 32 &gt;&gt;= halve' &gt;&gt;= halve' &gt;&gt;= halve' [2] ghci&gt; halve' 32 &gt;&gt; mzero &gt;&gt;= halve' &gt;&gt;= halve' &gt;&gt;= halve' [] ~~~</p>
<p>So there we have it! <code>Nothing</code> is just like <code>[]</code>, <code>Just x</code> is just like <code>[x]</code>. This whole time! It's all so clear now! Why does <code>Maybe</code> even exist, anyway, when we can just use <code>[]</code> and <code>[x]</code> for <code>Nothing</code> and <code>Just x</code> and be none the wiser? (Take some time to think about it if you want!)</p>
<p>In fact, if we generalize our type signature for <code>halve</code>, we can do some crazy things...</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L40-L43 genericHalve :: MonadPlus m =&gt; Int -&gt; m Int genericHalve n = do guard $ even n return $ n <code>div</code> 2 ~~~</p>
<p>~~~haskell ghci&gt; genericHalve 8 :: Maybe Int Just 4 ghci&gt; genericHalve 8 :: [Int] [4] ghci&gt; genericHalve 7 :: Maybe Int Nothing ghci&gt; genericHalve 7 :: [Int] [] ~~~</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<p>Now, when we say something like <code>genericHalve 8 :: Maybe Int</code>, it means &quot;I want <code>genericHalve 8</code>...and I want the type to be <code>Maybe Int</code>.&quot; This is necessary here because in our <code>genericHalve</code> can be <em>any</em> MonadPlus, so we have to tell ghci which MonadPlus we want. &lt;/div&gt;</p>
<p>(<a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/Halves.hs">All three versions of <code>halve</code> available for playing around with</a>)</p>
<p>So there you have it. Maybe and lists are one and the same. Lists <em>do</em> too represent the concept of failure and success. So...what's the difference?</p>
<h2>A List Apart</h2>
<p>Lists can model failure the same way that Maybe can. But it should be apparent that lists can do a little &quot;more&quot; than Maybe...</p>
<p>Consider <code>[3, 5]</code>. Clearly this is to represent some sort of &quot;success&quot; (because a failure would be an empty list). But what kind of &quot;success&quot; could it represent?</p>
<p>How about we look at it this way: <code>[3, 5]</code> represents two separate <em>paths</em> to success. When we look at a <code>Just 5</code>, we see a computation that succeeded with a 5. When we see a <code>[3, 5]</code>, we may interpret it as a computation that had two possible succesful paths: one succeeding with a 3 and another with a 5.</p>
<p>You can also say that it represents a computation that <em>could have chosen</em> to succeed in a 3, or a 5. In this way, the list monad is often referred to as &quot;the choice monad&quot;.</p>
<p>This view of a list as a collection of possible successes or choices of successes is not the only way to think of a list as a monad...but it is the way that the Haskell community has adopted as arguably the most useful. (The other main way is to approach it completely differently, making list not even a MonadPlus and therefore not representing failure or success at all)</p>
<p>Think of it this way: A value goes through a long and arduous journey with many choices and possible paths and forks. At the end of it, you have the result of every path that could have lead to a success. Contrast this to the Maybe monad, where a value goes through this arduous journey, but never has any choice. There is only one path --- successful, or otherwise. A Maybe is deterministic...a list provides a choice in paths.</p>
<h2>halveOrDouble</h2>
<p>Let's take a simple example: <code>halveOrDouble</code>. It provides two successful paths if you are even: halving and doubling. It only provides one choice or possible path to success if you are odd: doubling. In this way it is slightly racist.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/HalveOrDouble.hs#L19-L21 halveOrDouble :: Int -&gt; [Int] halveOrDouble n | even n = [n <code>div</code> 2, n * 2] | otherwise = [n * 2] ~~~</p>
<p>~~~haskell ghci&gt; halveOrDouble 6 [ 3,12] ghci&gt; halveOrDouble 7 [ 14] ~~~</p>
<p>(<a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/HalveOrDouble.hs">Play with this and other functions this section on your own</a>)</p>
<p>As you can see in the first case, with the 6, there are two paths to success: the halve, and the double. In the second case, with the 7, there is only one --- the double.</p>
<p>How about we subject a number to this halving-or-doubling journey twice? What do we expect?</p>
<ol>
<li>The path of halve-halve only works if the number is divisible by two twice. So this is only a successful path if the number is divisible by four.</li>
<li>The path of halve-double only works if the number is even. So this is only a successful path in that case.</li>
<li>The path of double-halve will work in all cases! It is a success always.</li>
<li>The path of double-double will also work in all cases...it'll never fail for our sojourning number!</li>
</ol>
<p>So...halving-or-doubling twice has two possible successful paths for an odd number, three successful paths for a number divisible by two but not four, and four successful paths for a number divisible by four.</p>
<p>Let's try it out:</p>
<p>~~~haskell ghci&gt; halveOrDouble 5 &gt;&gt;= halveOrDouble [ 5, 20] ghci&gt; halveOrDouble 6 &gt;&gt;= halveOrDouble [ 6, 6, 24] ghci&gt; halveOrDouble 8 &gt;&gt;= halveOrDouble [ 2, 8, 8, 32] ~~~</p>
<p>The first list represents the results of all of the possible successful paths 5 could have taken to &quot;traverse&quot; the dreaded <code>halveOrDouble</code> landscape twice --- double-halve, or double-double. The second, 6 could have emerged successful with halve-double, double-halve, or double-double. For 8, all paths are successful, incidentally. He better check his privilege.</p>
<h3>Do notation</h3>
<p>Let's look at the same thing in do notation form to offer some possible insight:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/HalveOrDouble.hs#L24-L27 halveOrDoubleTwice :: Int -&gt; [Int] halveOrDoubleTwice n = do x &lt;- halveOrDouble n halveOrDouble x ~~~</p>
<p>Do notation describes <strong>a single path of a value</strong>. This is slightly confusing at first. But look at it --- it has the <em>exact same form</em> as a Maybe monad do block.</p>
<p>This thing describes, in general terms, the path of a <strong>single value</strong>. <code>x</code> is <strong>not</strong> a list --- it represents a single value, in the middle of its treacherous journey.</p>
<p>Here is an illustration, tracing out &quot;individual paths&quot;:</p>
<p>~~~haskell halveOrDoubleTwice :: Int -&gt; [Int] halveOrDoubleTwice n = do -- halveOrDoubleTwice 6 x &lt;- halveOrDouble n -- x &lt;- Just 3 Just 12 halveOrDouble x -- Nothing Just 6 Just 6 Just 24 ~~~</p>
<p>where you take the left path if you want to halve, and the right path if you want to double.</p>
<p>Remember, just like in the Maybe monad, the <code>x</code> represents the value &quot;inside&quot; the object --- <code>x</code> represents a 3 <strong>or</strong> a 12 (but not &quot;both&quot;), depending on what path you are taking/are &quot;in&quot;. That's why we can call <code>halveOrDouble x</code>: <code>halveOrDouble</code> only takes <code>Int</code>s and <code>x</code> is <em>one</em> <code>Int</code> along the path.</p>
<h3>A winding journey</h3>
<p>Note that once you bind a value to a variable (like <code>x</code>), then that is the value for <code>x</code> for the entire rest of the journey. In fact, let's see it in action:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/HalveOrDouble.hs#L29-L29 hod2PlusOne :: Int -&gt; [Int] hod2PlusOne n = do -- hod2PlusOne 6 x &lt;- halveOrDouble n -- x &lt;- Just 3 Just 12 halveOrDouble x -- Nothing Just 6 Just 6 Just 24 return $ x + 1 -- (skip) Just 4 Just 13 Just 13 ~~~</p>
<p>~~~haskell ghci&gt; hod2PlusOne 6 [ 4,13,13] ~~~</p>
<p>Okay! This is getting interesting now. What's going on? Well, there are four possible &quot;paths&quot;.</p>
<ol>
<li>In the half-half path, <code>x</code> (the result of the first halving) is 3. However, the half-half path is a failure --- 6 cannot be halved twice. Therefore, even though <code>x</code> is three, the path has already failed before we get to the <code>return (x + 1)</code>. Just like in the case with Maybe, once something fails during the process of the journey, the entire journey is a failure.</li>
<li>In the half-double path, <code>x</code> is also 3. However, this journey doesn't fail. It survives to the end. After the doubling, the value of the journey at that point is &quot;Just 6&quot;. Afterwards, it &quot;auto-succeeds&quot; and replaces the current value with the value of <code>x</code> on that path (3) plus 1 --- 4. This is just like how in the Maybe monad, we return a new value after the guard.</li>
<li>In the double-halve path, <code>x</code> (the result of the first operation, a double) is 12. The second operation makes the value in the journey a 6; At the end of it all, we succeed with whatever the value of <code>x</code> is on that specific journey (12) is, plus one. 13.</li>
<li>Same story here, but for double-double; <code>x</code> is 12. At the end of it all, the journey never fails, so it succeeds with <code>x + 1</code>, or 13.</li>
</ol>
<h4>Trying out every path</h4>
<p>If this doesn't satisfy you, here is an example of four Maybe do blocks where we &quot;flesh out&quot; each possible path, with the value of the block at each line in comments:</p>
<p>~~~haskell double :: Int -&gt; Maybe Int double n = Just n</p>
<p>halveHalvePlusOne :: Int -&gt; Maybe Int halveHalvePlusOne n = do -- n = 6 x &lt;- halve n -- Just 3 (x = 3) halve x -- Nothing return $ x + 1 -- (skip)</p>
<p>halveDoublePlusOne :: Int -&gt; Maybe Int halveDoublePlusOne = do -- n = 6 x &lt;- halve n -- Just 3 (x = 3) double x -- Just 6 return $ x + 1 -- Just 4</p>
<p>doubleHalvePlusOne :: Int -&gt; Maybe Int doubleHalvePlusOne = do -- n = 6 x &lt;- double n -- Just 12 (x = 12) halve x -- Just 6 return $ x + 1 -- Just 13</p>
<p>doubleDoublePlusOne :: Int -&gt; Maybe Int doubleDoublePlusOne = do -- n = 6 x &lt;- double n -- Just 12 (x = 12) double x -- Just 6 return $ x + 1 -- Just 13 ~~~</p>
<h4>A graphical look</h4>
<p>This tree might also be a nice illustration, showing what happens at each stage of the journey.</p>
<p><img src="/img/entries/monad-plus/halvedouble.png" title="hod2PlusOne 6" alt="hod2PlusOne 6, all journeys illustrated" /></p>
<p>Every complete &quot;journey&quot; is a complete path from top to bottom. You can see that the left-left journey (the half-halve journey) fails. The left-right journey (the halve-double journey) passes, and at the end is given the value of <code>x + 1</code> for the <code>x</code> in that particular journey. The other journeys work the same way!</p>
<h2>Solving real-ish problems</h2>
<p>That wasn't too bad, was it? We're actually just about ready to start implementing our solution to the Wolf/Goat/Cabbage puzzle!</p>
<p>Before we end this post let's build some more familiarity with the List monad and try out a very common practical example.</p>
<p>&lt;!-- That wasn't too bad! We're <em>almost</em> ready to begin implementing our solution --&gt; &lt;!-- to the Wolf/Goat/Cabbage puzzle. --&gt;</p>
<p>&lt;!-- Let's try one &quot;real&quot;-ish problem to build some more --&gt;</p>
<p>&lt;!-- But we're going to go through a couple more examples of branching journeys --&gt; &lt;!-- first --- both as a way to build more familiarity with the &quot;branching journey --&gt; &lt;!-- monad&quot; (list), and also as a nice conclusion to this post. --&gt;</p>
<p>&lt;!-- ### Testing multiple paths --&gt;</p>
<p>&lt;!-- Here's a fun one. --&gt;</p>
<p>&lt;!-- &quot;What operations on a number will make it a multiple of three?&quot; --&gt;</p>
<p>&lt;!-- ~~~haskell --&gt; &lt;!-- isMultThree :: Int -&gt; Bool -- 1 --&gt; &lt;!-- isMultThree a = a <code>mod</code> 3 == 0 --&gt;</p>
<p>&lt;!-- testNumber :: Int -&gt; [String] --&gt; &lt;!-- testNumber n = do --&gt; &lt;!-- (f, fName) &lt;- [ ((<em>2) , &quot;times two&quot;) -- 2 --&gt; &lt;!-- , ((</em>3) , &quot;times three&quot;) --&gt; &lt;!-- , ((+2) , &quot;plus two&quot;) --&gt; &lt;!-- , ((+3) , &quot;plus three&quot;) --&gt; &lt;!-- , ((^2) , &quot;square&quot;) --&gt; &lt;!-- , ((+1).(^2) , &quot;square plus 1&quot;) --&gt; &lt;!-- , ((+1).(^3) , &quot;cube plus 1&quot;) --&gt; &lt;!-- , (id , &quot;stay the same&quot;) --&gt; &lt;!-- ] --&gt; &lt;!-- let z = f n -- 3 --&gt;</p>
<p>&lt;!-- guard $ isMultThree z -- 4 --&gt; &lt;!-- return fName -- 5 --&gt; &lt;!-- ~~~ --&gt;</p>
<p>&lt;!-- ~~~haskell --&gt; &lt;!-- ghci&gt; testNumber 4 --&gt; &lt;!-- [&quot;times three&quot;, &quot;plus two&quot;] --&gt; &lt;!-- ghci&gt; testNumber 5 --&gt; &lt;!-- [&quot;times three&quot;, &quot;cube plus 1&quot;] --&gt; &lt;!-- ghci&gt; testNumber 6 --&gt; &lt;!-- [&quot;times two&quot;, &quot;times three&quot;, &quot;plus three&quot;, &quot;square&quot;, &quot;stay the same&quot;] --&gt; &lt;!-- ghci&gt; testNumber 7 --&gt; &lt;!-- [&quot;times three&quot;, &quot;plus two&quot;] --&gt; &lt;!-- ghci&gt; testNumber 8 --&gt; &lt;!-- [&quot;times three&quot;, &quot;cube plus 1&quot;] --&gt; &lt;!-- ~~~ --&gt;</p>
<p>&lt;!-- [Play with it here!][testNumber] --&gt;</p>
<p>&lt;!-- [testNumber]: https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/TestNumber.hs --&gt;</p>
<p>&lt;!-- Let's go over this step-by-step: --&gt;</p>
<p>&lt;!-- 1. First of all, define the utility function <code>isMultThree a</code>, which is true --&gt; &lt;!-- when <code>a</code> is a multiple of three and false when it isn't. --&gt; &lt;!-- 2. The journey diverges immediately. <code>f</code> and <code>fName</code> is now a value that --&gt; &lt;!-- depends on the path we take. If we take the first path, <code>f = (*2)</code> (the --&gt; &lt;!-- doubling function) and <code>fName = &quot;times two&quot;</code>. On the second path, <code>f = --&gt; &lt;!--     (*3)</code> (the tripling function) and <code>fName = &quot;times three&quot;</code>, etc. --&gt; &lt;!-- 3. We alias <code>z</code> to be the function we chose applied to <code>x</code>. If we had chosen --&gt; &lt;!-- the path <code>f = (*2)</code>, <code>z</code> would be <code>(*2) x</code>, which is <code>x*2</code>. This is --&gt; &lt;!-- mainly for readability. --&gt; &lt;!-- 4. We check if <code>z</code> is a multiple of three. If it isn't, the journey sadly --&gt; &lt;!-- ends here. For example, if we called the function with <code>n = 4</code>, and we --&gt; &lt;!-- had chosen <code>f = (^2)</code> (the square function), this journey (involving the --&gt; &lt;!-- choice of <code>(^2)</code>) would meet its failure here...but the journey with the --&gt; &lt;!-- choice <code>f = (+2)</code> would not! --&gt; &lt;!-- 5. At the end of the weary journey, we return the name of the function we --&gt; &lt;!-- chose. This step is never reached for failed journeys. --&gt;</p>
<p>&lt;!-- Here is another diagram, similar to the last. --&gt;</p>
<p>&lt;!-- <img src="/img/entries/monad-plus/testnumber.png" title="testNumber 5" alt="testNumber 5, all journeys illustrated" /> --&gt;</p>
<h3>Finding the right combinations</h3>
<p>Here is probably the most common of all examples involving the list monad: finding Pythagorean triples.</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/TriplesUnder.hs#L12-L18 triplesUnder :: Int -&gt; [Int] triplesUnder n = do a &lt;- [1..n] b &lt;- [a..n] c &lt;- [b..n] guard $ a^2 + b^2 == c^2 return (a,b,c) ~~~</p>
<p>(<a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/TriplesUnder.hs">Download it and try it out yourself!</a>)</p>
<ol>
<li>Our journey begins with picking a number between 1 and <code>n</code> and setting it to <code>a</code>.</li>
<li>Next, we pick a number between <code>a</code> and <code>n</code> and set it to <code>b</code>. We start from <code>a</code> because if we don't, we are probably going to be testing the same tuple twice.</li>
<li>Next, we pick a number between <code>b</code> and <code>n</code>. This is our hypotenuse, and of course all hypontenii are larger than either side.</li>
<li>Now, we mercilessly and ruthlessly end all journeys who were unfortunate enough to pick a non-Pythagorean combination --- combinations where <code>a^2 + b^2</code> is not <code>c^2</code></li>
<li>For those successful journeys, we succeed with a tuple containing our victorious triple <code>(a,b,c)</code>.</li>
</ol>
<p>Let's try &quot;following&quot; this path with some arbitrary choices, looking at arbitrary journeys for <code>n = 10</code>:</p>
<ul>
<li>We pick <code>a</code> as 2, <code>b</code> as 3, and <code>c</code> as 9. All is good until we get to the guard. <code>a^2 + b^2</code> is 10, which is not <code>c^2</code> (81), unfortunately. This <code>(2,3,10)</code> journey ends here.</li>
<li>We pick <code>a</code> as 3, <code>b</code> as 4, and <code>c</code> as 5. On the guard, we succeed: <code>a^2 + b^2</code> is 25, which indeed is <code>c^2</code>. Our journey passes the guard, and then succeeds with a value of <code>(3,4,5)</code>. This is indeed counted among the successful paths --- among the victorious!</li>
</ul>
<p>Paths like <code>a = 5</code> and <code>b = 3</code> do not even happen. This is because if we pick <code>a = 5</code>, then in that particular journey, <code>b</code> can only be chosen between <code>5</code> and <code>n</code> inclusive.</p>
<p>Remember, the final result is the accumulation of <strong>all such successful journeys</strong>. A little bit of combinatorics will show that there are $\frac{1}{6} \times \frac{(n+2)!}{(n-1)!}$ possible journeys to attempt. Only the ones that do not fail (at the guard) will make it to the end. Remember how MonadPlus works --- one failure along the journey means that the <em>entire journey</em> is a failure.</p>
<p>Let's see what we get when we try it at the prompt:</p>
<p>~~~haskell ghci&gt; triplesUnder 10 [ ( 3, 4, 5),( 6, 8,10) ] ghci&gt; triplesUnder 25 [ ( 3, 4, 5),( 5,12,13),( 6, 8,10),( 7,24,25) ,( 8,15,17),( 9,12,15),(12,16,20),(15,20,25) ] ~~~</p>
<p>Perfect! You can probably quickly verify that all of these solutions are indeed Pythagorean triples. Out of the 220 journeys undertaken by <code>triplesUnder 10</code>, only two of them survived to the end to be successful. Out of the 2925 journeys in <code>triplesUnder 25</code>, only eight of them made it to the end. The rest &quot;died&quot;/failed, and as a result we do not even observe their remains. It is a cruel and unforgiving world.</p>
<p>While the full diagram of <code>triplesUnder 5</code> has 35 branches, here is a diagram for those branches with $a &gt; 2$, which has 10:</p>
<p><img src="/img/entries/monad-plus/triplesunder.png" title="triplesUnder 5" alt="triplesUnder 5, all journeys (where a &gt; 2) illustrated" /></p>
<h2>Almost There!</h2>
<p>Let's do a quick review:</p>
<ul>
<li>You can really treat List exactly as if it were Maybe by using the general MonadPlus terms <code>mzero</code> and <code>return</code>. If you do this, <code>Nothing</code> is equivalent to <code>[]</code>, and <code>Just x</code> is equivalent to <code>[x]</code>. Trippy!</li>
<li>However, whereas Maybe is a &quot;deterministic&quot; success, for a list, a list of successes represents the end results of <em>possible paths</em> to success. Chaining two &quot;path splits&quot; results in the item having to traverse both splits one after another.</li>
<li>If any of these paths meet a failure at some point in their journey, the entire path is a failure and doesn't show up in the list of successes. <em>This</em> is the &quot;MonadPlus&quot;ness of it all.</li>
<li>When you use a do block (or reason about paths), it helps to think of each do block as representing one specific path in a Maybe monad, with arbitrary choices. Your <code>&lt;-</code> binds all represent <em>one specific element</em>, <em>just</em> like for Maybe.</li>
</ul>
<p>The last point is particularly important and is pretty pivotal in understanding what is coming up next. Remember that all Maybe blocks and List blocks really essentially look <em>exactly the same</em>. This keeping-track-of-separate-paths thing is all handled behind-the scenes.</p>
<p>In fact you should be able to look at code like:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/TriplesUnder.hs#L12-L18 triplesUnder :: Int -&gt; [Int] triplesUnder n = do a &lt;- [1..n] b &lt;- [a..n] c &lt;- [b..n] guard $ a^2 + b^2 == c^2 return (a,b,c) ~~~</p>
<p>and see that it is structurally identical to</p>
<p>~~~haskell triplesUnder' :: Int -&gt; Maybe Int triplesUnder' n = do a &lt;- Just 3 b &lt;- Just 5 c &lt;- Just 8 guard $ a^2 + b^2 == c^2 return (a,b,c) ~~~</p>
<p>for any arbitrary choice of <code>a</code>, <code>b</code>, and <code>c</code>, except instead of <code>Just 3</code> (or <code>[3]</code>), you have <code>[2,3,4]</code>, etc.</p>
<p>In fact recall that this block:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L40-L43 genericHalve :: MonadPlus m =&gt; Int -&gt; m Int genericHalve n = do guard $ even n return $ n <code>div</code> 2 ~~~</p>
<p>is general enough that it works for both.</p>
<p>Hopefully this all serves to show that <strong>in do blocks, Lists and Maybes are structurally identical</strong>. You reason with them the exact same way you do with Maybe's. In something like <code>x &lt;- Just 5</code>, <code>x</code> represents a <strong>single value</strong>, the 5. In something like <code>x &lt;- [1,2,3]</code>, <code>x</code> <em>also</em> represents a single value --- the 1, the 2, or the 3, depending on which path you are currently on. Then later in the block, you can refer to <code>x</code>, and <code>x</code> refers to <em>that</em> one specific <code>x</code> for that path.</p>
<h3>Until next time</h3>
<p>So I feel like we are at all we need to know to really use the list monad to solve a large class of logic problems (because who needs Prolog, anyway?).</p>
<p>Between now and next time, think about how you would approach a logic problem like the Wolf/Goat/Cabbage problem with the concepts of MonadPlus? What would <code>mzero</code>/fail be useful for? What would the idea of a success be useful for, and what would the idea of &quot;multiple paths to success&quot; in a journey even mean? What is the journey?</p>
<p>Until next!</p></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;MonadPlus: Success/Failure Monads&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+monadplus-success-failure-monads.html" class="tag-a-series" title="Short series on the abstractions and uses of the MonadPlus typeclass --- objects
whose monad instance represent success/failure."> series history</a>.</div></li><li><div>This entry is a part of a series called <b>&quot;Practical Monads&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-monads.html" class="tag-a-series" title="Ongoing series exploring interesting objects and their curious monad instances."> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/monads.html" class="tag-a-tag">#monads</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+monadplus-success-failure-monads.html" class="tag-a-series">+MonadPlus: Success/Failure Monads</a></li><li><a href="https://blog.jle.im/entries/series/+practical-monads.html" class="tag-a-series">+Practical Monads</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.html">Practical Fun with Monads --- Introducing: MonadPlus!</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/wolf-goat-cabbage-the-list-monadplus-logic-problems.html">Wolf, Goat, Cabbage: The List MonadPlus &amp; Logic Problems</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.html';
    this.page.identifier = 'monad-plus-2';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>