<!DOCTYPE HTML>
<html><head><title>Lenses embody Products, Prisms embody Sums · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="I’ve written about a variety of topics on this blog, but one thing I haven’t touched in too much detail is the topic of lenses and optics. A big part of this is because there are already so many great resources on lenses, like the famous (and my favorite) lenses over tea series. This post won’t be a “lens tutorial”, but rather a dive into a (what I believe is an) insightful perspective on lenses and prisms that I’ve heard repeated many times, but not yet all gathered together into a single place. In particular, I’m going to talk about the perspective of lenses and prisms as embodying the essences of products and sums (respectively), and how that observation can help you with a more “practical” understanding of lenses and prisms."><meta property="og:type" content="article"><meta property="og:title" content="Lenses embody Products, Prisms embody Sums"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/lenses-products-prisms-sums.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/lenses-products-prisms-sums.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Lenses embody Products, Prisms embody Sums</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/lenses-and-prisms.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/lenses-products-prisms-sums.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/lenses-products-prisms-sums.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>I’ve written about a variety of topics on this blog, but one thing I haven’t touched in too much detail is the topic of lenses and optics. A big part of this is because there are already so many great resources on lenses, like the famous (and my favorite) <a href="https://artyom.me/lens-over-tea-1">lenses over tea</a> series.</p>
<p>This post won’t be a “lens tutorial”, but rather a dive into a (what I believe is an) insightful perspective on lenses and prisms that I’ve heard repeated many times, but not yet all gathered together into a single place. In particular, I’m going to talk about the perspective of lenses and prisms as embodying the essences of products and sums (respectively), and how that observation can help you with a more “practical” understanding of lenses and prisms.</p>
<h2 id="products-and-sums">Products and Sums</h2>
<p>In Haskell, “products and sums” can roughly be said to correspond to “tuples and <code>Either</code>”. If I have two types <code>A</code> and <code>B</code>, <code>(A, B)</code> is their “product” type. It’s often called an “anonymous product”, because we can make one without having to give it a fancy name. It’s called a product type because <code>A</code> has <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> possible values and <code>B</code> has <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m" alt="m" title="m" /> possible values, then <code>(A, B)</code> has <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n%20%5Ctimes%20m" alt="n \times m" title="n \times m" /> possible values<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. And, <code>Either A B</code> is their (anonymous) “sum” type. It’s called a sum type because <code>Either A B</code> has <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n%20%2B%20m" alt="n + m" title="n + m" /> possible values. I won’t go much deeper into this, but there are <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">many useful tutorials already online</a> on this topic!</p>
<h2 id="lets-get-productive">Let’s Get Productive!</h2>
<p>It’s easy to recognize <code>(Int, Double)</code> as a product between <code>Int</code> and <code>Bool</code>. However, did you know that some types are secretly product types in disguise?</p>
<p>For example, here’s a classic example of a lensable data type</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">P</span> {<span class="ot"> _pName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                ,<span class="ot"> _pAge  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">                }</a></code></pre></div>
<p><code>Person</code> is an algebraic data type — so-called because it is actually a <em>product</em> between a <code>String</code> and <code>Int</code>. <code>Person</code> is <em>isomorphic</em> to <code>(String, Int)</code>. I will be writing this as <code>Person &lt;~&gt; (String, Int)</code>.</p>
<p>By <em>isomorphic</em>, I mean that there are functions <code>split :: Person -&gt; (String, Int)</code> and <code>unsplit :: (String, Int) -&gt; Person</code> where <code>unsplit . split = id</code> and <code>split . unsplit = id</code>. You can think of this property as stating formally that you should be able to go from one type to the other without “losing any information”.</p>
<p>In our case, we have:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">split ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">split (<span class="dt">P</span> n a) <span class="fu">=</span> (n, a)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">unsplit ::</span> (<span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">unsplit (n, a) <span class="fu">=</span> <span class="dt">P</span> n a</a></code></pre></div>
<p>And we can verify that <code>unsplit . split</code> is <code>id</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">unsplit <span class="fu">.</span><span class="ot"> split ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">unsplit <span class="fu">.</span> split</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="fu">=</span> \x          <span class="ot">-&gt;</span> unsplit (split x)        <span class="co">-- substitute definition of (.)</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">P</span> n a <span class="ot">-&gt;</span> unsplit (split (<span class="dt">P</span> n a))  <span class="co">-- expand patterns</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">P</span> n a <span class="ot">-&gt;</span> unsplit (n, a)           <span class="co">-- substitute definition of split</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">P</span> n a <span class="ot">-&gt;</span> <span class="dt">P</span> n a                    <span class="co">-- substitute definition of unsplit</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">=</span> \x      <span class="ot">-&gt;</span> x                            <span class="co">-- condense patterns</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="fu">=</span> id                                      <span class="co">-- definition of id</span></a></code></pre></div>
<p>And verification of <code>split . unsplit = id</code> is left as an exercise.</p>
<p>There are some other interesting products in Haskell, too. One such example is <code>NonEmpty a</code> being a product between <code>a</code> (the head/first item) and <code>[a]</code> (the tail/rest of the items). This means that <code>NonEmpty a</code> is isomorphic to <code>(a, [a])</code> — we have <code>NonEmpty a &lt;~&gt; (a, [a])</code>!</p>
<p>Another curious product is the fact that every type <code>a</code> is a product between <em>itself</em> and unit, <code>()</code>. That is, every type <code>a</code> is isomorphic to <code>(a, ())</code>. Freaky, right?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- a &lt;~&gt; (a, ())</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">split ::</span> a <span class="ot">-&gt;</span> (a, ())</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">split x <span class="fu">=</span> (x, ())</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">unsplit ::</span> (a, ()) <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">unsplit (x, _) <span class="fu">=</span> x</a></code></pre></div>
<p>One final interesting “product in disguise” is <code>Either a a</code>. “But wait,” you say. “That’s a sum…right??”</p>
<p>Well, yeah. But in addition, any <code>Either a a</code> is the product between <code>Bool</code> and <code>a</code>. That is, <code>Either a a</code> is isomorphic to <code>(Bool, a)</code>. The <code>Bool</code> tells you “left or right?” and the <code>a</code> is the contents!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- Either a a &lt;~&gt; (Bool, a)</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">split ::</span> <span class="dt">Either</span> a a <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, a)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">split (<span class="dt">Left</span>  x) <span class="fu">=</span> (<span class="dt">False</span>, x)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">split (<span class="dt">Right</span> x) <span class="fu">=</span> (<span class="dt">True</span> , x)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">unsplit ::</span> (<span class="dt">Bool</span>, a) <span class="ot">-&gt;</span> <span class="dt">Either</span> a a</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">unsplit (<span class="dt">False</span>, x) <span class="fu">=</span> <span class="dt">Left</span>  x</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">unsplit (<span class="dt">True</span> , x) <span class="fu">=</span> <span class="dt">Right</span> x</a></code></pre></div>
<p>Proving that <code>unsplit . split = id</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">unsplit <span class="fu">.</span><span class="ot"> split ::</span> <span class="dt">Either</span> a a <span class="ot">-&gt;</span> <span class="dt">Either</span> a a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">unsplit <span class="fu">.</span> split <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">=</span> \x            <span class="ot">-&gt;</span> unsplit (split x)          <span class="co">-- substitute definition of (.)</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="co">-- trying case 1</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Left</span>  y <span class="ot">-&gt;</span> unsplit (split (<span class="dt">Left</span>  y))  <span class="co">-- expand pattern for case 1</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Left</span>  y <span class="ot">-&gt;</span> unsplit (<span class="dt">False</span>, y)         <span class="co">-- substitute definition of split</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Left</span>  y <span class="ot">-&gt;</span> <span class="dt">Left</span>  y                    <span class="co">-- substitute definition of unsplit</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="fu">=</span> \x            <span class="ot">-&gt;</span> x                          <span class="co">-- condense pattern for case 1</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="fu">=</span> id                                          <span class="co">-- definition of id</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">      <span class="co">-- trying case 2</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Right</span> y <span class="ot">-&gt;</span> unsplit (split (<span class="dt">Right</span> y))  <span class="co">-- expand pattern for case 2</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Right</span> y <span class="ot">-&gt;</span> unsplit (<span class="dt">True</span> , y)         <span class="co">-- substitute definition of split</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Right</span> y <span class="ot">-&gt;</span> <span class="dt">Right</span> y                    <span class="co">-- substitute definition of unsplit</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    <span class="fu">=</span> \x            <span class="ot">-&gt;</span> x                          <span class="co">-- condense pattern for case 2</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    <span class="fu">=</span> id                                          <span class="co">-- definition of id</span></a></code></pre></div>
<p>And <code>split . unsplit = id</code> is again left as an exercise.</p>
<p>(<code>\case</code> here is from the <em>-XLambdaCase</em> extension)</p>
<h3 id="lenses">Lenses</h3>
<p>So, how do lenses come into the picture?</p>
<p>Let’s review a bit. A <code>Lens' s a</code> is a way to “access” an <code>a</code> “inside” an <code>s</code>, respecting some laws.</p>
<p>A <code>Lens' s a</code> is a data type with the following API:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">view ::</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a)                <span class="co">-- get the &#39;a&#39; from an &#39;s&#39;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">set  ::</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s)           <span class="co">-- set the &#39;a&#39; inside an &#39;s&#39;</span></a></code></pre></div>
<p>respecting <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial#the-lens-laws-">some laws</a> — get-put, put-get, and put-put.</p>
<p>Abstract mathematical laws are great and all, but I’m going to tell you a secret that will render those laws obsolete.</p>
<p>At first, you might naively implement lenses like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Lens&#39;</span> s a <span class="fu">=</span> <span class="dt">Lens&#39;</span> {<span class="ot"> view ::</span> s <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">                       ,<span class="ot"> set  ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">                       }</a></code></pre></div>
<p>But this is bad bad bad. That’s because you can use this to represent lenses that “break the laws”. This representation is, to use the technical term, “too big”. It allows more more values than are actual lenses.</p>
<p>So, here’s the secret: A <code>Lens' s a</code> means that <em><code>s</code> is a product between <code>a</code> and some type <code>q</code></em>.</p>
<p>That means that if it is possible to represent <code>s</code> as some <code>(a, q)</code> (that is, <code>s &lt;~&gt; (a, q)</code>), <em>then you have two lenses</em>! Lenses are nothing more than <strong>descriptions of products</strong>!</p>
<p>In other words, a <code>Lens' s a</code> is nothing more than a witness for an <code>exists q. s &lt;~&gt; (a, q)</code> isomorphism.</p>
<p>With that in mind, let’s re-visit a saner definition of lenses based on the idea that lenses embody descriptions of products:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Lens&#39;</span> s a <span class="fu">=</span> forall q<span class="fu">.</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">                 <span class="dt">Lens&#39;</span> {<span class="ot"> split   ::</span> s <span class="ot">-&gt;</span> (a, q)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                       ,<span class="ot"> unsplit ::</span> (a, q) <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">                       }    <span class="co">-- ^ s &lt;~&gt; (a, q)</span></a></code></pre></div>
<p>Now, if <code>split</code> and <code>join</code> form an isomorphism, <em>this can only represent valid lenses</em>!<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>We can implement our necessary lens API as so:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">view ::</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">view <span class="dt">Lens&#39;</span>{<span class="fu">..</span>} <span class="fu">=</span> fst <span class="fu">.</span> split</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">set ::</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">set <span class="dt">Lens&#39;</span>{<span class="fu">..</span>} newVal x <span class="fu">=</span> unsplit (newVal, q)      <span class="co">-- &quot;replace&quot; the `a`</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    (_, q) <span class="fu">=</span> split x</a></code></pre></div>
<p>(Using the <em>-XRecordWildcards</em> extension, where <code>Lens'{..}</code> binds <code>split</code> and <code>unsplit</code> to the fields of the lens)</p>
<p>The implementation of the helper function <code>over</code> (which modifies the <code>a</code> with a function) is also particularly elegant:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">over ::</span> <span class="dt">Lens&#39;</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">over <span class="dt">Lens&#39;</span>{<span class="fu">..</span>} f <span class="fu">=</span> unsplit <span class="fu">.</span> first f <span class="fu">.</span> split</a></code></pre></div>
<p>The surprising result of this perspective is that <strong>every product yields lenses</strong> (one for every item in the product), and <strong>every lens witnesses one side of a product</strong>.</p>
<h3 id="insights-gleamed">Insights Gleamed</h3>
<p>Let’s take a look at our first product we talked about:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">P</span> {<span class="ot"> _pName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">                ,<span class="ot"> _pAge  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">                }</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">split ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">split (<span class="dt">P</span> n a) <span class="fu">=</span> (n, a)</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">unsplit ::</span> (<span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">unsplit (n, a) <span class="fu">=</span> <span class="dt">P</span> n a</a></code></pre></div>
<p>Because <code>Person</code> is a product between <code>String</code> and <code>Int</code>, we get <em>two lenses</em>: a <code>Lens' Person String</code> and <code>Lens' Person Int</code>. <em>Every product</em> gives us a lens for every item in the product.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">pName ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Person</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">pName <span class="fu">=</span> <span class="dt">Lens&#39;</span> { split   <span class="fu">=</span> \(<span class="dt">P</span> n a) <span class="ot">-&gt;</span> (n, a)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">              , unsplit <span class="fu">=</span> \(n, a)  <span class="ot">-&gt;</span> <span class="dt">P</span> n a</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">              }</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="ot">pAge ::</span> <span class="dt">Lens&#39;</span> <span class="dt">Person</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">pAge <span class="fu">=</span> <span class="dt">Lens&#39;</span> { split   <span class="fu">=</span> \(<span class="dt">P</span> n a) <span class="ot">-&gt;</span> (a, n)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">             , unsplit <span class="fu">=</span> \(a, n)  <span class="ot">-&gt;</span> <span class="dt">P</span> n a</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">             }</a></code></pre></div>
<p>These are actually the typical lenses associated with record! You get exactly these lenses if you use <code>makeLenses</code> from the <em>lens</em> package!</p>
<p>The inverse is true too. <strong>Every lens witnesses a product</strong>. The fact that we have a lawful <code>pName :: Lens' Person String</code> means that a <code>Person</code> <em>must</em> be a product between <code>String</code> and some other (hidden) type.</p>
<p>It can be insightful to look at products that we know and see what lenses those correspond to.</p>
<p>For example, our <code>NonEmpty a &lt;~&gt; (a, [a])</code> product tells us that <code>NonEmpty a</code> has at least two lenses: a “head” lens <code>Lens' (NonEmpty a) a</code> and a “tail” lens <code>Lens' (NonEmpty a) [a]</code>.</p>
<p>Our <code>a &lt;~&gt; (a, ())</code> product gives some interesting insight. This tells us that we always have an “identity” lens <code>Lens' a a</code>, and a “unit” lens <code>Lens' a ()</code>, for any <code>a</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">identity ::</span> <span class="dt">Lens&#39;</span> a a</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">identity <span class="fu">=</span> <span class="dt">Lens&#39;</span> { split   <span class="fu">=</span> \x      <span class="ot">-&gt;</span> (x, ())</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">                 , unsplit <span class="fu">=</span> \(x, _) <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">                 }</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">unital ::</span> <span class="dt">Lens&#39;</span> a ()</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">unital <span class="fu">=</span> <span class="dt">Lens&#39;</span> { split   <span class="fu">=</span> \x       <span class="ot">-&gt;</span> ((), x)</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">               , unsplit <span class="fu">=</span> \((), x) <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">               }</a></code></pre></div>
<p>In the language of lens, <code>identity :: Lens' a a</code> tells us that all <code>a</code>s have an <code>a</code> “inside” them. However, in the language of products, this just tells us that <code>a</code> can be represented as <code>(a, ())</code>. In the language of lens, <code>unital :: Lens' a ()</code> tells us that all <code>a</code>s have a <code>()</code> “inside” them. In the language of products, this just tells us that <code>a &lt;~&gt; (a, ())</code>.</p>
<p>What insight does our <code>Either a a &lt;~&gt; (Bool, a)</code> product perspective give us? Well, let’s write out their types and see what it might suggest:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">mysteryLens1 ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">Either</span> a a) <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">mysteryLens2 ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">Either</span> a a) a</a></code></pre></div>
<p>Looking at <code>mysteryLens1 :: Lens' (Either a a) Bool</code>, we are saying that every <code>Either a a</code> has some <code>Bool</code> “inside” it. From our knowledge of our product, we know that this <code>Bool</code> is really a <em>flag</em> for left-ness or right-ness. Getting the <code>Bool</code> is finding out if we’re in <code>Left</code> or <code>Right</code>, and flipping the <code>Bool</code> “inside” is really just swapping from <code>Left</code> to <code>Right</code>.</p>
<p>Looking at <code>mysteryLens2 :: Lens' (Either a a) a</code>, we are saying that every <code>Either a a</code> has some <code>a</code> “inside” it. From what we know about the underlying product, the <code>a</code> is just the “contained value”, <em>ignoring</em> leftness or rightness. Getting the <code>a</code> is getting the contained value and losing leftness/rightness, and re-setting the <code>a</code> inside is modifying the contained value but preserving leftness/rightness.</p>
<p>So that’s really the essence of what a <code>Lens'</code> is. A <code>Lens' s a</code> is the embodiment of the fact that <code>s</code> can be represented as a product between <code>a</code> and something else — that <code>s &lt;~&gt; (a, q)</code>. All of the lens laws just boil down to this. <strong>Lenses embody products</strong>.</p>
<h2 id="theres-sum-thing-about-this">There’s Sum-thing about This…</h2>
<p>It’s easy to recognize <code>Either Int Bool</code> as a sum between <code>Int</code> and <code>Bool</code>. However, did you know that some types are secretly sums in disguise?</p>
<p>For example, here’s a data type you might encounter out there in the real world:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Shape</span> <span class="fu">=</span> <span class="dt">Circle</span>  <span class="dt">Double</span>           <span class="co">-- radius</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">           <span class="fu">|</span> <span class="dt">RegPoly</span> <span class="dt">Natural</span> <span class="dt">Double</span>   <span class="co">-- number of sides, length of sides</span></a></code></pre></div>
<p><code>Circle 2.9</code> represents a circle with radius 2.9, and <code>RegPoly 8 4.6</code> represents a octagon (8-sided figure) whose sides all have length 4.6.</p>
<p><code>Shape</code> is an algebraic data type — so-called because it is actually a <em>sum</em> between <code>Double</code> and <code>(Natural, Double)</code> (a <code>Natural</code> is the non-negative <code>Integer</code> type). <code>Shape</code> is <em>isomorphic</em> to <code>Either Double (Natural, Double)</code>. To prove it, let’s witness <code>Shape &lt;~&gt; Either Double (Natural, Double)</code> using the functions <code>match</code> and <code>inject</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- Shape &lt;~&gt; Either Double (Natural, Double)</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">match ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Double</span> (<span class="dt">Natural</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">match (<span class="dt">Circle</span>  r  ) <span class="fu">=</span> <span class="dt">Left</span> r</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">match (<span class="dt">RegPoly</span> n s) <span class="fu">=</span> <span class="dt">Right</span> (n, s)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="ot">inject ::</span> <span class="dt">Either</span> <span class="dt">Double</span> (<span class="dt">Natural</span>, <span class="dt">Double</span>) <span class="ot">-&gt;</span> <span class="dt">Shape</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">inject (<span class="dt">Left</span>   r    ) <span class="fu">=</span> <span class="dt">Circle</span>  r</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">inject (<span class="dt">Right</span> (n, s)) <span class="fu">=</span> <span class="dt">RegPoly</span> n s</a></code></pre></div>
<p>Since <code>inject . match = id</code> and <code>match . inject = id</code>, this proves that <code>Shape</code> is a sum in disguise.</p>
<p>Another interesting “hidden sum” is the fact that <code>[a]</code> in Haskell is actually a sum between <code>()</code> and <code>(a, [a])</code>. That’s right — it’s a sum between <code>()</code> and…itself?</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- [a] &lt;~&gt; Either () (a, [a])</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">match ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Either</span> () (a, [a])</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">match []     <span class="fu">=</span> <span class="dt">Left</span>  ()</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">match (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Right</span> (x, xs)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6"></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">inject ::</span> <span class="dt">Either</span> () (a, [a]) <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">inject (<span class="dt">Left</span>   _     ) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">inject (<span class="dt">Right</span> (x, xs)) <span class="fu">=</span> x<span class="fu">:</span>xs</a></code></pre></div>
<p>If you don’t believe me, just verify that <code>inject . match = id</code> and <code>match . inject = id</code> :)</p>
<p>And, if we consider the “empty data type” <code>Void</code>, the type with no inhabitants:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Void</span>           <span class="co">-- no constructors, no valid inhabitants</span></a></code></pre></div>
<p>then we have a curious sum: every type <code>a</code> is a sum between <em>itself</em> and <code>Void</code>. In other words, <code>a</code> is isomorphic to <code>Either a Void</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- a &lt;~&gt; Either a Void</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">match ::</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> a <span class="dt">Void</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">match x <span class="fu">=</span> <span class="dt">Left</span> x</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="ot">inject ::</span> <span class="dt">Either</span> a <span class="dt">Void</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">inject (<span class="dt">Left</span>  x) <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">inject (<span class="dt">Right</span> v) <span class="fu">=</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">                    {}  <span class="co">-- empty case statement because we have</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">                        <span class="co">-- no constructors of &#39;v&#39; we need to</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">                        <span class="co">-- match on</span></a></code></pre></div>
<p>Again, if you don’t believe me, verify that <code>inject . match = id</code> and <code>match . inject = id</code>!</p>
<p>One last example – one of my favorite sums from math is the fact that the natural numbers are a sum between … themselves and themselves. <code>Natural &lt;~&gt; Either Natural Natural</code>. Sometimes you might hear this stated as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?2%20%5Cmathbb%7BN%7D%20%5Cequiv%20%5Cmathbb%7BN%7D" alt="2 \mathbb{N} \equiv \mathbb{N}" title="2 \mathbb{N} \equiv \mathbb{N}" /> (where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?2%20%5Cmathbb%7BN%7D" alt="2 \mathbb{N}" title="2 \mathbb{N}" /> can be thought of as a fancy way of writing <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BN%7D%20%2B%20%5Cmathbb%7BN%7D" alt="\mathbb{N} + \mathbb{N}" title="\mathbb{N} + \mathbb{N}" />). So, the sum of the naturals with themselves is…exactly the naturals?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co">-- Natural &lt;~&gt; Either Natural Natural</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">match ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Natural</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">match n <span class="fu">=</span> <span class="kw">case</span> n <span class="ot">`divMod`</span> <span class="dv">2</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    (q, <span class="dv">0</span>) <span class="ot">-&gt;</span> <span class="dt">Left</span>  q       <span class="co">-- even number</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    (q, <span class="dv">1</span>) <span class="ot">-&gt;</span> <span class="dt">Right</span> <span class="dv">1</span>       <span class="co">-- odd number</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="ot">inject ::</span> <span class="dt">Either</span> <span class="dt">Natural</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">inject (<span class="dt">Left</span>  q) <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> q</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">inject (<span class="dt">Right</span> q) <span class="fu">=</span> <span class="dv">2</span> <span class="fu">*</span> q <span class="fu">+</span> <span class="dv">1</span></a></code></pre></div>
<p>Go figure!</p>
<h3 id="through-the-looking-prism">Through the Looking-Prism</h3>
<p>Now let’s bring prisms into the picture. A <code>Prism' s a</code> also refers to some <code>a</code> “inside” an <code>s</code>, with the following API: <code>preview</code> and <code>review</code><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">preview ::</span> <span class="dt">Prism&#39;</span> s a <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)   <span class="co">-- get the &#39;a&#39; in the &#39;s&#39; if it exists</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">review  ::</span> <span class="dt">Prism&#39;</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s)         <span class="co">-- reconstruct the &#39;s&#39; from an &#39;a&#39;</span></a></code></pre></div>
<p>Naively you might implement a prism like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Prism&#39;</span> s a <span class="fu">=</span> <span class="dt">Prism&#39;</span> {<span class="ot"> preview ::</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">                         ,<span class="ot"> review  ::</span> a <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">                         }</a></code></pre></div>
<p>But, again, this implementation space is too big. There are way too many values of this type that aren’t <em>actual</em> “lawful” prisms. And the laws are kind of muddled here.</p>
<p>You might be able to guess where I’m going at this point. Whereas a <code>Lens' s a</code> is nothing more than a witness to the fact that <code>s</code> is a <em>product</em> <code>(a, q)</code> … a <code>Prism' s a</code> is nothing more than a witness to the fact that <code>s</code> is a <em>sum</em> <code>Either a q</code>. If it is possible to represent <code>s</code> as some <code>Either a q</code>…then you have two prisms! Prisms are nothing more than <strong>descriptions of products</strong>!</p>
<p>A <code>Prism' s a</code> is nothing more than a witness for an <code>exists q. s &lt;~&gt; Either a q</code> isomorphism.</p>
<p>Under this interpretation, we can write a nice representation of <code>Prism'</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Prism&#39;</span> s a <span class="fu">=</span> forall q<span class="fu">.</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">                  <span class="dt">Prism&#39;</span> {<span class="ot"> match  ::</span> s <span class="ot">-&gt;</span> <span class="dt">Either</span> a q</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">                         ,<span class="ot"> inject ::</span> <span class="dt">Either</span> a q <span class="ot">-&gt;</span> s</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">                         }</a></code></pre></div>
<p>Now, if <code>match</code> and <code>inject</code> form an isomorphism, <em>this can only represent valid prisms</em>!</p>
<p>We can now implement the prism API:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">preview ::</span> <span class="dt">Prism&#39;</span> s a <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">preview <span class="dt">Prism&#39;</span>{<span class="fu">..</span>} x <span class="fu">=</span> <span class="kw">case</span> match x <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">    <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    <span class="dt">Right</span> y <span class="ot">-&gt;</span> <span class="dt">Just</span> y</a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6"><span class="ot">review  ::</span> <span class="dt">Prism&#39;</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">review <span class="dt">Prism&#39;</span>{<span class="fu">..</span>} <span class="fu">=</span> inject <span class="fu">.</span> <span class="dt">Left</span></a></code></pre></div>
<p>Like for lenses, prisms also admit a particularly elegant formulation for <code>over</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="ot">over ::</span> <span class="dt">Lens&#39;</span> s a  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">over <span class="dt">Lens&#39;</span>{<span class="fu">..</span>}  <span class="fu">=</span> inject <span class="fu">.</span> first <span class="fu">.</span> match</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">over ::</span> <span class="dt">Prism&#39;</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">over <span class="dt">Prism&#39;</span>{<span class="fu">..</span>} <span class="fu">=</span> inject <span class="fu">.</span> first <span class="fu">.</span> match</a></code></pre></div>
<p>Neat, they’re actually exactly identical! Who would have thought? (For lenses we use the <code>(,)</code> instance for <code>Bifunctor</code> with <code>first</code>, and for prisms we use the <code>Either</code> instance.)</p>
<p>So, again, <strong>every sum yields prisms</strong>, and <strong>every prism witnesses one side of a sum</strong>.</p>
<h3 id="prism-tour">Prism Tour</h3>
<p>Let’s go back at our example prisms and see what sort of insight we can gain from this perspective.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Shape</span> <span class="fu">=</span> <span class="dt">Circle</span>  <span class="dt">Double</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">           <span class="fu">|</span> <span class="dt">RegPoly</span> <span class="dt">Natural</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">match ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Double</span> (<span class="dt">Natural</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">match (<span class="dt">Circle</span>  r  ) <span class="fu">=</span> <span class="dt">Left</span> r</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">match (<span class="dt">RegPoly</span> n s) <span class="fu">=</span> <span class="dt">Right</span> (n, s)</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"></a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="ot">inject ::</span> <span class="dt">Either</span> <span class="dt">Double</span> (<span class="dt">Natural</span>, <span class="dt">Double</span>) <span class="ot">-&gt;</span> <span class="dt">Shape</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">inject (<span class="dt">Left</span>   r    ) <span class="fu">=</span> <span class="dt">Circle</span>  r</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">inject (<span class="dt">Right</span> (n, s)) <span class="fu">=</span> <span class="dt">RegPoly</span> n s</a></code></pre></div>
<p>Because <code>Shape</code> is a sum between <code>Double</code> and <code>(Natural, Double)</code>, we get <em>two prisms</em>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">_Circle ::</span> <span class="dt">Prism&#39;</span> <span class="dt">Shape</span> <span class="dt">Natural</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">_Circle <span class="fu">=</span> <span class="dt">Prism&#39;</span> { match  <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Circle</span>  r    <span class="ot">-&gt;</span> <span class="dt">Left</span> r</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">                                  <span class="dt">RegPoly</span> n s  <span class="ot">-&gt;</span> <span class="dt">Right</span> (n, s)</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">                 , inject <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Left</span>   r     <span class="ot">-&gt;</span> <span class="dt">Circle</span> r</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">                                  <span class="dt">Right</span> (n, s) <span class="ot">-&gt;</span> <span class="dt">RegPoly</span> n s</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">                 }</a>
<a class="sourceLine" id="cb28-7" data-line-number="7"></a>
<a class="sourceLine" id="cb28-8" data-line-number="8"><span class="ot">_RegPoly ::</span> <span class="dt">Prism&#39;</span> <span class="dt">Shape</span> (<span class="dt">Natural</span>, <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">_RegPoly <span class="fu">=</span> <span class="dt">Prism&#39;</span> { match  <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Circle</span>  r    <span class="ot">-&gt;</span> <span class="dt">Right</span> r</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">                                   <span class="dt">RegPoly</span> n s  <span class="ot">-&gt;</span> <span class="dt">Left</span> (n, s)</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">                  , inject <span class="fu">=</span> \<span class="kw">case</span> <span class="dt">Left</span>  (n, s) <span class="ot">-&gt;</span> <span class="dt">RegPoly</span> n s</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">                                   <span class="dt">Right</span>  r     <span class="ot">-&gt;</span> <span class="dt">Circle</span> r</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">                  }</a></code></pre></div>
<p>And these are actually the typical prisms associated with an ADT. You actually get exactly these if you use <code>makePrisms</code> from the <em>lens</em> package.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>All of this is disregarding the notorious “bottom” value that inhabits every type.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>This type is technically also “too big” (you can write a value where <code>split</code> and <code>unsplit</code> do not form an isomorphism), but I think, to me, “<code>split</code> and <code>join</code> must form an isomorphism” is a much clearer and natural law than get-put/put-get/put-put.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>I didn’t invent these names :)<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/lenses-products-prisms-sums.html';
    this.page.identifier = 'lenses-and-prisms';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/mstksg">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>