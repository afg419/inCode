<?xml version="1.0" encoding="UTF-8"?><rss dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>in Code â€” Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description><item><title>Introducing "in Code"!</title><link>https://blog.jle.im/entry/introducing-in-code.html</link><description>&lt;p&gt;Throughout my time programming and developing, I've noticed that there are few legitimately useful sources of practical and beneficial knowledge on the subject on the internet. There are good books. There is &lt;a href="http://www.stackoverflow.com"&gt;Stack Overflow&lt;/a&gt;. And there are the blogs.&lt;/p&gt;
&lt;p&gt;I've probably learned more useful information from blogs than I have from nearly any other source --- from small things like how to fix that compile error on ffmpeg or teaching me my first steps in learning tools I now use every day like git. From blogs I've learned not just small things that help me here and there, but also the building blocks that I have to thank for allowing me to learn so much of what I know now.&lt;/p&gt;
&lt;p&gt;In addition to these, blogs are the theatre of many gifted essayists, who are always enthusiastic to share their insight from the deeper aspects of what programming actually means, and their roles in the construction of the world we live in today.&lt;/p&gt;
&lt;p&gt;Having worked on my fair share of projects, I've accumulated some meager, humble practical knowledge from the field over these short years. So this is my opportunity to finally give back. My hope is first to fill in all of those small holes in knowledge that happen to slip through and can sometimes only be found with the perfect google search. Second to share a bit of my discoveries along my journeys in development and any relevant insights from my studies that may be useful to others. Third, to share any mature open source projects I'm working on that may be of use to the world. And forth, to maybe shine some light on greater themes that I have noticed when looking back on things.&lt;/p&gt;
&lt;p&gt;It's also been said that blogs are a good way for someone to help themselves organize their thoughts and kind of put them all together. Maybe if I log my progress on projects as I go along, I can look back and refer to them later. And maybe --- just maybe --- they can be useful to other humans.&lt;/p&gt;
&lt;p&gt;So anyways, this is it. Welcome to &lt;strong&gt;in Code&lt;/strong&gt;!&lt;/p&gt;</description><author>Justin Le</author><category>Meta</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-in-code.html</guid><pubDate>Tue, 17 Sep 2013 17:51:13 UTC</pubDate><creator>Justin Le</creator><subject>Meta</subject><date>2013-09-17</date></item><item><title>Shake: Task Automation and Scripting in Haskell</title><link>https://blog.jle.im/entry/shake-task-automation-and-scripting-in-haskell.html</link><description>&lt;p&gt;As someone who comes from a background in ruby and &lt;em&gt;rake&lt;/em&gt;, I'm used to powerful task management systems with expressive dependency. &lt;em&gt;Make&lt;/em&gt; is a favorite tool of mine when I'm working on projects with people who don't use ruby, and when I'm working on ruby projects I never go far without starting a good Rakefile. The two tools provided a perfect DSL for setting up systems of tasks that had complicated file and task dependencies.&lt;/p&gt;
&lt;p&gt;As I was starting to learn Haskell and building larger-scale Haskell projects, I began to look for alternatives in Haskell. Was there a Haskell counterpart to Ruby's &lt;a href="http://rake.rubyforge.org/"&gt;&lt;em&gt;rake&lt;/em&gt;&lt;/a&gt;, Node's &lt;a href="https://github.com/mde/jake"&gt;&lt;em&gt;jake&lt;/em&gt;&lt;/a&gt;? (Not to mention the tools of slightly different philosophy &lt;a href="http://gruntjs.com/"&gt;&lt;em&gt;grunt&lt;/em&gt;&lt;/a&gt; and &lt;a href="http://ant.apache.org/"&gt;&lt;em&gt;ant&lt;/em&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;It turns out that by far the most established answer is a library known as &lt;a href="http://hackage.haskell.org/package/shake"&gt;&lt;em&gt;Shake&lt;/em&gt;&lt;/a&gt; (maintained by the prolific Neil Mitchell of &lt;a href="http://haskell.org/hoogle"&gt;&lt;em&gt;hoogle&lt;/em&gt;&lt;/a&gt; fame and much more). So far it's served me pretty well. Its documentation is written from the perspective of chiefly using it as a build tool (more &amp;quot;make&amp;quot; than &amp;quot;rake&amp;quot;), so if you're looking to use it as a task management system, you might have to do some digging. Hopefully this post can help you get started.&lt;/p&gt;
&lt;p&gt;I also go over the core concepts of a task management system, so I assume no knowledge of &lt;em&gt;make&lt;/em&gt;; this post therefore should also be a good introduction to starting with any sort of task management system.&lt;/p&gt;
&lt;h2&gt;Our Sample Project&lt;/h2&gt;
&lt;p&gt;Our sample project is going to be a report build system that builds reports written in markdown with &lt;a href="http://johnmacfarlane.net/pandoc/"&gt;pandoc&lt;/a&gt; into html, pdf, and doc formats. This is honestly one of my most common use cases for &lt;em&gt;make&lt;/em&gt;, so porting it all to &lt;em&gt;shake&lt;/em&gt; will be something useful for me.&lt;/p&gt;
&lt;p&gt;The final directory structure will look like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;img
&lt;ul&gt;
&lt;li&gt;img1.jpg&lt;/li&gt;
&lt;li&gt;img2.jpg&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;out
&lt;ul&gt;
&lt;li&gt;report.doc&lt;/li&gt;
&lt;li&gt;report.html&lt;/li&gt;
&lt;li&gt;report.pdf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;src
&lt;ul&gt;
&lt;li&gt;report.md&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;css
&lt;ul&gt;
&lt;li&gt;report.css&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shakefile&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;When we run &lt;code&gt;shake&lt;/code&gt;, we want to build &lt;code&gt;report.doc&lt;/code&gt; and &lt;code&gt;report.pdf&lt;/code&gt; if &lt;code&gt;report.md&lt;/code&gt; or any of the images have changed, and &lt;code&gt;report.html&lt;/code&gt; if &lt;code&gt;report.md&lt;/code&gt;, &lt;code&gt;report.css&lt;/code&gt;, or any of the images have changed.&lt;/p&gt;
&lt;p&gt;Furthermore, &lt;code&gt;img2.jpg&lt;/code&gt; actually comes from online, and requires us to re-download it every time we compile to make sure it is up to date.&lt;/p&gt;
&lt;h2&gt;Setup&lt;/h2&gt;
&lt;h3&gt;Installing Shake&lt;/h3&gt;
&lt;p&gt;Installing &lt;em&gt;shake&lt;/em&gt; is as simple as installing any other cabal package:&lt;/p&gt;
&lt;p&gt;~~~bash $ cabal update $ cabal install shake ~~~&lt;/p&gt;
&lt;p&gt;I'll will be using &lt;code&gt;shake-0.10.6&lt;/code&gt; for this post.&lt;/p&gt;
&lt;h3&gt;Setting up the Shakefile&lt;/h3&gt;
&lt;p&gt;We set up our Shakefile with a simple scaffold:&lt;/p&gt;
&lt;p&gt;~~~haskell -- Shakefile&lt;/p&gt;
&lt;p&gt;import Development.Shake&lt;/p&gt;
&lt;p&gt;opts = shakeOptions { shakeFiles = &amp;quot;.shake/&amp;quot; } -- 1&lt;/p&gt;
&lt;p&gt;(~&amp;gt;) = phony -- 2 -- (obsolete)&lt;/p&gt;
&lt;p&gt;main :: IO () main = shakeArgs opts $ do want []&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;clean&amp;quot; ~&amp;gt; removeFilesAfter &amp;quot;.shake&amp;quot; [&amp;quot;//*&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~~~&lt;/p&gt;
&lt;p&gt;On my machine I've set this up to be generated by a &lt;a href="https://gist.github.com/mstksg/6588764"&gt;bash script&lt;/a&gt; called &amp;quot;shakeup&amp;quot;, so I can start a project up on a Shakefile by simply typing &lt;code&gt;shakeup&lt;/code&gt; at the project root.&lt;/p&gt;
&lt;p&gt;Some notes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Store shake's metadata files to the folder &lt;code&gt;.shake/&lt;/code&gt;. This differs from the default behavior, where all files would be saved to the root directory with &lt;code&gt;.shake&lt;/code&gt; as a filename prefix.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I've aliased the operator &lt;code&gt;~&amp;gt;&lt;/code&gt; for &lt;code&gt;phony&lt;/code&gt; to allow for a more expressive infix notation --- more on this later. I've submitted a patch to the project and it should be included in the next cabal release.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: As of the 0.10.7 release of &lt;em&gt;Shake&lt;/em&gt;, this is no longer needed, as &lt;code&gt;~&amp;gt;&lt;/code&gt; is included in the library.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;What is a Rule?&lt;/h2&gt;
&lt;p&gt;If you haven't used &lt;em&gt;make&lt;/em&gt; before, it is important that you understand the key concepts before moving on.&lt;/p&gt;
&lt;p&gt;A task management system/build system is a system that works to ensure that all files in the project are &amp;quot;up to date&amp;quot;. In our case, our system will ensure that the files in the &lt;code&gt;out&lt;/code&gt; directory are up to date.&lt;/p&gt;
&lt;p&gt;In order to do this, files are given &amp;quot;rules&amp;quot;. Rules specify:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What other files/rules this file &amp;quot;depends&amp;quot; on&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instructions to execute to make this file up to date (or to create the file), if it is not already up to date or created.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A file or rule is out of date if any of its dependencies are out of date &lt;strong&gt;or&lt;/strong&gt; if the file it indicates is either not created or has been updated since the last time the task management system has run. When this happens, the guilty dependencies are updated using their own rules. Afterwards, the file's own instructions are executed.&lt;/p&gt;
&lt;p&gt;If a file has no rule, &amp;quot;out of date&amp;quot; simply means that it has been updated or changed since the last time the task management system has run, or it does not exist. If it has, then all files or rules that depend on it are also out of date.&lt;/p&gt;
&lt;p&gt;A good task management system is smart enough to keep track of what is up to date and what isn't. If multiple rules all have one dependency, that dependency might be checked and updated every single time. For example, all of our builds in this sample project require &lt;code&gt;img2.jpg&lt;/code&gt; to be downloaded afresh from online. A naive build system might re-download &lt;code&gt;img2.jpg&lt;/code&gt; for every single build, instead of once for all three.&lt;/p&gt;
&lt;h2&gt;File Rules&lt;/h2&gt;
&lt;p&gt;Let's set up &lt;code&gt;src/report.md&lt;/code&gt; with a simple markdown document on our new project:&lt;/p&gt;
&lt;p&gt;~~~markdown &amp;lt;!-- src/report.md --&amp;gt;&lt;/p&gt;
&lt;h1&gt;Report&lt;/h1&gt;
&lt;p&gt;This is a report. Render me!&lt;/p&gt;
&lt;p&gt;&lt;img src="img/img1.jpg" alt="first image" /&gt; &lt;img src="img/img2.jpg" alt="second image" /&gt; ~~~&lt;/p&gt;
&lt;p&gt;Our project tree should look like this at this point:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;img
&lt;ul&gt;
&lt;li&gt;img1.jpg&lt;/li&gt;
&lt;li&gt;img2.jpg&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;out&lt;/li&gt;
&lt;li&gt;src
&lt;ul&gt;
&lt;li&gt;report.md&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;template&lt;/li&gt;
&lt;li&gt;Shakefile&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's set up our first rule -- rendering &lt;code&gt;out/report.doc&lt;/code&gt; if &lt;code&gt;report.md&lt;/code&gt; has changed.&lt;/p&gt;
&lt;p&gt;~~~haskell &amp;quot;out/report.doc&amp;quot; *&amp;gt; \f -&amp;gt; do need [&amp;quot;src/report.md&amp;quot;,&amp;quot;img/img1.jpg&amp;quot;,&amp;quot;img/img2.jpg&amp;quot;] cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f ] ~~~&lt;/p&gt;
&lt;p&gt;This is equivalent to the Makefile rule:&lt;/p&gt;
&lt;p&gt;~~~makefile out/report.doc: src/report.md pandoc src/report.md -o out/report.doc ~~~&lt;/p&gt;
&lt;p&gt;The operator &lt;code&gt;*&amp;gt;&lt;/code&gt; attaches an &lt;a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html#t:Action"&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt; (with a parameter) to a &lt;a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html#t:FilePattern"&gt;&lt;code&gt;FilePattern&lt;/code&gt;&lt;/a&gt; (a string) -- that is, when &lt;em&gt;shake&lt;/em&gt; decides that it needs that specified file on the left hand side to be up to date, it runs the action on the right hand side with that filename as a parameter.&lt;/p&gt;
&lt;p&gt;To be clear, the right hand side is of type:&lt;/p&gt;
&lt;p&gt;~~~haskell rightHandSide :: FilePattern -&amp;gt; Action () ~~~&lt;/p&gt;
&lt;p&gt;where the &lt;code&gt;FilePattern&lt;/code&gt; is the filename of the file that is being &amp;quot;needed&amp;quot;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;need&lt;/code&gt; function specifies all of the dependencies of that action. If &lt;em&gt;shake&lt;/em&gt; decides it needs &lt;code&gt;out/report.doc&lt;/code&gt; to be up to date, &lt;code&gt;need&lt;/code&gt; tells it that it first needs &lt;code&gt;src/report.md&lt;/code&gt; and the images to be up to date -- or rather, that &lt;code&gt;out/report.doc&lt;/code&gt; is only out of date if &lt;code&gt;src/report.md&lt;/code&gt; or the images are out of date, or have changed since the last build.&lt;/p&gt;
&lt;p&gt;With this in mind, let us write the rest of our file rules:&lt;/p&gt;
&lt;p&gt;~~~haskell -- Shakefile&lt;/p&gt;
&lt;p&gt;&amp;quot;out/report.doc&amp;quot; *&amp;gt; \f -&amp;gt; do need [&amp;quot;src/report.md&amp;quot;,&amp;quot;img/img1.jpg&amp;quot;,&amp;quot;img/img2.jpg&amp;quot;] cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f ]&lt;/p&gt;
&lt;p&gt;&amp;quot;out/report.pdf&amp;quot; *&amp;gt; \f -&amp;gt; do need [&amp;quot;src/report.md&amp;quot;,&amp;quot;img/img1.jpg&amp;quot;,&amp;quot;img/img2.jpg&amp;quot;] cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f, &amp;quot;-V&amp;quot;, &amp;quot;links-as-notes&amp;quot; ]&lt;/p&gt;
&lt;p&gt;&amp;quot;out/report.html&amp;quot; *&amp;gt; \f -&amp;gt; do need [ &amp;quot;src/report.md&amp;quot; , &amp;quot;img/img1.jpg&amp;quot; , &amp;quot;img/img2.jpg&amp;quot; , &amp;quot;css/report.css&amp;quot; ] cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f, &amp;quot;-c&amp;quot;, &amp;quot;css/report.css&amp;quot;, &amp;quot;-S&amp;quot; ]&lt;/p&gt;
&lt;p&gt;&amp;quot;img/img2.jpg&amp;quot; *&amp;gt; \f -&amp;gt; do cmd &amp;quot;wget&amp;quot; [ &amp;quot;http://example.com/img2.jpg&amp;quot;, &amp;quot;-O&amp;quot;, f ] ~~~&lt;/p&gt;
&lt;p&gt;And that is it!&lt;/p&gt;
&lt;h2&gt;Running Shake&lt;/h2&gt;
&lt;p&gt;How do we tell &lt;em&gt;shake&lt;/em&gt; what file it is that we want to be up to date? We specify this by modifying the line &lt;code&gt;want []&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;~~~haskell want [&amp;quot;out/report.doc&amp;quot;,&amp;quot;out/report.pdf&amp;quot;,&amp;quot;out/report.html&amp;quot;] ~~~&lt;/p&gt;
&lt;p&gt;That tells &lt;em&gt;shake&lt;/em&gt; that when we run &lt;code&gt;main&lt;/code&gt; with no arguments, we want those three files to be checked to be up to date.&lt;/p&gt;
&lt;p&gt;Now, to wrap it all together, we run:&lt;/p&gt;
&lt;p&gt;~~~bash $ runhaskell Shakefile ~~~&lt;/p&gt;
&lt;p&gt;And let the magic happen!&lt;/p&gt;
&lt;p&gt;I run this enough times that I like to alias this:&lt;/p&gt;
&lt;p&gt;~~~bash&lt;/p&gt;
&lt;h1&gt;in ~/.bashrc&lt;/h1&gt;
&lt;p&gt;alias shake=runhaskell Shakefile ~~~&lt;/p&gt;
&lt;p&gt;Note that &lt;code&gt;want&lt;/code&gt; specifies the &lt;strong&gt;default&lt;/strong&gt; &amp;quot;wants&amp;quot;. You can specify your own collection by passing a parameter:&lt;/p&gt;
&lt;p&gt;~~~bash $ runhaskell Shakefile out/report.doc ~~~&lt;/p&gt;
&lt;h2&gt;Wildcards&lt;/h2&gt;
&lt;p&gt;You may have noticed that even though we had multiple images in the &lt;code&gt;img&lt;/code&gt; folder, we required them all explicitly. This could cause problems. What if in the future, our documents used more images?&lt;/p&gt;
&lt;p&gt;We can define wildcards using &lt;em&gt;shake&lt;/em&gt;'s &lt;code&gt;getDirectoryFiles&lt;/code&gt;, which returns results of a wildcard search in an &lt;code&gt;Action&lt;/code&gt; monad. &lt;code&gt;getDirectoryFiles&lt;/code&gt; takes a directory base and a list of wildcards.&lt;/p&gt;
&lt;p&gt;~~~haskell -- Shakefile&lt;/p&gt;
&lt;p&gt;srcFiles :: Action [FilePath] srcFiles = getDirectoryFiles &amp;quot;&amp;quot; [ &amp;quot;src/report.md&amp;quot; , &amp;quot;img/*.jpg&amp;quot; ]&lt;/p&gt;
&lt;p&gt;main :: IO () main = shakeArgs opts $ do want [&amp;quot;out/report.doc&amp;quot;,&amp;quot;out/report.pdf&amp;quot;,&amp;quot;out/report.html&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;out/report.doc&amp;quot; *&amp;gt; \f -&amp;gt; do
    deps &amp;lt;- srcFiles
    need deps
    cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f ]

&amp;quot;out/report.pdf&amp;quot; *&amp;gt; \f -&amp;gt; do
    deps &amp;lt;- srcFiles
    need deps
    cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f, &amp;quot;-V&amp;quot;, &amp;quot;links-as-notes&amp;quot; ]

&amp;quot;out/report.html&amp;quot; *&amp;gt; \f -&amp;gt; do
    deps &amp;lt;- srcFiles
    need $ &amp;quot;css/report.css&amp;quot; : deps
    cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f, &amp;quot;-c&amp;quot;, &amp;quot;css/report.css&amp;quot;, &amp;quot;-S&amp;quot; ]

&amp;quot;img/img2.jpg&amp;quot; *&amp;gt; \f -&amp;gt; do
    cmd &amp;quot;wget&amp;quot; [ &amp;quot;http://example.com/img2.jpg&amp;quot;, &amp;quot;-O&amp;quot;, f ]

&amp;quot;clean&amp;quot; ~&amp;gt; removeFilesAfter &amp;quot;.shake&amp;quot; [&amp;quot;//*&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~~~&lt;/p&gt;
&lt;p&gt;If you are comfortable with applicative style, you can make it all happen on one line:&lt;/p&gt;
&lt;p&gt;~~~haskell &amp;quot;out/report.doc&amp;quot; *&amp;gt; \f -&amp;gt; do need &amp;lt;$&amp;gt; srcFiles ~~~&lt;/p&gt;
&lt;p&gt;(You'll need to import &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; from &lt;code&gt;Control.Applicative&lt;/code&gt;, and GHC will complain about the discarded value unless you use &lt;code&gt;void&lt;/code&gt; or enable &lt;code&gt;-fno-warn-wrong-do-bind&lt;/code&gt;)&lt;/p&gt;
&lt;h2&gt;Phony Rules&lt;/h2&gt;
&lt;p&gt;Now, you might sometimes want rules that are &amp;quot;just tasks&amp;quot; that don't relate to creating a specific file. That is, they still depend on other files or rules and are triggered to update when their dependencies are out of date, but they just aren't about building files.&lt;/p&gt;
&lt;p&gt;For example, what if you wanted a task &lt;code&gt;build-some&lt;/code&gt;, which builds only &lt;code&gt;report.pdf&lt;/code&gt; and &lt;code&gt;report.doc&lt;/code&gt;, and outputs a proverb to the command line?&lt;/p&gt;
&lt;p&gt;One thing you can do is to simply use a rule with a name that does not correspond to any file:&lt;/p&gt;
&lt;p&gt;~~~haskell -- Bad &amp;quot;build-some&amp;quot; *&amp;gt; _ -&amp;gt; do need [&amp;quot;out/report.pdf&amp;quot;,&amp;quot;out/report.doc&amp;quot;] cmd &amp;quot;fortune&amp;quot; [&amp;quot;&amp;quot;] ~~~&lt;/p&gt;
&lt;p&gt;However, this is kind of an inelegant solution. There really actually is not a file &lt;code&gt;build-some&lt;/code&gt;. Also, if someone ever decides to create a file called &lt;code&gt;build-some&lt;/code&gt;, you'll find that this rule never gets run.&lt;/p&gt;
&lt;p&gt;The best way is to create a &amp;quot;phony&amp;quot; rule, which is a rule that is not tied to a file. This is the reason for the alias I specified at the beginning of the post:&lt;/p&gt;
&lt;p&gt;~~~haskell -- Good &amp;quot;build-some&amp;quot; ~&amp;gt; do need [&amp;quot;out/report.pdf&amp;quot;,&amp;quot;out/report.doc&amp;quot;] cmd &amp;quot;fortune&amp;quot; [&amp;quot;&amp;quot;] ~~~&lt;/p&gt;
&lt;p&gt;And voilÃ !&lt;/p&gt;
&lt;h3&gt;Cleanup&lt;/h3&gt;
&lt;p&gt;You might have noticed the phony rule in the scaffold Shakefile:&lt;/p&gt;
&lt;p&gt;~~~haskell &amp;quot;clean&amp;quot; ~&amp;gt; removeFilesAfter &amp;quot;.shake&amp;quot; [&amp;quot;//*&amp;quot;] ~~~&lt;/p&gt;
&lt;p&gt;If you run &lt;code&gt;shake clean&lt;/code&gt;, it will remove all files in the &lt;code&gt;.shake/&lt;/code&gt; directory after the rule has completed its execution. &lt;code&gt;removeFilesAfter&lt;/code&gt; removes the files in the given base directory (&lt;code&gt;.shake&lt;/code&gt;) matching the given wildcards (&lt;code&gt;[&amp;quot;//*&amp;quot;]&lt;/code&gt;) after all rules have completed their course.&lt;/p&gt;
&lt;p&gt;This is useful for cleaning up &lt;em&gt;shake&lt;/em&gt;'s metadata files after you are done with your build, or if you want to run the task management system on a clean start.&lt;/p&gt;
&lt;h2&gt;Completed File&lt;/h2&gt;
&lt;p&gt;~~~haskell -- Shakefile {-# OPTIONS_GHC -fno-warn-wrong-do-bind #-}&lt;/p&gt;
&lt;p&gt;import Control.Applicative ((&amp;lt;$&amp;gt;)) import Development.Shake&lt;/p&gt;
&lt;p&gt;opts = shakeOptions { shakeFiles = &amp;quot;.shake/&amp;quot; }&lt;/p&gt;
&lt;p&gt;main :: IO () main = shakeArgs opts $ do want [&amp;quot;out/report.doc&amp;quot;,&amp;quot;out/report.pdf&amp;quot;,&amp;quot;out/report.html&amp;quot;]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;build-some&amp;quot; ~&amp;gt; do
    need [&amp;quot;out/report.pdf&amp;quot;,&amp;quot;out/report.doc&amp;quot;]
    cmd &amp;quot;fortune&amp;quot; [&amp;quot;&amp;quot;]

&amp;quot;out/report.doc&amp;quot; *&amp;gt; \f -&amp;gt; do
    need &amp;lt;$&amp;gt; srcFiles
    cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f ]

&amp;quot;out/report.pdf&amp;quot; *&amp;gt; \f -&amp;gt; do
    need &amp;lt;$&amp;gt; srcFiles
    cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f, &amp;quot;-V&amp;quot;, &amp;quot;links-as-notes&amp;quot; ]

&amp;quot;out/report.html&amp;quot; *&amp;gt; \f -&amp;gt; do
    deps &amp;lt;- srcFiles
    need $ &amp;quot;css/report.css&amp;quot; : deps
    cmd &amp;quot;pandoc&amp;quot; [ &amp;quot;src/report.md&amp;quot;, &amp;quot;-o&amp;quot;, f, &amp;quot;-c&amp;quot;, &amp;quot;css/report.css&amp;quot;, &amp;quot;-S&amp;quot; ]

&amp;quot;img/img2.jpg&amp;quot; *&amp;gt; \f -&amp;gt; do
    cmd &amp;quot;wget&amp;quot; [ &amp;quot;http://example.com/img2.jpg&amp;quot;, &amp;quot;-O&amp;quot;, f ]

&amp;quot;clean&amp;quot; ~&amp;gt; removeFilesAfter &amp;quot;.shake&amp;quot; [&amp;quot;//*&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;srcFiles :: Action [FilePath] srcFiles = getDirectoryFiles &amp;quot;&amp;quot; [ &amp;quot;src/report.md&amp;quot; , &amp;quot;img/*.jpg&amp;quot; ] ~~~&lt;/p&gt;
&lt;h2&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;If you look at the &lt;a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html"&gt;Shake Documentation&lt;/a&gt;, you will find a lot of ways you can build complex networks of dependencies.&lt;/p&gt;
&lt;p&gt;Hopefully there are enough use cases here to be useful in general applications.&lt;/p&gt;
&lt;h3&gt;Monadic Tricks&lt;/h3&gt;
&lt;p&gt;Because everything is Haskell, you can easily generate rules using your basic monad iterators by taking advantage of Haskell's extensive standard library of monad functions. For example, if you want to generate multiple reports, you can use &lt;code&gt;forM_&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;~~~haskell let reports = [&amp;quot;report1&amp;quot;, &amp;quot;report2&amp;quot;, &amp;quot;report3&amp;quot;]&lt;/p&gt;
&lt;p&gt;want $ (\s f -&amp;gt; &amp;quot;out/&amp;quot; ++ s ++ &amp;quot;.&amp;quot; ++ f) &amp;lt;$&amp;gt; [&amp;quot;report1&amp;quot;,&amp;quot;report2&amp;quot;,&amp;quot;report3&amp;quot;] &amp;lt;*&amp;gt; [&amp;quot;doc&amp;quot;,&amp;quot;pdf&amp;quot;,&amp;quot;html&amp;quot;]&lt;/p&gt;
&lt;p&gt;forM_ [&amp;quot;report1&amp;quot;,&amp;quot;report2&amp;quot;,&amp;quot;report3&amp;quot;] $ \reportName -&amp;gt; do let outBase = &amp;quot;out/&amp;quot; ++ reportName srcName = &amp;quot;src/&amp;quot; ++ reportName ++ &amp;quot;.md&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;outBase ++ &amp;quot;.doc&amp;quot; *&amp;gt; \f -&amp;gt; do
    need &amp;lt;$&amp;gt; srcFiles
    cmd &amp;quot;pandoc&amp;quot; [ srcName, &amp;quot;-o&amp;quot;, f ]

outBase ++ &amp;quot;.pdf&amp;quot; *&amp;gt; \f -&amp;gt; do
    need &amp;lt;$&amp;gt; srcFiles
    cmd &amp;quot;pandoc&amp;quot; [ srcName, &amp;quot;-o&amp;quot;, f, &amp;quot;-V&amp;quot;, &amp;quot;links-as-notes&amp;quot; ]

outBase ++ &amp;quot;.html&amp;quot; *&amp;gt; \f -&amp;gt; do
    deps &amp;lt;- srcFiles
    need $ &amp;quot;css/report.css&amp;quot; : deps
    cmd &amp;quot;pandoc&amp;quot; [ srcName, &amp;quot;-o&amp;quot;, f, &amp;quot;-c&amp;quot;, &amp;quot;css/report.css&amp;quot;, &amp;quot;-S&amp;quot; ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;~~~&lt;/p&gt;
&lt;p&gt;Note however that you can get the same thing by just using wildcards (with &lt;code&gt;takeFileName&lt;/code&gt;). But this is just an example, feel free to let your imagination roam!&lt;/p&gt;
&lt;h3&gt;Looking Forward&lt;/h3&gt;
&lt;p&gt;We've seen how &lt;em&gt;Shake&lt;/em&gt; is good at setting up systems for managing and executing dependencies. This is good for running simple system commands. However, there is a lot more about scripting and task automation than managing dependencies.&lt;/p&gt;
&lt;p&gt;For example, almost everything we've done can be done with a simple Makefile. What does Haskell offer to the scripting scene?&lt;/p&gt;
&lt;h4&gt;Strong Typing&lt;/h4&gt;
&lt;p&gt;As you'll know, one of the magical things about Haskell is that because of its expressive strong typing system, you leave the debugging to the compiler. If it compiles, it works exactly the way you want!&lt;/p&gt;
&lt;p&gt;This is pretty lacking in the bare-bones system we have in place now. Right now we are just firing off arbitrary system commands that are basically specified in strings with no type of typing. We can compile anything, whether there are bugs in it or not.&lt;/p&gt;
&lt;p&gt;Luckily &lt;em&gt;Shake&lt;/em&gt; is very good at integrating seamlessly with any kind of framework. We can leave this up to other frameworks.&lt;/p&gt;
&lt;p&gt;One popular framework for this that is gaining in maturity is &lt;a href="http://hackage.haskell.org/package/shelly"&gt;&lt;em&gt;Shelly&lt;/em&gt;&lt;/a&gt; (A fork of an older project that is an &lt;a href="http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts"&gt;ongoing&lt;/a&gt; Yesod Project &lt;a href="http://www.yesodweb.com/blog/2012/07/shelly-update"&gt;experiment&lt;/a&gt;), but you are welcome to using your own. At the present Haskell is still developing and growing in this aspect. I hope to eventually write an article about &lt;em&gt;Shelly&lt;/em&gt; integration with &lt;em&gt;Shake&lt;/em&gt;.&lt;/p&gt;
&lt;h4&gt;Other&lt;/h4&gt;
&lt;p&gt;These are just some ways to think about using &lt;em&gt;Shake&lt;/em&gt; in new more creative ways. Let me know if you think of any clever integrations in the comments!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/shake-task-automation-and-scripting-in-haskell.html</guid><pubDate>Wed, 18 Sep 2013 00:23:11 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Tutorials</subject><date>2013-09-18</date></item><item><title>The Hamster Hotel: An Introduction to Control Theory (Part 1)</title><link>https://blog.jle.im/entry/the-hamster-hotel-an-introduction-to-control-theory.html</link><description>&lt;p&gt;Over this summer my work has been in the field of control theory. I must admit that I at first found it a little odd that the idea of &amp;quot;controlling something&amp;quot; --- say, the temperature of a room or the speed of a fan --- could be an extremely deep/rich mathematical and engineering discipline.&lt;/p&gt;
&lt;p&gt;This series should hopefully be an enlightening walk through this wonderful world that is control theory, and explore (without any complex mathematics) just how much genius goes into those simple things we all take for granted.&lt;/p&gt;
&lt;p&gt;Welcome to &lt;strong&gt;the Hamster Hotel&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;The Hamster Hotel&lt;/h2&gt;
&lt;p&gt;You run a hamster hotel (a hotel for hamsters) and you have a problem. Elevators. Your hamster guests need to get from one story to another. They walk into the elevator, the elevator takes them to the right floor, and they walk off.&lt;/p&gt;
&lt;p&gt;Due to an unfortunate mix-up on your contractor's part, your only option is elevators operated via water jets (like the ones at water fountains). You can control how hard the jets push with a valve that you can open or shut partially. The water jets push little plates in chutes up, and the hamsters hitch along for a ride.&lt;/p&gt;
&lt;p&gt;Let's say you can control how much the valve is open by twisting a knob (kind of like a garden hose). The more open the valve is, the higher the jet goes and the higher the elevator car.&lt;/p&gt;
&lt;p&gt;How do you find out how much you have to open the valve up to get the car to go &lt;em&gt;exactly&lt;/em&gt; to the second story?&lt;/p&gt;
&lt;h2&gt;That's Easy! (?)&lt;/h2&gt;
&lt;p&gt;Let's try out some simple solutions. What would you do first?&lt;/p&gt;
&lt;h3&gt;Measure it out&lt;/h3&gt;
&lt;p&gt;The most straightforward solution would be to get a ruler and do some good ol' empirical science-ing. You'll open the valve until you get to each floor. Then, you'll write down the amount that you've twisted the knob (10%, 20%?). Then, whenever you want to go to a floor, you'll look it up on your table, twist the knob to the corresponding value, and hamsters rejoice!&lt;/p&gt;
&lt;p&gt;Time to do this. Ground floor? 0% twisted open. Second floor? 3%. Third floor? 12%. Fourth floor? 27%. To get to the roof, you need to only set it to 48% open.&lt;/p&gt;
&lt;p&gt;Now that you have completely science'd the situation, it's time to start using your elevator. You load up a hamster for the inaugural ride.&lt;/p&gt;
&lt;h4&gt;The Plight of the Hamster&lt;/h4&gt;
&lt;p&gt;First problem. With a hamster actually inside the elevator, the whole thing is heavier, and a 3% open valve just doesn't cut it anymore to get it up even one story. You find out that have to crank it up to 5%. Third floor now takes a 20% opened valve.&lt;/p&gt;
&lt;p&gt;This is a disaster! Not only is your valued guest disappointed, but this fiasco has also rendered the entire first percentages table useless. You might try to change the table to account for one hamster. But what if your guest takes along also the missus as well? Should we keep two tables -- one for a one-hamster car, and one for a two-hamster car?&lt;/p&gt;
&lt;p&gt;But we musn't stereotype --- hamsters all have different weights. And what if the guests had luggage? Maybe we can measure the luggage, and create a new table for every possible total weight combination?&lt;/p&gt;
&lt;p&gt;What if one day the water pressure of the water jet drops, so less water comes out when the knob is twisted? Do you have to remeasure everything all over again?&lt;/p&gt;
&lt;p&gt;Clearly, there must be a better way.&lt;/p&gt;
&lt;h3&gt;The Analyzer&lt;/h3&gt;
&lt;p&gt;You just graduated with your bachelor's degree in Physics. You know all about the laws governing force, gravity, water, pressure, potential energy, friction, turbulence, hamster physiology ... all of that stuff. You memorized all of the equations, because that's what Physics is all about, right?[^itsnot]&lt;/p&gt;
&lt;p&gt;So, you whip out your precious equations (which you hold to be worth at least the $200,000 you spent to learn them). Sure enough, you have enough equations in your tool belt to describe and model the physical system almost perfectly. There are some constants you need to figure out --- the friction in the shaft, for example, or the width of your pipes --- and after that, given the weight of the load, the water pressure per degree of knob twist (which may change depending on the day), the desired height, the ambient room temperature, the heat of the elevator shaft, the temperature inside the pipes, the current air pressure, the humidity, the state of the lubrication in the shaft ... you can predict exactly how much you need to twist that water knob.&lt;/p&gt;
&lt;p&gt;You write a little program on your TI-89 to calculate the right amount of twist for all of those parameters, and you are good to go!&lt;/p&gt;
&lt;h4&gt;Does Not Compute&lt;/h4&gt;
&lt;p&gt;You see where the flaw in the plan is?&lt;/p&gt;
&lt;p&gt;Of course: it's very rude to ask a hamster for her weight!&lt;/p&gt;
&lt;p&gt;Also, aside from that, there are just too many parameters you have to constantly monitor, measure, and maintain. If you don't get it all exactly right, your hamsters are likely to get stuck inside somehow. Certainly not the path to gaining a five star reputation!&lt;/p&gt;
&lt;p&gt;Even if you somehow managed to find all of the proper parameters to a &amp;quot;good enough&amp;quot; level every time ... in general, it's unrealistic to expect to be able to derive an analytic solution to all of your problems.&lt;/p&gt;
&lt;p&gt;All these things aside, there are even graver issues that plague this system.&lt;/p&gt;
&lt;p&gt;What if the parameters change in mid-trip? What if the water pressure suddenly dropped? What if the lubrication was different along the length of the shaft? What if a hamster jumps onto the car last-minute?&lt;/p&gt;
&lt;p&gt;Certainly if any of these things happened, our poor hamster guests would undoubtedly fall straight to their doom.&lt;/p&gt;
&lt;p&gt;The problem with this system is that it's simply not &lt;strong&gt;dynamic&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Sure, you could make a model that accounts for all of the changes possible, but is that really practical?&lt;/p&gt;
&lt;p&gt;For a genius the likes of which the world has never seen, it may be &lt;em&gt;possible&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But ... there &lt;em&gt;has&lt;/em&gt; to be a better way.&lt;/p&gt;</description><author>Justin Le</author><category>Engineering</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/the-hamster-hotel-an-introduction-to-control-theory.html</guid><pubDate>Thu, 26 Sep 2013 22:05:13 UTC</pubDate><creator>Justin Le</creator><subject>Engineering, Ramblings</subject><date>2013-09-26</date></item><item><title>The Hamster Hotel: An Introduction to Control Theory (Part 2)</title><link>https://blog.jle.im/entry/the-hamster-hotel-an-introduction-to-control-theory-2.html</link><description>&lt;p&gt;As we left it off in &lt;a href="/entry/the-hamster-hotel-an-introduction-to-control-theory"&gt;part 1&lt;/a&gt;, our elevator is still in trouble. You have an elevator for your humble hotel that consists of a plate being pushed up a shaft with a fountain of water where we can control the fountain strength, but you don't really have any way to automate getting it to go to just the right height.&lt;/p&gt;
&lt;p&gt;You've tried writing down the proper fountain strengths for every floor, but changes in weight of the hamsters and lots of other factors make this unreliable. You've tried mathematically analyzing and accounting for all of these other factors, but not only is it impractical, but it can't possibly account for dynamic changes in the system.&lt;/p&gt;
&lt;p&gt;Let's take a look at a possible solution that might have some promise.&lt;/p&gt;
&lt;h2&gt;I Detect a Clue&lt;/h2&gt;
&lt;p&gt;You decide to put aside your elevator problems for now and focus on other aspects of your business. You do very well, actually, and your hotel grows to large acclaim in the hamster world. Still, you can't help but be embarrassed every day when you explain that your elevator is still not adequately controllable.&lt;/p&gt;
&lt;p&gt;You gain enough revenue that you decide to try things again with a human factor. You hire an elevator boy.&lt;/p&gt;
&lt;p&gt;Your scheme is simple: have a little bell attached at the point where every elevator reaches the perfect height. Your elevator boy will turn the knob up, up, up until he hears the bell, and then stop it right after.&lt;/p&gt;
&lt;p&gt;The same thing works for going down -- tell him to turn the knob down, down until he hears a bell.&lt;/p&gt;
&lt;p&gt;And suddenly, things seem to click.&lt;/p&gt;
&lt;h3&gt;The Key&lt;/h3&gt;
&lt;p&gt;This system accounts for all of the problems we ran into before. We have a human here who can account for everything. He makes all of the adjustments on the fly. He doesn't need to know any exact percentages ... he doesn't need to worry about water pressure or friction or hamster weights, or any of that stuff. All he needs to know is &amp;quot;should I be increasing the flow, decreasing it, or leaving it alone?&amp;quot; So maybe the heavier hamsters get to their destinations slower --- so what? You've discovered something amazing.&lt;/p&gt;
&lt;p&gt;The key difference here is the &lt;em&gt;detection&lt;/em&gt;. You are no longer thinking of a static system that will never change --- you are constantly adjusting on the fly. You are doing things, detecting the reactions, and responding to those detections. In control theory, this difference is what we call &lt;strong&gt;feedback&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Feedback&lt;/em&gt; is the process of letting what you &lt;em&gt;observe&lt;/em&gt; from your changes affect what you &lt;em&gt;change next, on the fly&lt;/em&gt;&lt;/strong&gt;, which then affects what you &lt;em&gt;observe&lt;/em&gt;, etc. etc.&lt;/p&gt;
&lt;p&gt;And &lt;em&gt;this&lt;/em&gt; is the key.&lt;/p&gt;
&lt;p&gt;In control theory, this would be known as moving from an &lt;strong&gt;open loop&lt;/strong&gt; (where we don't let what we observe affect what we change on-the-fly) to a &lt;strong&gt;closed loop&lt;/strong&gt; (where we do).&lt;/p&gt;
&lt;p&gt;Also note one other fundamental shift we just made: Based on what we observe, we &lt;em&gt;change&lt;/em&gt;. We no longer are finding out what we should &lt;em&gt;set&lt;/em&gt; --- we are instead figuring out how we should &lt;em&gt;change&lt;/em&gt;. We don't care about 10%, 20%, 30%, etc. anymore --- we only care about twisting the knob &lt;em&gt;left&lt;/em&gt; or &lt;em&gt;right&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Simple Improvements&lt;/h3&gt;
&lt;p&gt;Still, this system isn't perfect. Sometimes, if you forget to feed your elevator boy, he will accidentally miss the bell and overshoot slightly. No big deal. You attach some &lt;a href="http://www.snapcircuits.net/"&gt;very simple electronics&lt;/a&gt; to your elevator shaft so that a &lt;em&gt;red&lt;/em&gt; light comes on if the elevator is too low, a &lt;em&gt;blue&lt;/em&gt; light comes on if it's too high, and a &lt;em&gt;green&lt;/em&gt; light if it's just right.&lt;/p&gt;
&lt;p&gt;Finally, with all of the electronics installed, your elevator boy knows three rules: increase the flow if the light is red, decrease the flow if it's blue, and leave it constant if it's green.&lt;/p&gt;
&lt;p&gt;Of course, you were hoping (from the beginning) to be able to do have this be done without human intervention.&lt;/p&gt;
&lt;p&gt;One day, you figure out that you can do the entire thing electronically. To save money, you fire your elevator boy and set up a motor to twist the knob. In addition to the lights, your circuit will also trigger the motor to loosen the valve (spin right) if the car is too low, tighten it (spin left) if it's too high, and stop the motor when it is just right.&lt;/p&gt;
&lt;p&gt;Congratulations, you now have your very first automated closed feedback loop, known as the &lt;a href="http://en.wikipedia.org/wiki/Bang%E2%80%93bang_control"&gt;bang--bang controller&lt;/a&gt;[^bangbangnote].&lt;/p&gt;
&lt;p&gt;With this in hand, you are sure to have no obstacles to firmly establishing your hamster hotel empire.&lt;/p&gt;
&lt;h3&gt;Problems Again&lt;/h3&gt;
&lt;p&gt;Of course, our bang--bang controller is (as you might expect from the crudeness of the name) not exactly the be-all and end-all solution that control theory exists to provide.&lt;/p&gt;
&lt;p&gt;Let's look at its shortcomings even in our simple scenario.&lt;/p&gt;
&lt;p&gt;In reality, the light will almost never be green for long. If a platform is properly aligned as a hamster steps on it, it will be nudged off balance. The light will immediately turn red, the motor will immediately adjust the jet and the car at full speed. This is felt as a &amp;quot;jitter&amp;quot; (Which, as I have on good word, is a particularly unpleasant sensation for a hamster.)&lt;/p&gt;
&lt;p&gt;Could you possibly make the &amp;quot;adjustment speed&amp;quot; slower? That is, could you slow down the speed that your motor runs at, so that the adjustment is slow enough as to not be felt as a rapid jitter?&lt;/p&gt;
&lt;p&gt;Well, you can! But if your motor is slow, it will actually take much too long to ever move anywhere. Perhaps the proper non-jittering motor speed is the same speed that would cause the car to take an hour to move up one story. Not acceptable!&lt;/p&gt;
&lt;p&gt;You either jitter, or you take too long to move anywhere. Whatever motor speed you choose will always have one problem or the other.&lt;/p&gt;
&lt;p&gt;Furthermore, here we assume that our motor can instantly react to the changes in the red/blue/green lights. However, real-world motors can't simply change their direction immediately. Have you ever tried getting a car going 60 mph forwards to move 60 mph backwards instantly?&lt;/p&gt;
&lt;p&gt;Imagine applying this, then, to the elevator. It'll move up, up, up, then notice that it's at the right level. But before it can stop, it's already too high. It starts turning the motor the other way, to go down, down at the same speed ... it reaches the right level, but by the time it can stop, it's too low.&lt;/p&gt;
&lt;p&gt;This idea of &lt;em&gt;overshoot&lt;/em&gt; will cause your elevator car to forever go up and down, bouncing up and down without ever settling on the green zone even once. This is because your motor only has one speed, and however much you overshoot going up, it'll be exactly as much as you overshoot going down, and as much as you overshoot going up the next time.&lt;/p&gt;
&lt;p&gt;For now ... you might just have to rehire your elevator boy.&lt;/p&gt;
&lt;h2&gt;The Hamster Hole Grows Deeper&lt;/h2&gt;
&lt;p&gt;Are these the last of our problems standing in the way of a fully automated control system? Well, if you've noticed one trend in this post, it might be that as soon as we conquer one problem ... many others inevitably pop up. Any simple solution to these that you can think of now will have its own share of issues and problems.&lt;/p&gt;
&lt;p&gt;However, believe it or not, one day we will finally reach an end to this rat race and arrive at what is today known as the canonical &amp;quot;best&amp;quot; compromise for our system --- the system that deals with all of the problems mentioned here, and nearly all of the problems that come up with the naive solutions of the ones we face now. The best we got. Not perfect --- and not the best for many specific systems --- but the best overall, general scheme for problems of this particular type.&lt;/p&gt;
&lt;p&gt;I'm saying this to prevent you from being weary. We may have come a long way, and there may be much more to tackle, but fear not --- there is a satisfying end to this hamster hole.&lt;/p&gt;
&lt;p&gt;But first! How will we solve these fundamental problems --- jittering and oscillation --- of the bang--bang controller?&lt;/p&gt;</description><author>Justin Le</author><category>Engineering</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/the-hamster-hotel-an-introduction-to-control-theory-2.html</guid><pubDate>Tue,  1 Oct 2013 19:47:41 UTC</pubDate><creator>Justin Le</creator><subject>Engineering, Ramblings</subject><date>2013-10-01</date></item><item><title>Deploying Medium to Large Haskell Apps to Heroku by Precompiling</title><link>https://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku.html</link><description>&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;: This post was written in 2013, where the options available to someone looking to host a Haskell site on Heroku were fairly limited. It's (as of the time of writing this) 2015 now and things have changed. Check out &lt;a href="http://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku#disqus_thread"&gt;the comments&lt;/a&gt; for two good alternatives to this that are working today!&lt;/p&gt;
&lt;p&gt;Consider the rest of this article obsolete, or look here if none of the solutions given in the comments work :)&lt;/p&gt;
&lt;h2&gt;Old Article (Written 2013)&lt;/h2&gt;
&lt;p&gt;If you do a search on how to deploy Haskell apps to Heroku these days, chances are you are going to find the very elegant method (here's &lt;a href="http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html#deploying-to-heroku"&gt;one solution&lt;/a&gt;, and &lt;a href="http://blog.begriffs.com/2013/08/deploying-yesod-to-heroku-with-postgres.html"&gt;another&lt;/a&gt;) involving leveraging Heroku's powerful &lt;a href="https://devcenter.heroku.com/articles/cedar"&gt;Cedar stack&lt;/a&gt; and having Heroku use &lt;code&gt;cabal install&lt;/code&gt; to download and compile your app and all of its dependencies into a native binary on the server itself. It's a rather beautiful solution to the problem of a truly polyglot automated production server.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/mstksg/blog"&gt;blog engine&lt;/a&gt; that runs this blog is written in Haskell. When I tried to deploy it using those steps, I encountered a rather frustrating roadblock:&lt;/p&gt;
&lt;p&gt;Heroku enforces a hard time-out limit of &lt;strong&gt;fifteen minutes&lt;/strong&gt; for all of its apps to compile and deploy. And because &lt;em&gt;cabal&lt;/em&gt; needs time to download and compile every dependency, a typical non-trivial app (like a blog) would reach this limit very quickly with only a &lt;a href="https://github.com/mstksg/blog/blob/master/blog.cabal#L20-52"&gt;modest amount of dependencies&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I did some searching on this and asked around on the irc channel, but I was not able to find any real-world examples of &lt;em&gt;non-trivial&lt;/em&gt; apps being deployed to Haskell using this method. It seemed like most articles simply deployed a toy project, and left it at that. (On that note, if anyone has actually had success with this, or knows someone who has, please let me know)&lt;/p&gt;
&lt;p&gt;Until Heroku's time-out limit can be adjusted or bypassed, the only real solution (besides incrementally pushing dependencies with a buildpack that caches --- a solution even uglier and less practical) is to pre-compile your binary to an architecture that Heroku supports.&lt;/p&gt;
&lt;p&gt;There are some tutorials on this already, but few are up to date and flexible/comprehensive, so here is my shot.&lt;/p&gt;
&lt;p&gt;As an &lt;strong&gt;important note&lt;/strong&gt;: this method is a lot less elegant and maintanable (in principle) than the recommended buildpack method; only use it if you are absolutely certain that buildpacks won't work for you.&lt;/p&gt;
&lt;p&gt;Also note that this assumes that your app is already configured to work on Heroku --- that it doesn't modify the filesystem after the deploy (so no &lt;em&gt;sqlite&lt;/em&gt;), it uses the &lt;code&gt;$DATABASE_URL&lt;/code&gt; environment variable to establish database connections, it uses the &lt;code&gt;$PATH&lt;/code&gt; environment variable to choose the port to listen to, and other small things you just have to worry about that is out of the scope of this post.&lt;/p&gt;
&lt;p&gt;Much of this post is owed to &lt;a href="https://github.com/yesodweb/yesod/wiki/Deploying-Yesod-Apps-to-Heroku"&gt;this article on the Yesod wiki&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Compiling Your Binary&lt;/h2&gt;
&lt;h3&gt;The Virtual Machine&lt;/h3&gt;
&lt;p&gt;First of all, we need to find ourselves a machine with the same architecture as the Heroku virtual machines. For most people, it is not practical to go out and buy a physical machine that you can use for yourself, so we're going to be setting up a virtual one here.&lt;/p&gt;
&lt;p&gt;A lot of this is going to be verbatim from &lt;a href="https://github.com/yesodweb/yesod/wiki/Setting-up-a-virtual-machine%2C-using-VirtualBox-and-Vagrant"&gt;this reference&lt;/a&gt;, with a few updates.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;You're going to need &lt;a href="https://www.virtualbox.org/wiki/Downloads"&gt;VirtualBox&lt;/a&gt;, from Oracle. Most modern work on virtual machines leverage this great tool.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install &lt;a href="http://downloads.vagrantup.com/"&gt;vagrant&lt;/a&gt;, a really convenient wrapper around the raw VirtualBox functionality that integrates things like build scripts and configurations into an easy-to-use package.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Clone/download the &lt;a href="https://bitbucket.org/puffnfresh/vagrant-haskell-heroku"&gt;vagrant-haskell-heroku&lt;/a&gt; project from BitBucket. This is the vagrant project that will set up everything you need to build and deploy to Heroku --- an installation of GHC, the Haskell Platform, and the Heroku Toolbelt, all on a 64 bit Ubuntu 10.04 image.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Edit the &lt;code&gt;Vagrantfile&lt;/code&gt;; on the line starting with &lt;code&gt;chef.json.merge!&lt;/code&gt;, change the values to the versions of &lt;a href="http://www.haskell.org/ghc/"&gt;GHC&lt;/a&gt; and &lt;a href="http://www.haskell.org/platform/"&gt;Haskell Platform&lt;/a&gt; you will be using.&lt;/p&gt;
&lt;p&gt;~~~ruby chef.json.merge!({ :ghc&lt;em&gt;version =&amp;gt; '7.4.4', :haskell&lt;/em&gt;platform_version =&amp;gt; '2012.4.0.0'}) ~~~&lt;/p&gt;
&lt;p&gt;I'm using &lt;code&gt;ghc-7.6.3&lt;/code&gt; to develop, and as of October 2013, the lastest stable Haskell Platform is &lt;code&gt;2013.2.0.0&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Launch your virtual machine with&lt;/p&gt;
&lt;p&gt;~~~bash $ vagrant up ~~~&lt;/p&gt;
&lt;p&gt;This will launch the VM and install the given versions of GHC and the Haskell Platform. You are mostly good to go now -- log onto your machine using&lt;/p&gt;
&lt;p&gt;~~~bash $ vagrant ssh ~~~&lt;/p&gt;
&lt;p&gt;If this doesn't work, try installing &lt;code&gt;libgc-dev&lt;/code&gt;. &lt;code&gt;vagrant ssh&lt;/code&gt; should send you into an &amp;quot;ssh&amp;quot; session on your VM. Once there, let's run some basic bookkeeping/updating that isn't handled by the vagrant project:&lt;/p&gt;
&lt;p&gt;~~~bash $ sudo apt-get update $ sudo apt-get upgrade $ sudo apt-get install git-core $ cabal update ~~~&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And you should have a fresh virtual machine compatible with Heroku ready to build your project on.&lt;/p&gt;
&lt;h3&gt;Building Your Project&lt;/h3&gt;
&lt;p&gt;At this point, there are many ways to proceed. Building is now more or less the same as if you were building on your own production server. Here is one way to go about it.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Get your project files onto your guest (virtual) machine.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If your projects are on a version control repository like &lt;a href="https://www.github.com"&gt;Github&lt;/a&gt; or any accessible server, then getting your files on your guest machine and keeping them up-to-date is as easy as a &lt;code&gt;git pull&lt;/code&gt; (substitute git for whatever version control you use).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If not, the directory that your vagrant files are stored in is actually mounted onto the file system of the guest machine. You can access it at &lt;code&gt;/vagrant&lt;/code&gt; on the guest machine.&lt;/p&gt;
&lt;p&gt;This is really handy for transferring things like ssh keys, but you can also use this to get your project files onto your guest machine. Simply copy them over somehow onto a folder in the vagrant directory, and you can then access them on your virtual machine and do what you want with them.&lt;/p&gt;
&lt;p&gt;However, if you want to keep your files up to date, you'll have to do this manually.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you are using version control like &lt;em&gt;git&lt;/em&gt;, but you aren't hosting it on a server (and why not? you can even &lt;a href="https://github.com/sitaramc/gitolite"&gt;host a repo server locally on your own machine&lt;/a&gt;.), see if you can use a local folder as a repository source.&lt;/p&gt;
&lt;p&gt;For &lt;em&gt;git&lt;/em&gt;, this is pretty simple. You only need to run &lt;code&gt;git init --bare&lt;/code&gt; on the folder you want to use as the repository, and add the local filesystem path as the remote url. There are many resources explaining this process in detail, like &lt;a href="http://www.jedi.be/blog/2009/05/06/8-ways-to-share-your-git-repository/"&gt;this post&lt;/a&gt; and &lt;a href="http://treeleaf.be/blog/2011/03/creating-a-new-git-repository-on-a-local-file-system/"&gt;this one&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Build the executable. This is the same as on any machine. However, I strongly recommend using some kind of sandboxing system like &lt;a href="http://hackage.haskell.org/package/cabal-dev"&gt;cabal-dev&lt;/a&gt;, or cabal 1.18's built-in sandboxing, just to make sure you don't run into any problems in the future.&lt;/p&gt;
&lt;p&gt;~~~bash&lt;/p&gt;
&lt;h1&gt;using cabal-dev&lt;/h1&gt;
&lt;p&gt;$ cabal install cabal-dev&lt;/p&gt;
&lt;h1&gt;you can add ~/.cabal/bin to your $PATH if you want&lt;/h1&gt;
&lt;p&gt;$ ~/.cabal/bin/cabal-dev install ~~~&lt;/p&gt;
&lt;p&gt;If any of your cabal packages require developer libraries to be installed on your machine (anything involving Postgres comes to mind), you'll need to be sure that they are installed. A simple &lt;code&gt;apt-get&lt;/code&gt; should take care of this for all relevant packages.&lt;/p&gt;
&lt;p&gt;After everything downloads, builds, installs, etc., your executable will be created as &lt;code&gt;dist/build/app-name/app-name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This will also be a good test as to whether or not you specified your dependencies in your &lt;code&gt;.cabal&lt;/code&gt; file properly.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Deploying it all&lt;/h2&gt;
&lt;p&gt;Almost there! Your binary is now compiled; how are you going to deploy it to Heroku?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;First, you have to commit your binary to version control. Some people recommend using a separate branch for this, but because your guest machine's project directory is kind of a transient thing, this really isn't that necessary.&lt;/p&gt;
&lt;p&gt;You can simply forcefully add the file to git as it is, because chances are you have it already in your &lt;code&gt;.gitignore&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;~~~bash $ git add -f dist/build/app-name/app-name ~~~&lt;/p&gt;
&lt;p&gt;Alternatively, you can create a &lt;code&gt;bin/&lt;/code&gt; folder and copy the executable there. It really doesn't make a difference, except that you don't have to modify your &lt;code&gt;.gitignore&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, you need to create your &lt;code&gt;Procfile&lt;/code&gt; --- this specifies the processes that Heroku will be executing.&lt;/p&gt;
&lt;p&gt;~~~yaml&lt;/p&gt;
&lt;h1&gt;Procfile&lt;/h1&gt;
&lt;p&gt;web: # system command to launch your server ~~~&lt;/p&gt;
&lt;p&gt;For some web servers, it is simply the path to the executable; for some frameworks like &lt;em&gt;Yesod&lt;/em&gt;, you need to specify the flag &lt;code&gt;-p $PORT&lt;/code&gt;, because Heroku specifies the port you are to listen to via the environment variable.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Heroku requires every project to have &lt;em&gt;some&lt;/em&gt; buildpack. Because the actual web processes are specified in your &lt;code&gt;Procfile&lt;/code&gt;, buildpacks won't interfere with any actual execution of your server.&lt;/p&gt;
&lt;p&gt;There are three easy ways to do this --- you can either use a blank &lt;code&gt;requirements.txt&lt;/code&gt; (the easiest way) to act like a &lt;em&gt;Python&lt;/em&gt; app, a valid but empty &lt;code&gt;package.json&lt;/code&gt; to act like a &lt;em&gt;Node.js&lt;/em&gt; app, or a valid but empty &lt;code&gt;Gemfile&lt;/code&gt; and &lt;code&gt;Gemfile.lock&lt;/code&gt; combination to act like a &lt;em&gt;ruby&lt;/em&gt; app.&lt;/p&gt;
&lt;p&gt;But hey, if you use any node packages or gems or python packages in your project, then you can actually use this to your advantage! I personally use &lt;em&gt;&lt;a href="http://compass-style.org/"&gt;compass&lt;/a&gt;&lt;/em&gt; a lot for their extensions to &lt;em&gt;sass&lt;/em&gt;, so adding it is as simple as using a &lt;em&gt;Gemfile&lt;/em&gt; --- just like in any normal ruby app.&lt;/p&gt;
&lt;p&gt;If you want to mix and match libraries from different languages/ecosystems, you can use the &lt;a href="https://github.com/ddollar/heroku-buildpack-multi"&gt;multi&lt;/a&gt; buildpack and have Heroku check for packages in all of the normal package managers of the languages you specify.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Configure your &lt;a href="https://toolbelt.heroku.com/"&gt;Heroku Toolbelt&lt;/a&gt;, and deploy.&lt;/p&gt;
&lt;p&gt;~~~bash&lt;/p&gt;
&lt;h1&gt;create your app&lt;/h1&gt;
&lt;p&gt;$ heroku create appname&lt;/p&gt;
&lt;h1&gt;and, after making sure everything is set up, committed, and in order...&lt;/h1&gt;
&lt;p&gt;$ git push heroku master ~~~&lt;/p&gt;
&lt;p&gt;If you have done everything right, this should be succesful. Hooray!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make sure your &lt;code&gt;web&lt;/code&gt; process is running properly. You can do this by going to &lt;a href="https://dashboard.heroku.com/apps" class="uri"&gt;https://dashboard.heroku.com/apps&lt;/a&gt;, clicking on your app, and making sure under &lt;strong&gt;Dynos&lt;/strong&gt; that the check box next to &amp;quot;web&amp;quot; is checked off.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that should be it!&lt;/p&gt;
&lt;h2&gt;After the Deploy&lt;/h2&gt;
&lt;p&gt;Your app should be running successfully now! Probably. Maybe. If you run into any problems, let me know in the comments. But to preempt any issues that might arise, here are some things that it might be important to pay attention to.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you are using Heroku's Postgres instances (and you should, they are amazing and probably more reliable than anything you could host yourself on cheap, for free), you will have to make sure to &lt;a href="https://devcenter.heroku.com/articles/heroku-postgresql"&gt;configure them properly&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you have problems making a connection, you can try the &lt;a href="http://hackage.haskell.org/package/heroku"&gt;heroku&lt;/a&gt; package on Hackage and integrate it with your database connection backends.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You are probably going to want to automate your entire re-deploy process --- the pull, the build/install, the copying of the executable, the committing of the binary to version control, and the deploy to Heroku.&lt;/p&gt;
&lt;p&gt;You can use your favorite task management system, like &lt;em&gt;Make&lt;/em&gt;, &lt;em&gt;Rake&lt;/em&gt;, or even &lt;em&gt;Shake&lt;/em&gt; (see my &lt;a href="/entry/shake-task-automation-and-shell-scripting-in-haskell"&gt;brief tutorial on Shake&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Your basic workflow should consist of pushing your project files to your repository on your host machine, and &lt;code&gt;vagrant ssh&lt;/code&gt;-ing onto your guest machine and executing one or two commands to automate the entire re-deploy process.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Be aware of good virtual machine management practices. Suspend your machine whenever you are not using it:&lt;/p&gt;
&lt;p&gt;~~~bash&lt;/p&gt;
&lt;h1&gt;suspend&lt;/h1&gt;
&lt;p&gt;$ vagrant suspend&lt;/p&gt;
&lt;h1&gt;resume&lt;/h1&gt;
&lt;p&gt;$ vagrant resume ~~~&lt;/p&gt;
&lt;p&gt;and you will also prevent things from getting hairy in case of a system crash on the host side.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Good luck developing for the web on the Haskell platform, and welcome to the club!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku.html</guid><pubDate>Mon,  7 Oct 2013 19:07:25 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Tutorials</subject><date>2013-10-07</date></item><item><title>log.sh: Lightweight Command Line Note &amp; Logging</title><link>https://blog.jle.im/entry/log-sh-lightweight-command-line-note-logging.html</link><description>&lt;p&gt;What do you use to send off quick one-off notes and logs about a project you are working on? Found a nice link to a resource you'll want to look up later...want to jot down a sudden realization?&lt;/p&gt;
&lt;p&gt;Maybe you use some external note-taking software, like &lt;em&gt;Evernote&lt;/em&gt;. But wouldn't it be nice to have something that is completely in the command line? Do you really need to fire up an entire GUI just to write down one line, put down one link? And do you really need these notes to all be thrown in with your others?&lt;/p&gt;
&lt;p&gt;You might be using a command line interface to a larger note-taking system like &lt;em&gt;&lt;a href="http://geeknote.me/"&gt;geeknote&lt;/a&gt;&lt;/em&gt;. But it's kind of a hassle to open up an entire text editor every time you want to make a small one-liner. Doesn't quite meld with the &lt;a href="http://www.faqs.org/docs/artu/ch01s06.html"&gt;Unix philosophy&lt;/a&gt;. Maybe you are comfortable simply appending to a text file with &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;...but what if you want to add things like timestamps?&lt;/p&gt;
&lt;p&gt;Here's introducing &lt;strong&gt;&lt;em&gt;&lt;a href="https://github.com/mstksg/log.sh"&gt;log.sh&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://github.com/mstksg/log.sh"&gt;Log.sh&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="https://github.com/mstksg/log.sh"&gt;log.sh&lt;/a&gt;&lt;/em&gt; is intended for these use cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Project-based notes
&lt;ul&gt;
&lt;li&gt;Quick links to resources, references&lt;/li&gt;
&lt;li&gt;Small local project TODO's&lt;/li&gt;
&lt;li&gt;Reminders and gotchas&lt;/li&gt;
&lt;li&gt;Logging progress, short micro-journaling to record check points in progress.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Simple quick references (in the home directory)
&lt;ul&gt;
&lt;li&gt;Reminders on system configuration todo's&lt;/li&gt;
&lt;li&gt;Refreshers on simple tasks that you only do a few times a year&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of all, it is meant to be quick, fast, efficient, streamlined, simple.&lt;/p&gt;
&lt;h3&gt;Usage&lt;/h3&gt;
&lt;h4&gt;Entering a note&lt;/h4&gt;
&lt;p&gt;Don't believe me? Here's how you enter in a note:&lt;/p&gt;
&lt;p&gt;~~~bash $ log.sh hey, this is a note! ~~~&lt;/p&gt;
&lt;p&gt;(Note no need to surround your log with quotes or anything.)&lt;/p&gt;
&lt;p&gt;That command will write the line&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Sun Sep 29 16:07:21 PDT 2013]  hey, this is a note!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to the active log file. As a cute trick, you can specify the flag &lt;code&gt;-t&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;~~~bash $ log.sh -t buy milk ~~~&lt;/p&gt;
&lt;p&gt;which will handily add a cute &lt;code&gt;[ ]&lt;/code&gt; before the item like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Sun Sep 29 16:14:03 PDT 2013]  [ ] buy milk&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Editing your log file&lt;/h4&gt;
&lt;p&gt;The little &lt;code&gt;[ ]&lt;/code&gt; is handy because you can open up the log file in a text editor of your choice and &amp;quot;check&amp;quot; it off.&lt;/p&gt;
&lt;p&gt;That's actually very easy, because&lt;/p&gt;
&lt;p&gt;~~~bash $ log.sh -e ~~~&lt;/p&gt;
&lt;p&gt;will open the active log file in your favorite editor, specified by the &lt;code&gt;$EDITOR&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;h4&gt;The Log File&lt;/h4&gt;
&lt;p&gt;What is the &amp;quot;active&amp;quot; log file? Where is this log being stored? Ideally, it is either in the root directory of the relevant project, or in your home folder.&lt;/p&gt;
&lt;p&gt;To create a log file in your current working directory, enter&lt;/p&gt;
&lt;p&gt;~~~bash $ log.sh -c ~~~&lt;/p&gt;
&lt;p&gt;This'll create a file &lt;code&gt;.log.log&lt;/code&gt; in the directory.&lt;/p&gt;
&lt;p&gt;Now, if you are in any subdirectory, the default behavior is that &lt;em&gt;&lt;a href="https://github.com/mstksg/log.sh"&gt;log.sh&lt;/a&gt;&lt;/em&gt; will first check the current directory for a log file; if it doesn't find it, it goes up a directory and checks there, checking up and up until it finds a valid log file. That file is the &amp;quot;active&amp;quot; one, where all of your adds and edits will refer to.&lt;/p&gt;
&lt;h4&gt;Log Contexts&lt;/h4&gt;
&lt;p&gt;If you try to enter a note from a subdirectory, you'll get something cool:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Sun Sep 29 16:10:38 PDT 2013]  (./subdir) logging from ./subdir!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="https://github.com/mstksg/log.sh"&gt;log.sh&lt;/a&gt;&lt;/em&gt; will automatically include the context of your log in your note body.&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;Didn't want to bore you right off the bat with implementation/installation details. But here it is. The entire thing is open source, and written in bash.&lt;/p&gt;
&lt;p&gt;Install by either cloning the github repo or downloading &lt;a href="https://github.com/mstksg/log.sh/releases"&gt;the latest release&lt;/a&gt;. Put the file &lt;code&gt;log.sh&lt;/code&gt; into a directory in your &lt;code&gt;$PATH&lt;/code&gt;. If you wish, alias it to something short, like &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That should be it!&lt;/p&gt;
&lt;h3&gt;That's it!&lt;/h3&gt;
&lt;p&gt;That's really all there is to it! You can customize the filename of the log file created/searched for, or you can even specify the exact path of the log file you want to append to or edit using command line flags. More detail on how to do this in the documentation:&lt;/p&gt;
&lt;p&gt;~~~bash $ log.sh -h ~~~&lt;/p&gt;
&lt;p&gt;Basically, the entire thing is meant to be as frictionless, fast, and thoughtless as possible. Enter in small notes to reference later in only the time it takes for you to actually write the note --- no need to mungle around with text editors and picking which file to append to and dealing with timestamps. &lt;em&gt;&lt;a href="https://github.com/mstksg/log.sh"&gt;log.sh&lt;/a&gt;&lt;/em&gt; has got you covered!&lt;/p&gt;
&lt;p&gt;I do recommend, if you use this, aliasing the command to something short. I personally use &lt;code&gt;n&lt;/code&gt;, so I write notes by saying:&lt;/p&gt;
&lt;p&gt;~~~bash $ n goodbye! ~~~&lt;/p&gt;
&lt;p&gt;Hopefully this script ends up being as useful to you as it has to me. Feel free to leave any comments on questions/bugs/improvements, and I'm always happy to take contributions and pull requests.&lt;/p&gt;</description><author>Justin Le</author><category>Projects</category><guid isPermaLink="true">https://blog.jle.im/entry/log-sh-lightweight-command-line-note-logging.html</guid><pubDate>Tue, 15 Oct 2013 18:53:48 UTC</pubDate><creator>Justin Le</creator><subject>Projects</subject><date>2013-10-15</date></item><item><title>The Compromiseless Reconciliation of I/O and Purity</title><link>https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html</link><description>&lt;p&gt;One of the crazy ideals of functional programming is the idea that your program is simply a list of definitions of mathematical functions. And like real math functions, FP functions are &lt;strong&gt;pure&lt;/strong&gt;. That means that (1) they cannot affect any state, and (2) that they must return the same thing every time they are called with the same arguments.&lt;/p&gt;
&lt;p&gt;When you first learn functional programming, this manifests as &amp;quot;your variables are immutable and you can't do loops; use recursion instead.&amp;quot; And if you do that, everything is &amp;quot;fine&amp;quot;.&lt;/p&gt;
&lt;p&gt;However, there is an apparent glaring problem with this adherence to purity: &lt;strong&gt;I/O&lt;/strong&gt;. Input and output are inherently stateful.&lt;/p&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;For the obvious (input) example, consider &lt;code&gt;getchar()&lt;/code&gt; in C. It returns the character that a user enters. Obviously, if &lt;code&gt;getchar()&lt;/code&gt; returned the same thing every time, you'd have an extraordinarily useless function. Input &lt;em&gt;inherently violates&lt;/em&gt; purity, it seems. (Also, consider a &lt;a href="http://xkcd.com/221/"&gt;function generating random numbers&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;The idea of output violates purity as well. Consider calling &lt;code&gt;printf()&lt;/code&gt; in C. You're going to change the state of the terminal. A benign example, of course; but what about a function &lt;code&gt;add_database_row()&lt;/code&gt; that adds a row to your database? A call of &lt;code&gt;get_database_row()&lt;/code&gt; will now return something different than it would have returned before. &lt;code&gt;get_database_row()&lt;/code&gt; now returns two different things when run at two different times --- impure! Blasphemy!&lt;/p&gt;
&lt;p&gt;Of course, it should be obvious that not being able to perform IO means that your program is essentially useless in most real world applications. But purity is pretty cool, and it gives us guarantees that let us &lt;a href="http://u.jle.im/19JxV5S"&gt;reason with our code&lt;/a&gt; in ways that are impossible with impure code, and with unprecedented safety. It opens the doors to previously inaccessible models of parallel, concurrent, and distributed programming. It allows the compiler to do crazy optimization tricks. It allows for powerful mathematical analysis of our programs. The full benefits of purity are beyond the scope of this article, but you can trust me when they say that they are too much to give up over a technicality.&lt;/p&gt;
&lt;p&gt;So how can we reconcile the idea of a pure language with ~~anything useful~~ I/O?&lt;/p&gt;
&lt;h2&gt;A Functional &amp;quot;Program&amp;quot;&lt;/h2&gt;
&lt;h3&gt;Declarations&lt;/h3&gt;
&lt;p&gt;Let's look at an almost-typical Haskell program.&lt;/p&gt;
&lt;p&gt;~~~haskell -- factorial n: n! factorial :: Int -&amp;gt; Int factorial 0 = 1 factorial n = n * factorial (n-1)&lt;/p&gt;
&lt;p&gt;-- fib n: the nth Fibonacci number fib :: Int -&amp;gt; Int fib 0 = 1 fib 1 = 1 fib n = fib (n-2) + fib (n-1)&lt;/p&gt;
&lt;p&gt;-- first&lt;em&gt;n&lt;/em&gt;fibs n: a list of the first n Fibonacci numbers first&lt;em&gt;n&lt;/em&gt;fibs :: Int -&amp;gt; [Int] first&lt;em&gt;n&lt;/em&gt;fibs n = map fib [1..n] ~~~&lt;/p&gt;
&lt;p&gt;One of the first things you should notice is that this looks strikingly similar to a list of math equations...and almost not like a program.&lt;/p&gt;
&lt;p&gt;Notice one important thing about this (at least, in Haskell): there is no inherent ordering in any of these statements. By this, I mean that &lt;code&gt;factorial&lt;/code&gt;, &lt;code&gt;fib&lt;/code&gt;, and &lt;code&gt;first_n_fibs&lt;/code&gt; can be defined in any order. When you write declarations of mathematical objects on paper, the order in which you declare them should have no bearing on what they represent. These are functions. Immortal, unchanging, ethereal, separate from time and space. It is simply nonsensical to talk about order in this context.[^strictness]&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Thanks to evincarofautum of reddit for pointing out that the ordering of the --&amp;gt; &amp;lt;!-- pattern matches in this example actually do matter. --&amp;gt;&lt;/p&gt;
&lt;p&gt;Also note that these declarations don't always declare integers/numbers. &lt;code&gt;first_n_fibs&lt;/code&gt; actually declares a data structure --- a list that contains integers. Of course this is no big problem...mathematical functions can map integers to matrices, or matrices to functions, anything you can think of. We aren't limited to simply defining primitive things. We can also define structures that contain things.&lt;/p&gt;
&lt;p&gt;Of course, this &amp;quot;program&amp;quot; doesn't actually &lt;em&gt;do&lt;/em&gt; anything. Let's look at some more programs and see if we can address this.&lt;/p&gt;
&lt;h3&gt;Representing Actions&lt;/h3&gt;
&lt;p&gt;There are a lot of data structures/data types that may be expressed in Haskell. One in particular is called &lt;code&gt;IO&lt;/code&gt;. &lt;code&gt;IO a&lt;/code&gt; represents a computation that returns something of type &lt;code&gt;a&lt;/code&gt;. There are a couple of pre-packaged computations included in the standard library. Let's write another almost-typical Haskell program with some.&lt;/p&gt;
&lt;p&gt;~~~haskell -- getStringFromStdin: returns a computation that represents the act of -- getting a string from stdin. or rather, a series of instructions on -- interacting with the computer and generating a String. getStringFromStdin :: IO String getStringFromStdin = getLine&lt;/p&gt;
&lt;p&gt;-- printFibN: returns a computation that represents the act of printing the -- nth Fibonacci number to stdout and returns () (Nothing). or rather, -- a series of instruction on interacting with the computer to get it to -- print a Fibonacci number and returning nothing. printFibN :: Int -&amp;gt; IO () printFibN n = print (fib n) ~~~&lt;/p&gt;
&lt;p&gt;Let's look at these.&lt;/p&gt;
&lt;p&gt;These are simply functions/declarations, just like the ones above. Although instead of returning an integer or a list data structure, it returns a special data structure that represents a computation. &lt;code&gt;[a]&lt;/code&gt; represents a list of &lt;code&gt;a&lt;/code&gt;'s. &lt;code&gt;IO a&lt;/code&gt; represents an abstract computation (or a series of system instructions) that returns an &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These declarations and functions are also simply &amp;quot;math&amp;quot; functions. Instead of returning a set or a matrix or a vector, it returns another type of object.&lt;/p&gt;
&lt;p&gt;Note that this has nothing to do with execution. &lt;code&gt;printFibN&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; execute a print statement. No more than writing &lt;code&gt;printFibN&lt;/code&gt; on a piece of paper will cause it to magically evaluate. It does not execute anything: it is simply an abstract data structure representing a computation.&lt;/p&gt;
&lt;p&gt;Note again that there is no inherent ordering involved. Whether you define one or the other first, it does not change what the two names really &lt;em&gt;represent&lt;/em&gt;. Just like if you defined two matrices on a piece of paper in a different order, it does not change the matrices they represent.&lt;/p&gt;
&lt;p&gt;Also note that all of these declarations are completely pure. &lt;code&gt;getStringFromStdin&lt;/code&gt; will return the exact same &lt;em&gt;representation of a computation&lt;/em&gt; every single time. &lt;code&gt;printFibN n&lt;/code&gt; will return the exact same &lt;em&gt;computation representation&lt;/em&gt; for every &lt;code&gt;n&lt;/code&gt; every single time. The exact same instruction sequence every single time for every &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And yes, the objects themselves don't actually execute anything. That's like saying writing down a matrix executes something in the real world.&lt;/p&gt;
&lt;h3&gt;Data Structures, Not Commands&lt;/h3&gt;
&lt;p&gt;To illustrate the difference between a data structure representing a computation and a computation itself, let's look at a possible confusion that might arise from mixing up the two.&lt;/p&gt;
&lt;p&gt;~~~haskell getStringAndPrint :: IO () getStringAndPrint = print (getStringFromStdin) ~~~&lt;/p&gt;
&lt;p&gt;What would you expect to happen here?&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;print&lt;/code&gt; is an IO instruction prints out what it is passed. &lt;code&gt;getStringFromStdin&lt;/code&gt; is a computation object that gives a string when executed.&lt;/p&gt;
&lt;p&gt;In another language, which deals with computations (and not representations of them), you would expect it to get a string from stdin and then print it. Sort of like an echo.&lt;/p&gt;
&lt;p&gt;However, this is not the case in Haskell. What is &lt;code&gt;getStringFromStdin&lt;/code&gt;? It is &lt;em&gt;not&lt;/em&gt; a string --- it is a computation object.&lt;/p&gt;
&lt;p&gt;What will happen is that &lt;code&gt;print&lt;/code&gt; (when executed by a computer) won't print the result of &lt;code&gt;getStringFromStdin&lt;/code&gt;. &lt;code&gt;print&lt;/code&gt; will print out the &lt;strong&gt;representation of the computation&lt;/strong&gt;! It'll print out the &lt;em&gt;data structure representing the computation&lt;/em&gt;, or some string &amp;quot;representing&amp;quot; the act of the computation!&lt;/p&gt;
&lt;p&gt;(At least, that's what it's supposed to do. Unfortunately, &lt;code&gt;IO&lt;/code&gt; data structures do not come built-in with a method for their string representation in vanilla Haskell. But the point remains that &lt;code&gt;print&lt;/code&gt; would &lt;em&gt;try&lt;/em&gt; to print out the data structure itself somehow, and not the actual result of the computation)&lt;/p&gt;
&lt;h2&gt;Instructions as Data Structures&lt;/h2&gt;
&lt;p&gt;Let's take a step back and think about what it even means to have a data structure representing computation.&lt;/p&gt;
&lt;p&gt;You can think about it as some kind of list/nested tree (or more accurately, a graph) of instructions for someone to follow. For the case of &lt;code&gt;IO Int&lt;/code&gt;, you can see it as, internally, some kind of tree/nested instruction set for someone to follow in order to produce an &lt;code&gt;Int&lt;/code&gt;. In the case of &lt;code&gt;IO&lt;/code&gt;, for GHC, the &amp;quot;someone&amp;quot; is a computer. Or more specifically, a processor. GHC directly translates any standalone IO object into assembly code (or even a less optimal C code).&lt;/p&gt;
&lt;p&gt;Technically, you &lt;em&gt;could&lt;/em&gt; &amp;quot;think&amp;quot; of every IO object as a self-contained and encapsulated little packet of assembly or C code that you can compose and nest and merge, etc. with other such packets, without worrying about the lower level code itself. But don't do this, or you risk confusing a possible representation of an object for the actual abstract object itself. (Think about it like saying that a mathematical matrix is a series of pencil swirls on a piece of paper.) But yes, at any time, you can &amp;quot;compile&amp;quot;/make concrete an IO object into standalone C code with GHC. This is actually a fact, and every IO object can be said to correspond directly with a chunk of C code.&lt;/p&gt;
&lt;p&gt;Really, though, there are many ways to &amp;quot;translate&amp;quot; this data structure into instructions for anyone to follow. &lt;a href="http://hackage.haskell.org/package/haste-compiler"&gt;Haste&lt;/a&gt;, for example, takes &lt;code&gt;IO&lt;/code&gt; data structure and turns it into something that can be run in a Javascript interpreter. That is, it takes something like &lt;code&gt;printFibN n&lt;/code&gt;, takes the internal tree instruction set, and writes it out concretely in javascript.&lt;/p&gt;
&lt;p&gt;In fact it would not be too hard to imagine a compiler that would take any arbitrary &lt;code&gt;IO&lt;/code&gt; structure and translate it into human-followable (yet very verbose) instructions on a piece of paper, written in plain English. Or French, for that matter.&lt;/p&gt;
&lt;p&gt;That is because that's all &lt;code&gt;IO&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; --- a tree/graph data structure representing an instruction series, that we assemble/build/compose using Haskell code. The same way you would assemble/build an array, or a dictionary, or a linked list in any other language.&lt;/p&gt;
&lt;h3&gt;Other Examples&lt;/h3&gt;
&lt;p&gt;It might help to think about similar &amp;quot;instruction-like&amp;quot; data structures.&lt;/p&gt;
&lt;p&gt;Take &lt;a href="http://hackage.haskell.org/package/persistent"&gt;Persistent&lt;/a&gt;, which (in some variants) provides the &lt;code&gt;SqlPersistM&lt;/code&gt; data structure. This data structure represents an interaction with an SQL Database. In other words, it represents a tree of instructions for interacting with one. When you give it to the Persistent library, it'll translate that &lt;code&gt;SqlPersistM&lt;/code&gt; into a series of &lt;strong&gt;SQL queries&lt;/strong&gt;! Yes, it produces actual SQL query strings, using the instructions from the data structure, executes them, and returns the result. An &lt;code&gt;SqlPersistM Int&lt;/code&gt; is an SQL interaction that returns an Int when run with the Persistent library.&lt;/p&gt;
&lt;p&gt;Then you have &lt;a href="http://hackage.haskell.org/package/parsec"&gt;Parsec&lt;/a&gt;, which provides a &lt;code&gt;Parsec&lt;/code&gt; data structure, which are &lt;em&gt;instructions for Parsec to parse a string&lt;/em&gt;. A &lt;code&gt;Parsec Int&lt;/code&gt; structure[^parsect] represents instructions for parsing a string into an &lt;code&gt;Int&lt;/code&gt;. When you give a &lt;code&gt;Parsec Int&lt;/code&gt; and a string to parse to the Parsec library, it will run the parse specified by the &lt;code&gt;Parsec&lt;/code&gt; object and return (hopefully) a parsed &lt;code&gt;Int&lt;/code&gt;. Remember, a &lt;code&gt;Parsec Int&lt;/code&gt; object does &lt;em&gt;not&lt;/em&gt; actually &amp;quot;parse&amp;quot; anything; It is &lt;em&gt;used by Parsec&lt;/em&gt; to parse a string and return an &lt;code&gt;Int&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;The reason why we use these data structures in Haskell, instead of actually writing SQL queries and parsing rules from scratch, is because they become &lt;em&gt;composable&lt;/em&gt;. SQL queries? Not very composable. Parsing rules? Not exactly, either. In this way, you can build complex SQL queries without ever touching a query string by composing simple queries. You can create very complex and intricate parsing rules without every having to &amp;quot;worry&amp;quot; about actually writing the parser: you just compose simple, smaler parsers.&lt;/p&gt;
&lt;p&gt;And this is really what Haskell &amp;quot;does best&amp;quot; (and possibly what Haskell was really made for): assembling and composing these possibly complex instruction data structures in a pure way and &amp;quot;passing them on&amp;quot; to things that can take them and use them to do great things. An &lt;code&gt;SqlPersistM&lt;/code&gt; is used by Persistent, a &lt;code&gt;Parsec&lt;/code&gt; is used by Parsec, and an &lt;code&gt;IO&lt;/code&gt; is used by...well, what? A computer!&lt;/p&gt;
&lt;h2&gt;The &amp;quot;Main&amp;quot; Point&lt;/h2&gt;
&lt;p&gt;So now we see that Haskell has no problems returning a data structure that represents computer instructions (well, at least, Haskell's standard library handles all of it for us by giving us useful instruction primitives that we can build more complex instructions from).&lt;/p&gt;
&lt;p&gt;Now we have an instruction object. How do we actually get a computer to use and execute it?&lt;/p&gt;
&lt;p&gt;For this, we rely on convention (or arbitrary specification, however you like to see it). A Haskell compiler will &amp;quot;understand&amp;quot; your data structures, and it picks &lt;strong&gt;one&lt;/strong&gt; of them to compile into a binary format for your computer (or whatever format your executing environment reads best). Out of all of the IO objects you can return/represent, the Haskell compiler chooses one of them to be the one it actually compiles into computer-readable code.&lt;/p&gt;
&lt;p&gt;And by convention/specification, it is the IO object with the name &amp;quot;main&amp;quot;:&lt;/p&gt;
&lt;p&gt;~~~haskell -- printFibN: returns a computation that represents the act of printing the -- nth Fibonacci number to stdout and returns () (Nothing). printFibN :: Int -&amp;gt; IO () printFibN n = print (fib n)&lt;/p&gt;
&lt;p&gt;-- main: The IO object that we agree that the compiler will actually compile. main :: IO () main = printFibN 10 ~~~&lt;/p&gt;
&lt;p&gt;And here we are. A full, executable Haskell program. You can &lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/io-purity/IO-Purity.hs"&gt;download and run it yourself&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As we can see, every function or declaration that makes up our program is completely pure and side-effectless. In fact, the assembly of &lt;code&gt;main&lt;/code&gt; itself is side-effectless and pure. We assemble the &lt;code&gt;IO ()&lt;/code&gt; that &lt;code&gt;main&lt;/code&gt; returns in a pure way. &lt;code&gt;printFibN 10&lt;/code&gt; will return the exact same computation representation every single time we run it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printFibN 10&lt;/code&gt; is &lt;strong&gt;pure&lt;/strong&gt;. Every time we &lt;em&gt;evaluate&lt;/em&gt; &lt;code&gt;printFibN 10&lt;/code&gt;, we get the exact same computation representation/instruction list.&lt;/p&gt;
&lt;p&gt;Therefore, &lt;code&gt;main&lt;/code&gt; is pure, as well. Every time we evaluate &lt;code&gt;main&lt;/code&gt;, we get the exact same computational data structure.&lt;/p&gt;
&lt;h3&gt;Purity challenged?&lt;/h3&gt;
&lt;p&gt;Now consider:&lt;/p&gt;
&lt;p&gt;~~~haskell -- getStringFromStdin: returns a computation that represents the act of -- getting a string from stdin getStringFromStdin :: IO String getStringFromStdin = getLine&lt;/p&gt;
&lt;p&gt;-- main: The IO object that we agree that the compiler will actually compile. main :: IO () main = getStringFromStdin &amp;gt;&amp;gt;= (\result -&amp;gt; print result) ~~~&lt;/p&gt;
&lt;p&gt;(Sample can be &lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/io-purity/Challenge.hs"&gt;downloaded and run&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(An aside: &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; here is an operator that takes the result of the left hand side's computation and passes it as a parameter to the right hand side. Essentially, it turns two IO computation data structures and combines/chains them into one big one. The &lt;code&gt;(\x -&amp;gt; print x)&lt;/code&gt; syntax says &amp;quot;take the &lt;code&gt;x&lt;/code&gt; passed to you and use it in &lt;code&gt;print x&lt;/code&gt;&amp;quot;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; gets something from the standard input, and then prints it.&lt;/p&gt;
&lt;p&gt;Oh wait. This means that if I type something different into standard input, the program will return something different, right? How is this pure?&lt;/p&gt;
&lt;p&gt;Here is the crucial difference between &lt;strong&gt;evaluation&lt;/strong&gt; and &lt;strong&gt;execution&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; will always &lt;strong&gt;evaluate&lt;/strong&gt; to the exact same computation data structure.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; will always be the &lt;em&gt;exact&lt;/em&gt; same program, no matter when you run it. (In particular, the program that gets a string from stdin and prints it)&lt;/p&gt;
&lt;p&gt;The computer/processor --- which is given a binary representation of the IO data structure, and is completely separate from the language itself --- now &lt;strong&gt;executes&lt;/strong&gt; this binary/compiled data structure/program. Its execution of this binary is, of course, potentially unpredictable and in general non-deterministic, and can depend on things like the temperature, the network connection, the person at the keyboard, the database contents, etc. The &lt;em&gt;instructions/binary&lt;/em&gt; that it follows will be the same every time. The &lt;em&gt;result&lt;/em&gt; of those instructions will be different every time (as someone who has ever attempted to bake a cake can testify).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; is a function that returns/evaluates deterministically to a data structure representing a computation.&lt;/p&gt;
&lt;p&gt;The computation that it represents is not necessarily deterministic.&lt;/p&gt;
&lt;p&gt;This distinction between &lt;strong&gt;evaluation&lt;/strong&gt; and &lt;strong&gt;execution&lt;/strong&gt; is what sets apart this I/O model that permits its purity.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; is a pure value. The instruction data structure &lt;code&gt;main&lt;/code&gt; represesents impure instructions.&lt;/p&gt;
&lt;p&gt;And &lt;em&gt;that&lt;/em&gt; is how we can deal with I/O in Haskell while remaining a pure language.&lt;/p&gt;
&lt;h3&gt;Illustrating the difference&lt;/h3&gt;
&lt;p&gt;To really understand the difference between evaluation and execution, let's look at this example:&lt;/p&gt;
&lt;p&gt;~~~haskell ignoreAndSayHello :: IO a -&amp;gt; IO () ignoreAndSayHello to_ignore = print &amp;quot;Hello!&amp;quot;&lt;/p&gt;
&lt;p&gt;main :: IO () main = ignoreAndSayHello getStringFromStdin ~~~&lt;/p&gt;
&lt;p&gt;What does this program do?&lt;/p&gt;
&lt;p&gt;Naively, we expect it to ask for a string from standard input, ignore the result, and print &amp;quot;Hello!&amp;quot;.&lt;/p&gt;
&lt;p&gt;Actually, this is &lt;strong&gt;not&lt;/strong&gt; what it does.&lt;/p&gt;
&lt;p&gt;This is because &lt;code&gt;ignoreAndSayHello getStringFromStdin&lt;/code&gt; will evaluate to &lt;code&gt;print &amp;quot;Hello&amp;quot;&lt;/code&gt; (remember, it ignores its argument). So &lt;code&gt;main&lt;/code&gt; evaluates to one single IO action: &lt;code&gt;print &amp;quot;Hello!&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So your program returns the simple IO action &lt;code&gt;print &amp;quot;Hello!&amp;quot;&lt;/code&gt; --- the computation returned by &lt;code&gt;main&lt;/code&gt; therefore simply prints &amp;quot;Hello!&amp;quot;. This computation does not represent anything that would ask for input.&lt;/p&gt;
&lt;p&gt;The &amp;quot;real&amp;quot; way to do this would be:&lt;/p&gt;
&lt;p&gt;~~~haskell ignoreAndSayHello :: IO a -&amp;gt; IO () ignoreAndSayHello to&lt;em&gt;ignore = to&lt;/em&gt;ignore &amp;gt;&amp;gt;= (\result -&amp;gt; print &amp;quot;Hello!&amp;quot;)&lt;/p&gt;
&lt;p&gt;main :: IO () main = ignoreAndSayHello getStringFromStdin ~~~&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; &amp;quot;combines&amp;quot; two IO objects into one. It returns a new IO object that takes the result of the left-hand side and uses it as an argument to the right hand side. Easy, right?&lt;/p&gt;
&lt;h2&gt;Ordering&lt;/h2&gt;
&lt;p&gt;One major implication that is apparent throughout this entire process is that statements in Haskell have &lt;strong&gt;no inherent order&lt;/strong&gt;. As we saw, we had a list of declaration of many different IO actions --- none of which were necessarily evaluated or executed. There is no sense of &amp;quot;this function is 'first', this function is 'second'&amp;quot;. Indeed, the idea of ordering makes no sense when you think of things as mathematical functions.&lt;/p&gt;
&lt;p&gt;While there is no &amp;quot;first&amp;quot; or &amp;quot;second&amp;quot;, there is a &lt;code&gt;main&lt;/code&gt;, which is the function the compiler/interpreter passes to the runtime environment as the computation we agree to run. &amp;quot;Order&amp;quot; arrives at this point. We explicity &amp;quot;create&amp;quot; an IO data structure and specify the ordering implicitly with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;. More specifically, &lt;code&gt;print&lt;/code&gt; requires the result of &lt;code&gt;getStringFromStdin&lt;/code&gt;, so there arises the first semblances of &amp;quot;ordering&amp;quot;: in the explicit composition of different IO actions into one big one.&lt;/p&gt;
&lt;p&gt;As it turns out, there is a &lt;a href="http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/"&gt;nice blog post&lt;/a&gt; by Chris Taylor illustrating how this wordering ordering could be implemented in the internal data structure of IO.&lt;/p&gt;
&lt;p&gt;Long story short, &lt;code&gt;IO&lt;/code&gt;'s interface provides features to chain and combine IO actions into one big IO action, as we did before with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This interface creates dependency trees in the internal IO data structure that enforces ordering.&lt;/p&gt;
&lt;p&gt;But the real story is that outside of the internals of a single &lt;code&gt;IO&lt;/code&gt;, there is no inherent ordering --- not even between different &lt;code&gt;IO&lt;/code&gt; objects!&lt;/p&gt;
&lt;h2&gt;Resolution&lt;/h2&gt;
&lt;p&gt;In retrospect, the solution seems obvious. A functional program does what it does best --- return an object, purely. This object is the actual computation itself, which can be pure or impure, deterministic or nondeterministic --- we just pass it off, and the execution environment can do whatever it wants with it. Not our problem anymore! This is the difference between evaluation (the pure process) and execution (the impure one).&lt;/p&gt;
&lt;p&gt;We have the best of both worlds. Purity and...well, usefulness!&lt;/p&gt;
&lt;p&gt;In fact, because of how Haskell is structured...an impure function does not even make sense. How would one even write a traditional &amp;quot;impure&amp;quot; function in this language? The language itself is centered around the idea of composing computation instruction data types. What would an impure function even look like? Even if it were possible, impurity would be a jarring, unnatural adjustment to the language that doesn't even really &amp;quot;make sense&amp;quot;.&lt;/p&gt;
&lt;p&gt;More importantly, however, there isn't really any other way Haskell could handle this and still feel Haskell. The reason for this is that this is why Haskell succeeds where other languages struggle: Though we have only seen a glimpse of this in this in this article, Haskell provides very specialized tools for assembling and composing complex instruction data structures that make it extremely simple, expressive, and elegant. Tools for combining two parsing rules into one. Tools for combining two SQL operations into one. For a language that handles computational data structures so well, &lt;em&gt;not&lt;/em&gt; handling IO this way would be a real shame!&lt;/p&gt;
&lt;h3&gt;Why?&lt;/h3&gt;
&lt;p&gt;One might ask about the usefulness of this whole thing. After all, don't most languages &amp;quot;compile&amp;quot; to the same assembly code every time? Why this game?&lt;/p&gt;
&lt;p&gt;The reason is that we can now deal with programs --- entire chunks of assembly code --- as first-class objects. You can pass in computational instruction objects to a function the same way you can pass any normal object. You can have two separate little &amp;quot;assembly code chunks&amp;quot; in complete isolation...and then you can combine them if you want, as well. You can easily introduce parallel forks --- you can always pass in an &amp;quot;assembly code chunk&amp;quot;, so why not pass an IO object into a fork function? Every separate IO object is self-contained and manipulatable. This fact is also true for the other &amp;quot;instruction set&amp;quot;-like objects mentioned earlier. You can build them up and compose them and pass them as first-class things.&lt;/p&gt;
&lt;p&gt;And like we said before, you get all the benefits of &lt;a href="http://u.jle.im/19JxV5S"&gt;equational reasoning&lt;/a&gt; because you're dealing with pure &amp;quot;inert&amp;quot; compositions --- this is something you could never get if you dealt with executing the actual functions themselves!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html</guid><pubDate>Tue, 12 Nov 2013 19:37:27 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Ramblings</subject><date>2013-11-12</date></item><item><title>A Brief Primer on Classical and Quantum Mechanics for Numerical Techniques</title><link>https://blog.jle.im/entry/a-brief-primer-on-classical-and-quantum-mechanics.html</link><description>&lt;p&gt;Okay! In this series we will be going over many subjects in both physics and computational techniques, including the Lagrangian formulation of classical mechanics, basic principles of quantum mechanics, the Path Integral formatulion of quantum mechanics, the Metropolis-Hastings Monte Carlo method, dealing with entropy and randomness in a pure language, and general principles in numerical computation! Fun stuff, right?&lt;/p&gt;
&lt;p&gt;The end product will be a tool for deriving the ground state probability distribution of arbitrary quantum systems, which is somewhat of a big deal in any field that runs into quantum effects (which is basically every modern field). But the real goal will be to hopefully impart some insight that can be applied to broarder and more abstract applications. I am confident that these techniques can be applied to many problems in computation to great results.&lt;/p&gt;
&lt;p&gt;I'm going to assume little to no knowledge in Physics and a somewhat intermediate working knowledge of programming. We're going to be working in both my favorite imperative language and my favorite functional language.&lt;/p&gt;
&lt;p&gt;In this first post I'm just going to go over the basics of the physics before we dive into the simulation. Here we go!&lt;/p&gt;
&lt;h2&gt;Classical Mechanics&lt;/h2&gt;
&lt;h3&gt;Newtonian Mechanics&lt;/h3&gt;
&lt;p&gt;Mechanics has always been a field in physics that has held a special place in my heart. It is most likely the field most people are first exposed to in a physics course. To me, there really is no more fundamental and pure form of physics. I mean...it's the study of how things move under forces. How can you get any deeper to the heart of physics than that?&lt;/p&gt;
&lt;p&gt;When most people think of mechanics, they think of $F = m a$, inertia, and that every reaction has an equal and opposite re-action. These are Newton's &amp;quot;Laws of Motion&amp;quot; and they provide what can be referred to as a &amp;quot;state-updating function&amp;quot;: Given a state of the world at time $t&lt;em&gt;0$, Newton's laws can be used to &amp;quot;generate&amp;quot; the state of the world at time $t&lt;/em&gt;0 + \Delta t$.&lt;/p&gt;
&lt;p&gt;This sounds pretty useful, but it wasn't long before physicists began wishing they had other tools with which to study the mechanics of certain systems. Newton's equations worked very well for the cases that made it famous, but were surprisingly unuseful, impractical, or clumsy in many others. And when we talk about relativity, where things like $\Delta t$ can't even be trivially defined, it is almost completely useless without complicated modifications.&lt;/p&gt;
&lt;p&gt;So it was almost exactly one hundred years after Newton's laws that two people named &lt;a href="http://en.wikipedia.org/wiki/Joseph-Louis_Lagrange"&gt;Lagrange&lt;/a&gt; and &lt;a href="http://en.wikipedia.org/wiki/Leonhard_Euler"&gt;Euler&lt;/a&gt; (who is the &amp;quot;e&amp;quot; in $e$) followed a wild hunch that ended up paying off.&lt;/p&gt;
&lt;h3&gt;Lagrangian Mechanics&lt;/h3&gt;
&lt;p&gt;To understand Lagrangian Mechanics, we must abandon our idea of &amp;quot;force&amp;quot; as the fundamental phenomenon. Instead of forces, we deal with &amp;quot;potential fields&amp;quot;.&lt;/p&gt;
&lt;p&gt;You can imagine potential fields as a roller coaster track, or as a landscape of rolling grassy hills. The height of a track or a landscape at that point corresponds to the value of the potential at that point. Potential fields work like this: Every object &amp;quot;wants&amp;quot; to go &lt;em&gt;downwards&lt;/em&gt; in a potential field --- it will want to go in the direction (backwards/forwards for the roller coaster, north/south/east/west for the hilly landscape) that will take it downwards. We don't care why, or how --- it just &amp;quot;wants&amp;quot; to. And the steeper the downwardness, the greater the compulsion.&lt;/p&gt;
&lt;p&gt;We call this potential field $U(\vec{r})$, which means &amp;quot;$U$ at the point $\vec{r}$&amp;quot;. ($\vec{r}$ denotes a point in space)&lt;/p&gt;
&lt;p&gt;Relating this to $F = m a$, the force on the object is now equal to the steepness of the potential field at the point where the object is, and in the direction that would allow the object to go downwards in potential. Objects always wish to minimize their potential, and do so as fast as they can. In mathematical terminology, we say that $F(\vec{r}) = - \vec{\nabla} U(\vec{r})$.&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/entries/path-integral-intro/potential3d.png" title="An example of a 2D potential $U(\vec{r})$." alt="An example of a 2D potential $U(\vec{r})$." /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/entries/path-integral-intro/gradient.png" title="Top-down view of the potential in the previous figure, overlayed with arrows indicating the direction and magnitude of $F(\vec{r})$." alt="Top-down view of the potential in the previous figure, overlayed with arrows indicating the direction and magnitude of $F(\vec{r})$." /&gt;&lt;/p&gt;
&lt;p&gt;Now, for Lagrangian Mechanics:&lt;/p&gt;
&lt;p&gt;Let's say I tell you an object's location at time $t&lt;em&gt;0$, and its location later at time $t&lt;/em&gt;1$, and the potential energy field. What path did that object take to get from point A to point B?&lt;/p&gt;
&lt;p&gt;A pretty open question, right? You don't really have that much information to go off of. You just know point A and point B. It could have taken any path, for all we know! If we only knew $F = m a$, not only would we be at a complete loss at how to even start, but we wouldn't even know if there was only one or even a hundred valid paths a particle could have taken.&lt;/p&gt;
&lt;p&gt;The solution to this problem is actually rather unexpected. Consider every single path/curve from point A to point B. Every single one. Now, assign each path a number known as the &lt;strong&gt;Action&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For every point, add up the &amp;quot;Kinetic Energy&amp;quot; at that point, which, for classical mechanics, is the square of the object's speed multiplied by $\frac{1}{2} m$.&lt;/li&gt;
&lt;li&gt;For every point, add up $U(\vec{r})$ at that point.&lt;/li&gt;
&lt;li&gt;Subtract (2) from (1).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Think about every possible path. Calculate the action for each one. The path that the object takes is &lt;em&gt;the path with the lowest action&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It's almost as if the object &amp;quot;does the math&amp;quot; in its head: &amp;quot;I'm going to go from here to there...let me calculate which path I can take has the lowest action. Okay, got it!&amp;quot;&lt;/p&gt;
&lt;p&gt;Lagrangian Mechanics provides for us a way to find out just what path an object must have taken to get from point A to point B.&lt;/p&gt;
&lt;p&gt;As it turns out, looking at things this way opens up entire worlds of understanding. For example, just from this, we find that &lt;em&gt;total energy is conserved&lt;/em&gt; over time for a closed system (trust me on this; the calculus is slightly tricky). We also have a formulation that works fine under Special Relativity in all frames of reference with almost no tweaks. And yes, if you actually do find the path of lowest action, the path will somehow magically always follow the state-updating equations $F = m a$. It's just now we have a much more insighftul and meaningful way to look at the universe:&lt;/p&gt;
&lt;p&gt;Paths &lt;strong&gt;always attempt to minimize their action&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Okay. We don't have that much time to spend on this, or its philosophical implications, so we're going to move on now to Quantum Mechanics.&lt;/p&gt;
&lt;h2&gt;Quantum Mechanics&lt;/h2&gt;
&lt;h3&gt;SchrÃ¶dinger Formulation&lt;/h3&gt;
&lt;p&gt;If there was one thing that &amp;quot;everyone&amp;quot; knew about quantum mechanics, it would either be &lt;a href="http://en.wikipedia.org/wiki/Schr%C3%B6dinger&amp;#39;s_cat"&gt;ScrÃ¶dinger's Cat&lt;/a&gt; or the fact that objects are no longer &amp;quot;for sure&amp;quot; anywhere. They are only &lt;em&gt;probably&lt;/em&gt; somewhere.&lt;/p&gt;
&lt;p&gt;How can we then analyze the behavior of &lt;em&gt;anything&lt;/em&gt;? If everything is just a probability, and nothing is certain, we can't really use the same &amp;quot;state-updating functions&amp;quot; that we used to rely on, because the positions and velocities of the objects in question don't even have well-defined values.&lt;/p&gt;
&lt;p&gt;Physicists' first solutions involved creating a new &amp;quot;state&amp;quot; that did not involve particles at all. This &amp;quot;state&amp;quot; described the state of the universe, but not in terms of particles and positions and velocities. It is a new &lt;em&gt;abstract&lt;/em&gt; state. Then, they invented the equivalent of an $F = m a$ for this abstract state --- an equation that, for every abstract state at time $t&lt;em&gt;0$, gives you the abstract state at time $t&lt;/em&gt;0 + \Delta t$.&lt;/p&gt;
&lt;p&gt;This approach is useful...just like $F = m a$ was useful. But it inherits all of the problems of $F = m a$. How can we apply what we learned about actions and Lagrangian mechanics to Quantum Mechanics? How do we make Lagrangian mechanics &amp;quot;quantum&amp;quot;?&lt;/p&gt;
&lt;h3&gt;Path Integral Formulation&lt;/h3&gt;
&lt;p&gt;The answer is a bit simple, actually.&lt;/p&gt;
&lt;p&gt;Instead of saying &amp;quot;the object will chose the path with the least action&amp;quot;, we say &lt;strong&gt;the object chooses a random path, choosing lower-action paths more often&lt;/strong&gt;. That is, if an electron is shot from point A to point B, the electron picks a random path from point A to point B. It is a &lt;em&gt;weighted random choice&lt;/em&gt; based on the action of each path --- if Path $\alpha$ has lower action than Path $\beta$, the electron will pick path $\alpha$ more often than path $\beta$.&lt;/p&gt;
&lt;p&gt;There are some small technical differences (the process of calculating the action is slightly different, and you end up summing over complex numbers for certain reasons), but the fundamental principle remains the same.&lt;/p&gt;
&lt;p&gt;So say we have an electron floating around a hydrogen atom (a hydrogen atom creates a very pretty and easy to work with potential field). We know it is at point A at time $t&lt;em&gt;0$, and point B at time $t&lt;/em&gt;1$. What path did the electron take to get there?&lt;/p&gt;
&lt;p&gt;Simple: We don't know. But we can say that it &lt;em&gt;probably&lt;/em&gt; took the path with the least action. It &lt;em&gt;could have also&lt;/em&gt; taken the path with the &lt;em&gt;second to least&lt;/em&gt; action...but that's just slightly less likely. It &lt;em&gt;probably did not&lt;/em&gt; take the path with the greatest action...but who knows --- it might have! It's like it rolls a dice to determine which path it goes on, but the dice is weighted so that lower-action paths are rolled more often than higher-action paths.&lt;/p&gt;
&lt;p&gt;The electron &lt;em&gt;wants&lt;/em&gt; to take the lowest-action path...but sometimes decides not to.&lt;/p&gt;
&lt;p&gt;So now we see what Lagrangian Mechanics in classical mechanics really &lt;em&gt;is&lt;/em&gt;: It's quantum mechanics, except that the lowest-action path is &lt;em&gt;so much likelier&lt;/em&gt; than any other path that we almost never see the second-to-least action path taken.&lt;/p&gt;
&lt;p&gt;As it turns out, like Lagrangian mechanics opened eyes to new worlds in classical mechanics, the Path Integral formulation[^naming] of quantum mechanics opened up totally new worlds that the previous &amp;quot;state updating formula&amp;quot; approach could have never dreamed of.&lt;/p&gt;
&lt;h2&gt;Implications&lt;/h2&gt;
&lt;p&gt;Okay, so what does this all have to do with us?&lt;/p&gt;
&lt;p&gt;How many processes do we know that can be modeled by something trying to minimize itself, but not always succeeding? What data patterns can be unveiled by modeling things this way?&lt;/p&gt;
&lt;p&gt;I'll leave this question slightly open-ended, but I'm also going to hint at the next installment's contents.&lt;/p&gt;
&lt;h3&gt;Particle in a potential&lt;/h3&gt;
&lt;p&gt;Let's go back again to our electron next to an atom. Let's say that this electron will move around and return back to its current position at time $t_0 + \Delta t$, for very large $\Delta t$. From what we learned, this electron can really take any path it wants, going anywhere in the universe and back again. Any closed loop that that zig zags or curls anywhere is a valid path.&lt;/p&gt;
&lt;p&gt;We can &amp;quot;pick&amp;quot; a random path, weighted by the action, and see where the electron goes in that path. See where we find the electron along points in the path. After many picks, we start seeing where the electron is &amp;quot;most likely to be&amp;quot;. We find the probability distribution of an electron in that potential.&lt;/p&gt;
&lt;p&gt;We now have a way, given any quantum potential, to find the probability distribution of a particle in that potential.&lt;/p&gt;
&lt;p&gt;From here we can also find the particle's average energy, and many other properties of a particle given an arbitrary quantum potential.&lt;/p&gt;
&lt;p&gt;Now let's implement it.&lt;/p&gt;</description><author>Justin Le</author><category>Physics</category><category>Computation</category><guid isPermaLink="true">https://blog.jle.im/entry/a-brief-primer-on-classical-and-quantum-mechanics.html</guid><pubDate>Sat, 30 Nov 2013 00:32:12 UTC</pubDate><creator>Justin Le</creator><subject>Physics, Computation</subject><date>2013-11-30</date></item><item><title>Practical Fun with Monads --- Introducing: MonadPlus!</title><link>https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.html</link><description>&lt;p&gt;Monads. Haskell's famous for them, but they are one of the most ill-understood concepts to the public. They are mostly shrouded in mystery because of their association with how Haskell models I/O. This reputation is undeserved. Monads don't have anything to do with I/O.&lt;/p&gt;
&lt;p&gt;This series is a part of a global effort to pull away the shroud of mystery behind monads and show that they are fun! And exciting! And really just a way of chaining together functions that allow for new ways of approaching puzzles.&lt;/p&gt;
&lt;p&gt;The first sub-series (chapter?) will be on a specific class/family of monads known as &lt;em&gt;MonadPlus&lt;/em&gt;. At the end of it all, we are going to be solving the classic logic puzzle, as old as time itself, using &lt;strong&gt;only&lt;/strong&gt; the List monad instance, and no loops, queues, or fancy stuff like that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can't leave the wolf alone with the goat, or the wolf will eat the goat. He can't leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let us enter a brave new world!&lt;/p&gt;
&lt;h3&gt;A quick review of monads&lt;/h3&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This article is written for both beginners --- people who have a fuzzy idea of monads and a minimal understanding of functional programming principles, but who have some experience in Object-Oriented Programming in a language like Java or C++ --- and intermediate Haskell users --- people who have a somewhat firm grasp on monads, but want to know about monads on a broader context (in particular, the MonadPlus typeclass).&lt;/p&gt;
&lt;p&gt;Intermediate Haskell users will most likely find this post to be review, and I'll put a link in this paragraph when the next part is up so we can get to &amp;quot;real&amp;quot; Haskelling. However, this post might be beneficial if you read it while asking, at every point, &amp;quot;How can this be abstracted and generalized?&amp;quot;. It's a fun exercise!&lt;/p&gt;
&lt;p&gt;This article attempts to explain all Haskell syntax that might be foreign to beginners. That being said, if you ever run into anything you can't understand, feel free to either read the articles above, give &lt;a href="http://learnyouahaskell.com/"&gt;Learn You A Haskell&lt;/a&gt; a quick read (you won't regret it!), or leave a comment --- I'd love to answer your questions or hear your responses!&lt;/p&gt;
&lt;p&gt;This first post will cover the basics of MonadPlus with the simplest MonadPlus of all; the second part will explore the List MonadPlus, and the third will finally tackle the Wolf/Goat/Cabbage puzzle with our combined knowledge. &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;Okay, so as a Haskell blogger, I'm actually not allowed to write any monad tutorials. Luckily for you, however, I don't need too --- there are a wealth of great ones. &lt;a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html"&gt;Adit provides a great concise one&lt;/a&gt;, and, if you want, &lt;a href="http://www.haskell.org/haskellwiki/All_About_Monads"&gt;a more in depth one&lt;/a&gt; is on the haskell.org wiki about all sorts of monads and using them in real life.&lt;/p&gt;
&lt;p&gt;Remember --- different monads do not actually have any non-superficial relationship to one another. When we say monads, we just mean objects for which we have defined a way to chain together functions &amp;quot;inside&amp;quot; wrappers, containers, or contexts.&lt;/p&gt;
&lt;h2&gt;Maybe, maybe not&lt;/h2&gt;
&lt;p&gt;Monads are very useful when you are dealing with objects that are containers. Let's look at the most obvious container -- a &lt;code&gt;Maybe a&lt;/code&gt;. A &lt;code&gt;Maybe a&lt;/code&gt; is a container that can either be &lt;code&gt;Just x&lt;/code&gt; (representing a successful result &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt;) or a &lt;code&gt;Nothing&lt;/code&gt; (representing a failed result).&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hi! These &amp;quot;Welcome to Haskell&amp;quot; asides are going to be for you readers that are unfamiliar with Haskell syntax. Feel free to ignore them if you already feel comfortable.&lt;/p&gt;
&lt;p&gt;Anyways, if you've ever done any object-oriented programming, you might be able to think of &lt;code&gt;Maybe a&lt;/code&gt; as an abstract/virtual superclass with templates/generics --- &lt;code&gt;Maybe&amp;lt;a&amp;gt;&lt;/code&gt;, kinda. And that superclass has two subclasses: &lt;code&gt;Just&amp;lt;a&amp;gt;&lt;/code&gt;, which has one public instance variable &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;Nothing&lt;/code&gt;, which contains no instance variables. &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;Often times you'll have functions that fail, and you want to chain them. The easiest way is that any function that is chained onto a failed value will be skipped; a failure is the final result.&lt;/p&gt;
&lt;p&gt;Consider the &lt;code&gt;halve&lt;/code&gt; function, which returns &lt;code&gt;Just (x `div` 2)&lt;/code&gt; on a successful halving, or &lt;code&gt;Nothing&lt;/code&gt; on an unsuccessful halving:&lt;/p&gt;
&lt;p&gt;~~~haskell halve :: Int -&amp;gt; Maybe Int -- 1 halve x | even x = Just (x &lt;code&gt;div&lt;/code&gt; 2) -- 2 | otherwise = Nothing -- 3 ~~~&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hi again! There are some quick syntax features here.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;This first line declares that the type of the function &lt;code&gt;halve&lt;/code&gt; is &lt;code&gt;Int -&amp;gt; Maybe Int&lt;/code&gt;, which means that it takes in an &lt;code&gt;Int&lt;/code&gt; and returns a &lt;code&gt;Maybe Int&lt;/code&gt; --- an integer wrapped in a &amp;quot;Maybe&amp;quot; container.&lt;/li&gt;
&lt;li&gt;This says that if x is even, then return a successful &lt;code&gt;Just (x `div` 2)&lt;/code&gt;. &lt;code&gt;x `div` 2&lt;/code&gt; is x divided by two, in case you couldn't guess already.&lt;/li&gt;
&lt;li&gt;Otherwise, return &lt;code&gt;Nothing&lt;/code&gt; --- a failure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;Because Maybe comes built-in as a monad, we can now chain &lt;code&gt;halve&lt;/code&gt;s on results of other &lt;code&gt;halves&lt;/code&gt;, and have any failures automatically propagate to the end and short circuit your entire computation:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; halve 8 Just 4 ghci&amp;gt; halve 7 Nothing ghci&amp;gt; halve 8 &amp;gt;&amp;gt;= halve Just 2 ghci&amp;gt; halve 7 &amp;gt;&amp;gt;= halve Nothing -- 1 ghci&amp;gt; halve 6 &amp;gt;&amp;gt;= halve Nothing ghci&amp;gt; halve 6 &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve Nothing ghci&amp;gt; halve 32 &amp;gt;&amp;gt; Nothing Nothing -- 2 ghci&amp;gt; halve 32 &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve Just 2 ghci&amp;gt; halve 32 &amp;gt;&amp;gt; Nothing &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve Nothing -- 3 ~~~&lt;/p&gt;
&lt;p&gt;You can play with this yourself by &lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/Halve.hs"&gt;loading up the function yourself&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this article, code that begins with &lt;code&gt;ghci&amp;gt;&lt;/code&gt; represents commands to be entered at the interactive prompt, ghci. Code that doesn't is actual source code. &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; means &amp;quot;use the results of the last thing to calculate this next thing&amp;quot; --- it &amp;quot;chains&amp;quot; the functions.&lt;/p&gt;
&lt;p&gt;How does this work, exactly? That's not really in the scope of this article (any monad tutorial will explain this in more detail). But here are some interesting points:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Note that this command doesn't even bother with the second &lt;code&gt;halve&lt;/code&gt;. It knows that the end result will be &lt;code&gt;Nothing&lt;/code&gt; no matter what (because &lt;code&gt;halve 7&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt;), so it just skips right past the second &lt;code&gt;halve&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a special variation of &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; says &amp;quot;take the result of the last thing and use it on this&amp;quot;, while &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; says &amp;quot;ignore the result of the last thing and always return this&amp;quot;. So &lt;code&gt;&amp;gt;&amp;gt; Nothing&lt;/code&gt; means &amp;quot;I don't care what the last thing succeeded with, I'm going to fail right here.&amp;quot;&lt;/li&gt;
&lt;li&gt;Disastrous! Even though halving 32 four times usually is fine (giving &lt;code&gt;Just 2&lt;/code&gt;), having just one failure along the way means that the entire thing is a failure. &lt;code&gt;halve 32 &amp;gt;&amp;gt; Nothing&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt;, so the whole thing is just &lt;code&gt;(Nothing) &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can think of this failing phenomenon like this: At every step, Haskell attempts to apply &lt;code&gt;halve&lt;/code&gt; to the result of the previous step. However, you can't &lt;code&gt;halve&lt;/code&gt; a &lt;code&gt;Nothing&lt;/code&gt; because a &lt;code&gt;Nothing&lt;/code&gt; has no value to halve!&lt;/p&gt;
&lt;h3&gt;Do notation&lt;/h3&gt;
&lt;p&gt;Haskell provides a convenient way of writing chained &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;'s called do notation; here are a few samples matched with their equivalent &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; form:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; half 8 Just 4 ghci&amp;gt; do half 8 Just 4&lt;/p&gt;
&lt;p&gt;ghci&amp;gt; halve 8 &amp;gt;&amp;gt;= halve Just 2 ghci&amp;gt; do x &amp;lt;- halve 8 | halve x Just 2&lt;/p&gt;
&lt;p&gt;ghci&amp;gt; halve 32 &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve Just 2 ghci&amp;gt; do x &amp;lt;- halve 32 | y &amp;lt;- halve x | z &amp;lt;- halve y | halve z Just 2&lt;/p&gt;
&lt;p&gt;ghci&amp;gt; halve 32 &amp;gt;&amp;gt; Nothing &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve Nothing ghci&amp;gt; do x &amp;lt;- halve 32 | Nothing | y &amp;lt;- halve x | z &amp;lt;- halve y | halve z Nothing ~~~&lt;/p&gt;
&lt;p&gt;In this notation, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;'s do not contain the &lt;code&gt;Just&lt;/code&gt;/&lt;code&gt;Nothing&lt;/code&gt;'s --- they represent the actual &lt;strong&gt;Ints inside them&lt;/strong&gt;, so we can so something like &lt;code&gt;halve x&lt;/code&gt; (where &lt;code&gt;halve&lt;/code&gt; only takes Ints, not &lt;code&gt;Maybe Int&lt;/code&gt;'s)&lt;/p&gt;
&lt;p&gt;It kind of feels very imperative-y --- &amp;quot;do &lt;code&gt;halve 32&lt;/code&gt; and assign the result (16) to &lt;code&gt;x&lt;/code&gt;...do &lt;code&gt;halve x&lt;/code&gt; and assign the result (8) to &lt;code&gt;y&lt;/code&gt;...&amp;quot; --- but remember, it's still just a bunch of chained &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;s in the end.&lt;/p&gt;
&lt;h2&gt;Failure is an option&lt;/h2&gt;
&lt;p&gt;The important thing to note here is that &amp;quot;do&amp;quot; notation basically builds up one &amp;quot;giant&amp;quot; object. Remember the last two examples --- the second to last one, all of those lines were in an effort to build one giant &lt;code&gt;Just 2&lt;/code&gt; value. In the last example, all of those lines were in an effort to build one giant &lt;code&gt;Nothing&lt;/code&gt; value. That's why one &lt;code&gt;Nothing&lt;/code&gt; &amp;quot;ruined&amp;quot; the whole thing. The entire computation is one big &lt;code&gt;Maybe a&lt;/code&gt;. If at any point in your attempt to build that &lt;code&gt;Maybe a&lt;/code&gt;, you fail, then you have &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, remember, saying &amp;quot;x is a monad&amp;quot; just means &amp;quot;we have defined a way of chaining functions/operations on x&amp;quot;. Just like how we can now chain multiple functions that return Maybe's (that don't take Maybe's as input). However, given any object, there is probably more than one way to meaningfully define this &amp;quot;chaining&amp;quot;.&lt;/p&gt;
&lt;p&gt;Sometimes, it's useful to base your definition of chaining on the idea of a failure/success process. Sometimes it's useful to define chaining as &amp;quot;We are building up either a success or a failure...and if at any point I fail, the whole thing is a failure&amp;quot;.&lt;/p&gt;
&lt;p&gt;There is a special name for this design pattern. In Haskell, we call something like this a &amp;quot;&lt;a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus"&gt;MonadPlus&lt;/a&gt;&amp;quot;[^disclaimer] [^either].&lt;/p&gt;
&lt;p&gt;I know, it's an embarrassingly bad name, and it's like this is for historical reasons (related to the footnote above). The name doesn't even hint at a fail/succeedness. But we're stuck with it for pretty much the entire foreseeable future, so when you chose to adopt a success/failure model for your chaining process, you have a &lt;em&gt;MonadPlus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There is a vocabulary we can use so we can talk about all MonadPlus's in a general way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We call a success a &amp;quot;return&amp;quot;. Yeah...the name is super confusing because of how the word &amp;quot;return&amp;quot; is used in almost every other context in computer science. But hey. Oh well.&lt;/li&gt;
&lt;li&gt;We call a failure an &amp;quot;mzero&amp;quot;. Yes, this name is pretty lame too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For Maybe, a &amp;quot;return&amp;quot; with the value &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Just x&lt;/code&gt;, and an &amp;quot;mzero&amp;quot; is a &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Something cool about Haskell is that if we type &lt;code&gt;return x&lt;/code&gt;, it'll interpret it as an auto-success of value &lt;code&gt;x&lt;/code&gt;. If we type &lt;code&gt;mzero&lt;/code&gt;, it'll be an &amp;quot;alias&amp;quot; of whatever your failure is.&lt;/p&gt;
&lt;p&gt;That means that for Maybe, &lt;code&gt;return x&lt;/code&gt; is the same as &lt;code&gt;Just x&lt;/code&gt;, and &lt;code&gt;mzero&lt;/code&gt; is an alias for &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you are familiar with object oriented languages like Java, MonadPlus is really like an &lt;strong&gt;interface&lt;/strong&gt;. That is, if something is a MonadPlus, there is a &amp;quot;guarantee&amp;quot; that that something will implement/define &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; for that particular object. In this way, &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; are &lt;em&gt;polymorphic functions&lt;/em&gt; that change their behavior based on what type you are talking about, and you can write code that works with all MonadPlus's generically without worrying about their actual type by using only &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; (instead of say, &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Nothing&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In Haskell, the term we use (instead of &amp;quot;interface&amp;quot;) is &amp;quot;&lt;strong&gt;typeclass&lt;/strong&gt;&amp;quot;. There are some subtle differences --- typeclasses are in general more powerful of a tool than interfaces --- but the two concepts provide similar roles in their respective languages. &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;As a small note, the term/command &amp;quot;return&amp;quot;/&lt;code&gt;return&lt;/code&gt; is shared by all monads. However, monads don't ascribe any (general) conceptual &amp;quot;meaning&amp;quot; or &amp;quot;purpose&amp;quot; to return. For any old monad, it can mean whatever you want it to mean for that specific monad. However, in the context of MonadPlus, &amp;quot;return&amp;quot; has a very specific meaning: &lt;em&gt;succeed&lt;/em&gt;. Because of this, &amp;quot;return&amp;quot; and &amp;quot;succeed&amp;quot; will be treated as synonyms in this article.&lt;/p&gt;
&lt;h3&gt;MonadPlus examples&lt;/h3&gt;
&lt;p&gt;To see this in action, let's revisit the last do block and make it more generic, and just rephrase it in a form that we are going to be encountering more when we solve our problem with the List monad (which is (spoilers) also a MonadPlus):&lt;/p&gt;
&lt;p&gt;~~~haskell halveThriceOops :: Int -&amp;gt; Maybe Int halveThriceOops n = do -- call with n = 32 x &amp;lt;- halve n -- Just 16 -- 1 mzero -- Nothing -- 2 y &amp;lt;- halve x -- (skip) -- 3 z &amp;lt;- halve y -- (skip) return z -- (skip) -- 4 ~~~&lt;/p&gt;
&lt;p&gt;Note that I've also included a line-by-line 'trace' of the do block with what the monad &amp;quot;is&amp;quot; at that point. It is what is calculated on that line, and it would be the value returned if you just exited at that step.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Business as usual. Halve &lt;code&gt;n&lt;/code&gt; if possible and place the reuslt in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is 32, then &lt;code&gt;x&lt;/code&gt; will be 16.&lt;/li&gt;
&lt;li&gt;The failure. Remember, &lt;code&gt;mzero&lt;/code&gt; means &amp;quot;fail here automatically&amp;quot;, which, in a Maybe object, means &lt;code&gt;Nothing&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now from here on, nothing else even matters...the entire block is a failure!&lt;/li&gt;
&lt;li&gt;If possible, succeed with the value in &lt;code&gt;z&lt;/code&gt;. This is supposed to be a &lt;code&gt;Just&lt;/code&gt; with the value of &lt;code&gt;z&lt;/code&gt;. Unfortunately, the entire block failed a long time ago. So sad!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Diversion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A small diversion.&lt;/p&gt;
&lt;p&gt;This is a little nicety, but there is the common library monad function &lt;code&gt;sequence :: Monad m =&amp;gt; [m a] -&amp;gt; m [a]&lt;/code&gt;, which turns a &lt;code&gt;[Maybe a]&lt;/code&gt; into a &lt;code&gt;Maybe [a]&lt;/code&gt;. Conceptually, &lt;code&gt;sequence&lt;/code&gt; turns a list of monads into a monad containing a list.&lt;/p&gt;
&lt;p&gt;In the context of MonadPlus, it would be turning a list of Success/Failures into a succesful or failed list. It builds a succesful/failed list.&lt;/p&gt;
&lt;p&gt;From what we have learned, if any part of that building process is a failure, the entire thing is necessarily a failure. This is reflected in &lt;code&gt;sequence&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; sequence [Just 1, Just 4, Just 6] Just [1,4,6] ghci&amp;gt; sequence [Just 1, Nothing, Just 6] Nothing ~~~&lt;/p&gt;
&lt;p&gt;If you already know a few other common library monad functions (like &lt;code&gt;replicateM&lt;/code&gt;, &lt;code&gt;forM&lt;/code&gt;, etc.), try reasoning about how they would work on Maybe's and MonadPlus's in general --- they aren't just for IO! &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;h3&gt;Guards&lt;/h3&gt;
&lt;p&gt;It feels like just slapping in &lt;code&gt;mzero&lt;/code&gt; willy-nilly is not that useful, because then things just fail always no matter what. Wouldn't it be handy to have a function that says &amp;quot;fail right...here, if this condition is not met&amp;quot;? Like &lt;code&gt;mzero&lt;/code&gt;, but instead of always failing, fails on certain conditions.&lt;/p&gt;
&lt;p&gt;Luckily, Haskell gives us one in the standard library:&lt;/p&gt;
&lt;p&gt;~~~haskell guard :: MonadPlus m =&amp;gt; Bool -&amp;gt; m () -- 1 guard True = return () guard False = mzero ~~~&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is a type signature, like before. We say that &lt;code&gt;guard&lt;/code&gt; is a function that takes a &lt;code&gt;Bool&lt;/code&gt; and returns a &lt;code&gt;m ()&lt;/code&gt; --- a monad containing &lt;code&gt;()&lt;/code&gt;. But we say that &lt;code&gt;m&lt;/code&gt;, the monad, must be a MonadPlus.&lt;/p&gt;
&lt;p&gt;For example, if we applied this to Maybe, the concrete signature would be &lt;code&gt;guard :: Bool -&amp;gt; Maybe ()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;guard&lt;/code&gt; will make sure a condition is met, or else it fails the entire thing. If the condition is met, then it succeeds and places a &lt;code&gt;()&lt;/code&gt; in the value.&lt;/p&gt;
&lt;p&gt;We can use this to re-implement &lt;code&gt;halve&lt;/code&gt;, using do notation, aware of Maybe's MonadPlus-ness:&lt;/p&gt;
&lt;p&gt;~~~haskell halve :: Int -&amp;gt; Maybe Int halve n = do -- &amp;lt;halve 8&amp;gt; &amp;lt;halve 7&amp;gt; guard $ even n -- Just () Nothing return $ n &lt;code&gt;div&lt;/code&gt; 2 -- Just 4 (skip) ~~~&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;guard $ even n&lt;/code&gt; seems confusing, but it is just shorthand for &lt;code&gt;guard (even n)&lt;/code&gt;. We just don't like writing all those parentheses out. &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;So, first, &lt;code&gt;halve&lt;/code&gt; is &lt;code&gt;Just ()&lt;/code&gt; (succeeds with a blank value &lt;code&gt;()&lt;/code&gt;) if &lt;code&gt;n&lt;/code&gt; is even, or else &lt;code&gt;Nothing&lt;/code&gt; (fails automatically) otherwise. Finally, if it has not yet failed, it attempts to succeed with &lt;code&gt;n `div` 2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can trust me when I say this works the exact same way! You can &lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/HalveGuard.hs"&gt;try it out yourself&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;As a friendly reminder, this entire block is &amp;quot;compiled&amp;quot;/desugared to:&lt;/p&gt;
&lt;p&gt;~~~haskell halve n :: Int -&amp;gt; Maybe Int halve n = guard (even n) &amp;gt;&amp;gt; return (n &lt;code&gt;div&lt;/code&gt; 2) ~~~&lt;/p&gt;
&lt;h2&gt;A practical use&lt;/h2&gt;
&lt;p&gt;We aren't where we need to be to begin tackling that Wolf/Goat/Cabbage puzzle yet...so to let this article not be a complete anticlimax (as a result of my bad planning --- I had originally intended to do the entire three-part series as one article), let's look at a practical problem that you can solve using the Maybe monad.&lt;/p&gt;
&lt;p&gt;The obvious examples are situations where it is useful to be able to chain failable operations such as retrieving things from a database or a network connection or applying partial functions (functions that only work on some values, like our &lt;code&gt;halve&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;However, here is a neat one.&lt;/p&gt;
&lt;p&gt;Let's say we are making a game where you can lose health by being hit or gain health by picking up powerups. We want to calculate the final health at the end of the game. It seems a bit easy: just add up all the losses and gains! Unfortunately, it's not so simple --- it needs to be implemented such that if your health ever dips below 0, you are dead. Forever. No powerups will ever help you.&lt;/p&gt;
&lt;p&gt;Think about how you would implement this normally. You might have a state object that stores the current health as well as a flag with the current dead/alive state, and at every step, check if the health is 0 or lower; if it is, swap the flag to be dead and ignore all other updates.&lt;/p&gt;
&lt;p&gt;But let's try doing this instead with the Maybe monad:&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/MaybeGame.hs#L26-L51 -- die or fail immediately die :: Maybe Int die = mzero -- or die = mzero&lt;/p&gt;
&lt;p&gt;-- if not dead, sets the health to the given level setHealth :: Int -&amp;gt; Maybe Int setHealth n = return n -- or setHealth n = return n&lt;/p&gt;
&lt;p&gt;-- damage the player (from its previous health) and check for death hit :: Int -&amp;gt; Maybe Int hit currHealth = do let newHealth = currHealth - 1 guard $ newHealth &amp;gt; 0 -- fail/die immediately unless newHealth -- is positive return newHealth -- succeed with newHealth if not already -- dead&lt;/p&gt;
&lt;p&gt;-- an alternative but identical definition of &lt;code&gt;hit&lt;/code&gt;, using &amp;gt;&amp;gt;= and &amp;gt;&amp;gt; hit' :: Int -&amp;gt; Maybe Int hit' currHealth = guard (newHealth &amp;gt; 0) &amp;gt;&amp;gt; return newHealth where newHealth = currHealth - 1&lt;/p&gt;
&lt;p&gt;-- increase the player's health from its previous health powerup :: Int -&amp;gt; Maybe Int powerup currHealth = return $ currHealth + 1 ~~~&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; setHealth 2 &amp;gt;&amp;gt;= hit &amp;gt;&amp;gt;= powerup &amp;gt;&amp;gt;= hit &amp;gt;&amp;gt;= powerup &amp;gt;&amp;gt;= powerup Just 3 ghci&amp;gt; setHealth 2 &amp;gt;&amp;gt;= hit &amp;gt;&amp;gt;= powerup &amp;gt;&amp;gt;= hit &amp;gt;&amp;gt;= hit &amp;gt;&amp;gt;= powerup Nothing ghci&amp;gt; setHealth 10 &amp;gt;&amp;gt;= powerup &amp;gt;&amp;gt; die &amp;gt;&amp;gt;= powerup &amp;gt;&amp;gt;= powerup Nothing ghci&amp;gt; do h0 &amp;lt;- setHealth 2 -- Just 2 | h1 &amp;lt;- hit h0 -- Just 1 | h2 &amp;lt;- powerup h1 -- Just 2 | h3 &amp;lt;- hit h2 -- Just 1 | h4 &amp;lt;- hit h3 -- Nothing | h5 &amp;lt;- powerup h4 -- (skip) | h6 &amp;lt;- powerup h5 -- (skip) | return h6 -- (skip) Nothing ~~~&lt;/p&gt;
&lt;p&gt;And voilÃ ! &lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/MaybeGame.hs"&gt;Fire it up yourself&lt;/a&gt; if you want to test it out in person!&lt;/p&gt;
&lt;p&gt;You can think of the last do block conceptually this way: remember, &lt;code&gt;h3&lt;/code&gt; does not represent the &lt;code&gt;Just 1&lt;/code&gt; value --- &lt;code&gt;h3&lt;/code&gt; represents the number &lt;em&gt;inside&lt;/em&gt; the &lt;code&gt;Just 1&lt;/code&gt; --- the 1. So &lt;code&gt;h4&lt;/code&gt; is supposed to represent the number inside its value, too. But because &lt;code&gt;hit h3&lt;/code&gt; results in &lt;code&gt;Nothing&lt;/code&gt;; &lt;code&gt;Nothing&lt;/code&gt; has no value &amp;quot;inside&amp;quot;, so &lt;code&gt;h4&lt;/code&gt; doesn't even have a value! So obviously it doesn't even make sense to call &lt;code&gt;powerup h4&lt;/code&gt;...therefore &lt;code&gt;h5&lt;/code&gt; has no value either! It's therefore meaningless to call &lt;code&gt;powerup h5&lt;/code&gt;, so meaningless to &lt;code&gt;return h6&lt;/code&gt;...the entire thing is a beautiful disaster. A fiasco. Mission accomplished!&lt;/p&gt;
&lt;p&gt;The whole thing works as expected; you can even die suddenly with &lt;code&gt;die&lt;/code&gt;, which ignores your current health.&lt;/p&gt;
&lt;p&gt;Interestingly enough, we could actually eliminate all references to Maybe altogether by always using &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; instead of &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Nothing&lt;/code&gt;. And if we make our type signatures generic enough, we could use this with &lt;em&gt;any&lt;/em&gt; MonadPlus! But that is for another day.&lt;/p&gt;
&lt;h2&gt;Looking forward&lt;/h2&gt;
&lt;p&gt;Wow, who knew you could spend so much time talking about failure. Anyways, this is a good place to stop before we move onto how List is also a MonadPlus. Okay, so what have we learned?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monads are just a way of chaining functions on objects, and of course, every object's chaining process is different. In fact there might be even more than one way to meaningfully chain functions on an object!&lt;/li&gt;
&lt;li&gt;One useful &amp;quot;chaining approach&amp;quot; is to model things as success-failure chains, where you are building something from successes, but if you fail once in the process, the entire process fails. An object that uses this approach/design pattern is called a MonadPlus.&lt;/li&gt;
&lt;li&gt;The Maybe object is one such example. We can define 'chaining' failable functions as functions that continue if the previous function succeeded, or propagate a failure if the previous function fails. A failable function, for a Maybe object, is a function &lt;code&gt;:: a -&amp;gt; Maybe b&lt;/code&gt; or even &lt;code&gt;:: Maybe b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is a common vocabulary for talking about MonadPlus concepts --- &amp;quot;return&amp;quot; means &amp;quot;succeed with this value&amp;quot;, and &amp;quot;mzero&amp;quot; means &amp;quot;fail now&amp;quot;.&lt;/li&gt;
&lt;li&gt;Due to Haskell's polymorphism, we can &amp;quot;forget&amp;quot; we are using Maybe and in fact talk about/write for &amp;quot;general&amp;quot; MonadPlus's, with &lt;code&gt;return x&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; resulting in the appropriate success/fail objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the mean time, think about how it might make sense to chain operations on lists (ie, repeatedly applying functions &lt;code&gt;:: a -&amp;gt; [b]&lt;/code&gt; to lists).&lt;/p&gt;
&lt;p&gt;By this, I mean, given a function that turns a value into a list of values &lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt;, find a way to meaningfully &amp;quot;chain&amp;quot; that function to a previous list and get a new list:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; oldList &amp;gt;&amp;gt;= f newList -- a new list based on old list; f &amp;quot;chained&amp;quot; to &lt;code&gt;oldList&lt;/code&gt;. ~~~&lt;/p&gt;
&lt;p&gt;Is there more than one way to think about chaining them, even? And in what ways we can define this &amp;quot;chaining&amp;quot; to represent success/failure? Until next time!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.html</guid><pubDate>Mon,  9 Dec 2013 18:09:26 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Ramblings</subject><date>2013-12-09</date></item><item><title>The List MonadPlus --- Practical Fun with Monads (Part 2 of 3)</title><link>https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.html</link><description>&lt;p&gt;Part two of an exploration of a very useful design pattern in Haskell known as MonadPlus, a part of an effort to make &amp;quot;practical&amp;quot; monads less of a mystery and fun to the good peoples of this earth.&lt;/p&gt;
&lt;p&gt;When we last left off on the &lt;a href="http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus"&gt;MonadPlus introduction&lt;/a&gt;, we understood that there are times when you want to chain functions on objects in a way that &amp;quot;resembles&amp;quot; a failure/success process. We did this by exploring the most simple of all MonadPlus's: a simple &amp;quot;dumb&amp;quot; container for a value is either in a success or a failure. We looked at how the MonadPlus design pattern really &amp;quot;behaved&amp;quot;.&lt;/p&gt;
&lt;p&gt;This time we're going to look at another MonadPlus --- the List. By the end of this series we're going to be using nothing but the list's MonadPlus properties to solve this classic logic problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can't leave the wolf alone with the goat, or the wolf will eat the goat. He can't leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's get to it!&lt;/p&gt;
&lt;h3&gt;MonadWhat? A review&lt;/h3&gt;
&lt;p&gt;Let's take a quick review! Remember, a monad is just an object where you have defined a way to chain functions inside it. You'll find that you can be creative this &amp;quot;chaining&amp;quot; behavior, and for any given type of object you can definitely define more than one way to &amp;quot;chain&amp;quot; functions on that type of object. One &amp;quot;design pattern&amp;quot; of chaining is MonadPlus, where we use this chaining to model success/failure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mzero&lt;/code&gt; means &amp;quot;failure&amp;quot;, and chaining anything onto a failure will still be a failure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return x&lt;/code&gt; means &amp;quot;succeed with &lt;code&gt;x&lt;/code&gt;&amp;quot;, and will return a &amp;quot;successful&amp;quot; result with a value of &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can read through the &lt;a href="http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus"&gt;previous article&lt;/a&gt; for examples of seeing these principles in action and in real code.&lt;/p&gt;
&lt;p&gt;Without further ado, let us start on the list monad.&lt;/p&gt;
&lt;h2&gt;Starting on the List Monad&lt;/h2&gt;
&lt;p&gt;Now, when I say &amp;quot;list monad&amp;quot;, I mean &amp;quot;one way that you can implement chaining operations on a list&amp;quot;. To be more precise, I should say &amp;quot;haskell's default choice of chaining method on lists&amp;quot;. Technically, &lt;strong&gt;there is no &amp;quot;the list monad&amp;quot;&lt;/strong&gt;...there is &amp;quot;a way we can make the List data structure a monad&amp;quot;.&lt;/p&gt;
&lt;p&gt;And what's one way we can do this? You could probably take a wild guess. Yup, we can model lists as a MonadPlus --- we can model chaining in a way that revolves around successes and failures.&lt;/p&gt;
&lt;p&gt;So, how can a list model success/failure? Does that even make sense?&lt;/p&gt;
&lt;p&gt;Let's take a look at last article's &lt;code&gt;halve&lt;/code&gt; function:&lt;/p&gt;
&lt;p&gt;~~~haskell -- the built in function &lt;code&gt;guard&lt;/code&gt;, to refresh your memory guard :: MonadPlus m =&amp;gt; Bool -&amp;gt; m () guard True = return () guard False = mzero&lt;/p&gt;
&lt;p&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L30-L33 halve :: Int -&amp;gt; Maybe Int halve n = do guard $ even n return $ n &lt;code&gt;div&lt;/code&gt; 2 ~~~&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; halve 6 Just 3 ghci&amp;gt; halve 7 Nothing ghci&amp;gt; halve 8 &amp;gt;&amp;gt;= halve Just 2 ghci&amp;gt; halve 7 &amp;gt;&amp;gt;= halve Nothing ~~~&lt;/p&gt;
&lt;p&gt;Here, our success/fail mechanism was built into the Maybe container. Remember, first, it fails automatically if &lt;code&gt;n&lt;/code&gt; is not even; then, it auto-succeeds with &lt;code&gt;n `div` 2&lt;/code&gt; (which only works if it has not already failed). But note that we didn't actually really &amp;quot;need&amp;quot; Maybe here...we could have used anything that had an &lt;code&gt;mzero&lt;/code&gt; (insta-fail, which is used in &lt;code&gt;guard&lt;/code&gt;) and a &lt;code&gt;return&lt;/code&gt; (auto-succeed).&lt;/p&gt;
&lt;p&gt;Let's see what happens when we replace our Maybe container with a list:&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L35-L38 halve' :: Int -&amp;gt; [Int] halve' n = do guard $ even n return $ n &lt;code&gt;div&lt;/code&gt; 2 ~~~&lt;/p&gt;
&lt;p&gt;This is...the exact same function body. We didn't do anything but change the type signature. But because you believe me when I say that List is a MonadPlus...this should work, right? &lt;code&gt;guard&lt;/code&gt; should work for &lt;em&gt;any&lt;/em&gt; MonadPlus, because every MonadPlus has an &lt;code&gt;mzero&lt;/code&gt; (fail). &lt;code&gt;return&lt;/code&gt; should work for any MonadPlus, too --- it wouldn't be a MonadPlus without &lt;code&gt;return&lt;/code&gt; implemented! (Remember, typeclasses are similar to interfaces in OOP) We don't know exactly what failing and succeeding actually &lt;em&gt;looks&lt;/em&gt; like in a list yet...but if you know it's a MonadPlus (which List is, in the standard library), you know that it &lt;em&gt;has&lt;/em&gt; these concepts defined somewhere.&lt;/p&gt;
&lt;p&gt;So, how is list a meaningful MonadPlus? Simple: a &amp;quot;failure&amp;quot; is an empty list. A &amp;quot;success&amp;quot; is a non-empty list.&lt;/p&gt;
&lt;p&gt;Watch:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; halve' 6 [3] ghci&amp;gt; halve' 7 [] ghci&amp;gt; halve' 8 &amp;gt;&amp;gt;= halve' [2] ghci&amp;gt; halve' 7 &amp;gt;&amp;gt;= halve' [] ghci&amp;gt; halve' 32 &amp;gt;&amp;gt;= halve' &amp;gt;&amp;gt;= halve' &amp;gt;&amp;gt;= halve' [2] ghci&amp;gt; halve' 32 &amp;gt;&amp;gt; mzero &amp;gt;&amp;gt;= halve' &amp;gt;&amp;gt;= halve' &amp;gt;&amp;gt;= halve' [] ~~~&lt;/p&gt;
&lt;p&gt;So there we have it! &lt;code&gt;Nothing&lt;/code&gt; is just like &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;Just x&lt;/code&gt; is just like &lt;code&gt;[x]&lt;/code&gt;. This whole time! It's all so clear now! Why does &lt;code&gt;Maybe&lt;/code&gt; even exist, anyway, when we can just use &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[x]&lt;/code&gt; for &lt;code&gt;Nothing&lt;/code&gt; and &lt;code&gt;Just x&lt;/code&gt; and be none the wiser? (Take some time to think about it if you want!)&lt;/p&gt;
&lt;p&gt;In fact, if we generalize our type signature for &lt;code&gt;halve&lt;/code&gt;, we can do some crazy things...&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L40-L43 genericHalve :: MonadPlus m =&amp;gt; Int -&amp;gt; m Int genericHalve n = do guard $ even n return $ n &lt;code&gt;div&lt;/code&gt; 2 ~~~&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; genericHalve 8 :: Maybe Int Just 4 ghci&amp;gt; genericHalve 8 :: [Int] [4] ghci&amp;gt; genericHalve 7 :: Maybe Int Nothing ghci&amp;gt; genericHalve 7 :: [Int] [] ~~~&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&amp;quot;note&amp;quot;&amp;gt; &lt;strong&gt;Welcome to Haskell!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now, when we say something like &lt;code&gt;genericHalve 8 :: Maybe Int&lt;/code&gt;, it means &amp;quot;I want &lt;code&gt;genericHalve 8&lt;/code&gt;...and I want the type to be &lt;code&gt;Maybe Int&lt;/code&gt;.&amp;quot; This is necessary here because in our &lt;code&gt;genericHalve&lt;/code&gt; can be &lt;em&gt;any&lt;/em&gt; MonadPlus, so we have to tell ghci which MonadPlus we want. &amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/Halves.hs"&gt;All three versions of &lt;code&gt;halve&lt;/code&gt; available for playing around with&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;So there you have it. Maybe and lists are one and the same. Lists &lt;em&gt;do&lt;/em&gt; too represent the concept of failure and success. So...what's the difference?&lt;/p&gt;
&lt;h2&gt;A List Apart&lt;/h2&gt;
&lt;p&gt;Lists can model failure the same way that Maybe can. But it should be apparent that lists can do a little &amp;quot;more&amp;quot; than Maybe...&lt;/p&gt;
&lt;p&gt;Consider &lt;code&gt;[3, 5]&lt;/code&gt;. Clearly this is to represent some sort of &amp;quot;success&amp;quot; (because a failure would be an empty list). But what kind of &amp;quot;success&amp;quot; could it represent?&lt;/p&gt;
&lt;p&gt;How about we look at it this way: &lt;code&gt;[3, 5]&lt;/code&gt; represents two separate &lt;em&gt;paths&lt;/em&gt; to success. When we look at a &lt;code&gt;Just 5&lt;/code&gt;, we see a computation that succeeded with a 5. When we see a &lt;code&gt;[3, 5]&lt;/code&gt;, we may interpret it as a computation that had two possible succesful paths: one succeeding with a 3 and another with a 5.&lt;/p&gt;
&lt;p&gt;You can also say that it represents a computation that &lt;em&gt;could have chosen&lt;/em&gt; to succeed in a 3, or a 5. In this way, the list monad is often referred to as &amp;quot;the choice monad&amp;quot;.&lt;/p&gt;
&lt;p&gt;This view of a list as a collection of possible successes or choices of successes is not the only way to think of a list as a monad...but it is the way that the Haskell community has adopted as arguably the most useful. (The other main way is to approach it completely differently, making list not even a MonadPlus and therefore not representing failure or success at all)&lt;/p&gt;
&lt;p&gt;Think of it this way: A value goes through a long and arduous journey with many choices and possible paths and forks. At the end of it, you have the result of every path that could have lead to a success. Contrast this to the Maybe monad, where a value goes through this arduous journey, but never has any choice. There is only one path --- successful, or otherwise. A Maybe is deterministic...a list provides a choice in paths.&lt;/p&gt;
&lt;h2&gt;halveOrDouble&lt;/h2&gt;
&lt;p&gt;Let's take a simple example: &lt;code&gt;halveOrDouble&lt;/code&gt;. It provides two successful paths if you are even: halving and doubling. It only provides one choice or possible path to success if you are odd: doubling. In this way it is slightly racist.&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/HalveOrDouble.hs#L19-L21 halveOrDouble :: Int -&amp;gt; [Int] halveOrDouble n | even n = [n &lt;code&gt;div&lt;/code&gt; 2, n * 2] | otherwise = [n * 2] ~~~&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; halveOrDouble 6 [ 3,12] ghci&amp;gt; halveOrDouble 7 [ 14] ~~~&lt;/p&gt;
&lt;p&gt;(&lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/HalveOrDouble.hs"&gt;Play with this and other functions this section on your own&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;As you can see in the first case, with the 6, there are two paths to success: the halve, and the double. In the second case, with the 7, there is only one --- the double.&lt;/p&gt;
&lt;p&gt;How about we subject a number to this halving-or-doubling journey twice? What do we expect?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The path of halve-halve only works if the number is divisible by two twice. So this is only a successful path if the number is divisible by four.&lt;/li&gt;
&lt;li&gt;The path of halve-double only works if the number is even. So this is only a successful path in that case.&lt;/li&gt;
&lt;li&gt;The path of double-halve will work in all cases! It is a success always.&lt;/li&gt;
&lt;li&gt;The path of double-double will also work in all cases...it'll never fail for our sojourning number!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So...halving-or-doubling twice has two possible successful paths for an odd number, three successful paths for a number divisible by two but not four, and four successful paths for a number divisible by four.&lt;/p&gt;
&lt;p&gt;Let's try it out:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; halveOrDouble 5 &amp;gt;&amp;gt;= halveOrDouble [ 5, 20] ghci&amp;gt; halveOrDouble 6 &amp;gt;&amp;gt;= halveOrDouble [ 6, 6, 24] ghci&amp;gt; halveOrDouble 8 &amp;gt;&amp;gt;= halveOrDouble [ 2, 8, 8, 32] ~~~&lt;/p&gt;
&lt;p&gt;The first list represents the results of all of the possible successful paths 5 could have taken to &amp;quot;traverse&amp;quot; the dreaded &lt;code&gt;halveOrDouble&lt;/code&gt; landscape twice --- double-halve, or double-double. The second, 6 could have emerged successful with halve-double, double-halve, or double-double. For 8, all paths are successful, incidentally. He better check his privilege.&lt;/p&gt;
&lt;h3&gt;Do notation&lt;/h3&gt;
&lt;p&gt;Let's look at the same thing in do notation form to offer some possible insight:&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/HalveOrDouble.hs#L24-L27 halveOrDoubleTwice :: Int -&amp;gt; [Int] halveOrDoubleTwice n = do x &amp;lt;- halveOrDouble n halveOrDouble x ~~~&lt;/p&gt;
&lt;p&gt;Do notation describes &lt;strong&gt;a single path of a value&lt;/strong&gt;. This is slightly confusing at first. But look at it --- it has the &lt;em&gt;exact same form&lt;/em&gt; as a Maybe monad do block.&lt;/p&gt;
&lt;p&gt;This thing describes, in general terms, the path of a &lt;strong&gt;single value&lt;/strong&gt;. &lt;code&gt;x&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a list --- it represents a single value, in the middle of its treacherous journey.&lt;/p&gt;
&lt;p&gt;Here is an illustration, tracing out &amp;quot;individual paths&amp;quot;:&lt;/p&gt;
&lt;p&gt;~~~haskell halveOrDoubleTwice :: Int -&amp;gt; [Int] halveOrDoubleTwice n = do -- halveOrDoubleTwice 6 x &amp;lt;- halveOrDouble n -- x &amp;lt;- Just 3 Just 12 halveOrDouble x -- Nothing Just 6 Just 6 Just 24 ~~~&lt;/p&gt;
&lt;p&gt;where you take the left path if you want to halve, and the right path if you want to double.&lt;/p&gt;
&lt;p&gt;Remember, just like in the Maybe monad, the &lt;code&gt;x&lt;/code&gt; represents the value &amp;quot;inside&amp;quot; the object --- &lt;code&gt;x&lt;/code&gt; represents a 3 &lt;strong&gt;or&lt;/strong&gt; a 12 (but not &amp;quot;both&amp;quot;), depending on what path you are taking/are &amp;quot;in&amp;quot;. That's why we can call &lt;code&gt;halveOrDouble x&lt;/code&gt;: &lt;code&gt;halveOrDouble&lt;/code&gt; only takes &lt;code&gt;Int&lt;/code&gt;s and &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;one&lt;/em&gt; &lt;code&gt;Int&lt;/code&gt; along the path.&lt;/p&gt;
&lt;h3&gt;A winding journey&lt;/h3&gt;
&lt;p&gt;Note that once you bind a value to a variable (like &lt;code&gt;x&lt;/code&gt;), then that is the value for &lt;code&gt;x&lt;/code&gt; for the entire rest of the journey. In fact, let's see it in action:&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/HalveOrDouble.hs#L29-L29 hod2PlusOne :: Int -&amp;gt; [Int] hod2PlusOne n = do -- hod2PlusOne 6 x &amp;lt;- halveOrDouble n -- x &amp;lt;- Just 3 Just 12 halveOrDouble x -- Nothing Just 6 Just 6 Just 24 return $ x + 1 -- (skip) Just 4 Just 13 Just 13 ~~~&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; hod2PlusOne 6 [ 4,13,13] ~~~&lt;/p&gt;
&lt;p&gt;Okay! This is getting interesting now. What's going on? Well, there are four possible &amp;quot;paths&amp;quot;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In the half-half path, &lt;code&gt;x&lt;/code&gt; (the result of the first halving) is 3. However, the half-half path is a failure --- 6 cannot be halved twice. Therefore, even though &lt;code&gt;x&lt;/code&gt; is three, the path has already failed before we get to the &lt;code&gt;return (x + 1)&lt;/code&gt;. Just like in the case with Maybe, once something fails during the process of the journey, the entire journey is a failure.&lt;/li&gt;
&lt;li&gt;In the half-double path, &lt;code&gt;x&lt;/code&gt; is also 3. However, this journey doesn't fail. It survives to the end. After the doubling, the value of the journey at that point is &amp;quot;Just 6&amp;quot;. Afterwards, it &amp;quot;auto-succeeds&amp;quot; and replaces the current value with the value of &lt;code&gt;x&lt;/code&gt; on that path (3) plus 1 --- 4. This is just like how in the Maybe monad, we return a new value after the guard.&lt;/li&gt;
&lt;li&gt;In the double-halve path, &lt;code&gt;x&lt;/code&gt; (the result of the first operation, a double) is 12. The second operation makes the value in the journey a 6; At the end of it all, we succeed with whatever the value of &lt;code&gt;x&lt;/code&gt; is on that specific journey (12) is, plus one. 13.&lt;/li&gt;
&lt;li&gt;Same story here, but for double-double; &lt;code&gt;x&lt;/code&gt; is 12. At the end of it all, the journey never fails, so it succeeds with &lt;code&gt;x + 1&lt;/code&gt;, or 13.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Trying out every path&lt;/h4&gt;
&lt;p&gt;If this doesn't satisfy you, here is an example of four Maybe do blocks where we &amp;quot;flesh out&amp;quot; each possible path, with the value of the block at each line in comments:&lt;/p&gt;
&lt;p&gt;~~~haskell double :: Int -&amp;gt; Maybe Int double n = Just n&lt;/p&gt;
&lt;p&gt;halveHalvePlusOne :: Int -&amp;gt; Maybe Int halveHalvePlusOne n = do -- n = 6 x &amp;lt;- halve n -- Just 3 (x = 3) halve x -- Nothing return $ x + 1 -- (skip)&lt;/p&gt;
&lt;p&gt;halveDoublePlusOne :: Int -&amp;gt; Maybe Int halveDoublePlusOne = do -- n = 6 x &amp;lt;- halve n -- Just 3 (x = 3) double x -- Just 6 return $ x + 1 -- Just 4&lt;/p&gt;
&lt;p&gt;doubleHalvePlusOne :: Int -&amp;gt; Maybe Int doubleHalvePlusOne = do -- n = 6 x &amp;lt;- double n -- Just 12 (x = 12) halve x -- Just 6 return $ x + 1 -- Just 13&lt;/p&gt;
&lt;p&gt;doubleDoublePlusOne :: Int -&amp;gt; Maybe Int doubleDoublePlusOne = do -- n = 6 x &amp;lt;- double n -- Just 12 (x = 12) double x -- Just 6 return $ x + 1 -- Just 13 ~~~&lt;/p&gt;
&lt;h4&gt;A graphical look&lt;/h4&gt;
&lt;p&gt;This tree might also be a nice illustration, showing what happens at each stage of the journey.&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/entries/monad-plus/halvedouble.png" title="hod2PlusOne 6" alt="hod2PlusOne 6, all journeys illustrated" /&gt;&lt;/p&gt;
&lt;p&gt;Every complete &amp;quot;journey&amp;quot; is a complete path from top to bottom. You can see that the left-left journey (the half-halve journey) fails. The left-right journey (the halve-double journey) passes, and at the end is given the value of &lt;code&gt;x + 1&lt;/code&gt; for the &lt;code&gt;x&lt;/code&gt; in that particular journey. The other journeys work the same way!&lt;/p&gt;
&lt;h2&gt;Solving real-ish problems&lt;/h2&gt;
&lt;p&gt;That wasn't too bad, was it? We're actually just about ready to start implementing our solution to the Wolf/Goat/Cabbage puzzle!&lt;/p&gt;
&lt;p&gt;Before we end this post let's build some more familiarity with the List monad and try out a very common practical example.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- That wasn't too bad! We're &lt;em&gt;almost&lt;/em&gt; ready to begin implementing our solution --&amp;gt; &amp;lt;!-- to the Wolf/Goat/Cabbage puzzle. --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Let's try one &amp;quot;real&amp;quot;-ish problem to build some more --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- But we're going to go through a couple more examples of branching journeys --&amp;gt; &amp;lt;!-- first --- both as a way to build more familiarity with the &amp;quot;branching journey --&amp;gt; &amp;lt;!-- monad&amp;quot; (list), and also as a nice conclusion to this post. --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- ### Testing multiple paths --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Here's a fun one. --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- &amp;quot;What operations on a number will make it a multiple of three?&amp;quot; --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- ~~~haskell --&amp;gt; &amp;lt;!-- isMultThree :: Int -&amp;gt; Bool -- 1 --&amp;gt; &amp;lt;!-- isMultThree a = a &lt;code&gt;mod&lt;/code&gt; 3 == 0 --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- testNumber :: Int -&amp;gt; [String] --&amp;gt; &amp;lt;!-- testNumber n = do --&amp;gt; &amp;lt;!-- (f, fName) &amp;lt;- [ ((&lt;em&gt;2) , &amp;quot;times two&amp;quot;) -- 2 --&amp;gt; &amp;lt;!-- , ((&lt;/em&gt;3) , &amp;quot;times three&amp;quot;) --&amp;gt; &amp;lt;!-- , ((+2) , &amp;quot;plus two&amp;quot;) --&amp;gt; &amp;lt;!-- , ((+3) , &amp;quot;plus three&amp;quot;) --&amp;gt; &amp;lt;!-- , ((^2) , &amp;quot;square&amp;quot;) --&amp;gt; &amp;lt;!-- , ((+1).(^2) , &amp;quot;square plus 1&amp;quot;) --&amp;gt; &amp;lt;!-- , ((+1).(^3) , &amp;quot;cube plus 1&amp;quot;) --&amp;gt; &amp;lt;!-- , (id , &amp;quot;stay the same&amp;quot;) --&amp;gt; &amp;lt;!-- ] --&amp;gt; &amp;lt;!-- let z = f n -- 3 --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- guard $ isMultThree z -- 4 --&amp;gt; &amp;lt;!-- return fName -- 5 --&amp;gt; &amp;lt;!-- ~~~ --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- ~~~haskell --&amp;gt; &amp;lt;!-- ghci&amp;gt; testNumber 4 --&amp;gt; &amp;lt;!-- [&amp;quot;times three&amp;quot;, &amp;quot;plus two&amp;quot;] --&amp;gt; &amp;lt;!-- ghci&amp;gt; testNumber 5 --&amp;gt; &amp;lt;!-- [&amp;quot;times three&amp;quot;, &amp;quot;cube plus 1&amp;quot;] --&amp;gt; &amp;lt;!-- ghci&amp;gt; testNumber 6 --&amp;gt; &amp;lt;!-- [&amp;quot;times two&amp;quot;, &amp;quot;times three&amp;quot;, &amp;quot;plus three&amp;quot;, &amp;quot;square&amp;quot;, &amp;quot;stay the same&amp;quot;] --&amp;gt; &amp;lt;!-- ghci&amp;gt; testNumber 7 --&amp;gt; &amp;lt;!-- [&amp;quot;times three&amp;quot;, &amp;quot;plus two&amp;quot;] --&amp;gt; &amp;lt;!-- ghci&amp;gt; testNumber 8 --&amp;gt; &amp;lt;!-- [&amp;quot;times three&amp;quot;, &amp;quot;cube plus 1&amp;quot;] --&amp;gt; &amp;lt;!-- ~~~ --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- [Play with it here!][testNumber] --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- [testNumber]: https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/TestNumber.hs --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Let's go over this step-by-step: --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- 1. First of all, define the utility function &lt;code&gt;isMultThree a&lt;/code&gt;, which is true --&amp;gt; &amp;lt;!-- when &lt;code&gt;a&lt;/code&gt; is a multiple of three and false when it isn't. --&amp;gt; &amp;lt;!-- 2. The journey diverges immediately. &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;fName&lt;/code&gt; is now a value that --&amp;gt; &amp;lt;!-- depends on the path we take. If we take the first path, &lt;code&gt;f = (*2)&lt;/code&gt; (the --&amp;gt; &amp;lt;!-- doubling function) and &lt;code&gt;fName = &amp;quot;times two&amp;quot;&lt;/code&gt;. On the second path, &lt;code&gt;f = --&amp;gt; &amp;lt;!--     (*3)&lt;/code&gt; (the tripling function) and &lt;code&gt;fName = &amp;quot;times three&amp;quot;&lt;/code&gt;, etc. --&amp;gt; &amp;lt;!-- 3. We alias &lt;code&gt;z&lt;/code&gt; to be the function we chose applied to &lt;code&gt;x&lt;/code&gt;. If we had chosen --&amp;gt; &amp;lt;!-- the path &lt;code&gt;f = (*2)&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; would be &lt;code&gt;(*2) x&lt;/code&gt;, which is &lt;code&gt;x*2&lt;/code&gt;. This is --&amp;gt; &amp;lt;!-- mainly for readability. --&amp;gt; &amp;lt;!-- 4. We check if &lt;code&gt;z&lt;/code&gt; is a multiple of three. If it isn't, the journey sadly --&amp;gt; &amp;lt;!-- ends here. For example, if we called the function with &lt;code&gt;n = 4&lt;/code&gt;, and we --&amp;gt; &amp;lt;!-- had chosen &lt;code&gt;f = (^2)&lt;/code&gt; (the square function), this journey (involving the --&amp;gt; &amp;lt;!-- choice of &lt;code&gt;(^2)&lt;/code&gt;) would meet its failure here...but the journey with the --&amp;gt; &amp;lt;!-- choice &lt;code&gt;f = (+2)&lt;/code&gt; would not! --&amp;gt; &amp;lt;!-- 5. At the end of the weary journey, we return the name of the function we --&amp;gt; &amp;lt;!-- chose. This step is never reached for failed journeys. --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Here is another diagram, similar to the last. --&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- &lt;img src="/img/entries/monad-plus/testnumber.png" title="testNumber 5" alt="testNumber 5, all journeys illustrated" /&gt; --&amp;gt;&lt;/p&gt;
&lt;h3&gt;Finding the right combinations&lt;/h3&gt;
&lt;p&gt;Here is probably the most common of all examples involving the list monad: finding Pythagorean triples.&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/TriplesUnder.hs#L12-L18 triplesUnder :: Int -&amp;gt; [Int] triplesUnder n = do a &amp;lt;- [1..n] b &amp;lt;- [a..n] c &amp;lt;- [b..n] guard $ a^2 + b^2 == c^2 return (a,b,c) ~~~&lt;/p&gt;
&lt;p&gt;(&lt;a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/TriplesUnder.hs"&gt;Download it and try it out yourself!&lt;/a&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Our journey begins with picking a number between 1 and &lt;code&gt;n&lt;/code&gt; and setting it to &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Next, we pick a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; and set it to &lt;code&gt;b&lt;/code&gt;. We start from &lt;code&gt;a&lt;/code&gt; because if we don't, we are probably going to be testing the same tuple twice.&lt;/li&gt;
&lt;li&gt;Next, we pick a number between &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;. This is our hypotenuse, and of course all hypontenii are larger than either side.&lt;/li&gt;
&lt;li&gt;Now, we mercilessly and ruthlessly end all journeys who were unfortunate enough to pick a non-Pythagorean combination --- combinations where &lt;code&gt;a^2 + b^2&lt;/code&gt; is not &lt;code&gt;c^2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For those successful journeys, we succeed with a tuple containing our victorious triple &lt;code&gt;(a,b,c)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's try &amp;quot;following&amp;quot; this path with some arbitrary choices, looking at arbitrary journeys for &lt;code&gt;n = 10&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We pick &lt;code&gt;a&lt;/code&gt; as 2, &lt;code&gt;b&lt;/code&gt; as 3, and &lt;code&gt;c&lt;/code&gt; as 9. All is good until we get to the guard. &lt;code&gt;a^2 + b^2&lt;/code&gt; is 10, which is not &lt;code&gt;c^2&lt;/code&gt; (81), unfortunately. This &lt;code&gt;(2,3,10)&lt;/code&gt; journey ends here.&lt;/li&gt;
&lt;li&gt;We pick &lt;code&gt;a&lt;/code&gt; as 3, &lt;code&gt;b&lt;/code&gt; as 4, and &lt;code&gt;c&lt;/code&gt; as 5. On the guard, we succeed: &lt;code&gt;a^2 + b^2&lt;/code&gt; is 25, which indeed is &lt;code&gt;c^2&lt;/code&gt;. Our journey passes the guard, and then succeeds with a value of &lt;code&gt;(3,4,5)&lt;/code&gt;. This is indeed counted among the successful paths --- among the victorious!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Paths like &lt;code&gt;a = 5&lt;/code&gt; and &lt;code&gt;b = 3&lt;/code&gt; do not even happen. This is because if we pick &lt;code&gt;a = 5&lt;/code&gt;, then in that particular journey, &lt;code&gt;b&lt;/code&gt; can only be chosen between &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; inclusive.&lt;/p&gt;
&lt;p&gt;Remember, the final result is the accumulation of &lt;strong&gt;all such successful journeys&lt;/strong&gt;. A little bit of combinatorics will show that there are $\frac{1}{6} \times \frac{(n+2)!}{(n-1)!}$ possible journeys to attempt. Only the ones that do not fail (at the guard) will make it to the end. Remember how MonadPlus works --- one failure along the journey means that the &lt;em&gt;entire journey&lt;/em&gt; is a failure.&lt;/p&gt;
&lt;p&gt;Let's see what we get when we try it at the prompt:&lt;/p&gt;
&lt;p&gt;~~~haskell ghci&amp;gt; triplesUnder 10 [ ( 3, 4, 5),( 6, 8,10) ] ghci&amp;gt; triplesUnder 25 [ ( 3, 4, 5),( 5,12,13),( 6, 8,10),( 7,24,25) ,( 8,15,17),( 9,12,15),(12,16,20),(15,20,25) ] ~~~&lt;/p&gt;
&lt;p&gt;Perfect! You can probably quickly verify that all of these solutions are indeed Pythagorean triples. Out of the 220 journeys undertaken by &lt;code&gt;triplesUnder 10&lt;/code&gt;, only two of them survived to the end to be successful. Out of the 2925 journeys in &lt;code&gt;triplesUnder 25&lt;/code&gt;, only eight of them made it to the end. The rest &amp;quot;died&amp;quot;/failed, and as a result we do not even observe their remains. It is a cruel and unforgiving world.&lt;/p&gt;
&lt;p&gt;While the full diagram of &lt;code&gt;triplesUnder 5&lt;/code&gt; has 35 branches, here is a diagram for those branches with $a &amp;gt; 2$, which has 10:&lt;/p&gt;
&lt;p&gt;&lt;img src="/img/entries/monad-plus/triplesunder.png" title="triplesUnder 5" alt="triplesUnder 5, all journeys (where a &amp;gt; 2) illustrated" /&gt;&lt;/p&gt;
&lt;h2&gt;Almost There!&lt;/h2&gt;
&lt;p&gt;Let's do a quick review:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can really treat List exactly as if it were Maybe by using the general MonadPlus terms &lt;code&gt;mzero&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. If you do this, &lt;code&gt;Nothing&lt;/code&gt; is equivalent to &lt;code&gt;[]&lt;/code&gt;, and &lt;code&gt;Just x&lt;/code&gt; is equivalent to &lt;code&gt;[x]&lt;/code&gt;. Trippy!&lt;/li&gt;
&lt;li&gt;However, whereas Maybe is a &amp;quot;deterministic&amp;quot; success, for a list, a list of successes represents the end results of &lt;em&gt;possible paths&lt;/em&gt; to success. Chaining two &amp;quot;path splits&amp;quot; results in the item having to traverse both splits one after another.&lt;/li&gt;
&lt;li&gt;If any of these paths meet a failure at some point in their journey, the entire path is a failure and doesn't show up in the list of successes. &lt;em&gt;This&lt;/em&gt; is the &amp;quot;MonadPlus&amp;quot;ness of it all.&lt;/li&gt;
&lt;li&gt;When you use a do block (or reason about paths), it helps to think of each do block as representing one specific path in a Maybe monad, with arbitrary choices. Your &lt;code&gt;&amp;lt;-&lt;/code&gt; binds all represent &lt;em&gt;one specific element&lt;/em&gt;, &lt;em&gt;just&lt;/em&gt; like for Maybe.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last point is particularly important and is pretty pivotal in understanding what is coming up next. Remember that all Maybe blocks and List blocks really essentially look &lt;em&gt;exactly the same&lt;/em&gt;. This keeping-track-of-separate-paths thing is all handled behind-the scenes.&lt;/p&gt;
&lt;p&gt;In fact you should be able to look at code like:&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/TriplesUnder.hs#L12-L18 triplesUnder :: Int -&amp;gt; [Int] triplesUnder n = do a &amp;lt;- [1..n] b &amp;lt;- [a..n] c &amp;lt;- [b..n] guard $ a^2 + b^2 == c^2 return (a,b,c) ~~~&lt;/p&gt;
&lt;p&gt;and see that it is structurally identical to&lt;/p&gt;
&lt;p&gt;~~~haskell triplesUnder' :: Int -&amp;gt; Maybe Int triplesUnder' n = do a &amp;lt;- Just 3 b &amp;lt;- Just 5 c &amp;lt;- Just 8 guard $ a^2 + b^2 == c^2 return (a,b,c) ~~~&lt;/p&gt;
&lt;p&gt;for any arbitrary choice of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, except instead of &lt;code&gt;Just 3&lt;/code&gt; (or &lt;code&gt;[3]&lt;/code&gt;), you have &lt;code&gt;[2,3,4]&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;In fact recall that this block:&lt;/p&gt;
&lt;p&gt;~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/Halves.hs#L40-L43 genericHalve :: MonadPlus m =&amp;gt; Int -&amp;gt; m Int genericHalve n = do guard $ even n return $ n &lt;code&gt;div&lt;/code&gt; 2 ~~~&lt;/p&gt;
&lt;p&gt;is general enough that it works for both.&lt;/p&gt;
&lt;p&gt;Hopefully this all serves to show that &lt;strong&gt;in do blocks, Lists and Maybes are structurally identical&lt;/strong&gt;. You reason with them the exact same way you do with Maybe's. In something like &lt;code&gt;x &amp;lt;- Just 5&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; represents a &lt;strong&gt;single value&lt;/strong&gt;, the 5. In something like &lt;code&gt;x &amp;lt;- [1,2,3]&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; &lt;em&gt;also&lt;/em&gt; represents a single value --- the 1, the 2, or the 3, depending on which path you are currently on. Then later in the block, you can refer to &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; refers to &lt;em&gt;that&lt;/em&gt; one specific &lt;code&gt;x&lt;/code&gt; for that path.&lt;/p&gt;
&lt;h3&gt;Until next time&lt;/h3&gt;
&lt;p&gt;So I feel like we are at all we need to know to really use the list monad to solve a large class of logic problems (because who needs Prolog, anyway?).&lt;/p&gt;
&lt;p&gt;Between now and next time, think about how you would approach a logic problem like the Wolf/Goat/Cabbage problem with the concepts of MonadPlus? What would &lt;code&gt;mzero&lt;/code&gt;/fail be useful for? What would the idea of a success be useful for, and what would the idea of &amp;quot;multiple paths to success&amp;quot; in a journey even mean? What is the journey?&lt;/p&gt;
&lt;p&gt;Until next!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.html</guid><pubDate>Wed, 18 Dec 2013 19:08:38 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Ramblings</subject><date>2013-12-18</date></item><language>en</language><copyright>Copyright 2016 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Sun, 14 Jan 2018 06:52:01 UTC</lastBuildDate><generator>feed-1.0.0.0 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><creator>Justin Le</creator><language>en</language><rights>Copyright 2016 Justin Le</rights><date>2018-01-14</date><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description></channel></rss>