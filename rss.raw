<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>in Code — Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description><item><title>Introduction to Singletons (Part 2)</title><link>https://blog.jle.im/entry/introduction-to-singletons-2.html</link><description>&lt;p&gt;Welcome back to our journey through the singleton design pattern and the great &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library!&lt;/p&gt;
&lt;p&gt;This post is a direct continuation of &lt;a href=&quot;https://blog.jle.im/entry/introduction-to-singletons-1.html&quot;&gt;Part 1&lt;/a&gt;, so be sure to check that out first if you haven’t already! If you hare just jumping in now, I suggest taking some time to to through the exercises if you haven’t already!&lt;/p&gt;
&lt;p&gt;Again, code is built on &lt;em&gt;GHC 8.2.2&lt;/em&gt; with the &lt;em&gt;&lt;a href=&quot;https://www.stackage.org/lts-10.0&quot;&gt;lts-10.0&lt;/a&gt;&lt;/em&gt; snapshot (so, singletons-2.3.1).&lt;/p&gt;
&lt;h2 id=&quot;review&quot;&gt;Review&lt;/h2&gt;
&lt;p&gt;Let’s return to our &lt;code&gt;Door&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L19-25&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  data DoorState = Opened | Closed | Locked
    deriving (Show, Eq)
  |])

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; doorMaterial ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; } &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First, this derives the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; with the values &lt;code&gt;Opened&lt;/code&gt;, &lt;code&gt;Closed&lt;/code&gt;, and &lt;code&gt;Locked&lt;/code&gt;, and also the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; with the &lt;em&gt;types&lt;/em&gt; &lt;code&gt;&#39;Opened&lt;/code&gt;, &lt;code&gt;&#39;Closed&lt;/code&gt;, and &lt;code&gt;&#39;Locked&lt;/code&gt;. We then also derive the singletons (and implicit-style typeclass instances, reflectors, etc.) with the template haskell.&lt;/p&gt;
&lt;p&gt;Then, there’s &lt;code&gt;Door&lt;/code&gt;. &lt;code&gt;Door&lt;/code&gt; is great! It is an &lt;em&gt;indexed data type&lt;/em&gt; (indexed by a type of kind &lt;code&gt;DoorState&lt;/code&gt;) in that picking a different type variable gives a different “type” of Door:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Door &#39;Opened&lt;/code&gt; is a type that represents the type of an opened door&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Door &#39;Closed&lt;/code&gt; is a &lt;em&gt;different&lt;/em&gt; type that represents the type of a &lt;em&gt;closed&lt;/em&gt; door&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Door &#39;Locked&lt;/code&gt; is yet another (third) type that represents the type of a &lt;em&gt;locked&lt;/em&gt; door.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, really, when we define &lt;code&gt;Door s&lt;/code&gt;, we really are defining &lt;em&gt;three distinct&lt;/em&gt; types&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is great and all, but isn’t Haskell a language with static, compile-time types? Doesn’t that mean that we have to know if our doors are opened, closed, or locked at compile-time?&lt;/p&gt;
&lt;p&gt;This is something we can foresee being a big issue. It’s easy enough to create a &lt;code&gt;Door s&lt;/code&gt; if you know &lt;code&gt;s&lt;/code&gt; at compile-time by just typing in a type annotation (&lt;code&gt;UnsafeMkDoor &amp;quot;Oak&amp;quot; :: Door &#39;Opened&lt;/code&gt;) or by using a monomorphic constructor (&lt;code&gt;mkDoor @SOpened &amp;quot;Oak&amp;quot;&lt;/code&gt;). But what if we &lt;em&gt;don’t&lt;/em&gt; know &lt;code&gt;s&lt;/code&gt; at compile-time?&lt;/p&gt;
&lt;p&gt;To learn how to do this, we first need to learn how to &lt;em&gt;not care&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;ditching-the-phantom&quot;&gt;Ditching the Phantom&lt;/h2&gt;
&lt;p&gt;Sometimes we don’t &lt;em&gt;actually&lt;/em&gt; care about the state of the door in the &lt;em&gt;type&lt;/em&gt; of the door. We don’t want &lt;code&gt;Door &#39;Opened&lt;/code&gt; and &lt;code&gt;Door &#39;Closed&lt;/code&gt;…we want a type to just represent a door, without the status in its type.&lt;/p&gt;
&lt;p&gt;This might come about a bunch of different ways. Maybe you’re reading a &lt;code&gt;Door&lt;/code&gt; data from a serialization format, and you want to be able to parse &lt;em&gt;any&lt;/em&gt; door (whatever door is serialized).&lt;/p&gt;
&lt;p&gt;To learn how to not care, we can describe a type for a door that does &lt;em&gt;not&lt;/em&gt; have its status in its type.&lt;/p&gt;
&lt;p&gt;We have a couple of options here. First, we can create a new type &lt;code&gt;SomeDoor&lt;/code&gt; that is the same as &lt;code&gt;Door&lt;/code&gt;, except instead of keeping its status in its type, it keeps it as a runtime value:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;
    {&lt;span class=&quot;ot&quot;&gt; someDoorState    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
    ,&lt;span class=&quot;ot&quot;&gt; someDoorMaterial ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
    }

&lt;span class=&quot;co&quot;&gt;-- or, in GADT syntax&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;::&lt;/span&gt;
      {&lt;span class=&quot;ot&quot;&gt; someDoorState    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
      ,&lt;span class=&quot;ot&quot;&gt; someDoorMaterial ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
      } &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the similarity of &lt;code&gt;SomeDoor&lt;/code&gt;’s declaration to &lt;code&gt;Door&lt;/code&gt;’s declaration above. It’s mostly the same, except, instead of &lt;code&gt;DoorState&lt;/code&gt; being a type parameter, it is instead a runtime value inside &lt;code&gt;SomeDoor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, this is actually a type that we &lt;em&gt;could&lt;/em&gt; have been using this entire time, if we didn’t care about type safety. In the real world and in real applications, we actually might have written &lt;code&gt;SomeDoor&lt;/code&gt; &lt;em&gt;before&lt;/em&gt; we ever thought about &lt;code&gt;Door&lt;/code&gt; with a phantom type. It’s definitely the more typical “standard” Haskell thing.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SomeDoor&lt;/code&gt; is great. But because it’s a completely different type, we can’t re-use any of our &lt;code&gt;Door&lt;/code&gt; functions on this &lt;code&gt;SomeDoor&lt;/code&gt;. We potentially have to write the same function twice for both &lt;code&gt;Door&lt;/code&gt; and &lt;code&gt;SomeDoor&lt;/code&gt;, because they have different implementations.&lt;/p&gt;
&lt;h3 id=&quot;the-existential-datatype&quot;&gt;The Existential Datatype&lt;/h3&gt;
&lt;p&gt;However, there’s another path we can take. With the power of singletons, we can actually implement &lt;code&gt;SomeDoor&lt;/code&gt; &lt;em&gt;in terms of&lt;/em&gt; &lt;code&gt;Door&lt;/code&gt;, using an &lt;strong&gt;existential data type&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- using existential constructor syntax&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s) (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s)

&lt;span class=&quot;co&quot;&gt;-- or, using GADT syntax (preferred)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L56-57&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;MkSomeDoor&lt;/code&gt; is a constructor for an existential data type, meaning that the data type “hides” a type variable &lt;code&gt;s&lt;/code&gt;. Note the type (&lt;code&gt;Sing s -&amp;gt; Door s -&amp;gt; SomeDoor&lt;/code&gt;) and how the result type (&lt;code&gt;SomeDoor&lt;/code&gt;) &lt;em&gt;forgets&lt;/em&gt; the &lt;code&gt;s&lt;/code&gt; and hides all traces of it. Think of it like a type variable sponge – type variable goes in, but it’s absorbed opaquely into the result type.&lt;/p&gt;
&lt;p&gt;Note the similarities between our original &lt;code&gt;SomeDoor&lt;/code&gt; and this one.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- | Re-implementing door&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- | Re-using Door, as an existential type&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
                            &lt;span class=&quot;co&quot;&gt;-- ^ data Door s = UnsafeMkDoor String&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, our type before re-implements &lt;code&gt;Door&lt;/code&gt;. But the new one actually directly uses the original &lt;code&gt;Door s&lt;/code&gt;. This means we can &lt;em&gt;directly&lt;/em&gt; re-use our &lt;code&gt;Door&lt;/code&gt; functions on &lt;code&gt;SomeDoor&lt;/code&gt;s, without needing to write completely new implementations.&lt;/p&gt;
&lt;p&gt;In Haskell, existential data types are pretty nice, syntactically, to work with. Let’s write some basic functions to see. First, a function to “make” a &lt;code&gt;SomeDoor&lt;/code&gt; from a &lt;code&gt;Door&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L59-63&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
fromDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;fromDoor_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
fromDoor_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromDoor sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So that’s how we &lt;em&gt;make&lt;/em&gt; one…how do we &lt;em&gt;use&lt;/em&gt; it? Let’s port our &lt;code&gt;Door&lt;/code&gt; functions to &lt;code&gt;SomeDoor&lt;/code&gt;, by re-using our pre-existing functions whenever we can, and &lt;em&gt;pattern matching&lt;/em&gt; on &lt;code&gt;MkSomeDoor&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L65-72&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;closeSomeOpenedDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
closeSomeOpenedDoor (&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; s d) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromDoor_ &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; closeDoor d
    &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;lockAnySomeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
lockAnySomeDoor (&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; s d) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromDoor_ &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; lockAnyDoor s d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using an existential wrapper with a singleton makes this pretty simple – just a simple unwrapping and re-wrapping! Imagine having to re-implement all of these functions for a completely different type, and having to re-implement all of our previous &lt;code&gt;Door&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;It’s important to remember that the secret ingredient here is the &lt;code&gt;Sing s&lt;/code&gt; we store inside &lt;code&gt;MkSomeDoor&lt;/code&gt; – it gives our pattern matchers the ability to deduce the &lt;code&gt;s&lt;/code&gt; type. Without it, the &lt;code&gt;s&lt;/code&gt; would be lost forever.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;MkSomeDoor&lt;/code&gt; did not have the &lt;code&gt;Sing&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- no Sing s ???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It would then be impossible to write &lt;code&gt;closeSomeOpenedDoor&lt;/code&gt; in a way that only works on opened doors:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;closeSomeOpenedDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
closeSomeOpenedDoor (&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; d) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;-- is the door opened, closed, or locked?&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;-- there&amp;#39;s no way to know!&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;-- curses, type erasure!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;the-link&quot;&gt;The Link&lt;/h3&gt;
&lt;p&gt;It’s important to remember that our original separate-implementation &lt;code&gt;SomeDoor&lt;/code&gt; is, functionally, identical to the new code-reusing &lt;code&gt;Door&lt;/code&gt;. All of the contents are isomorphic with each other, and you could write a function converting one to the other. This is because &lt;em&gt;having an existentially quantified singleton is the same as having a value of the corresponding type.&lt;/em&gt; Having an existentially quantified &lt;code&gt;SingDS s&lt;/code&gt; is &lt;em&gt;the same as&lt;/em&gt; having a value of type &lt;code&gt;DoorState&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In fact, the &lt;em&gt;singletons&lt;/em&gt; library gives us a direct existential wrapper:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- from singletons (not the actual definition)&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are three values of type &lt;code&gt;SomeSing DoorState&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A value of type &lt;code&gt;SomeSing DoorState&lt;/code&gt; (which contains an existentially quantified &lt;code&gt;Sing s&lt;/code&gt; – a &lt;code&gt;SingDS&lt;/code&gt;) is &lt;em&gt;the same&lt;/em&gt; as a value of type &lt;code&gt;DoorState&lt;/code&gt;. The two types are identical! (Or, well, isomorphic. As a fun exercise, write out the explicit isomorphism – the &lt;code&gt;SomeSing DoorState -&amp;gt; DoorState&lt;/code&gt; and the &lt;code&gt;DoorState -&amp;gt; SomeSing DoorState&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Our new &lt;code&gt;SomeDoor&lt;/code&gt; containing an existentially quantified &lt;code&gt;Sing s&lt;/code&gt; is the same as our first &lt;code&gt;SomeDoor&lt;/code&gt; containing just a &lt;code&gt;DoorState&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;why-do-we-sing&quot;&gt;Why do we sing?&lt;/h4&gt;
&lt;p&gt;If they’re identical, why use a &lt;code&gt;Sing&lt;/code&gt; or the new &lt;code&gt;SomeDoor&lt;/code&gt; at all? Why not just use a &lt;code&gt;DoorState&lt;/code&gt; value?&lt;/p&gt;
&lt;p&gt;One main reason (besides allowing code-reuse like we did earlier) is that &lt;em&gt;using the singleton lets us directly recover the type&lt;/em&gt;. Essentially, a &lt;code&gt;Sing s&lt;/code&gt; not only contains whether it is Opened/Closed/Locked (like a &lt;code&gt;DoorState&lt;/code&gt; would), but also it contains it in a way that GHC can use to &lt;em&gt;bring it all back&lt;/em&gt; to the type level.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;forall s. SomeDoor (Sing s) (Door s)&lt;/code&gt; essentially contains &lt;code&gt;s&lt;/code&gt; &lt;em&gt;with&lt;/em&gt; &lt;code&gt;Door s&lt;/code&gt;. When you see this, you &lt;em&gt;should read this as&lt;/em&gt; &lt;code&gt;forall s. SomeDoor s (Door s)&lt;/code&gt; (and, indeed, this is similar to how it is written in dependently typed languages.)&lt;/p&gt;
&lt;p&gt;It’s kind of like how, when you’re used to reading Applicative style, you start seeing &lt;code&gt;f &amp;lt;$&amp;gt; x &amp;lt;*&amp;gt; y&lt;/code&gt; and reading it like &lt;code&gt;f x y&lt;/code&gt;. When you see &lt;code&gt;forall s. SomeDoor (Sing s) (Door s)&lt;/code&gt;, you should read (the pseudo-haskell) &lt;code&gt;forall s. SomeDoor s (Door s)&lt;/code&gt;. The role of &lt;code&gt;Sing s&lt;/code&gt; there is, like in Part 1, simply to be a run-time stand-in for the type &lt;code&gt;s&lt;/code&gt; itself.&lt;/p&gt;
&lt;p&gt;So, for our original &lt;code&gt;Door s&lt;/code&gt; functions, we need to know &lt;code&gt;s&lt;/code&gt; at runtime – storing the &lt;code&gt;Sing s&lt;/code&gt; gives GHC exactly that. Once you get the &lt;code&gt;Sing s&lt;/code&gt; back, you can now use it in all of our type-safe functions from Part 1, and you’re back in type-safe land.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;some-lingo&quot;&gt;Some Lingo&lt;/h3&gt;
&lt;p&gt;In the language of dependently typed programming, we call &lt;code&gt;SomeDoor&lt;/code&gt; a &lt;strong&gt;dependent sum&lt;/strong&gt;, because you can imagine it basically as a sum type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SDOpened&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened)&lt;/span&gt;
              &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SDClosed&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed)&lt;/span&gt;
              &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SDLocked&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A three-way sum between a &lt;code&gt;Door &#39;Opened&lt;/code&gt;, a &lt;code&gt;Door &#39;Closed&lt;/code&gt;, and a &lt;code&gt;Door &#39;Locked&lt;/code&gt;, essentially. If you have a &lt;code&gt;SomeDoor&lt;/code&gt;, it’s &lt;em&gt;either&lt;/em&gt; an opened door, a closed door, or a locked door. Try looking at this new &lt;code&gt;SomeDoor&lt;/code&gt; until you realize that this type is the same type as the previous &lt;code&gt;SomeDoor&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;You might also see &lt;code&gt;SomeDoor&lt;/code&gt; called a &lt;strong&gt;dependent pair&lt;/strong&gt; – it’s a “tuple” where the &lt;em&gt;type&lt;/em&gt; of the second item (our &lt;code&gt;Door s&lt;/code&gt;) is determined by the &lt;em&gt;value&lt;/em&gt; of the first item (our &lt;code&gt;Sing s&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In Idris, we could write &lt;code&gt;SomeDoor&lt;/code&gt; as a type alias, using its native &lt;a href=&quot;http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#dependent-pairs&quot;&gt;dependent pair syntactic sugar&lt;/a&gt;, as &lt;code&gt;(s ** Door s)&lt;/code&gt;. The &lt;em&gt;value&lt;/em&gt; of the first item reveals to us (through a pattern match, in Haskell) the &lt;em&gt;type&lt;/em&gt; of the second.&lt;/p&gt;
&lt;h3 id=&quot;types-at-runtime&quot;&gt;Types at Runtime&lt;/h3&gt;
&lt;p&gt;With this new tool, we finally have enough to build a function to “make” a door with the status unknown until runtime:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mkSomeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
mkSomeDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor_ &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mkDoor &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor_ &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mkDoor &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor_ &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mkDoor &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; mySomeDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSomeDoor &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Birch&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t mySomeDoor
&lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; putStrLn &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; mySomeDoor &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mySomeDoor was opened!&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mySomeDoor was closed!&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;mySomeDoor was locked!&amp;quot;&lt;/span&gt;
mySomeDoor was opened&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using &lt;code&gt;mkSomeDoor&lt;/code&gt;, we can truly pass in a &lt;code&gt;DoorState&lt;/code&gt; that we generate at runtime (from IO, or a user prompt, or a configuration file, maybe), and create a &lt;code&gt;Door&lt;/code&gt; based on it.&lt;/p&gt;
&lt;p&gt;Take &lt;em&gt;that&lt;/em&gt;, type erasure! :D&lt;/p&gt;
&lt;h3 id=&quot;the-existential-type&quot;&gt;The Existential Type&lt;/h3&gt;
&lt;p&gt;An &lt;em&gt;existentially quantified&lt;/em&gt; type is one that is hidden to the user/consumer, but directly chosen by the producer. The producer chooses the type, and the user has to handle any possible type that the producer gave.&lt;/p&gt;
&lt;p&gt;This is in direct contrast to the &lt;em&gt;universally quantified&lt;/em&gt; type (which most Haskellers are used to seeing), where the type is directly chosen by the &lt;em&gt;user&lt;/em&gt;. The user chooses the type, and the producer has to handle any possible type that the user asks for.&lt;/p&gt;
&lt;p&gt;For example, a function like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;read&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Read&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is universally quantified over &lt;code&gt;a&lt;/code&gt;: The &lt;em&gt;caller&lt;/em&gt; of &lt;code&gt;read&lt;/code&gt; gets to pick which type is given. The burden is on the implementor of &lt;code&gt;read&lt;/code&gt; to be able to handle whatever &lt;code&gt;a&lt;/code&gt; the user picks.&lt;/p&gt;
&lt;p&gt;But, for a value like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;myDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type variable &lt;code&gt;s&lt;/code&gt; is existentially quantified. The person who &lt;em&gt;made&lt;/em&gt; &lt;code&gt;myDoor&lt;/code&gt; picked what &lt;code&gt;s&lt;/code&gt; was. And, if you &lt;em&gt;use&lt;/em&gt; &lt;code&gt;myDoor&lt;/code&gt;, you have to be ready to handle &lt;em&gt;any&lt;/em&gt; &lt;code&gt;s&lt;/code&gt; they could have chosen.&lt;/p&gt;
&lt;p&gt;In Haskell, there’s another way to express an existentially quantified type: the CPS-style encoding. This way is useful because it doesn’t require creating an intermediate helper data type. To help us understand it, let’s compare a basic function in both styles. We saw earlier &lt;code&gt;mkSomeDoor&lt;/code&gt;, which takes a &lt;code&gt;DoorState&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; and returns an existentially quantified &lt;code&gt;Door&lt;/code&gt; in the form of &lt;code&gt;SomeDoor&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;mkSomeDoor
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
mkSomeDoor s m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor_ (mkDoor &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; m)
    &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor_ (mkDoor &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; m)
    &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor_ (mkDoor &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; m)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The caller of the function can then break open the &lt;code&gt;SomeDoor&lt;/code&gt; and must handle whatever &lt;code&gt;s&lt;/code&gt; they find inside.&lt;/p&gt;
&lt;p&gt;We can write the same function using a &lt;em&gt;CPS-style&lt;/em&gt; existential instead:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;withDoor
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withDoor s m f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; (mkDoor &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; m)
    &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; (mkDoor &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; m)
    &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; (mkDoor &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; m)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With a Rank-N Type, &lt;code&gt;withDoor&lt;/code&gt; takes a &lt;code&gt;DoorState&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; and a &lt;em&gt;function to handle a &lt;code&gt;Door s&lt;/code&gt; polymorphically&lt;/em&gt;. The caller of &lt;code&gt;withDoor&lt;/code&gt; must provide a handler that can handle &lt;em&gt;any&lt;/em&gt; &lt;code&gt;s&lt;/code&gt;, in a uniform and parametrically polymorphic way. The function then gives the result of the handler function called on the resulting &lt;code&gt;Sing s&lt;/code&gt; and &lt;code&gt;Door s&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; withDoor &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Birch&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \s d &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Opened door!&amp;quot;&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Closed door!&amp;quot;&lt;/span&gt;
         &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Locked door!&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; door&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key to making this work is that your handler function &lt;em&gt;has to be polymorphic&lt;/em&gt; over all possible &lt;code&gt;s&lt;/code&gt;s. This way, it can handle any potential &lt;code&gt;s&lt;/code&gt; that the producer gives. Essentially, the producer is “returning” an &lt;code&gt;s&lt;/code&gt; – existentially quantified.&lt;/p&gt;
&lt;h3 id=&quot;reification&quot;&gt;Reification&lt;/h3&gt;
&lt;p&gt;The general pattern we are exploring here is called &lt;strong&gt;reification&lt;/strong&gt; – we’re taking a dynamic run-time value, and lifting it to the type level as a type (here, the type variable &lt;code&gt;s&lt;/code&gt;). You can think of reification as the opposite of reflection, and imagine the two as being the “gateway” between the type-safe and unsafe world. In the dynamic world of a &lt;code&gt;DoorState&lt;/code&gt; term-level value, you have no type safety. You live in the world of &lt;code&gt;SomeDoor&lt;/code&gt;, &lt;code&gt;closeSomeOpenedDoor&lt;/code&gt;, &lt;code&gt;lockAnySomeDoor&lt;/code&gt;, etc. But, you can &lt;em&gt;reify&lt;/em&gt; your &lt;code&gt;DoorState&lt;/code&gt; value to a &lt;em&gt;type&lt;/em&gt;, and enter the type-safe world of &lt;code&gt;Door s&lt;/code&gt;, &lt;code&gt;closeDoor&lt;/code&gt;, &lt;code&gt;lockDoor&lt;/code&gt;, and &lt;code&gt;lockAnyDoor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;singletons&lt;/em&gt; library automatically generates functions to directly reify &lt;code&gt;DoorState&lt;/code&gt; values:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;toSing       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withSomeSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
&lt;span class=&quot;ot&quot;&gt;withSomeSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SDoorState&lt;/span&gt; s  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
                                     &lt;span class=&quot;co&quot;&gt;-- ^ using the convenience type synonym&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first one reifies a &lt;code&gt;DoorState&lt;/code&gt; as an existentially quantified data type, and the second one reifies one in CPS-style, without the intermediate data type.&lt;/p&gt;
&lt;p&gt;We can actually use these to write &lt;code&gt;mkSomeDoor&lt;/code&gt; and &lt;code&gt;withDoor&lt;/code&gt; in a nicer way, without directly pattern matching on our constructors:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L74-79&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mkSomeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
mkSomeDoor ds &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing ds &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fromDoor s &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mkDoor s

&lt;span class=&quot;ot&quot;&gt;withDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withDoor ds m f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing ds &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f s (mkDoor s m)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;zooming-out&quot;&gt;Zooming Out&lt;/h2&gt;
&lt;p&gt;Alright! We’ve spent two blog posts going over a lot of different things in the context of our humble &lt;code&gt;Door s&lt;/code&gt; type. Let’s zoom out and take a large-scale look at how &lt;em&gt;singletons&lt;/em&gt; (the design pattern, and the library) helps us in general.&lt;/p&gt;
&lt;h3 id=&quot;sing&quot;&gt;Sing&lt;/h3&gt;
&lt;p&gt;The crux of everything is the &lt;code&gt;Sing :: Type -&amp;gt; Type&lt;/code&gt; indexed type. If you see a value of type &lt;code&gt;Sing s&lt;/code&gt;, you should really just think “a runtime witness for &lt;code&gt;s&lt;/code&gt;”. If you see:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You should read it as (in pseudo-Haskell)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; { s } &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; { s } &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is seen clearly if we look at the partially applied type signatures:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;lockAnyDoor &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked -&amp;gt; SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you squint, this kinda looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;lockAnyDoor &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened :: Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;  &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked :: Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And indeed, when we get real dependent types in Haskell, we will really be directly passing types (that act as their own runtime values) instead of singletons.&lt;/p&gt;
&lt;p&gt;It is important to remember that &lt;code&gt;Sing&lt;/code&gt; is poly-kinded, so we can have &lt;code&gt;Sing &#39;Opened&lt;/code&gt;, but also &lt;code&gt;Sing &#39;True&lt;/code&gt;, &lt;code&gt;Sing 5&lt;/code&gt;, and &lt;code&gt;Sing &#39;[&#39;Just 3, &#39;Nothing, &#39;Just 0]&lt;/code&gt; as well. This is the real benefit of using the &lt;em&gt;singletons&lt;/em&gt; library instead of writing our own singletons – we get to work uniformly with singletons of all kinds.&lt;/p&gt;
&lt;h4 id=&quot;singi&quot;&gt;SingI&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SingI&lt;/code&gt; is a bit of typeclass trickery that lets us implicitly pass &lt;code&gt;Sing&lt;/code&gt;s to functions:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you see:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;  s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromDoor    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;  s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These are &lt;em&gt;identical in power&lt;/em&gt; to&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromDoor    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Either way, you’re passing in the ability to get a runtime witness on &lt;code&gt;s&lt;/code&gt; – just in one way, it is asked for as an explicit argument, and the second way, it is passed in using a typeclass.&lt;/p&gt;
&lt;p&gt;We can &lt;em&gt;convert&lt;/em&gt; from &lt;code&gt;SingI s -&amp;gt;&lt;/code&gt; style to &lt;code&gt;SingI s =&amp;gt;&lt;/code&gt; style using &lt;code&gt;sing&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L50-63&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;lockAnyDoor_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
lockAnyDoor_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; lockAnyDoor sing

&lt;span class=&quot;ot&quot;&gt;fromDoor_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
fromDoor_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromDoor sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can convert from &lt;code&gt;SingI s =&amp;gt;&lt;/code&gt; style to &lt;code&gt;SingI s -&amp;gt;&lt;/code&gt; style using &lt;code&gt;withSingI&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
lockAnyDoor s d &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSingI s (lockAnyDoor_ d)

&lt;span class=&quot;ot&quot;&gt;fromDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
fromDoor s d &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSingI s (fromDoor_ d)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, the same function – just two different styles of calling them.&lt;/p&gt;
&lt;h3 id=&quot;reflection-and-reification&quot;&gt;Reflection and Reification&lt;/h3&gt;
&lt;p&gt;Reflection is the process of bringing a type-level thing to a value at the term level (“losing” the type information in the process) and reification is the process of bringing a value at the &lt;em&gt;term level&lt;/em&gt; to the &lt;em&gt;type level&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Reflection and reification can be thought of as the gateways between the untyped/unsafe world and the typed/safe world. Reflection takes you from the typed world to the untyped world (from &lt;code&gt;Sing s&lt;/code&gt; to &lt;code&gt;DoorState&lt;/code&gt;) and reification takes you from the untyped world to the typed world (from &lt;code&gt;DoorState&lt;/code&gt; to &lt;code&gt;Sing s&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;One limitation in Haskell is that there is no actual link between the type &lt;code&gt;DoorState&lt;/code&gt; and its &lt;em&gt;values&lt;/em&gt; with the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; with its &lt;em&gt;types&lt;/em&gt;. Sure, the constructors have the same names, but the language doesn’t actually link them together for us.&lt;/p&gt;
&lt;h4 id=&quot;singkind&quot;&gt;SingKind&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;singletons&lt;/em&gt; library handles this by using a typeclass with associated types to implement a generalized reflection and reification process. It gives us the &lt;code&gt;SingKind&lt;/code&gt; “kindclass”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; k &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- `k` is a kind!&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- | Associate a kind k with its reflected type&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;r ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt;)

    &lt;span class=&quot;co&quot;&gt;-- | Reflect a singleton to its term-level value&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    fromSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;a ::&lt;/span&gt; k) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k

    &lt;span class=&quot;co&quot;&gt;-- | Reify a term-level value to the type level, as an existentially&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- quantified singleton&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    toSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instances of &lt;code&gt;SingKind&lt;/code&gt; are (promoted) &lt;em&gt;kinds&lt;/em&gt; like &lt;code&gt;Bool&lt;/code&gt;-the-kind, &lt;code&gt;DoorState&lt;/code&gt;-the-kind, etc., and &lt;code&gt;Demote&lt;/code&gt; is an associated type/type family that associates each instance with the &lt;em&gt;type&lt;/em&gt; it is promoted from. (Note – writing these type signatures requires the &lt;code&gt;-XTypeInType&lt;/code&gt; extension, which lets us treat kinds as types)&lt;/p&gt;
&lt;p&gt;For example, remember how &lt;code&gt;data DoorState = Opened | Closed | Locked&lt;/code&gt; created the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; (with value constructors &lt;code&gt;Opened&lt;/code&gt;, &lt;code&gt;Closed&lt;/code&gt;, and &lt;code&gt;Locked&lt;/code&gt;), and also the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; (with &lt;em&gt;type&lt;/em&gt; constructors &lt;code&gt;&#39;Opened&lt;/code&gt;, &lt;code&gt;&#39;Closed&lt;/code&gt;, and &lt;code&gt;&#39;Locked&lt;/code&gt;). Our &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; would be the instance of &lt;code&gt;SingKind&lt;/code&gt;, and &lt;code&gt;Demote DoorState&lt;/code&gt; would be the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The reason we need an explicit &lt;code&gt;Demote&lt;/code&gt; associated type is, again, that GHC doesn’t actually link the type and its promoted kind. &lt;code&gt;Demote&lt;/code&gt; lets us explicitly specify what type a &lt;code&gt;Kind&lt;/code&gt; should expect its term-level reflected values to be. (And, like most things in this post, &lt;code&gt;Demote&lt;/code&gt; will hopefully one day become obsolete, along with the rest of &lt;code&gt;SingKind&lt;/code&gt;)&lt;/p&gt;
&lt;h4 id=&quot;examples&quot;&gt;Examples&lt;/h4&gt;
&lt;p&gt;To illustrate explicitly, here is the automatically generated instance of &lt;code&gt;SingKind&lt;/code&gt; for the &lt;code&gt;DoorState&lt;/code&gt; &lt;em&gt;kind&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- the *kind* DoorState&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- the *type* DoorState&lt;/span&gt;

    fromSing
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;)        &lt;span class=&quot;co&quot;&gt;-- the *kind* DoorState&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;                    &lt;span class=&quot;co&quot;&gt;-- the *type* DoorState&lt;/span&gt;
    fromSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;

    toSing
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;                    &lt;span class=&quot;co&quot;&gt;-- the *type* DoorState&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- the *kind* DoorState&lt;/span&gt;
    toSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you are unfamiliar with how associated types work, &lt;code&gt;type Demote DoorState = DoorState&lt;/code&gt; means that wherever we see &lt;code&gt;Demote DoorState&lt;/code&gt; (with &lt;code&gt;DoorState&lt;/code&gt; the &lt;em&gt;kind&lt;/em&gt;), we replace it with &lt;code&gt;DoorState&lt;/code&gt; (the &lt;em&gt;type&lt;/em&gt;). That’s why the type of our reflection function &lt;code&gt;fromSing :: Sing s -&amp;gt; Demote DoorState&lt;/code&gt; can be simplified to &lt;code&gt;fromSing :: Sing s -&amp;gt; DoorState&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s take a look at the instance for &lt;code&gt;Bool&lt;/code&gt;, to compare:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- Bool singletons have two constructors:&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;False&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- the *kind* Bool&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- the *type* Bool&lt;/span&gt;

    fromSing
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;b ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)        &lt;span class=&quot;co&quot;&gt;-- the *kind* Bool&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;                    &lt;span class=&quot;co&quot;&gt;-- the *type* Bool&lt;/span&gt;
    fromSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;

    toSing
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;                    &lt;span class=&quot;co&quot;&gt;-- the *type* Bool&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- the *kind* Bool&lt;/span&gt;
    toSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a more sophisticated example, let’s look at the instance for &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- Maybe singletons have two constructors:&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNothing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Nothing&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SJust&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;Just x)&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; k &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; k) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- the *kind* Maybe&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; k) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k)        &lt;span class=&quot;co&quot;&gt;-- the *type* Maybe&lt;/span&gt;

    fromSing
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;m ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; k)        &lt;span class=&quot;co&quot;&gt;-- the *kind* Maybe&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k)           &lt;span class=&quot;co&quot;&gt;-- the *type* Maybe&lt;/span&gt;
    fromSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SNothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SJust&lt;/span&gt; sx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (fromSing sx)

    toSing
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k)             &lt;span class=&quot;co&quot;&gt;-- the *type* Maybe&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; k)           &lt;span class=&quot;co&quot;&gt;-- the *kind* Maybe&lt;/span&gt;
    toSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNothing&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SJust&lt;/span&gt; sx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This definition, I think, is a real testament to the usefulness of having all of our singletons be unified under the same system. Because of how &lt;code&gt;SingKind&lt;/code&gt; works, &lt;code&gt;Demote (Maybe DoorState)&lt;/code&gt; is evaluated to &lt;code&gt;Maybe (Demote DoorState)&lt;/code&gt;, which is simplified to &lt;code&gt;Maybe DoorState&lt;/code&gt;. This means that if we have a way to reify &lt;code&gt;DoorState&lt;/code&gt; values, we also have a way to reify &lt;code&gt;Maybe DoorState&lt;/code&gt; values! And, if we have a way to reflect &lt;code&gt;DoorState&lt;/code&gt; singletons, we also have a way to reflect &lt;code&gt;Maybe DoorState&lt;/code&gt; singletons!&lt;/p&gt;
&lt;h4 id=&quot;somesing&quot;&gt;SomeSing&lt;/h4&gt;
&lt;p&gt;Throughout all of this, we utilize &lt;code&gt;SomeSing&lt;/code&gt; as a generic poly-kinded existential wrapper:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; k) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, this says that &lt;code&gt;SomeSing k&lt;/code&gt; contains a &lt;code&gt;Sing x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is of kind &lt;code&gt;k&lt;/code&gt;. This is why we had, earlier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; k)   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; k)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we use &lt;code&gt;SomeSing&lt;/code&gt; with, say, &lt;code&gt;SClosed&lt;/code&gt;, we get &lt;code&gt;SomeSing :: Sing &#39;Closed -&amp;gt; SomeSing DoorState&lt;/code&gt;. &lt;code&gt;SomeSing&lt;/code&gt; is an indexed type that tells us the &lt;em&gt;kind&lt;/em&gt; of the type variable we existentially quantifying over. The value &lt;code&gt;SomeSing STrue&lt;/code&gt; would have the type &lt;code&gt;SomeSing Bool&lt;/code&gt;. The value &lt;code&gt;SomeSing (SJust SClosed)&lt;/code&gt; would have the type &lt;code&gt;SomeSing (Maybe DoorState)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;looking-forward&quot;&gt;Looking Forward&lt;/h2&gt;
&lt;p&gt;Between these first two parts, we explored a specific use case that would benefit from dependent types (simple phantom types for state transitions) and explored how the &lt;em&gt;singletons&lt;/em&gt; and design pattern help us implement the functionality necessary to make things useful, and snuck in some concepts from dependently typed programming as well. We then took a step back to explore the &lt;em&gt;singletons&lt;/em&gt; library in a more “universal” way, and saw how it is generalized to many different types.&lt;/p&gt;
&lt;p&gt;The code is available &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs&quot;&gt;here&lt;/a&gt; for you to play around with yourself!&lt;/p&gt;
&lt;p&gt;Now that the basics are out of the way, in Part 3 we’ll jump deep into type-level programming and being able to lift our term-level functions on values up to become type-level functions, and how to use this to express complex relationships and enhance our code!&lt;/p&gt;
&lt;p&gt;Let me know in the comments if you have any questions! I’m also usually idling on the freenode &lt;code&gt;#haskell&lt;/code&gt; channel, as well, as &lt;em&gt;jle`&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;And, again, I definitely recommend checking out the &lt;a href=&quot;https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf&quot;&gt;original singletons paper&lt;/a&gt; for a really nice technical overview of all of these techniques from the source itself.&lt;/p&gt;
&lt;h3 id=&quot;exercises&quot;&gt;Exercises&lt;/h3&gt;
&lt;p&gt;Check out the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs&quot;&gt;sample code&lt;/a&gt; for solutions!&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Let’s revisit our original redundant &lt;code&gt;SomeDoor&lt;/code&gt;, compared to our final &lt;code&gt;SomeDoor&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L56-87&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OldSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;OldMkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OldSomeDoor&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;MkSomeDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To help convince yourself that the two are equal, write functions converting between the two:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L89-92&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;toOld ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OldSomeDoor&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;fromOld ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OldSomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Avoid directly pattern matching on the singletons or constructors&lt;/strong&gt;. Instead, use &lt;em&gt;singletons&lt;/em&gt; library tools like &lt;code&gt;toSing&lt;/code&gt;, &lt;code&gt;withSomeSing&lt;/code&gt;, &lt;code&gt;fromSing&lt;/code&gt;, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Previously, we had an &lt;code&gt;unlockDoor&lt;/code&gt; function that took an &lt;code&gt;Int&lt;/code&gt; (the “password”) with a &lt;code&gt;Door &#39;Locked&lt;/code&gt; and returned a &lt;code&gt;Maybe (Door &#39;Closed)&lt;/code&gt;. It returns a &lt;code&gt;Door &#39;Closed&lt;/code&gt; (unlocked door) in &lt;code&gt;Just&lt;/code&gt; if an odd number was given, and &lt;code&gt;Nothing&lt;/code&gt; otherwise (a failed unlock)&lt;/p&gt;
&lt;p&gt;Use this to implement a that would return a &lt;code&gt;SomeDoor&lt;/code&gt;. Re-use the “password” logic from the original &lt;code&gt;unlockDoor&lt;/code&gt;. If the door is successfully unlocked (with a &lt;code&gt;Just&lt;/code&gt;), return the unlocked door in a &lt;code&gt;SomeDoor&lt;/code&gt;. Otherwise, &lt;em&gt;return the original locked door&lt;/em&gt; (in a &lt;code&gt;SomeDoor&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L95-100&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;unlockDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked -&amp;gt; Maybe (Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;)
unlockDoor n (&lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m)
    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;`mod`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m)
    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;unlockSomeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked -&amp;gt; SomeDoor&lt;/span&gt;
unlockSomeDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implement &lt;code&gt;openAnyDoor&#39;&lt;/code&gt; in the same style, with respect to &lt;code&gt;openAnyDoor&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L105-114&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;openAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened)&lt;/span&gt;
openAnyDoor n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; openAnyDoor_ sing
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    openAnyDoor_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened)&lt;/span&gt;
    openAnyDoor_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; openDoor
      &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fmap openDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; unlockDoor n

&lt;span class=&quot;ot&quot;&gt;openAnySomeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeDoor&lt;/span&gt;
openAnySomeDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember to re-use &lt;code&gt;openAnyDoor&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write the &lt;code&gt;SingKind&lt;/code&gt; instance for the promoted kind of a custom list type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door2.hs#L120-126&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; a (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; k) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;Cons x xs)&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; k &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; k) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; k) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;    fromSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;xs ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; k) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k)
    fromSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;    toSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; k) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; k)
    toSing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The singletons for &lt;code&gt;List&lt;/code&gt; are:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Nil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;Cons x xs)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the built-in singletons for the list type also uses these same constructor names, for &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;And also a not-so-obvious fourth type, &lt;code&gt;forall s. Door s&lt;/code&gt;, which is a subtype of all of those three!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;You might have noticed I was a bit sneaky by jumping straight &lt;code&gt;SomeDoor&lt;/code&gt; when we already had a perfectly good “I don’t care” option. We used it last post!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This does work! &lt;code&gt;lockAnyDoor&lt;/code&gt; takes a &lt;code&gt;Door s&lt;/code&gt; and doesn’t “care” about what &lt;code&gt;s&lt;/code&gt; it gets (it’s parametrically polymorphic).&lt;/p&gt;
&lt;p&gt;So, this normal “parametrically polymorphic” way is how we have, in the past, treated functions that &lt;em&gt;can take&lt;/em&gt; a &lt;code&gt;Door&lt;/code&gt; with an &lt;code&gt;s&lt;/code&gt; we don’t want the type system to care about. However, the reason we need &lt;code&gt;SomeDoor&lt;/code&gt; and existentially quantified types is for the situation where we want to &lt;em&gt;return&lt;/em&gt; something that we want to the type system to not care about.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/introduction-to-singletons-2.html</guid><pubDate>Tue,  9 Jan 2018 18:54:27 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell</dc:subject><dc:date>2018-01-09</dc:date></item><item><title>Advent of Code 2017! Ongoing solutions and explanations</title><link>https://blog.jle.im/entry/advent-of-code-2017.html</link><description>&lt;p&gt;Just a short post to share that I started a github repository of my &lt;a href=&quot;https://github.com/mstksg/advent-of-code-2017&quot;&gt;Advent of Code 2017 Solutions&lt;/a&gt;, as I write them!&lt;/p&gt;
&lt;p&gt;I also am including my &lt;a href=&quot;https://github.com/mstksg/advent-of-code-2017/blob/master/reflections.md&quot;&gt;reflections&lt;/a&gt; and explanations on my solutions, explaining my thought processes and how the solutions work.&lt;/p&gt;
&lt;p&gt;Yes I definitely spent a bit too much time writing the executable, which is an automated (cached) downloader, test suite runner (on sample inputs), and benchmark suite.&lt;/p&gt;
&lt;p&gt;I originally was only going to casually try the problems (like I did last year), but I hit a decent global rank by accident on Day 4 (which was very suited for Haskell!), and since then I’ve been taking things seriously to try to aim for the global leaderboard (top 100). This is a struggle for me because I’m not really the &lt;em&gt;fastest&lt;/em&gt; algorithm person, but I think it’s a fun goal for me to try to hit this year.&lt;/p&gt;
&lt;p&gt;Wish me luck! And if you haven’t started yet, it’s not too late to join in the fun! &lt;a href=&quot;https://twitter.com/glguy&quot;&gt;glguy&lt;/a&gt; has been maintaining the semi-official &lt;a href=&quot;adventofcode.com/2017/leaderboard/private&quot;&gt;Haskell Leaderboard&lt;/a&gt; (join code &lt;code&gt;43100-84040706&lt;/code&gt;) – come join us!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/advent-of-code-2017.html</guid><pubDate>Thu,  7 Dec 2017 21:46:51 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell</dc:subject><dc:date>2017-12-07</dc:date></item><item><title>Introduction to Singletons (Part 1)</title><link>https://blog.jle.im/entry/introduction-to-singletons-1.html</link><description>&lt;p&gt;Real dependent types are coming to Haskell soon! Until then, we have the great &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library :)&lt;/p&gt;
&lt;p&gt;If you’ve ever run into dependently typed programming in Haskell, you’ve probably encountered mentions of singletons (and the &lt;em&gt;singletons&lt;/em&gt; library). This series of articles will be my attempt at giving you the story of the library, the problems it solves, the power that it gives to you, and how you can integrate it into your code today!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; (Also, after &lt;a href=&quot;https://blog.jle.im/entry/verified-instances-in-haskell.html&quot;&gt;my previous April Fools post&lt;/a&gt;, people have been asking me for an actual non-joke singletons post)&lt;/p&gt;
&lt;p&gt;This post (Part 1) will go over first using the singleton pattern for &lt;em&gt;reflection&lt;/em&gt;, then introducing how the singletons library helps us. Part 2 will discuss using the library for &lt;em&gt;reification&lt;/em&gt;, to get types that depend on values at runtime. Part 3 will go into the basics singleton’s &lt;em&gt;defunctionalization&lt;/em&gt; system and how we can promote value-level functions to type-level functions, and Part 4 will delve into deeper applications of defunctionalization.&lt;/p&gt;
&lt;p&gt;I definitely am writing this post with the hope that it will be obsolete in a year or two. When dependent types come to Haskell, singletons will be nothing more than a painful historical note. But for now, singletons might be the best way to get your foot into the door and experience the thrill and benefits of dependently typed programming &lt;em&gt;today&lt;/em&gt;!&lt;/p&gt;
&lt;h3 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h3&gt;
&lt;p&gt;These posts will assume no knowledge of dependent types, and, for now, only basic to intermediate Haskell knowledge (Types, kinds, typeclasses, data types, functions). The material in this post &lt;em&gt;overlaps&lt;/em&gt; with my &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html&quot;&gt;dependently typed neural networks&lt;/a&gt; series, but the concepts are introduced in different contexts.&lt;/p&gt;
&lt;p&gt;All code is built on &lt;em&gt;GHC 8.2.2&lt;/em&gt; and with the &lt;em&gt;&lt;a href=&quot;https://www.stackage.org/lts-10.0&quot;&gt;lts-10.0&lt;/a&gt;&lt;/em&gt; snapshot (so, singletons-2.3.1). However, there are negligible changes in the GHC type system between GHC 8.0 and 8.2 (the only difference is in the libraries, more or less), so everything should work on GHC 8.0 as well!&lt;/p&gt;
&lt;p&gt;The content in the first section of this post, describing the singleton design pattern, uses the following extensions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DataKinds&lt;/li&gt;
&lt;li&gt;GADTs&lt;/li&gt;
&lt;li&gt;KindSignatures&lt;/li&gt;
&lt;li&gt;RankNTypes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With some optional “convenience extensions”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LambdaCase&lt;/li&gt;
&lt;li&gt;TypeApplications&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And the second section, introducing the &lt;em&gt;singletons&lt;/em&gt; library itself, uses, additionally:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TemplateHaskell&lt;/li&gt;
&lt;li&gt;TypeFamilies&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These extension will be explained when they are used or become relevant.&lt;/p&gt;
&lt;h2 id=&quot;the-phantom-of-the-types&quot;&gt;The Phantom of the Types&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;(The code for this pre-singletons section is available &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs&quot;&gt;on github&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let’s start with a very common Haskell trick that most learn early in their Haskelling journey: the &lt;a href=&quot;https://wiki.haskell.org/Phantom_type&quot;&gt;phantom type&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Phantom types in Haskell are a very simple way to add a layer of “type safety” for your types and DSL’s. It helps you restrict what values functions can take and encode pre- and post-conditions directly into your types.&lt;/p&gt;
&lt;p&gt;For example, in&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MkFoo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;a&lt;/code&gt; parameter is &lt;em&gt;phantom&lt;/em&gt;, because nothing of type &lt;code&gt;a&lt;/code&gt; in the data type…it just exists as a dummy parameter for the &lt;code&gt;Foo&lt;/code&gt; type. We can use &lt;code&gt;MkFoo&lt;/code&gt; without ever requiring something of type &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;MkFoo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;MkFoo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;MkFoo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- requires -XPolyKinds&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;MkFoo&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- requires -XConstraintKinds&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One use case of phantom type parameters is to prohibit certain functions on different types of values and let you be more descriptive with how your functions work together (like in &lt;a href=&quot;https://ren.zone/articles/safe-money&quot;&gt;safe-money&lt;/a&gt;). One “hello world” use case of phantom type parameters is to tag data as “sanitized” or “unsanitized” (&lt;code&gt;UserString &#39;Santitized&lt;/code&gt; type vs. &lt;code&gt;UserString &#39;Unsanitized&lt;/code&gt;) or paths as absolute or relative (&lt;code&gt;Path &#39;Absolute&lt;/code&gt; vs. &lt;code&gt;Path &#39;Relative&lt;/code&gt;). For a simple example, let’s check out a simple DSL for a type-safe door:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L12-15&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; doorMaterial ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A couple things going on here:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Our type we are going to be playing with is a &lt;code&gt;Door&lt;/code&gt;, which contains a single field &lt;code&gt;doorMaterial&lt;/code&gt; describing, say, the material that the door is made out of. (&lt;code&gt;UnsafeMkDoor &amp;quot;Oak&amp;quot;&lt;/code&gt; would be an oak door)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We’re using the &lt;code&gt;DataKinds&lt;/code&gt; extension to create both the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; as well as the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Normally, &lt;code&gt;data DoorState = Opened | Closed | Locked&lt;/code&gt; in Haskell defines the type &lt;code&gt;DoorState&lt;/code&gt; and the value constructors &lt;code&gt;Opened&lt;/code&gt;, &lt;code&gt;Closed&lt;/code&gt;, and &lt;code&gt;Locked&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, with &lt;code&gt;DataKinds&lt;/code&gt;, that statement also defines a new &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt;, with &lt;em&gt;type&lt;/em&gt; constructors &lt;code&gt;&#39;Opened&lt;/code&gt;, &lt;code&gt;&#39;Closed&lt;/code&gt;, and &lt;code&gt;&#39;Locked&lt;/code&gt;. (note the &lt;code&gt;&#39;&lt;/code&gt; ticks!)&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;We’re defining the &lt;code&gt;Door&lt;/code&gt; type with a &lt;em&gt;phantom parameter&lt;/em&gt; &lt;code&gt;s&lt;/code&gt;. It’s a phantom type because we don’t actually have any &lt;em&gt;values&lt;/em&gt; of type &lt;code&gt;s&lt;/code&gt; in our data type&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; …the &lt;code&gt;s&lt;/code&gt; is only just there as a dummy parameter for the type.&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;UnsafeMkDoor&lt;/code&gt; without ever using anything of type &lt;code&gt;s&lt;/code&gt;. In reality, a real &lt;code&gt;Door&lt;/code&gt; type would be a bit more complicated (and the direct &lt;code&gt;UnsafeMkDoor&lt;/code&gt; constructor would be hidden).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Birch&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Iron&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can also use the &lt;em&gt;TypeApplications&lt;/em&gt; extension to write this in a bit more convenient way –&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened &amp;quot;Birch&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked &amp;quot;Iron&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alternatively, we can define &lt;code&gt;Door&lt;/code&gt; using &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/GADT#Syntax&quot;&gt;&lt;em&gt;GADT&lt;/em&gt; syntax&lt;/a&gt; (which requires the &lt;code&gt;GADTs&lt;/code&gt; extension)&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; doorMaterial ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; } &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is defining the exact same type in the alternate “GADT syntax” style of data type declaration – here, we define types by giving the type of its constructors, &lt;code&gt;UnsafeMkDoor :: String -&amp;gt; Door s&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Door&lt;/code&gt; here is an &lt;strong&gt;indexed data type&lt;/strong&gt;, which is sometimes called a “type family” in the dependently typed programming world (which is not to be confused with type families in &lt;em&gt;GHC Haskell&lt;/em&gt;, &lt;code&gt;-XTypeFamilies&lt;/code&gt;, which is a language mechanism that is related but definitely not the same).&lt;/p&gt;
&lt;h3 id=&quot;phantoms-in-action&quot;&gt;Phantoms in Action&lt;/h3&gt;
&lt;p&gt;At first, this seems a bit silly. Why even have the extra type parameter if you don’t ever use it?&lt;/p&gt;
&lt;p&gt;Well, right off the bat, we can write functions that expect only a certain type of &lt;code&gt;Door&lt;/code&gt;, and return a specific type of &lt;code&gt;Door&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L17-18&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;closeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;
closeDoor (&lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, the &lt;code&gt;closeDoor&lt;/code&gt; function will &lt;em&gt;only&lt;/em&gt; take a &lt;code&gt;Door &#39;Opened&lt;/code&gt; (an opened door). And it will return a &lt;code&gt;Door &#39;Closed&lt;/code&gt; (a closed door).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; myDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened &amp;quot;Spruce&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t myDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t closeDoor myDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; yourDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed &amp;quot;Acacia&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t closeDoor yourDoor
&lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can think of this as a nice way of catching &lt;em&gt;logic errors&lt;/em&gt; at compile-time. If your door type did not have its status in the type, the &lt;code&gt;closeDoor&lt;/code&gt; could have been given a closed or locked door, and you’d have to handle and reject it at &lt;em&gt;runtime&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;By adding the state of the door into its type, we can encode our pre-conditions and post-conditions directly into the type. And any opportunity to move runtime errors to compile-time errors should be celebrated with a party!&lt;/p&gt;
&lt;p&gt;This would also stop you from doing silly things like closing a door twice in a row:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t closeDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; closeDoor
&lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Do you see why?&lt;/p&gt;
&lt;p&gt;With a couple of state transitions, we can write compositions that are type-checked to all be legal:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L20-24&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;lockDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;
lockDoor (&lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m

&lt;span class=&quot;ot&quot;&gt;openDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;
openDoor (&lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; m)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t closeDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; openDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; closeDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; openDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; openDoor
&lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because of the type of &lt;code&gt;lockDoor&lt;/code&gt;, you &lt;em&gt;cannot&lt;/em&gt; lock an opened door! Don’t even try! You’d have to close it first.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; myDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened &amp;quot;Spruce&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t myDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockDoor myDoor
&lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t closeDoor myDoor
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockDoor (closeDoor myDoor)
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;lockDoor&lt;/code&gt; expects a &lt;code&gt;Door &#39;Closed&lt;/code&gt;, so if you give it a &lt;code&gt;Door &#39;Opened&lt;/code&gt;, that’s a static compile-time type error. But, &lt;code&gt;closeDoor&lt;/code&gt; takes a &lt;code&gt;Door &#39;Opened&lt;/code&gt; and returns a &lt;code&gt;Door &#39;Closed&lt;/code&gt; – so &lt;em&gt;that&lt;/em&gt; is something that you can call &lt;code&gt;lockDoor&lt;/code&gt; with!&lt;/p&gt;
&lt;h3 id=&quot;the-phantom-menace&quot;&gt;The Phantom Menace&lt;/h3&gt;
&lt;p&gt;However, in standard Haskell, we quickly run into some practical problems if we program with phantom types this way.&lt;/p&gt;
&lt;p&gt;For example, how could we write a function to get the state of a door?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;doorStatus ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
doorStatos _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(It can be done with an ad-hoc typeclass, but it’s not simple, and it’s prone to implementation bugs)&lt;/p&gt;
&lt;p&gt;And, perhaps even more important, how can you create a &lt;code&gt;Door&lt;/code&gt; with a given state that isn’t known until runtime? If we know the type of our doors at compile-time, we can just explicitly write &lt;code&gt;UnsafeMkDoor &amp;quot;Iron&amp;quot; :: Door &#39;Opened&lt;/code&gt; or &lt;code&gt;UnsafeMkDoor @&#39;Opened &amp;quot;Iron&amp;quot;&lt;/code&gt;. But what if we wanted to make a door based on a &lt;code&gt;DoorState&lt;/code&gt; &lt;em&gt;value&lt;/em&gt;? Something we might not get until runtime?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mkDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s
mkDoor &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ?&lt;/span&gt;
mkDoor &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ?&lt;/span&gt;
mkDoor &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah hah, you say. That’s easy!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mkDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s
mkDoor &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt;
mkDoor &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt;
mkDoor &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, that’s not how types work in Haskell. Remember that for a polymorphic type &lt;code&gt;forall s. DoorState -&amp;gt; String -&amp;gt; Door s&lt;/code&gt;, the &lt;em&gt;caller&lt;/em&gt; picks the type variable.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t mkDoor &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Acacia&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oops!&lt;/p&gt;
&lt;h3 id=&quot;the-fundamental-issue-in-haskell&quot;&gt;The Fundamental Issue in Haskell&lt;/h3&gt;
&lt;p&gt;We’ve hit upon a fundamental issue in Haskell’s type system: &lt;strong&gt;type erasure&lt;/strong&gt;. In Haskell, types only exist &lt;em&gt;at compile-time&lt;/em&gt;, for help with type-checking. They are completely erased at runtime.&lt;/p&gt;
&lt;p&gt;This is usually what we want. It’s great for performance, and you can bypass things like the ad-hoc runtime type checking that you have to deal with in dynamic languages like python.&lt;/p&gt;
&lt;p&gt;But in our case, it makes functions like &lt;code&gt;doorState&lt;/code&gt; fundamentally impossible. Or, does it?&lt;/p&gt;
&lt;h2 id=&quot;the-singleton-pattern&quot;&gt;The Singleton Pattern&lt;/h2&gt;
&lt;p&gt;A singleton in Haskell is a type (of kind &lt;code&gt;Type&lt;/code&gt; – that is, &lt;code&gt;*&lt;/code&gt;) that has exactly one inhabitant. In practice (and when talking about the design pattern), it refers to a parameterized type that, for each pick of parameter, gives a type with exactly one inhabitant. It is written so that pattern matching on the &lt;em&gt;constructor&lt;/em&gt; of that value reveals the unique type parameter.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L26-29&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we’re using &lt;em&gt;GADT syntax&lt;/em&gt; again (but to make an actual GADT). (Also note that &lt;code&gt;Type&lt;/code&gt; is a synonym for the &lt;code&gt;*&lt;/code&gt; kind, exported from the &lt;em&gt;Data.Kind&lt;/em&gt; module) So, if we use &lt;code&gt;SOpened&lt;/code&gt;, we will get a &lt;code&gt;SingDS &#39;Opened&lt;/code&gt;. And if we have a &lt;code&gt;SingDS &#39;Opened&lt;/code&gt;, we know that it was constructed using &lt;code&gt;SOpened&lt;/code&gt;. Essentially, this gives us three values:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;the-power-of-the-pattern-match&quot;&gt;The Power of the Pattern Match&lt;/h3&gt;
&lt;p&gt;The power of singletons is that we can now &lt;em&gt;pattern match&lt;/em&gt; on types, essentially.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L17-35&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;closeDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;lockDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed -&amp;gt; Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
lockAnyDoor sng door &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sng &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; lockDoor (closeDoor door) &lt;span class=&quot;co&quot;&gt;-- in this branch, s is &amp;#39;Opened&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; lockDoor door             &lt;span class=&quot;co&quot;&gt;-- in this branch, s is &amp;#39;Closed&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; door                      &lt;span class=&quot;co&quot;&gt;-- in this branch, s is &amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;lockAnyDoor&lt;/code&gt; is a function that can take a door of any state (a &lt;code&gt;Door s&lt;/code&gt; of any &lt;code&gt;s&lt;/code&gt;) and &lt;em&gt;lock&lt;/em&gt; it using a composition of &lt;code&gt;lockDoor&lt;/code&gt; or &lt;code&gt;closeDoor&lt;/code&gt; as necessary.&lt;/p&gt;
&lt;p&gt;If we have &lt;code&gt;lockAnyDoor&lt;/code&gt; take a &lt;code&gt;SingDS s&lt;/code&gt; as its input (and, importantly, make sure that the &lt;code&gt;s&lt;/code&gt; in &lt;code&gt;SingDS s&lt;/code&gt; is the same &lt;code&gt;s&lt;/code&gt; in the &lt;code&gt;Door s&lt;/code&gt;), we can &lt;em&gt;pattern match&lt;/em&gt; on the &lt;code&gt;SingDS s&lt;/code&gt; to &lt;em&gt;reveal&lt;/em&gt; what &lt;code&gt;s&lt;/code&gt; is, to the type checker. This is known as a &lt;strong&gt;dependent pattern match&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If &lt;code&gt;SingDS s&lt;/code&gt;’s pattern match goes down the &lt;code&gt;SOpened -&amp;gt;&lt;/code&gt; case, then we &lt;em&gt;know&lt;/em&gt; that &lt;code&gt;s ~ &#39;Opened&lt;/code&gt;&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;. We know that &lt;code&gt;s&lt;/code&gt; must be &lt;code&gt;&#39;Opened&lt;/code&gt;, because &lt;code&gt;SOpened :: SingDS &#39;Opened&lt;/code&gt;, so there really isn’t anything else the &lt;code&gt;s&lt;/code&gt; in &lt;code&gt;SingDS s&lt;/code&gt; could be!&lt;/p&gt;
&lt;p&gt;So, if we know that &lt;code&gt;s ~ &#39;Opened&lt;/code&gt;, that means that the &lt;code&gt;Door s&lt;/code&gt; is &lt;code&gt;Door &#39;Opened&lt;/code&gt;. So because &lt;code&gt;door :: Door&#39; Opened&lt;/code&gt;, we have to &lt;code&gt;closeDoor&lt;/code&gt; it to get a &lt;code&gt;Door&#39; Closed&lt;/code&gt;, and then &lt;code&gt;lockDoor&lt;/code&gt; it to get a &lt;code&gt;Door &#39;Locked&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We say that &lt;code&gt;SOpened&lt;/code&gt; is a &lt;em&gt;runtime witness&lt;/em&gt; to &lt;code&gt;s&lt;/code&gt; being &lt;code&gt;&#39;Opened&lt;/code&gt;.&lt;/p&gt;
&lt;!-- Note that `lockDoor . closeDoor` will *only* compile if given a `Door --&gt;
&lt;!-- &#39;Opened`, but because of our dependent pattern match, we *know* we have a --&gt;
&lt;!-- `Door &#39;Opened`. --&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Same for the &lt;code&gt;SClosed -&amp;gt;&lt;/code&gt; branch – since &lt;code&gt;SClosed :: SingDS &#39;Closed&lt;/code&gt;, then &lt;code&gt;s ~ &#39;Closed&lt;/code&gt;, so our &lt;code&gt;Door s&lt;/code&gt; must be a &lt;code&gt;Door &#39;Closed&lt;/code&gt;. This allows us to simply take our &lt;code&gt;door :: Door &#39;Closed&lt;/code&gt; and use &lt;code&gt;lockDoor&lt;/code&gt; to get a &lt;code&gt;Door &#39;Locked&lt;/code&gt;&lt;/p&gt;
&lt;!-- just write `SClosed -&gt; lockDoor`. --&gt;
&lt;!-- Again, `lockDoor :: Door &#39;Closed -&gt; Door &#39;Locked`, so it would only work if --&gt;
&lt;!-- given a `Door &#39;Closed` -- which we know we have, because of the dependent --&gt;
&lt;!-- pattern match. --&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For the &lt;code&gt;SLocked -&amp;gt;&lt;/code&gt; branch, &lt;code&gt;SLocked :: SingDS &#39;Locked&lt;/code&gt;, so &lt;code&gt;s ~ &#39;Locked&lt;/code&gt;, so our &lt;code&gt;Door s&lt;/code&gt; is a &lt;code&gt;Door &#39;Locked&lt;/code&gt;. Our door is “already” locked, so we can just use the &lt;code&gt;door :: Door &#39;Locked&lt;/code&gt; that we got!&lt;/p&gt;
&lt;!-- use `id :: Door &#39;Locked -&gt; Door &#39;Locked`. --&gt;
&lt;!-- Note that `id :: Door &#39;Locked -&gt; Door &#39;Locked` would not work for any other --&gt;
&lt;!-- branch, and would be a compile-time error.  `id` only works if you know your --&gt;
&lt;!-- input is already `Door &#39;Locked`...which we know because of the dependent --&gt;
&lt;!-- pattern match. --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essentially, our singletons give us &lt;em&gt;runtime values&lt;/em&gt; that can be used as &lt;em&gt;witnesses&lt;/em&gt; for types and type variables. These values exist at runtime, so they “bypass” type erasure. Types themselves are directly erased, but we can hold on to them using these runtime tokens when we need them.&lt;/p&gt;
&lt;p&gt;Note that we can also write &lt;code&gt;lockAnyDoor&lt;/code&gt; using the &lt;em&gt;LambdaCase&lt;/em&gt; extension syntactic sugar, which I think offers a lot of extra insight:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;lockAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked)&lt;/span&gt;
lockAnyDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; lockDoor &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; closeDoor  &lt;span class=&quot;co&quot;&gt;-- in this branch, s is &amp;#39;Opened&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; lockDoor              &lt;span class=&quot;co&quot;&gt;-- in this branch, s is &amp;#39;Closed&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; id                    &lt;span class=&quot;co&quot;&gt;-- in this branch, s is &amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we can see &lt;code&gt;lockAnyDoor sng&lt;/code&gt; as a partially applied function that returns a &lt;code&gt;Door s -&amp;gt; Door &#39;Locked&lt;/code&gt; For any &lt;code&gt;SingDS s&lt;/code&gt; you give to &lt;code&gt;lockAnyDoor&lt;/code&gt;, &lt;code&gt;lockAnyDoor&lt;/code&gt; returns a “locker function” (&lt;code&gt;Door s -&amp;gt; Door &#39;Locked&lt;/code&gt;) that is custom-made for your &lt;code&gt;SingDS&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;lockAnyDoor SOpened&lt;/code&gt; will return a &lt;code&gt;Door &#39;Opened -&amp;gt; Door &#39;Locked&lt;/code&gt;. Here, it has to give &lt;code&gt;lockDoor . closeDoor :: Door &#39;Opened -&amp;gt; Door &#39;Locked&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;lockAnyDoor SClosed&lt;/code&gt; will return a &lt;code&gt;Door &#39;Closed -&amp;gt; Door &#39;Locked&lt;/code&gt; – namely &lt;code&gt;lockDoor :: Door &#39;Closed -&amp;gt; Door &#39;Locked&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;lockAnyDoor SLocked&lt;/code&gt; will return a &lt;code&gt;Door &#39;Locked -&amp;gt; Door &#39;Locked&lt;/code&gt;, which will just be &lt;code&gt;id :: Door &#39;Locked -&amp;gt; Door &#39;Locked&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that all of these functions will &lt;em&gt;only&lt;/em&gt; typecheck under the branch they fit in. If we gave &lt;code&gt;lockDoor&lt;/code&gt; for the &lt;code&gt;SOpened&lt;/code&gt; branch, or &lt;code&gt;id&lt;/code&gt; for the &lt;code&gt;SClosed&lt;/code&gt; branch, that’ll be a compile-time error!&lt;/p&gt;
&lt;h4 id=&quot;reflection&quot;&gt;Reflection&lt;/h4&gt;
&lt;p&gt;Writing &lt;code&gt;doorStatus&lt;/code&gt; is now pretty simple –&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;doorStatus ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
doorStatus &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;
doorStatus &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;
doorStatus &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The benefit of the singleton again relies on the fact that the &lt;code&gt;s&lt;/code&gt; in &lt;code&gt;SingDS s&lt;/code&gt; is the same as the &lt;code&gt;s&lt;/code&gt; in &lt;code&gt;Door s&lt;/code&gt;, so if the user gives a &lt;code&gt;SingDS s&lt;/code&gt;, it &lt;em&gt;has&lt;/em&gt; to match the &lt;code&gt;s&lt;/code&gt; in the &lt;code&gt;Door s&lt;/code&gt; they give.&lt;/p&gt;
&lt;p&gt;Since we don’t even care about the &lt;code&gt;door&lt;/code&gt;, we could also just write:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L37-40&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fromSingDS ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
fromSingDS &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;
fromSingDS &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;
fromSingDS &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which we can use to write a nicer &lt;code&gt;doorStatus&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L42-43&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;doorStatus ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
doorStatus s _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromSingDS s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This process – of turning a type variable (like &lt;code&gt;s&lt;/code&gt;) into a dynamic runtime value is known as &lt;strong&gt;reflection&lt;/strong&gt;. We move a value from the &lt;em&gt;type level&lt;/em&gt; to the &lt;em&gt;term level&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&quot;recovering-implicit-passing&quot;&gt;Recovering Implicit Passing&lt;/h3&gt;
&lt;p&gt;One downside is that we are required to manually pass in our witness. Wouldn’t it be nice if we could have it be passed implicitly? We can actually leverage typeclasses to give us this ability:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L45-53&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; s &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    singDS ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened where&lt;/span&gt;
    singDS &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed where&lt;/span&gt;
    singDS &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked where&lt;/span&gt;
    singDS &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that &lt;em&gt;it’s impossible&lt;/em&gt; to write our &lt;code&gt;SingDSI&lt;/code&gt; instances improperly! GHC checks to make sure that this is &lt;em&gt;correct&lt;/em&gt;)&lt;/p&gt;
&lt;p&gt;And so now we can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L55-59&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;lockAnyDoor_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
lockAnyDoor_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; lockAnyDoor singDS

&lt;span class=&quot;ot&quot;&gt;doorStatus_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;
doorStatus_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; doorStatus singDS&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, type inference will tell GHC that you want &lt;code&gt;singDS :: SingDS s&lt;/code&gt;, and it will pull out the proper singleton for the door you want to check!&lt;/p&gt;
&lt;p&gt;Now, we can call &lt;code&gt;lockAnyDoor_&lt;/code&gt; &lt;em&gt;without passing in&lt;/em&gt; a singleton, explicitly!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; myDoor &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened &amp;quot;Birch&amp;quot;&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockAnyDoor &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; myDoor &lt;span class=&quot;co&quot;&gt;-- our original method!&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockAnyDoor singDS myDoor  &lt;span class=&quot;co&quot;&gt;-- the power of type inference!&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t lockAnyDoor_ myDoor        &lt;span class=&quot;co&quot;&gt;-- no explicit singleton being passed!&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;the-same-power&quot;&gt;The Same Power&lt;/h4&gt;
&lt;p&gt;In Haskell, a constraint &lt;code&gt;SingDSI s =&amp;gt;&lt;/code&gt; is essentially the same as passing in &lt;code&gt;SingDS s&lt;/code&gt; explicitly. Either way, you are passing in a runtime witness that your function can use. You can think of &lt;code&gt;SingDSI s =&amp;gt;&lt;/code&gt; as passing it in &lt;em&gt;implicitly&lt;/em&gt;, and &lt;code&gt;SingDS s -&amp;gt;&lt;/code&gt; as passing it in &lt;em&gt;explicitly&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So, it’s important to remember that &lt;code&gt;lockAnyDoor&lt;/code&gt; and &lt;code&gt;lockAnyDoor_&lt;/code&gt; are the “same function”, with the same power. They are just written in different styles – &lt;code&gt;lockAnyDoor&lt;/code&gt; is written in explicit style, and &lt;code&gt;lockAnyDoor_&lt;/code&gt; is written in implicit style.&lt;/p&gt;
&lt;h4 id=&quot;going-backwards&quot;&gt;Going backwards&lt;/h4&gt;
&lt;p&gt;Going from &lt;code&gt;SingDSI s =&amp;gt;&lt;/code&gt; to &lt;code&gt;SingDS s -&amp;gt;&lt;/code&gt; (implicit to explicit) is very easy – just use &lt;code&gt;singDS&lt;/code&gt; to get a &lt;code&gt;SingDS s&lt;/code&gt; if you have a &lt;code&gt;SingDSI s&lt;/code&gt; constraint available. This is what we did for &lt;code&gt;lockAnyDoor_&lt;/code&gt; and &lt;code&gt;doorStatus_&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Going from &lt;code&gt;SingDS s -&amp;gt;&lt;/code&gt; to &lt;code&gt;SingDSI s =&amp;gt;&lt;/code&gt; (explicit to implicit) in Haskell is actually a little trickier. The typical way to do this is with a CPS-like utility function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L61-65&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withSingDSI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withSingDSI sng x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sng &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x
    &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x
    &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;withSingDSI&lt;/code&gt; takes a &lt;code&gt;SingDS s&lt;/code&gt;, and a value (of type &lt;code&gt;r&lt;/code&gt;) that requires a &lt;code&gt;SingDSI s&lt;/code&gt; instance to be created. And it creates that value for you!&lt;/p&gt;
&lt;p&gt;To use &lt;code&gt;x&lt;/code&gt;, you must have a &lt;code&gt;SingDSI s&lt;/code&gt; instance available. This all works because in each branch, &lt;code&gt;s&lt;/code&gt; is now a &lt;em&gt;specific&lt;/em&gt;, monomorphic, “concrete” &lt;code&gt;s&lt;/code&gt;, and GHC knows that such an instance exists for every branch.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the &lt;code&gt;SOpened&lt;/code&gt; branch, &lt;code&gt;s ~ &#39;Opened&lt;/code&gt;. We explicitly wrote an instance of &lt;code&gt;SingDSI&lt;/code&gt; for &lt;code&gt;&#39;Opened&lt;/code&gt;, so GHC &lt;em&gt;knows&lt;/em&gt; that there is a &lt;code&gt;SingDSI &#39;Opened&lt;/code&gt; instance in existence, allowing you to use/create &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;SClosed&lt;/code&gt; branch, &lt;code&gt;s ~ &#39;Closed&lt;/code&gt;, so GHC knows that there is a &lt;code&gt;SingDSI &#39;Closed&lt;/code&gt; instance (because we wrote one explicitly!), and gives &lt;em&gt;that&lt;/em&gt; to you – and so you are allowed to use/create &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;SLocked&lt;/code&gt; branch, &lt;code&gt;s ~ &#39;Locked&lt;/code&gt;, and because we wrote a &lt;code&gt;SingDSI &#39;Locked&lt;/code&gt; explicitly, we &lt;em&gt;know&lt;/em&gt; that a &lt;code&gt;SingDSI s&lt;/code&gt; instance is available, so we can use/create &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, we can run our implicit functions (like &lt;code&gt;lockAnyDoor_&lt;/code&gt;) by giving them explicit inputs:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L67-68&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;lockAnyDoor__ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;
lockAnyDoor__ s d &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSingDSI s (lockAnyDoor_ d)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And the cycle begins anew.&lt;/p&gt;
&lt;p&gt;One interesting thing to point out – note that the type of &lt;code&gt;withSingDSI&lt;/code&gt; is very similar to the type of another common combinator:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;withSingDSI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SingDSI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
flip&lt;span class=&quot;ot&quot;&gt;  ($)   ::&lt;/span&gt;        a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (        a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is a bit of a testament to what we said earlier about how a &lt;code&gt;SingDSI s =&amp;gt; ..)&lt;/code&gt; is the same as &lt;code&gt;SingDS s -&amp;gt; ..&lt;/code&gt;. &lt;code&gt;flip ($)&lt;/code&gt; takes a value and a function and applies the function to that value. &lt;code&gt;withSingDSI&lt;/code&gt; takes a value and “something like a function” and applies the “something like a function” to that value.&lt;/p&gt;
&lt;h3 id=&quot;fun-with-witnesses&quot;&gt;Fun with Witnesses&lt;/h3&gt;
&lt;p&gt;We can write a nice version of &lt;code&gt;mkDoor&lt;/code&gt; using singletons:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs#L70-71&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mkDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingDS&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s
mkDoor _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkDoor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We take advantage of the fact that &lt;code&gt;SingDS s&lt;/code&gt; “locks in” the &lt;code&gt;s&lt;/code&gt; type variable for &lt;code&gt;Door s&lt;/code&gt;. We can call it now with values of &lt;code&gt;SingDS&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t mkDoor &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Oak&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t mkDoor &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Spruce&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can’t do something silly like pass in &lt;code&gt;SLocked&lt;/code&gt; to get a &lt;code&gt;Door &#39;Opened&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;the-singletons-library&quot;&gt;The Singletons Library&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;(The code for this post-singletons section is available &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs&quot;&gt;on github&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Now that we understand some of the benefits of singletons as they relate to phantom types, we can appreciate what the singletons &lt;em&gt;library&lt;/em&gt; has to offer: a fully unified, coherent system for working with singletons of almost &lt;em&gt;all&lt;/em&gt; Haskell types!&lt;/p&gt;
&lt;p&gt;First, there’s Template Haskell for generating our singletons given our type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)

genSingletons [&lt;span class=&quot;ch&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;-- or&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L17-20&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  data DoorState = Opened | Closed | Locked
    deriving (Show, Eq)
  |])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This generates, for us:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- not the actual code, but essentially what happens&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;DoorState&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Sing&lt;/code&gt; is a poly-kinded type constructor (a “data family”). &lt;code&gt;STrue :: Sing &#39;True&lt;/code&gt; is the singleton for &lt;code&gt;&#39;True&lt;/code&gt;, &lt;code&gt;SJust SOpened :: Sing (&#39;Just &#39;Opened)&lt;/code&gt; is the singleton for &lt;code&gt;&#39;Just &#39;Opened&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;It also generates us instances for &lt;code&gt;SingI&lt;/code&gt;, a poly-kinded typeclass:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened where&lt;/span&gt;
    sing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed where&lt;/span&gt;
    sing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked where&lt;/span&gt;
    sing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is basically our &lt;code&gt;SingDSI&lt;/code&gt; typeclass, except we have instances for singletons of all kinds! (heh) There’s a &lt;code&gt;SingI&lt;/code&gt; instance for &lt;code&gt;&#39;True&lt;/code&gt;, a &lt;code&gt;SingI&lt;/code&gt; instance for &lt;code&gt;10&lt;/code&gt;, a &lt;code&gt;SingI&lt;/code&gt; instance for &lt;code&gt;&#39;Just &#39;Opened&lt;/code&gt;, etc.:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;Just &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;SJust&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We also have &lt;code&gt;withSingI&lt;/code&gt;, which is equivalent to our &lt;code&gt;withSingDSI&lt;/code&gt; function earlier.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;withSingI ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall r&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that if you have singletons for a kind &lt;code&gt;k&lt;/code&gt;, you also have instances for kind &lt;code&gt;Maybe k&lt;/code&gt;, as well. And also for &lt;code&gt;[k]&lt;/code&gt;, even! The fact that we have a unified way of working with and manipulating singletons of so many different types is a major advantage of using the &lt;em&gt;singletons&lt;/em&gt; library to manage your singletons instead of writing them yourself.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[ &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;, &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed, &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Locked&lt;/span&gt; ]
&lt;span class=&quot;co&quot;&gt;-- &amp;#39;SCons is the singleton for `:` (cons),&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- and &amp;#39;SNil is the singleton for `[]` (nil)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Remember that, because of &lt;code&gt;DataKinds&lt;/code&gt;, &lt;code&gt;Maybe&lt;/code&gt; is a kind constructor, who has two type constructors, the type &lt;code&gt;&#39;Nothing&lt;/code&gt; and the type constructor &lt;code&gt;&#39;Just :: k -&amp;gt; Maybe k&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Singletons for all kinds integrate together seamlessly, and you have mechanisms to generate them for your own type and roll it all into the system!&lt;/p&gt;
&lt;h3 id=&quot;extra-goodies&quot;&gt;Extra Goodies&lt;/h3&gt;
&lt;p&gt;In addition to generating singletons for our libraries, it gives us convenient functions for working with the different “manifestations” of our types.&lt;/p&gt;
&lt;p&gt;Recall that &lt;code&gt;DoorState&lt;/code&gt; has four different things associated with it now:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;The &lt;em&gt;type&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt;, whose value constructors are &lt;code&gt;Opened&lt;/code&gt;, &lt;code&gt;Closed&lt;/code&gt;, and &lt;code&gt;Locked&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt;, whose type constructors are &lt;code&gt;&#39;Opened&lt;/code&gt;, &lt;code&gt;&#39;Closed&lt;/code&gt;, and &lt;code&gt;&#39;Locked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The singletons for &lt;code&gt;&#39;Opened&lt;/code&gt;, &lt;code&gt;&#39;Closed&lt;/code&gt;, and &lt;code&gt;&#39;Locked&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SClosed&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Closed&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SLocked&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;SingI&lt;/code&gt; instances for &lt;code&gt;&#39;Opened&lt;/code&gt;, &lt;code&gt;&#39;Closed&lt;/code&gt;, and &lt;code&gt;&#39;Locked&#39;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kind of confusing, and in the future, when we have real dependent types, we can combine all of these manifestations into the &lt;em&gt;one&lt;/em&gt; thing. But for now, we do have to deal with converting between them, and for that, &lt;em&gt;singletons&lt;/em&gt; generates for us &lt;code&gt;fromSing :: Sing (s :: DoorState) -&amp;gt; DoorState&lt;/code&gt;. &lt;code&gt;fromSing&lt;/code&gt; takes us from singletons to term-level values (&lt;em&gt;reflection&lt;/em&gt;):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; fromSing &lt;span class=&quot;dt&quot;&gt;SOpened&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Opened&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It does this by defining a type class (actually, a “kind class”), &lt;code&gt;SingKind&lt;/code&gt;, associating each type to the corresponding datakinds-generated kind. The &lt;code&gt;SingKind&lt;/code&gt; instance for &lt;code&gt;DoorState&lt;/code&gt; links the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt; to the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;DoorState&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The library also defines a neat type synonym, &lt;code&gt;type SDoorState = Sing&lt;/code&gt;, so you can do &lt;code&gt;SDoorState &#39;Opened&lt;/code&gt; instead of &lt;code&gt;Sing &#39;Opened&lt;/code&gt;, if you wish.&lt;/p&gt;
&lt;p&gt;There are definitely more useful utility functions, but we will investigate these later on in the series! For now, you can look at the &lt;a href=&quot;http://hackage.haskell.org/package/singletons/docs/Data-Singletons.html&quot;&gt;documentation&lt;/a&gt; for the library to see more interesting utility functions!&lt;/p&gt;
&lt;h2 id=&quot;the-singularity&quot;&gt;The Singularity&lt;/h2&gt;
&lt;p&gt;In this post, at shortcomings in the usage of phantom types, and then saw how singletons could help us with these. Then, we looked at how the &lt;em&gt;singletons&lt;/em&gt; &lt;strong&gt;library&lt;/strong&gt; makes using this pattern extremely easy and smooth to integrate into your existing code.&lt;/p&gt;
&lt;p&gt;You can see all of the “manual singletons” code in this post &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/Door.hs&quot;&gt;here&lt;/a&gt;, and then see the code re-implemented using the &lt;em&gt;singletons&lt;/em&gt; library &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, remember the question that I asked earlier, about creating a &lt;code&gt;Door&lt;/code&gt; with a given state that we don’t know until runtime? So far, we are only able to create &lt;code&gt;Door&lt;/code&gt; and &lt;code&gt;SingDS&lt;/code&gt; from types we &lt;em&gt;know&lt;/em&gt; at compile-time. There is no way we have yet to convert a &lt;code&gt;DoorState&lt;/code&gt; from the value level to the type level – so it seems that there is no way to “load” a &lt;code&gt;Door s&lt;/code&gt; with an &lt;code&gt;s&lt;/code&gt; that depends on, say, a file’s contents, or user input. The fundamental issue is still &lt;em&gt;type erasure&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In Part 2, we will delve into how to overcome this and break through from the barrier of the dynamic “unsafe” runtime to the world of safe, typed, verified code, and see how the &lt;em&gt;singletons&lt;/em&gt; library gives us great tools for this. Afterwards, in Part 3, we will learn to express more complicated relationships with types and type-level functions using defunctionalization and the tools from the &lt;em&gt;singletons&lt;/em&gt; library, and finally break into the world of actual “type-level programming”.&lt;/p&gt;
&lt;p&gt;As always, let me know in the comments if you have any questions! You can also usually find me idling on the freenode &lt;code&gt;#haskell&lt;/code&gt; channel, as well, as &lt;em&gt;jle`&lt;/em&gt;. The &lt;em&gt;singletons&lt;/em&gt; &lt;a href=&quot;https://github.com/goldfirere/singletons/issues&quot;&gt;issue tracker&lt;/a&gt; is also very active. Happy haskelling!&lt;/p&gt;
&lt;p&gt;For further reading, check out the &lt;a href=&quot;https://cs.brynmawr.edu/~rae/papers/2012/singletons/paper.pdf&quot;&gt;original singletons paper&lt;/a&gt;! It’s very readable and goes over many of the same techniques in this blog post, just written with a different perspective and tone :)&lt;/p&gt;
&lt;h2 id=&quot;exercises&quot;&gt;Exercises&lt;/h2&gt;
&lt;p&gt;Click on the links in the corner of the text boxes for solutions! (or just check out &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs&quot;&gt;the source file&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;These should be written in the singletons library style, with &lt;code&gt;Sing&lt;/code&gt; instead of &lt;code&gt;SingDS&lt;/code&gt; and &lt;code&gt;SingI&lt;/code&gt; instead of &lt;code&gt;SingDSI&lt;/code&gt;. Review the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs&quot;&gt;singletons file&lt;/a&gt; for a comparison, if you are still unfamiliar.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Write a function to unlock a door, but only if the user enters an odd number (as a password).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L60-60&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;unlockDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Locked -&amp;gt; Maybe (Door &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Closed&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It should return a closed door in &lt;code&gt;Just&lt;/code&gt; if the caller gives an odd number, or &lt;code&gt;Nothing&lt;/code&gt; otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a function that can open any door, taking a password, in “implicit Sing” style:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/singletons/DoorSingletons.hs#L65-65&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;openAnyDoor ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Door&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Opened)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This should be written in terms of &lt;code&gt;unlockDoor&lt;/code&gt; and &lt;code&gt;openDoor&lt;/code&gt; (see above) – that is, you &lt;strong&gt;should not&lt;/strong&gt; use &lt;code&gt;UnsafeMkDoor&lt;/code&gt; directly for &lt;code&gt;openAnyDoor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the door is already unlocked or opened, it should ignore the &lt;code&gt;Int&lt;/code&gt; input.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;This series will be based on &lt;a href=&quot;http://talks.jle.im/lambdaconf-2017/singletons/&quot;&gt;a talk&lt;/a&gt; I gave over the summer, and will expand on it.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;The &lt;code&gt;&#39;&lt;/code&gt; ticks are technically optional, but I find that it’s good style, at this point in Haskell, to use them whenever you can. It’ll prevent a lot of confusion, trust me!&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Indeed, this is not even possible. There are no values of type &lt;code&gt;&#39;SClosed&lt;/code&gt;, &lt;code&gt;&#39;SOpened&lt;/code&gt;, etc.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;Actually, GADT syntax just requires &lt;code&gt;-XGADTSyntax&lt;/code&gt;, but &lt;code&gt;-XGADT&lt;/code&gt; allows you to actually make GADTs (which we will be doing later), and implies &lt;code&gt;-XGADTSyntax&lt;/code&gt;&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;&lt;code&gt;~&lt;/code&gt; here refers to “type equality”, or the constraint that the types on both sides are equal. &lt;code&gt;s ~ &#39;Opened&lt;/code&gt; can be read as “&lt;code&gt;s&lt;/code&gt; is &lt;code&gt;&#39;Opened&lt;/code&gt;”.&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/introduction-to-singletons-1.html</guid><pubDate>Fri, 22 Dec 2017 18:42:07 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell</dc:subject><dc:date>2017-12-22</dc:date></item><item><title>Hamiltonian Dynamics in Haskell</title><link>https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.html</link><description>&lt;p&gt;As promised in my &lt;a href=&quot;https://blog.jle.im/entry/introducing-the-hamilton-library.html&quot;&gt;&lt;em&gt;hamilton&lt;/em&gt; introduction post&lt;/a&gt; (published almost exactly one year ago!), I’m going to go over implementing of the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hamilton&quot;&gt;hamilton&lt;/a&gt;&lt;/em&gt; library using&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;em&gt;DataKinds&lt;/em&gt; (with &lt;em&gt;TypeLits&lt;/em&gt;) to enforce sizes of vectors and matrices and help guide us write our code&lt;/li&gt;
&lt;li&gt;Statically-sized linear algebra with &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Automatic differentiation with &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Statically-sized vectors with &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector-sized&quot;&gt;vector-sized&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This post will be a bit heavy in some mathematics and Haskell concepts. The expected audience is intermediate Haskell programmers. Note that this is &lt;em&gt;not&lt;/em&gt; a post on dependent types, because dependent types (types that depend on runtime values) are not explicitly used.&lt;/p&gt;
&lt;p&gt;The mathematics and physics are “extra” flavor text and could potentially be skipped, but you’ll get the most out of this article if you have basic familiarity with:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Basic concepts of multivariable calculus (like partial and total derivatives).&lt;/li&gt;
&lt;li&gt;Concepts of linear algebra (like dot products, matrix multiplication, and matrix inverses)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;No physics knowledge is assumed, but knowing a little bit of first semester physics would help you gain a bit more of an appreciation for the end result!&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://blog.jle.im/entry/introducing-the-hamilton-library.html&quot;&gt;hamilton library introduction&lt;/a&gt; should be considered a “soft prerequisite” for this post, as it presents motivations, visual demonstrations, and general overviews of the methods presented here!&lt;/p&gt;
&lt;h2 id=&quot;the-goal&quot;&gt;The Goal&lt;/h2&gt;
&lt;p&gt;At the end of this, we should be able to have Haskell &lt;em&gt;automatically generate&lt;/em&gt; &lt;strong&gt;equations of motions&lt;/strong&gt; for any arbitrary system described in arbitrary coordinate systems, and simulate that system.&lt;/p&gt;
&lt;p&gt;Normally, we’d describe a system using particles’ x and y coordinates, but our goal is to be able to describe our particles’ positions using any coordinate system we want (polar, distance-along-a-curved-rail, pendulum-angles, etc.) and have Haskell automatically generate equations of motions and time progressions of those coordinates.&lt;/p&gt;
&lt;p&gt;Read &lt;a href=&quot;https://blog.jle.im/entry/introducing-the-hamilton-library.html&quot;&gt;my hamilton library introduction&lt;/a&gt; for more information and examples!&lt;/p&gt;
&lt;h2 id=&quot;hamiltonian-mechanics&quot;&gt;Hamiltonian Mechanics&lt;/h2&gt;
&lt;p&gt;As mentioned in the previous post, Hamiltonian mechanics is a re-imagining of dynamics and mechanics (think “the world post-&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt;”) that not only opened up new doors to solving problems in classical, but also ended up being the right angle of viewing the world to unlock statistical mechanics and thermodynamics, and later even quantum mechanics.&lt;/p&gt;
&lt;p&gt;Hamiltonian mechanics lets you parameterize your system’s “position” in arbitrary ways (like the angle of rotation, for pendulum problems) and then posits that the full state of the system exists in something called &lt;em&gt;phase space&lt;/em&gt;, and that the system’s dynamics is its motion through phase space that is dictated by the geometry of the &lt;em&gt;Hamiltonian&lt;/em&gt; of that phase space.&lt;/p&gt;
&lt;p&gt;The system’s &lt;em&gt;Hamiltonian&lt;/em&gt; is a &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B2n%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D&quot; alt=&quot;\mathbb{R}^{2n} \rightarrow \mathbb{R}&quot; title=&quot;\mathbb{R}^{2n} \rightarrow \mathbb{R}&quot; /&gt; function from a point in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B2n%7D&quot; alt=&quot;\mathbb{R}^{2n}&quot; title=&quot;\mathbb{R}^{2n}&quot; /&gt; phase space (where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt; is the number of coordinates parameterizing your system) to a scalar in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D&quot; alt=&quot;\mathbb{R}&quot; title=&quot;\mathbb{R}&quot; /&gt;. For a time-independent system, the picture of the dynamics is pretty simple: the system moves along the &lt;em&gt;contour lines&lt;/em&gt; of the &lt;em&gt;Hamiltonian&lt;/em&gt; – the lines of equal “height”.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/hamilton/contour-lines.jpg&quot; title=&quot;Contour lines&quot; alt=&quot;Example of contour lines of a \mathbb{R}^2 \rightarrow \mathbb{R} function – the elevation of land, from the Ordinace Survey website.&quot; /&gt;&lt;figcaption&gt;Example of contour lines of a &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E2%20%5Crightarrow%20%5Cmathbb%7BR%7D&quot; alt=&quot;\mathbb{R}^2 \rightarrow \mathbb{R}&quot; title=&quot;\mathbb{R}^2 \rightarrow \mathbb{R}&quot; /&gt; function – the elevation of land, from the &lt;a href=&quot;https://www.ordnancesurvey.co.uk/blog/2015/11/map-reading-skills-making-sense-of-contour-lines/&quot;&gt;Ordinace Survey&lt;/a&gt; website.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In the example above, if we imagine that phase space is the 2D location, then the &lt;em&gt;Hamiltonian&lt;/em&gt; is the mountain. And for a system dropped anywhere on the mountain, its motion would be along the contour lines. For example, if a system started somewhere along the 10 contour line, it would begin to oscillate the entire phase space along the 10 contour line.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Every&lt;/em&gt; &lt;a href=&quot;https://www.youtube.com/watch?v=izGwDsrQ1eQ&quot;&gt;smooth&lt;/a&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B2n%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D&quot; alt=&quot;\mathbb{R}^{2n} \rightarrow \mathbb{R}&quot; title=&quot;\mathbb{R}^{2n} \rightarrow \mathbb{R}&quot; /&gt; function on phase space can be used as a Hamiltonian to describe the physics of some system. So, given any “mountain range” on phase space, any “elevation map” or real-valued function on phase space, you can treat it as a description of the dynamics of some physical system.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;trick&lt;/em&gt;, then, to using Hamiltonian dynamics to model your system, is:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Finding the phase space to describe your system. This can be done based on any continuous parameterization of your system (“generalized coordinates”), like angles of pendulums and so on.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finding the Hamiltonian on that phase space to describe your system.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And then Hamilton’s dynamics will give you the rest! All you do is “follow the contour lines” on that Hamiltonian!&lt;/p&gt;
&lt;h3 id=&quot;phase-space&quot;&gt;Phase Space&lt;/h3&gt;
&lt;p&gt;Hamiltonian dynamics are about systems moving around in phase space. It seems that phase space is the “room where it happens”, so to speak, so let’s dig deeper into what it is. &lt;em&gt;Phase space&lt;/em&gt; is a &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?2n&quot; alt=&quot;2n&quot; title=&quot;2n&quot; /&gt;-dimensional space parameterized by:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;All of the current values of the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt; parameters (“generalized coordinates”)&lt;/li&gt;
&lt;li&gt;All of the current “generalized momenta” of those &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt; parameters&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So if you were parameterizing your pendulum system by, say, the angle of the pendulum, then a point in phase space would be the current angle of the pendulum along with the current “generalized momentum” associated with the angle of the pendulum. What exactly &lt;em&gt;is&lt;/em&gt; generalized momentum? We’ll go over calculating it eventually, but what does it represent…&lt;em&gt;physically&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;The deeper answer involves the underlying Lie algebra of the Lie group associated with the generalized coordinates, but going into that would make this a completely different post. What I &lt;em&gt;can&lt;/em&gt; say is that the generalized momenta associated with (“conjugate to”) certain sets of familiar coordinates yield things that we typically call “momenta”:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;The momentum conjugate to normal Cartesian coordinates is just our normal run-of-the-mill &lt;em&gt;linear momentum&lt;/em&gt; (in the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D%20%3D%20m%20%5Cmathbf%7Bv%7D&quot; alt=&quot;\mathbf{p} = m \mathbf{v}&quot; title=&quot;\mathbf{p} = m \mathbf{v}&quot; /&gt;) from first semester physics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The momentum conjugate to the angle &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt; in polar coordinates is &lt;em&gt;angular momentum&lt;/em&gt; (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?L%20%3D%20m%20r%5E2%20%5Cdot%7B%5Ctheta%7D&quot; alt=&quot;L = m r^2 \dot{\theta}&quot; title=&quot;L = m r^2 \dot{\theta}&quot; /&gt;) from first semester physics.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The momentum conjugate to the radial coordinate &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; in polar coordinates is also just boring old linear momentum &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?p_r%20%3D%20m%20%5Cdot%7Br%7D&quot; alt=&quot;p_r = m \dot{r}&quot; title=&quot;p_r = m \dot{r}&quot; /&gt;, which makes sense because purely radial motion is just linear motion.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, it’s our normal momentum (for linear and polar coordinates) &lt;em&gt;generalized&lt;/em&gt; to arbitrary coordinates.&lt;/p&gt;
&lt;h3 id=&quot;hamiltonian-dynamics&quot;&gt;Hamiltonian Dynamics&lt;/h3&gt;
&lt;p&gt;I’ve explained Hamiltonian dynamics for time-independent Hamiltonians as “follow the contour lines”. If you remember your basic multi-variable calculus course, you’ll know that the line of “steepest ascent” is the gradient. If we call the Hamiltonian &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29&quot; alt=&quot;\mathcal{H}(\mathbf{q},\mathbf{p})&quot; title=&quot;\mathcal{H}(\mathbf{q},\mathbf{p})&quot; /&gt; (where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; is the vector of positions and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt; is the vector of momenta), then the direction of steepest ascent is&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cleft%20%5Clangle%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7Bq%7D%7D%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%2C%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7Bp%7D%7D%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%5Cright%20%5Crangle%0A&quot; alt=&quot;
\left \langle \frac{\partial}{\partial \mathbf{q}}
\mathcal{H}(\mathbf{q},\mathbf{p}), \frac{\partial}{\partial \mathbf{p}}
\mathcal{H}(\mathbf{q},\mathbf{p}) \right \rangle
&quot; title=&quot;
\left \langle \frac{\partial}{\partial \mathbf{q}}
\mathcal{H}(\mathbf{q},\mathbf{p}), \frac{\partial}{\partial \mathbf{p}}
\mathcal{H}(\mathbf{q},\mathbf{p}) \right \rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;But we want to move along the &lt;em&gt;contour lines&lt;/em&gt;…and these are the lines &lt;em&gt;perpendicular&lt;/em&gt; to the direction of steepest descent. The vector perpendicular to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20x%2C%20y%20%5Crangle&quot; alt=&quot;\langle x, y \rangle&quot; title=&quot;\langle x, y \rangle&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20y%2C%20-x%20%5Crangle&quot; alt=&quot;\langle y, -x \rangle&quot; title=&quot;\langle y, -x \rangle&quot; /&gt;,&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; so we just derived the actual Hamiltonian equations of motion: just move in the direction perpendicular to the steepest ascent! That is, to have things move on contour lines, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bq%7D&quot; alt=&quot;\dot{q}&quot; title=&quot;\dot{q}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bp%7D_q&quot; alt=&quot;\dot{p}_q&quot; title=&quot;\dot{p}_q&quot; /&gt; &lt;em&gt;should&lt;/em&gt; be:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cdot%7Bq%7D%20%26%20%3D%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20p_q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%5C%5C%0A%5Cdot%7Bp%7D_q%20%26%20%3D%20-%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%0A%5Cend%7Baligned%7D%0A&quot; alt=&quot;
\begin{aligned}
\dot{q} &amp;amp; = \frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p}) \\
\dot{p}_q &amp;amp; = - \frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})
\end{aligned}
&quot; title=&quot;
\begin{aligned}
\dot{q} &amp;amp; = \frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p}) \\
\dot{p}_q &amp;amp; = - \frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})
\end{aligned}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;This is a conclusion with one generalized coordinate &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q&quot; alt=&quot;q&quot; title=&quot;q&quot; /&gt;, but we can generalize this to systems with multiple coordinates as well, as long as this holds for &lt;em&gt;every&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q&quot; alt=&quot;q&quot; title=&quot;q&quot; /&gt; and the momentum conjugate to it (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?p_q&quot; alt=&quot;p_q&quot; title=&quot;p_q&quot; /&gt;). (For the rest of this post, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; refers to the vector of coordinates, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q&quot; alt=&quot;q&quot; title=&quot;q&quot; /&gt; refers to a single specific coordinate, and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?p_q&quot; alt=&quot;p_q&quot; title=&quot;p_q&quot; /&gt; refers to the momentum conjugate to that coordinate).&lt;/p&gt;
&lt;p&gt;Essentially, these give you “updating functions” for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q&quot; alt=&quot;q&quot; title=&quot;q&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?p_q&quot; alt=&quot;p_q&quot; title=&quot;p_q&quot; /&gt; – given &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29&quot; alt=&quot;\mathcal{H}(\mathbf{q},\mathbf{p})&quot; title=&quot;\mathcal{H}(\mathbf{q},\mathbf{p})&quot; /&gt;, you have a way to “update” the particle’s position in phase space. Just take the partial derivatives of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D&quot; alt=&quot;\mathcal{H}&quot; title=&quot;\mathcal{H}&quot; /&gt; at every step in time! To update &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q&quot; alt=&quot;q&quot; title=&quot;q&quot; /&gt;, nudge it by &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20p_q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29&quot; alt=&quot;\frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p})&quot; title=&quot;\frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p})&quot; /&gt;. To update &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?p_q&quot; alt=&quot;p_q&quot; title=&quot;p_q&quot; /&gt;, nudge it by &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?-%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29&quot; alt=&quot;-\frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})&quot; title=&quot;-\frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})&quot; /&gt;!&lt;/p&gt;
&lt;p&gt;This picture is appealing to me in a visceral way because it sort of seems like the system is “surfing” along the Hamiltonian’s contour lines. It’s being “pushed” &lt;em&gt;faster&lt;/em&gt; when the Hamiltonian is steeper, and slower when it’s more shallow. I can apply all my intuition as a surfer&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; to Hamiltonian mechanics!&lt;/p&gt;
&lt;h2 id=&quot;hamiltonian-dynamics-and-physical-systems&quot;&gt;Hamiltonian Dynamics and Physical Systems&lt;/h2&gt;
&lt;p&gt;Earlier I mentioned that the two steps for applying Hamiltonian mechanics to your system was figuring out your system’s conjugate momenta and the appropriate Hamiltonian. To explain this, I’m going to make a couple of simplifying assumptions that make the job easier for the purposes of this article:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Your coordinates and potential energy are time-independent.&lt;/li&gt;
&lt;li&gt;Your potential energy function only depends on &lt;em&gt;positions&lt;/em&gt;, and not &lt;em&gt;velocities&lt;/em&gt;. (So nothing like friction or wind resistance or magnetic field vector potentials)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With these assumptions, I’m going to skip over discussing the &lt;a href=&quot;https://en.wikipedia.org/wiki/Lagrangian_mechanics&quot;&gt;Lagrangian&lt;/a&gt; of the system, which is the traditional way to do this. You can think of this section as me presenting derived conclusions and skipping the derivations.&lt;/p&gt;
&lt;h3 id=&quot;conjugate-momenta&quot;&gt;Conjugate Momenta&lt;/h3&gt;
&lt;p&gt;For systems with velocity-independent potential energies, it can be shown that the momentum conjugate to coordinate &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q&quot; alt=&quot;q&quot; title=&quot;q&quot; /&gt; is&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0Ap_q%20%3D%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cdot%7Bq%7D%7D%20KE%28%5Cmathbf%7Bq%7D%2C%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29%0A&quot; alt=&quot;
p_q = \frac{\partial}{\partial \dot{q}} KE(\mathbf{q}, \dot{\mathbf{q}})
&quot; title=&quot;
p_q = \frac{\partial}{\partial \dot{q}} KE(\mathbf{q}, \dot{\mathbf{q}})
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?KE%28%5Cmathbf%7Bq%7D%2C%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29&quot; alt=&quot;KE(\mathbf{q},\dot{\mathbf{q}})&quot; title=&quot;KE(\mathbf{q},\dot{\mathbf{q}})&quot; /&gt; is the kinetic energy of the system, which is a function on the coordinates &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; and their rates of change, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D&quot; alt=&quot;\dot{\mathbf{q}}&quot; title=&quot;\dot{\mathbf{q}}&quot; /&gt;. For example, for normal Cartesian coordinates in one dimension, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?KE%28x%2C%20%5Cdot%7Bx%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20m%20%5Cdot%7Bx%7D%5E2&quot; alt=&quot;KE(x, \dot{x}) = \frac{1}{2} m \dot{x}^2&quot; title=&quot;KE(x, \dot{x}) = \frac{1}{2} m \dot{x}^2&quot; /&gt;. So the momentum conjugate to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0Ap_x%20%3D%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cdot%7Bx%7D%7D%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20m%20%5Cdot%7Bx%7D%5E2%20%5Cright%5D%20%3D%20m%20%5Cdot%7Bx%7D%0A&quot; alt=&quot;
p_x = \frac{\partial}{\partial \dot{x}} \left[ \frac{1}{2} m \dot{x}^2 \right] = m \dot{x}
&quot; title=&quot;
p_x = \frac{\partial}{\partial \dot{x}} \left[ \frac{1}{2} m \dot{x}^2 \right] = m \dot{x}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Just linear momentum, like I claimed before.&lt;/p&gt;
&lt;p&gt;Let’s generalize this to arbitrary coordinates. In general, for &lt;em&gt;Cartesian&lt;/em&gt; coordinates, the kinetic energy will always be&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0AKE%28%5Cmathbf%7Bx%7D%2C%20%5Cdot%7B%5Cmathbf%7Bx%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%5B%20m_1%20%5Cdot%7Bx%7D_1%5E2%20%2B%20m_2%20%5Cdot%7Bx%7D_2%5E2%20%2B%20m_3%20%5Cdot%7Bx%7D_3%5E2%20%2B%20%5Cdots%20%5Cright%5D%0A&quot; alt=&quot;
KE(\mathbf{x}, \dot{\mathbf{x}}) = \frac{1}{2} \left[ m_1 \dot{x}_1^2 + m_2 \dot{x}_2^2 + m_3 \dot{x}_3^2 + \dots \right]
&quot; title=&quot;
KE(\mathbf{x}, \dot{\mathbf{x}}) = \frac{1}{2} \left[ m_1 \dot{x}_1^2 + m_2 \dot{x}_2^2 + m_3 \dot{x}_3^2 + \dots \right]
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt; is the inertia associated with each coordinate…for example, if &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20x_1%2C%20x_2%20%5Crangle&quot; alt=&quot;\langle x_1, x_2 \rangle&quot; title=&quot;\langle x_1, x_2 \rangle&quot; /&gt; describes the location of an object of mass &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt;, then &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m_1%20%3D%20m_2%20%3D%20m&quot; alt=&quot;m_1 = m_2 = m&quot; title=&quot;m_1 = m_2 = m&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;To give us nice notation and make things more convenient, we’ll write this as a quadratic form over an inertia matrix:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0AKE%28%5Cdot%7B%5Cmathbf%7Bx%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bx%7D%7D%5ET%20%5Chat%7BM%7D%20%5Cdot%7B%5Cmathbf%7Bx%7D%7D%0A&quot; alt=&quot;
KE(\dot{\mathbf{x}}) = \frac{1}{2} \dot{\mathbf{x}}^T \hat{M} \dot{\mathbf{x}}
&quot; title=&quot;
KE(\dot{\mathbf{x}}) = \frac{1}{2} \dot{\mathbf{x}}^T \hat{M} \dot{\mathbf{x}}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BM%7D&quot; alt=&quot;\hat{M}&quot; title=&quot;\hat{M}&quot; /&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Diagonal_matrix&quot;&gt;diagonal matrix&lt;/a&gt; whose entries are the masses of each coordinate, and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bx%7D%7D&quot; alt=&quot;\dot{\mathbf{x}}&quot; title=&quot;\dot{\mathbf{x}}&quot; /&gt; is the column vector of all of the (Cartesian) coordinates, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cleft%5B%20%5Cdot%7Bx%7D_1%5C%2C%20%5Cdot%7Bx%7D_2%5C%2C%20%5Cdot%7Bx%7D_3%5C%2C%20%5Cdots%20%5Cright%5D%5ET&quot; alt=&quot;\left[ \dot{x}_1\, \dot{x}_2\, \dot{x}_3\, \dots \right]^T&quot; title=&quot;\left[ \dot{x}_1\, \dot{x}_2\, \dot{x}_3\, \dots \right]^T&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Now! How to generalize this to arbitrary coordinates? Well, if we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt; generalized coordinates &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; mapping to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt;-dimensional Cartesian coordinates, we can specify them as &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D%20%3D%20f%28%5Cmathbf%7Bq%7D%29&quot; alt=&quot;\mathbf{x} = f(\mathbf{q})&quot; title=&quot;\mathbf{x} = f(\mathbf{q})&quot; /&gt;, where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em&quot; alt=&quot;f : \mathbb{R}^n \rightarrow \mathbb{R}^m&quot; title=&quot;f : \mathbb{R}^n \rightarrow \mathbb{R}^m&quot; /&gt;, taking the vector of generalized coordinates and returning a vector for the position in Cartesian space. For example, for polar coordinates, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%28r%2C%20%5Ctheta%29%20%3D%20%5Cleft%20%5Clangle%20r%20%5Ccos%28%5Ctheta%29%2C%20r%20%5Csin%28%5Ctheta%29%20%5Cright%20%5Crangle&quot; alt=&quot;f(r, \theta) = \left \langle r \cos(\theta), r \sin(\theta) \right \rangle&quot; title=&quot;f(r, \theta) = \left \langle r \cos(\theta), r \sin(\theta) \right \rangle&quot; /&gt;, because, for polar coordinates, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x%20%3D%20r%20%5Ccos%28%5Ctheta%29&quot; alt=&quot;x = r \cos(\theta)&quot; title=&quot;x = r \cos(\theta)&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?y%20%3D%20r%20%5Csin%28%5Ctheta%29&quot; alt=&quot;y = r \sin(\theta)&quot; title=&quot;y = r \sin(\theta)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;So we can get &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D&quot; alt=&quot;\mathbf{x}&quot; title=&quot;\mathbf{x}&quot; /&gt; from &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; with &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt;, but how can we get &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bx%7D%7D&quot; alt=&quot;\dot{\mathbf{x}}&quot; title=&quot;\dot{\mathbf{x}}&quot; /&gt;, the vector of rate of changes? Well, if &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x_1%20%3D%20f_1%28q_1%2C%20q_2%2C%20q_3%20%5Cdots%29&quot; alt=&quot;x_1 = f_1(q_1, q_2, q_3 \dots)&quot; title=&quot;x_1 = f_1(q_1, q_2, q_3 \dots)&quot; /&gt;, then the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D_1&quot; alt=&quot;\dot{x}_1&quot; title=&quot;\dot{x}_1&quot; /&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_derivative&quot;&gt;total derivative&lt;/a&gt; of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x_1&quot; alt=&quot;x_1&quot; title=&quot;x_1&quot; /&gt; with respect to time:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cdot%7Bx%7D_1%20%3D%20%5Cfrac%7B%5Cpartial%20f_1%7D%7B%5Cpartial%20q_1%7D%20%5Cdot%7Bq%7D_1%20%2B%0A%20%20%20%20%5Cfrac%7B%5Cpartial%20f_1%7D%7B%5Cpartial%20q_2%7D%20%5Cdot%7Bq%7D_2%20%2B%0A%20%20%20%20%5Cfrac%7B%5Cpartial%20f_1%7D%7B%5Cpartial%20q_3%7D%20%5Cdot%7Bq%7D_3%20%2B%20%5Cdots%0A&quot; alt=&quot;
\dot{x}_1 = \frac{\partial f_1}{\partial q_1} \dot{q}_1 +
    \frac{\partial f_1}{\partial q_2} \dot{q}_2 +
    \frac{\partial f_1}{\partial q_3} \dot{q}_3 + \dots
&quot; title=&quot;
\dot{x}_1 = \frac{\partial f_1}{\partial q_1} \dot{q}_1 +
    \frac{\partial f_1}{\partial q_2} \dot{q}_2 +
    \frac{\partial f_1}{\partial q_3} \dot{q}_3 + \dots
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Or, in short:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cdot%7Bx%7D_i%20%3D%20%5Csum_%7Bj%20%3D%201%7D%5En%20%5Cfrac%7B%5Cpartial%20f_i%7D%7B%5Cpartial%20q_j%7D%20%5Cdot%7Bq%7D_j%0A&quot; alt=&quot;
\dot{x}_i = \sum_{j = 1}^n \frac{\partial f_i}{\partial q_j} \dot{q}_j
&quot; title=&quot;
\dot{x}_i = \sum_{j = 1}^n \frac{\partial f_i}{\partial q_j} \dot{q}_j
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;But, hey, this looks a lot like a matrix-vector multiplication! If we make &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{J}_f&quot; title=&quot;\hat{J}_f&quot; /&gt;, an &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n&quot; alt=&quot;m \times n&quot; title=&quot;m \times n&quot; /&gt; matrix of partial derivatives of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt; (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_%7Bfij%7D%20%3D%20%5Cfrac%7B%5Cpartial%20f_i%7D%7B%5Cpartial%20q_j%7D&quot; alt=&quot;\hat{J}_{fij} = \frac{\partial f_i}{\partial q_j}&quot; title=&quot;\hat{J}_{fij} = \frac{\partial f_i}{\partial q_j}&quot; /&gt;) at a given point (typically called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant&quot;&gt;Jacobian matrix of f&lt;/a&gt;, then we have a nice expression for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bx%7D%7D&quot; alt=&quot;\dot{\mathbf{x}}&quot; title=&quot;\dot{\mathbf{x}}&quot; /&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cdot%7B%5Cmathbf%7Bx%7D%7D%20%3D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A&quot; alt=&quot;
\dot{\mathbf{x}} = \hat{J}_f \dot{\mathbf{q}}
&quot; title=&quot;
\dot{\mathbf{x}} = \hat{J}_f \dot{\mathbf{q}}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And we can plug it in (remembering that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%28A%20B%29%5ET%20%3D%20B%5ET%20A%5ET&quot; alt=&quot;(A B)^T = B^T A^T&quot; title=&quot;(A B)^T = B^T A^T&quot; /&gt;) to our kinetic energy equation to get:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0AKE%28%5Cmathbf%7Bq%7D%2C%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BJ%7D_f%5ET%0A%20%20%20%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A&quot; alt=&quot;
KE(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T
    \hat{M} \hat{J}_f \dot{\mathbf{q}}
&quot; title=&quot;
KE(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T
    \hat{M} \hat{J}_f \dot{\mathbf{q}}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And for the final step, we differentiate with respect to the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bq%7D&quot; alt=&quot;\dot{q}&quot; title=&quot;\dot{q}&quot; /&gt;s (which is just the gradient &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cnabla_%7B%5Cdot%7B%5Cmathbf%7Bq%7D%7D%7D&quot; alt=&quot;\nabla_{\dot{\mathbf{q}}}&quot; title=&quot;\nabla_{\dot{\mathbf{q}}}&quot; /&gt;) to get &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt;, the vector of conjugate momenta:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7Bp%7D%20%3D%20%5Cnabla_%7B%5Cdot%7B%5Cmathbf%7Bq%7D%7D%7D%20%5Cleft%5B%0A%20%20%20%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A%20%20%5Cright%5D%0A%20%20%3D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A&quot; alt=&quot;
\mathbf{p} = \nabla_{\dot{\mathbf{q}}} \left[
    \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
  \right]
  = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
&quot; title=&quot;
\mathbf{p} = \nabla_{\dot{\mathbf{q}}} \left[
    \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
  \right]
  = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Now, we’re going to be using &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{J}_f^T \hat{M} \hat{J}_f&quot; title=&quot;\hat{J}_f^T \hat{M} \hat{J}_f&quot; /&gt; a lot, so let’s give it a name, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D&quot; alt=&quot;\hat{K}&quot; title=&quot;\hat{K}&quot; /&gt;. &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D&quot; alt=&quot;\hat{K}&quot; title=&quot;\hat{K}&quot; /&gt; represents some sort of coordinate-aware inertia term for our system. If the masses are all positive and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{J}_f&quot; title=&quot;\hat{J}_f&quot; /&gt; is full-rank&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;, then &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D&quot; alt=&quot;\hat{K}&quot; title=&quot;\hat{K}&quot; /&gt; is a symmetric, positive-definite, invertible matrix (by construction). It’s important to also remember that it’s an explicit function of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt;, because &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{J}_f&quot; title=&quot;\hat{J}_f&quot; /&gt; is a matrix of partial derivatives at a given &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt;. We now have a simple expression for the vector of conjugate momenta (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D%20%3D%20%5Chat%7BK%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D&quot; alt=&quot;\mathbf{p} = \hat{K} \dot{\mathbf{q}}&quot; title=&quot;\mathbf{p} = \hat{K} \dot{\mathbf{q}}&quot; /&gt;), and also for kinetic energy (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?KE%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BK%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D&quot; alt=&quot;KE = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}}&quot; title=&quot;KE = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}}&quot; /&gt;).&lt;/p&gt;
&lt;p&gt;It’s going to be important for us to also be able to go backwards (to get &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D&quot; alt=&quot;\dot{\mathbf{q}}&quot; title=&quot;\dot{\mathbf{q}}&quot; /&gt; from &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt;). Luckily, because we wrote the whole thing as a matrix operation, going backwards is easy – just take the matrix inverse, which we know exists!&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A&quot; alt=&quot;
\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}
&quot; title=&quot;
\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The power of linear algebra!&lt;/p&gt;
&lt;h3 id=&quot;hamiltonians-of-physical-systems&quot;&gt;Hamiltonians of Physical Systems&lt;/h3&gt;
&lt;p&gt;Ok, that’s step one. How about step two – finding the Hamiltonian for your system?&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;real&lt;/em&gt; Hamiltonian is actually the &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_bracket&quot;&gt;Poisson bracket&lt;/a&gt; of the system’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Lagrangian_mechanics&quot;&gt;Lagrangian&lt;/a&gt;, but I did some of the work for you for the case of time-independent coordinates where the potential energy depends &lt;em&gt;only&lt;/em&gt; on positions (so, no friction, wind resistance, time, etc.). In such a case, the Hamiltonian of a system is precisely the system’s total &lt;a href=&quot;https://en.wikipedia.org/wiki/Mechanical_energy&quot;&gt;mechanical energy&lt;/a&gt;, or its kinetic energy plus the potential energy:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%20KE%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%2B%20PE%28%5Cmathbf%7Bq%7D%29%0A&quot; alt=&quot;
\mathcal{H}(\mathbf{q},\mathbf{p}) = KE(\mathbf{q},\mathbf{p}) + PE(\mathbf{q})
&quot; title=&quot;
\mathcal{H}(\mathbf{q},\mathbf{p}) = KE(\mathbf{q},\mathbf{p}) + PE(\mathbf{q})
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Which makes a lot of intuitive sense, because you might recall that total mechanical energy is always conserved for certain types of systems. Incidentally, Hamiltonian dynamics makes sure that the value of the system’s Hamiltonian stays the same (because it moves along contour lines). So, the system’s Hamiltonian always stays the same, and so its total mechanical energy stays the same, as well! Energy is conserved because the Hamiltonian stays the same!&lt;/p&gt;
&lt;p&gt;Anyway, we want to build our system’s Hamiltonian from properties of the coordinate system, so plugging in our expression for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?KE&quot; alt=&quot;KE&quot; title=&quot;KE&quot; /&gt;, we get &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BK%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%2B%20PE%28%5Cmathbf%7Bq%7D%29&quot; alt=&quot;\mathcal{H}(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}} + PE(\mathbf{q})&quot; title=&quot;\mathcal{H}(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}} + PE(\mathbf{q})&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Oh, but oops, the Hamiltonian has to be a function of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt;, not of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D&quot; alt=&quot;\dot{\mathbf{q}}&quot; title=&quot;\dot{\mathbf{q}}&quot; /&gt;. Let’s remember that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D&quot; alt=&quot;\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}&quot; title=&quot;\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}&quot; /&gt; and find the final form of our Hamiltonian (after a bit of simplification, remembering that the inverse of a symmetric matrix is also symmetric):&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%20%2B%20PE%28%5Cmathbf%7Bq%7D%29%0A&quot; alt=&quot;
\mathcal{H}(\mathbf{q},\mathbf{p}) = \frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p} + PE(\mathbf{q})
&quot; title=&quot;
\mathcal{H}(\mathbf{q},\mathbf{p}) = \frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p} + PE(\mathbf{q})
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;hamiltonian-equations&quot;&gt;Hamiltonian Equations&lt;/h3&gt;
&lt;p&gt;We got our Hamiltonian! Now just to find our updating functions (the partial derivatives of the Hamiltonian), and we’re done with the math.&lt;/p&gt;
&lt;p&gt;Because we are assuming the case (with loss of generality) &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?PE&quot; alt=&quot;PE&quot; title=&quot;PE&quot; /&gt; doesn’t depend on &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt;, the partial derivatives of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D&quot; alt=&quot;\mathcal{H}&quot; title=&quot;\mathcal{H}&quot; /&gt; with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cnabla_%7B%5Cmathbf%7Bp%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A&quot; alt=&quot;
\nabla_{\mathbf{p}} \mathcal{H}(\mathbf{q},\mathbf{p}) = \hat{K}^{-1} \mathbf{p}
&quot; title=&quot;
\nabla_{\mathbf{p}} \mathcal{H}(\mathbf{q},\mathbf{p}) = \hat{K}^{-1} \mathbf{p}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;We already can calculate &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D%5E%7B-1%7D&quot; alt=&quot;\hat{K}^{-1}&quot; title=&quot;\hat{K}^{-1}&quot; /&gt;, so this wound up being easy peasy. But finding the partial derivatives with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; is a little trickier. The gradient is a linear operator, so we can break that down to just finding the gradient of the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?KE&quot; alt=&quot;KE&quot; title=&quot;KE&quot; /&gt; term &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D&quot; alt=&quot;\frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p}&quot; title=&quot;\frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p}&quot; /&gt;. Because &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D&quot; alt=&quot;\mathbf{p}&quot; title=&quot;\mathbf{p}&quot; /&gt; is an independent input to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D&quot; alt=&quot;\mathcal{H}&quot; title=&quot;\mathcal{H}&quot; /&gt;, we can just look at the gradient of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D%5E%7B-1%7D&quot; alt=&quot;\hat{K}^{-1}&quot; title=&quot;\hat{K}^{-1}&quot; /&gt;. We can simplify that even more by realizing that for any invertible matrix &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?A&quot; alt=&quot;A&quot; title=&quot;A&quot; /&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20A%5E%7B-1%7D%20%3D%20-%20A%5E%7B-1%7D%20%5Cleft%5B%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20A%20%5Cright%5D%20A%5E%7B-1%7D&quot; alt=&quot;\frac{\partial}{\partial q} A^{-1} = - A^{-1} \left[ \frac{\partial}{\partial q} A \right] A^{-1}&quot; title=&quot;\frac{\partial}{\partial q} A^{-1} = - A^{-1} \left[ \frac{\partial}{\partial q} A \right] A^{-1}&quot; /&gt;, so now we just need to find the partial derivatives of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D&quot; alt=&quot;\hat{K}&quot; title=&quot;\hat{K}&quot; /&gt;, or &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%7D&quot; alt=&quot;\hat{J}_f^T \hat{M} \hat{J}_f}&quot; title=&quot;\hat{J}_f^T \hat{M} \hat{J}_f}&quot; /&gt;. &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BM%7D&quot; alt=&quot;\hat{M}&quot; title=&quot;\hat{M}&quot; /&gt; is a constant term, so, using the good ol’ product rule over &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f%5ET&quot; alt=&quot;\hat{J}_f^T&quot; title=&quot;\hat{J}_f^T&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{J}_f&quot; title=&quot;\hat{J}_f&quot; /&gt;, we see that, after some simplification:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Cleft%5B%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%3D%0A%20%20%20%202%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Cleft%5B%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%0A&quot; alt=&quot;
\frac{\partial}{\partial q_i} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right]
&quot; title=&quot;
\frac{\partial}{\partial q_i} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right]
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f&quot; alt=&quot;\frac{\partial}{\partial q_i} \hat{J}_f&quot; title=&quot;\frac{\partial}{\partial q_i} \hat{J}_f&quot; /&gt; (an &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n&quot; alt=&quot;m \times n&quot; title=&quot;m \times n&quot; /&gt; matrix, like &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{J}_f&quot; title=&quot;\hat{J}_f&quot; /&gt;) represents the &lt;em&gt;second derivatives&lt;/em&gt; of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt; – the derivative (with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?q_i&quot; alt=&quot;q_i&quot; title=&quot;q_i&quot; /&gt;) of the derivatives.&lt;/p&gt;
&lt;p&gt;The collection of “second-order derivatives of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt;” is known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix#Vector-valued_functions&quot;&gt;Hessian Tensor&lt;/a&gt; (a vector-valued generalization of the Hessian matrix), which we will denote as &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BH%7D_f&quot; alt=&quot;\hat{H}_f&quot; title=&quot;\hat{H}_f&quot; /&gt;.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; We can write this in a nicer way by abusing matrix multiplication notation to get&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cleft%5B%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%3D%0A%20%20%20%202%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BH%7D_f%0A&quot; alt=&quot;
\nabla_{\mathbf{q}} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \hat{H}_f
&quot; title=&quot;
\nabla_{\mathbf{q}} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \hat{H}_f
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;if we use &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BH%7D_f&quot; alt=&quot;\hat{H}_f&quot; title=&quot;\hat{H}_f&quot; /&gt; as an &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n%20%5Ctimes%20m%20%5Ctimes%20n&quot; alt=&quot;n \times m \times n&quot; title=&quot;n \times m \times n&quot; /&gt; tensor, whose &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt; components are the each the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n&quot; alt=&quot;m \times n&quot; title=&quot;m \times n&quot; /&gt; matrices corresponding to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f&quot; alt=&quot;\frac{\partial}{\partial q_i} \hat{J}_f&quot; title=&quot;\frac{\partial}{\partial q_i} \hat{J}_f&quot; /&gt;&lt;/p&gt;
&lt;p&gt;And with that, we have our final expression for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29&quot; alt=&quot;\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})&quot; title=&quot;\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})&quot; /&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%0A%20%20%20%20-%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Cleft%5B%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20%2B%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A&quot; alt=&quot;
\frac{\partial}{\partial q_i} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
&quot; title=&quot;
\frac{\partial}{\partial q_i} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Or, to use our abuse of notation:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%0A%20%20%20%20-%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Chat%7BH%7D_f%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20%2B%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A&quot; alt=&quot;
\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
&quot; title=&quot;
\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And, finally, we have everything we need – we can now construct our equations of motion! To progress through phase space (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20%5Cmathbf%7Bq%7D%2C%20%5Cmathbf%7Bp%7D%5Crangle&quot; alt=&quot;\langle \mathbf{q}, \mathbf{p}\rangle&quot; title=&quot;\langle \mathbf{q}, \mathbf{p}\rangle&quot; /&gt;):&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%26%20%3D%20%5Cnabla_%7B%5Cmathbf%7Bp_q%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%0A%20%20%26%26%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%20%5C%5C%0A%5Cdot%7B%5Cmathbf%7Bp%7D%7D%20%26%20%3D%20-%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%0A%20%20%26%26%20%3D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Chat%7BH%7D_f%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20-%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A%5Cend%7Baligned%7D%0A&quot; alt=&quot;
\begin{aligned}
\dot{\mathbf{q}} &amp;amp; = \nabla_{\mathbf{p_q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;amp;&amp;amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp;amp; = - \nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;amp;&amp;amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
&quot; title=&quot;
\begin{aligned}
\dot{\mathbf{q}} &amp;amp; = \nabla_{\mathbf{p_q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;amp;&amp;amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp;amp; = - \nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;amp;&amp;amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;That’s it. We’re done. Have a nice day, thanks for reading!&lt;/p&gt;
&lt;h2 id=&quot;the-haskell&quot;&gt;The Haskell&lt;/h2&gt;
&lt;p&gt;Just kidding, now it’s time for the fun stuff :)&lt;/p&gt;
&lt;p&gt;Our final goal is to be able to simulate a &lt;em&gt;system of discrete particles&lt;/em&gt; through &lt;em&gt;arbitrary generalized coordinates&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To simplify the math, we always assume that, whatever generalized coordinates you are using (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5En&quot; alt=&quot;\mathbb{R}^n&quot; title=&quot;\mathbb{R}^n&quot; /&gt;), your system “actually” exists in some real flat Cartesian coordinate system (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5Em&quot; alt=&quot;\mathbb{R}^m&quot; title=&quot;\mathbb{R}^m&quot; /&gt;). This allows us to take advantage of all of that math we derived in the previous section.&lt;/p&gt;
&lt;p&gt;So, in order to fully describe the system, we need:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Each of their masses (or inertias) in their underlying &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt; Cartesian coordinates, which we’ll call &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bm%7D&quot; alt=&quot;\mathbf{m}&quot; title=&quot;\mathbf{m}&quot; /&gt;.&lt;/li&gt;
&lt;li&gt;A function &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em&quot; alt=&quot;f : \mathbb{R}^n \rightarrow \mathbb{R}^m&quot; title=&quot;f : \mathbb{R}^n \rightarrow \mathbb{R}^m&quot; /&gt; to convert the generalized coordinates (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%5En%7D&quot; alt=&quot;\mathbb{R^n}&quot; title=&quot;\mathbb{R^n}&quot; /&gt;) to Cartesian coordinates (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5Em&quot; alt=&quot;\mathbb{R}^m&quot; title=&quot;\mathbb{R}^m&quot; /&gt;)&lt;/li&gt;
&lt;li&gt;The potential energy function &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?U%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D&quot; alt=&quot;U : \mathbb{R}^n \rightarrow \mathbb{R}&quot; title=&quot;U : \mathbb{R}^n \rightarrow \mathbb{R}&quot; /&gt; in the generalized coordinates (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%5En%7D&quot; alt=&quot;\mathbb{R^n}&quot; title=&quot;\mathbb{R^n}&quot; /&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From these alone, we can derive the equations of motion for the particles in phase space as a system of first-order ODEs using the process described above. Then, given an initial phase space position, we can do numeric integration to simulate our system’s motion through phase space. To “surf the Hamiltonian waves in phase space”, so to speak.&lt;/p&gt;
&lt;p&gt;But, to be explicit, we also are going to need some derivatives for these functions/vectors, too. If you’ve been following along, the full enumeration of functions and vectors we need is:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bm%7D%20%26%20%3A%20%5Cmathbb%7BR%7D%5Em%20%5C%5C%0Af%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em%20%5C%5C%0A%5Chat%7BJ%7D_f%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20n%7D%20%5C%5C%0A%5Chat%7BH%7D_f%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20m%20%5Ctimes%20n%7D%20%5C%5C%0AU%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%20%5C%5C%0A%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20U%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5En%0A%5Cend%7Baligned%7D%0A&quot; alt=&quot;
\begin{aligned}
\mathbf{m} &amp;amp; : \mathbb{R}^m \\
f &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^m \\
\hat{J}_f &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{m \times n} \\
\hat{H}_f &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{n \times m \times n} \\
U &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R} \\
\nabla_{\mathbf{q}} U &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^n
\end{aligned}
&quot; title=&quot;
\begin{aligned}
\mathbf{m} &amp;amp; : \mathbb{R}^m \\
f &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^m \\
\hat{J}_f &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{m \times n} \\
\hat{H}_f &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{n \times m \times n} \\
U &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R} \\
\nabla_{\mathbf{q}} U &amp;amp; : \mathbb{R}^n \rightarrow \mathbb{R}^n
\end{aligned}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;But, as we’ll see, with libraries like &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt;&lt;/em&gt; in Haskell, we can really just ask the user for &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bm%7D&quot; alt=&quot;\mathbf{m}&quot; title=&quot;\mathbf{m}&quot; /&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt;, and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?U&quot; alt=&quot;U&quot; title=&quot;U&quot; /&gt; – all of the derivatives can be computed automatically.&lt;/p&gt;
&lt;h3 id=&quot;our-data-structures&quot;&gt;Our Data Structures&lt;/h3&gt;
&lt;p&gt;We can couple together all of these functions in a data type that fully describes the physics of our systems (the “shape” of the Hamiltonian):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L25-32&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt;
    {&lt;span class=&quot;ot&quot;&gt; sysInertia       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m                         &lt;span class=&quot;co&quot;&gt;-- ^ &amp;#39;m&amp;#39; vector&lt;/span&gt;
    ,&lt;span class=&quot;ot&quot;&gt; sysCoords        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m                  &lt;span class=&quot;co&quot;&gt;-- ^ f&lt;/span&gt;
    ,&lt;span class=&quot;ot&quot;&gt; sysJacobian      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; m n                &lt;span class=&quot;co&quot;&gt;-- ^ J_f&lt;/span&gt;
    ,&lt;span class=&quot;ot&quot;&gt; sysHessian       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; m n)   &lt;span class=&quot;co&quot;&gt;-- ^ H_f&lt;/span&gt;
    ,&lt;span class=&quot;ot&quot;&gt; sysPotential     ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;               &lt;span class=&quot;co&quot;&gt;-- ^ U&lt;/span&gt;
    ,&lt;span class=&quot;ot&quot;&gt; sysPotentialGrad ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n                  &lt;span class=&quot;co&quot;&gt;-- ^ grad U&lt;/span&gt;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;R n&lt;/code&gt; and &lt;code&gt;L m n&lt;/code&gt; are from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library; an &lt;code&gt;R n&lt;/code&gt; represents an n-vector (For example, an &lt;code&gt;R 4&lt;/code&gt; is a 4-vector), and an &lt;code&gt;L m n&lt;/code&gt; represents an &lt;code&gt;m x n&lt;/code&gt; matrix (For example, an &lt;code&gt;L 5 3&lt;/code&gt; is a 5x3 matrix).&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;System m n&lt;/code&gt; will describe a system parameterized by &lt;code&gt;n&lt;/code&gt; generalized coordinates, taking place in an underlying &lt;code&gt;m&lt;/code&gt;-dimensional Cartesian space.&lt;/p&gt;
&lt;p&gt;It’ll also be convenient to have a data type to describe the state of our system in terms of its generalized positions (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt;) and generalized velocities (the rates of changes of these positions, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D&quot; alt=&quot;\dot{\mathbf{q}}&quot; title=&quot;\dot{\mathbf{q}}&quot; /&gt;), which is sometimes called “configuration space”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L35-39&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt;
    {&lt;span class=&quot;ot&quot;&gt; confPositions  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
    ,&lt;span class=&quot;ot&quot;&gt; confVelocities ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
    }
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, more importantly, remember that Hamiltonian dynamics is all about surfing around on that phase space (generalized positions &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D&quot; alt=&quot;\mathbf{q}&quot; title=&quot;\mathbf{q}&quot; /&gt; and their conjugate momenta, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp_q%7D&quot; alt=&quot;\mathbf{p_q}&quot; title=&quot;\mathbf{p_q}&quot; /&gt;). So let’s make a type to describe the state of our system in phase space:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L42-46&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt;
    {&lt;span class=&quot;ot&quot;&gt; phasePositions ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
    ,&lt;span class=&quot;ot&quot;&gt; phaseMomenta   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
    }
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;getting-comfortable-with-our-data-types&quot;&gt;Getting comfortable with our data types&lt;/h3&gt;
&lt;p&gt;First of all, assuming we can construct a &lt;code&gt;System&lt;/code&gt; in a sound way, let’s imagine some useful functions.&lt;/p&gt;
&lt;p&gt;We can write a function &lt;code&gt;underlyingPosition&lt;/code&gt;, which allows you to give a position in generalized coordinates, and returns the position in the “underlying coordinate system”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L51-55&lt;/span&gt;
underlyingPosition
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m
underlyingPosition &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sysCoords&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the types in our function helps us know exactly what the function is doing — and also helps us implement it correctly. If we have a &lt;code&gt;System&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; dimensions, over an underlying &lt;code&gt;m&lt;/code&gt;-dimensional Cartesian space, then we would need to convert an &lt;code&gt;R n&lt;/code&gt; (an n-dimensional vector of all of the positions) into an &lt;code&gt;R m&lt;/code&gt; (a vector in the underlying Cartesian space).&lt;/p&gt;
&lt;p&gt;Simple enough, but let’s maybe try to calculate something more complicated: the &lt;em&gt;momenta&lt;/em&gt; of a system, given its positions and velocities (configuration).&lt;/p&gt;
&lt;p&gt;We remember that we have a nice formula for that, up above:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7Bp%7D%20%3D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A&quot; alt=&quot;
\mathbf{p} = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
&quot; title=&quot;
\mathbf{p} = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;We can translate that directly into Haskell code:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L59-67&lt;/span&gt;
momenta
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
momenta s (&lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; q v) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr j &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; mHat &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; j &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    j    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sysJacobian s q
    mHat &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; diag (sysInertia s)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that, because our vectors have their size indexed in their type, this is pretty simple to write and ensure that the shapes “line up”. In fact, GHC can even help you write this function by telling you what values can go in what locations. Being able to get rid of a large class of bugs and clean up your implementation space is nice, too!&lt;/p&gt;
&lt;p&gt;(Note that &lt;em&gt;hmatrix&lt;/em&gt; requires a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the size parameters of our vectors for some functions, so we add this as a constraint on our end.)&lt;/p&gt;
&lt;p&gt;With this, we can write a function to convert any state in configuration space to its coordinates in phase space:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L70-75&lt;/span&gt;
toPhase
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n
toPhase s c &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; (confPositions c) (momenta s c)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This function is important, because “configuration space” is how we actually directly observe our system – in terms of positions and velocities, and not in terms of positions and momenta (and sometimes conjugate momenta might not even have meaningful physical interpretations). So, having &lt;code&gt;toPhase&lt;/code&gt; lets us “initialize” our system in terms of direct observables, and then convert it to its phase space representation, which is something that Hamiltonian mechanics can work with.&lt;/p&gt;
&lt;h3 id=&quot;automatic-differentiation&quot;&gt;Automatic Differentiation&lt;/h3&gt;
&lt;p&gt;Now, creating a &lt;code&gt;System&lt;/code&gt; “from scratch” is not much fun, because you would have to manually differentiate your coordinate systems and potentials to generate your Jacobians and gradients.&lt;/p&gt;
&lt;p&gt;Here’s where the magic comes in – we can have Haskell generate our Jacobians and gradients &lt;em&gt;automatically&lt;/em&gt;, using the amazing &lt;a href=&quot;http://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; library! We can just use the appropriately named &lt;code&gt;grad&lt;/code&gt;, &lt;code&gt;jacobian&lt;/code&gt;, and &lt;code&gt;hessianF&lt;/code&gt; functions.&lt;/p&gt;
&lt;h4 id=&quot;quick-intro-to-ad&quot;&gt;Quick Intro to AD&lt;/h4&gt;
&lt;p&gt;At the simplest level, if we have a function from some number to some other number, we can use &lt;code&gt;diff&lt;/code&gt; to get its derivative:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;myFunc      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
diff&lt;span class=&quot;ot&quot;&gt; myFunc ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we have a function a function from a sized vector to a scalar, we can use &lt;code&gt;grad&lt;/code&gt; to get its gradient:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- import qualified Data.Vector.Sized as V&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;myFunc      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
grad&lt;span class=&quot;ot&quot;&gt; myFunc ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where each of the components in the resulting vector corresponds to the rate of change of the output according to variations in that component.&lt;/p&gt;
&lt;p&gt;We’re using &lt;strong&gt;statically sized vector&lt;/strong&gt; type from the &lt;a href=&quot;http://hackage.haskell.org/package/vector-sized&quot;&gt;vector-sized&lt;/a&gt; package (in the &lt;a href=&quot;http://hackage.haskell.org/package/vector-sized/docs/Data-Vector-Sized.html&quot;&gt;Data.Vector.Sized&lt;/a&gt; module), where &lt;code&gt;V.Vector n a&lt;/code&gt; is a &lt;code&gt;n&lt;/code&gt;-vector of &lt;code&gt;a&lt;/code&gt;s – for example, a &lt;code&gt;V.Vector 3 Double&lt;/code&gt; is a vector of 3 &lt;code&gt;Double&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;We have to use &lt;code&gt;Vector&lt;/code&gt; (instead of &lt;code&gt;R&lt;/code&gt;, from &lt;em&gt;hmatrix&lt;/em&gt;) because automatic differentiation for gradients requires &lt;em&gt;some Functor&lt;/em&gt; to work. An &lt;code&gt;R 5&lt;/code&gt; is essentially a &lt;code&gt;V.Vector 5 Double&lt;/code&gt;, except the latter can contain other, non-Double things – and therefore can be used by &lt;em&gt;ad&lt;/em&gt; to do its magic.&lt;/p&gt;
&lt;p&gt;If we have a function from a sized vector to a (differently) sized vector, we can use the &lt;code&gt;jacobian&lt;/code&gt; function to get its jacobian!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;myFunc          ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m a
jacobian&lt;span class=&quot;ot&quot;&gt; myFunc ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again note the usage of sized vector types, and the fact that our &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n&quot; alt=&quot;m \times n&quot; title=&quot;m \times n&quot; /&gt; matrix is represented by a &lt;code&gt;m&lt;/code&gt;-vector of &lt;code&gt;n&lt;/code&gt;-vectors.&lt;/p&gt;
&lt;p&gt;Finally, we can get our Hessian Tensor by using &lt;code&gt;hessianF&lt;/code&gt;:&lt;a href=&quot;#fn6&quot; class=&quot;footnoteRef&quot; id=&quot;fnref6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;myFunc
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m a
hessianF myFunc
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;conversion-between-vector-sized-and-hmatrix&quot;&gt;Conversion between vector-sized and hmatrix&lt;/h4&gt;
&lt;p&gt;So some ugly things – we need to write some functions to convert between &lt;em&gt;vector-sized&lt;/em&gt; sized vectors and &lt;em&gt;hmatrix&lt;/em&gt; vectors and matrices. These are fundamentally unsafe to write (but safe to use, after written properly):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- import qualified Data.Vector.Generic.Sized as VG&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L78-87&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;vec2r ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
vec2r &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromJust &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; create &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; VG.fromSized &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; VG.convert

&lt;span class=&quot;ot&quot;&gt;r2vec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
r2vec &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; VG.convert &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromJust &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; VG.toSized &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; extract

&lt;span class=&quot;ot&quot;&gt;vec2l ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; m n
vec2l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromJust &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (\rs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; withRows rs exactDims) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; toList &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fmap vec2r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These are necessary because &lt;em&gt;ad&lt;/em&gt; requires our vectors to be &lt;em&gt;Functors&lt;/em&gt;, but &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;L&lt;/code&gt; from &lt;em&gt;hmatrix&lt;/em&gt; are not your typical Hask Functors. One nice thing is that because they both use &lt;em&gt;TypeLits&lt;/em&gt; to get their sized parameters, we can get type-safe conversions that preserve their size information!&lt;/p&gt;
&lt;p&gt;Also, even though &lt;em&gt;ad&lt;/em&gt; gives our Hessian as an &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n%20%5Ctimes%20n&quot; alt=&quot;m \times n \times n&quot; title=&quot;m \times n \times n&quot; /&gt; tensor, we really want it as a n-vector of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n&quot; alt=&quot;m \times n&quot; title=&quot;m \times n&quot; /&gt; matrices – that’s how we interpreted it in our original math. So we just need to write an function to convert what &lt;em&gt;ad&lt;/em&gt; gives us to the form we expect. It’s mostly just fiddling around with the internals of &lt;em&gt;hmatrix&lt;/em&gt; in a rather inelegant way. (Again, unsafe to write, but safe to use once you do)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L90-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;rehessian ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; n n) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n (&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; m n)
rehessian &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fmap (fromJust &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (\rs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; withRows rs exactDims) &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; toList)
          &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; sequenceA
          &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fmap (fromJust &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; V.fromList &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; toRows)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;using-ad-to-auto-derive-systems&quot;&gt;Using AD to Auto-Derive Systems&lt;/h4&gt;
&lt;p&gt;Now to make a &lt;code&gt;System&lt;/code&gt; using just the mass vector, the coordinate conversion function, and the potential energy function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L97-113&lt;/span&gt;
mkSystem
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; m a)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n
mkSystem m f u &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt;
                  &lt;span class=&quot;co&quot;&gt;-- &amp;lt; convert from | actual thing | convert to &amp;gt;&lt;/span&gt;
    { sysInertia       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;                         m
    , sysCoords        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;      vec2r &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;            f &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; r2vec
    , sysJacobian      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;      vec2l &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;   jacobian f &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; r2vec
    , sysHessian       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; rehessian
                       &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fmap vec2l &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;   hessianF f &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; r2vec
    , sysPotential     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;                         u &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; r2vec
    , sysPotentialGrad &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;      vec2r &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;       grad u &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; r2vec
                  &lt;span class=&quot;co&quot;&gt;-- &amp;lt; convert from | actual thing | convert to &amp;gt;&lt;/span&gt;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, I hesitate to call this “trivial”…but, I think it really is a straightforward direct translation of the definitions, minus some boilerplate conversions back and forth using &lt;code&gt;r2vec&lt;/code&gt;, &lt;code&gt;vec2r&lt;/code&gt;, and &lt;code&gt;vec2l&lt;/code&gt;!&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;The vector of masses is just &lt;code&gt;m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The coordinate function is just &lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Jacobian of the coordinate function is just &lt;code&gt;jacobian f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The Hessian Tensor of the coordinate function is just &lt;code&gt;hessianF f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The potential energy function is just &lt;code&gt;u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The gradient of the potential energy function is just &lt;code&gt;grad u&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;em&gt;ad&lt;/em&gt; library automatically generated all of these for us and created a perfectly well-formed &lt;code&gt;System&lt;/code&gt; with all of its gradients and Jacobians and Hessians by giving only the coordinate function and the potential energy function, and in such a clean and concise way!&lt;/p&gt;
&lt;h3 id=&quot;equations-of-motion&quot;&gt;Equations of Motion&lt;/h3&gt;
&lt;p&gt;At this point, we’re ready to write our final equations of motion, which we found to be given by:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%26%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%20%5C%5C%0A%5Cdot%7B%5Cmathbf%7Bp%7D%7D%20%26%20%3D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Cleft%5B%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20-%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A%5Cend%7Baligned%7D%0A&quot; alt=&quot;
\begin{aligned}
\dot{\mathbf{q}} &amp;amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp;amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \nabla_{\mathbf{q}} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
&quot; title=&quot;
\begin{aligned}
\dot{\mathbf{q}} &amp;amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp;amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \nabla_{\mathbf{q}} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;These equations aren’t particularly beautiful, but it’s straightforward to translate them into Haskell (using &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D%20%3D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f&quot; alt=&quot;\hat{K} = \hat{J}_f^T \hat{M} \hat{J}_f&quot; title=&quot;\hat{K} = \hat{J}_f^T \hat{M} \hat{J}_f&quot; /&gt;):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L116-133&lt;/span&gt;
hamilEqns
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n)       &lt;span class=&quot;co&quot;&gt;-- dq/dt and dp/dt&lt;/span&gt;
hamilEqns s (&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; q p) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (dqdt, dpdt)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    j       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sysJacobian s q
    trj     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr j
    mHat    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; diag (sysInertia s)
    kHat    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; trj &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; mHat &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; j
    kHatInv &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; inv kHat
    dqdt    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; kHatInv &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; p
    dpdt    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec2r bigUglyThing &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; sysPotentialGrad s q
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        bigUglyThing &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          fmap (\j2 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;p &lt;span class=&quot;fu&quot;&gt;&amp;lt;.&amp;gt;&lt;/span&gt; kHatInv &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; trj &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; mHat &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; j2 &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; kHatInv &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; p)
               (sysHessian s q)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Of course, there is no way to get around the big ugly math term in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bp%7D_q&quot; alt=&quot;\dot{p}_q&quot; title=&quot;\dot{p}_q&quot; /&gt;, but at least it is a direct reading of the math!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;But!!&lt;/em&gt; I’d much rather write this scary Haskell than that scary math, because &lt;em&gt;ghc typechecks our math&lt;/em&gt;! When writing out those equations, we really had no idea if we were writing it correctly, and if the matrix and vector and tensor dimensions line up. If it even &lt;em&gt;made sense&lt;/em&gt; to multiply and transpose the quantities we had.&lt;/p&gt;
&lt;p&gt;However, when writing &lt;code&gt;hamilEqns&lt;/code&gt;, we let GHC &lt;em&gt;hold our hand for us&lt;/em&gt;. If any of our math is wrong, GHC will verify it for us! If any dimensions don’t match up, or any transpositions don’t make sense, we’ll know immediately. And if we’re ever lost, we can leave a &lt;em&gt;&lt;a href=&quot;https://wiki.haskell.org/GHC/Typed_holes&quot;&gt;typed hole&lt;/a&gt;&lt;/em&gt; – then GHC will tell you all of the values in scope that can &lt;em&gt;fit&lt;/em&gt; in that hole! Even if you don’t completely understand the math, this helps you implement it in a somewhat confident way.&lt;/p&gt;
&lt;p&gt;It’s admittedly difficult to convey how helpful these sized vector types are without working through trying to implement them yourself, so feel free to give it a try when you get the chance! :D&lt;/p&gt;
&lt;h3 id=&quot;numerical-integration&quot;&gt;Numerical Integration&lt;/h3&gt;
&lt;p&gt;The result of &lt;code&gt;hamilEqns&lt;/code&gt; gives the rate of change of the components of our &lt;code&gt;Phase n&lt;/code&gt;. The rest of the processes then is just to “step” &lt;code&gt;Phase n&lt;/code&gt;. Gradually update it, following these rate of changes!&lt;/p&gt;
&lt;p&gt;This process is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Numerical_integration&quot;&gt;numerical integration&lt;/a&gt;. The “best” way to do it is quite a big field, so for this article we’re going to be using the extremely extremely simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Euler_method&quot;&gt;Euler method&lt;/a&gt; to progress our system through time.&lt;/p&gt;
&lt;p&gt;Disclaimer – The Euler method is typically a &lt;strong&gt;very very bad&lt;/strong&gt; choice for numerical integration (even though, as popularized in the movie &lt;em&gt;Hidden Figures&lt;/em&gt;, it was good enough to &lt;a href=&quot;http://www.latimes.com/science/sciencenow/la-sci-sn-hidden-figures-katherine-johnson-20170109-story.html&quot;&gt;send humans to space?&lt;/a&gt;). We are just choosing it for this article because it’s very simple, conceptually!&lt;/p&gt;
&lt;p&gt;The basic idea is that you pick a time-step, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5CDelta%20t&quot; alt=&quot;\Delta t&quot; title=&quot;\Delta t&quot; /&gt;, and update each coordinate as:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0Ax%28t%20%2B%20%5CDelta%20t%29%20%3D%20x%28t%29%20%2B%20%5Cdot%7Bx%7D%28t%29%20%5CDelta%20t%0A&quot; alt=&quot;
x(t + \Delta t) = x(t) + \dot{x}(t) \Delta t
&quot; title=&quot;
x(t + \Delta t) = x(t) + \dot{x}(t) \Delta t
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Which makes sense visually if we imagine &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D&quot; alt=&quot;\dot{x}&quot; title=&quot;\dot{x}&quot; /&gt; as the “slope” of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; – it just means to follow the slope another &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5CDelta%20t&quot; alt=&quot;\Delta t&quot; title=&quot;\Delta t&quot; /&gt; steps. If the slope stays constant, this method is perfectly accurate. The inaccuracy, of course, happens when the slope changes drastically within that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5CDelta%20t&quot; alt=&quot;\Delta t&quot; title=&quot;\Delta t&quot; /&gt; (and also from the fact that small errors cause errors in the new calculations of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D&quot; alt=&quot;\dot{x}&quot; title=&quot;\dot{x}&quot; /&gt;, and so compound over time)&lt;/p&gt;
&lt;p&gt;You can understand this symbolically, as well, by remembering that the derivative can be approximated by &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D%28t%29%20%5Capprox%20%5Cfrac%7Bx%28t%20%2B%20%5CDelta%20t%29%20-%20x%28t%29%7D%7B%5CDelta%20t%7D&quot; alt=&quot;\dot{x}(t) \approx \frac{x(t + \Delta t) - x(t)}{\Delta t}&quot; title=&quot;\dot{x}(t) \approx \frac{x(t + \Delta t) - x(t)}{\Delta t}&quot; /&gt; for small &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5CDelta%20t&quot; alt=&quot;\Delta t&quot; title=&quot;\Delta t&quot; /&gt;, and so we can do a little bit of symbolic manipulation to get &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x%28t%20%2B%20%5CDelta%20t%29%20%5Capprox%20%5Cdot%7Bx%7D%28t%29%20%5CDelta%20t%20%2B%20x%28t%29&quot; alt=&quot;x(t + \Delta t) \approx \dot{x}(t) \Delta t + x(t)&quot; title=&quot;x(t + \Delta t) \approx \dot{x}(t) \Delta t + x(t)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;We can directly translate this into Haskell: (using &lt;code&gt;konst :: KnownNat n =&amp;gt; Double -&amp;gt; R n&lt;/code&gt;, making a constant vector, and &lt;code&gt;*&lt;/code&gt;, the component-wise product of two vectors)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L136-144&lt;/span&gt;
stepEuler
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n       &lt;span class=&quot;co&quot;&gt;-- ^ the system&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ dt&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n          &lt;span class=&quot;co&quot;&gt;-- ^ q(t) and p(t)&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n          &lt;span class=&quot;co&quot;&gt;-- ^ q(t + dt) and p(t + dt)&lt;/span&gt;
stepEuler s dt ph&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; q p) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; (q &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; konst dt &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dq) (p &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; konst dt &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dp)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    (dq, dp) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; hamilEqns s ph&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And repeatedly evolve this system as a lazy list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L147-155&lt;/span&gt;
runSystem
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; m n       &lt;span class=&quot;co&quot;&gt;-- ^ the system&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ dt&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n          &lt;span class=&quot;co&quot;&gt;-- ^ initial phase&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; n]        &lt;span class=&quot;co&quot;&gt;-- ^ progression of the system using Euler integration&lt;/span&gt;
runSystem s dt &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    go p0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; p0 &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; go (stepEuler s dt p0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;running-with-it&quot;&gt;Running with it&lt;/h2&gt;
&lt;p&gt;And…that’s it! Granted, in real life, we would be using a less naive integration method, but this is essentially the entire process!&lt;/p&gt;
&lt;p&gt;Let’s generate the boring system, a 5kg particle in 2D Cartesian Coordinates under gravity –&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L158-164&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;simpleSystem ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
simpleSystem &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSystem (vec2 &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) id pot
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- potential energy of a gravity field&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- U(x,y) = 9.8 * y&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    pot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
    pot xy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;9.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (xy &lt;span class=&quot;ot&quot;&gt;`V.index`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we initialize the particle at position &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D_0%20%3D%20%5Clangle%200%2C%200%20%5Crangle&quot; alt=&quot;\mathbf{q}_0 = \langle 0, 0 \rangle&quot; title=&quot;\mathbf{q}_0 = \langle 0, 0 \rangle&quot; /&gt; and velocity &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bv%7D_0%20%3D%20%5Clangle%201%2C%203%20%5Crangle&quot; alt=&quot;\mathbf{v}_0 = \langle 1, 3 \rangle&quot; title=&quot;\mathbf{v}_0 = \langle 1, 3 \rangle&quot; /&gt; (that is, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?v_x%20%3D%201&quot; alt=&quot;v_x = 1&quot; title=&quot;v_x = 1&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?v_y%20%3D%203&quot; alt=&quot;v_y = 3&quot; title=&quot;v_y = 3&quot; /&gt;), we should see something that travels at a constant velocity in x and something that starts moving “upwards” (in positive y) and eventually reaches a peak and moves downwards.&lt;/p&gt;
&lt;p&gt;We can make our initial configuration:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L168-172&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;simpleConfig0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
simpleConfig0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt;
    { confPositions  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec2 &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    , confVelocities &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec2 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then…let it run!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L174-178&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;simpleMain ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
simpleMain &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
    mapM_ (disp &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; phasePositions)  &lt;span class=&quot;co&quot;&gt;-- position with 2 digits of precision&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; take &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;                          &lt;span class=&quot;co&quot;&gt;-- 25 steps&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; runSystem simpleSystem &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; (toPhase simpleSystem simpleConfig0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;l Hamilton.hs
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; simpleMain
&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.10&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;0.30&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.20&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;0.58&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.30&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;0.84&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.40&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.08&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.50&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.30&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.60&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.51&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.70&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.69&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.80&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.85&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.90&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.99&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.00&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.12&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.10&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.22&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.20&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.31&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.30&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.37&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.40&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.42&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.50&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.44&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.60&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.45&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.70&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.43&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.80&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.40&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.90&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.35&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;2.00&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.28&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;2.10&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.18&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;2.20&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;2.07&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;2.30&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.94&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;2.40&lt;/span&gt;  &lt;span class=&quot;fl&quot;&gt;1.79&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Exactly what we’d expect! The &lt;code&gt;x&lt;/code&gt; positions increase steadily, and the &lt;code&gt;y&lt;/code&gt; positions increase, slow down, and start decreasing.&lt;/p&gt;
&lt;p&gt;We can try a slightly more complicated example that validates (and justifies) all of the work we’ve done – let’s simulate a simple pendulum. The state of a pendulum is characterized by one coordinate &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt;, which refers to the angular (clockwise) from the equilibrium “hanging straight down” position. &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta%20%3D%200&quot; alt=&quot;\theta = 0&quot; title=&quot;\theta = 0&quot; /&gt; corresponds to 6 o’ clock, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta%20%3D%20%5Cpi%2F2&quot; alt=&quot;\theta = \pi/2&quot; title=&quot;\theta = \pi/2&quot; /&gt; corresponds to 9 o’ clock, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta%20%3D%20-%20%5Cpi%20%2F%202&quot; alt=&quot;\theta = - \pi / 2&quot; title=&quot;\theta = - \pi / 2&quot; /&gt; corresponds to 3 o’ clock, etc. For a pendulum of length &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?l&quot; alt=&quot;l&quot; title=&quot;l&quot; /&gt;, we can translate that as &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20x%2C%20y%20%5Crangle%20%3D%20%5Clangle%20-%20l%20sin%28%5Ctheta%29%2C%20-%20l%20cos%28%5Ctheta%29%20%5Crangle&quot; alt=&quot;\langle x, y \rangle = \langle - l sin(\theta), - l cos(\theta) \rangle&quot; title=&quot;\langle x, y \rangle = \langle - l sin(\theta), - l cos(\theta) \rangle&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Let’s set up that system! We’ll put it under normal gravity potential, again (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?U%28x%2Cy%29%20%3D%209.8%20y&quot; alt=&quot;U(x,y) = 9.8 y&quot; title=&quot;U(x,y) = 9.8 y&quot; /&gt;). Our initial position &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta_0&quot; alt=&quot;\theta_0&quot; title=&quot;\theta_0&quot; /&gt; will be at equilibrium, and our initial angular velocity &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?v_%7B%5Ctheta%200%7D&quot; alt=&quot;v_{\theta 0}&quot; title=&quot;v_{\theta 0}&quot; /&gt; will be 0.1 radians/sec (clockwise), as we try to induce harmonic motion:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L181-210&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- | A pendulum system, parameterized by its angle clockwise from&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- equilibrium&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;pendulum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
pendulum &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSystem (vec2 &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) coords pot      &lt;span class=&quot;co&quot;&gt;-- 5kg particle&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- &amp;lt;x,y&amp;gt; = &amp;lt;-0.5 sin(theta), -0.5 cos(theta)&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- pendulum of length 0.25&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    coords ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
    coords (V.head&lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;theta) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromJust
                           &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; V.fromList
                           &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; [&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.25&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; sin theta, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.25&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; cos theta]
    &lt;span class=&quot;co&quot;&gt;-- potential energy of gravity field&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- U(x,y) = 9.8 * y&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    pot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RealFloat&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
    pot q &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;9.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (coords q &lt;span class=&quot;ot&quot;&gt;`V.index`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)

&lt;span class=&quot;ot&quot;&gt;pendulumConfig0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
pendulumConfig0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt;
    { confPositions  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    , confVelocities &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt;
    }

&lt;span class=&quot;ot&quot;&gt;pendulumMain ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
pendulumMain &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
    mapM_ (disp &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; phasePositions)  &lt;span class=&quot;co&quot;&gt;-- position with 2 digits of precision&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; take &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;                          &lt;span class=&quot;co&quot;&gt;-- 25 steps&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; runSystem pendulum &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; (toPhase pendulum pendulumConfig0)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pendulum should wobble back and forth, ever so slightly, around equilibrium.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;l Hamilton.hs
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; pendulumMain
&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.010&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.020&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.029&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.037&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.042&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.045&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.044&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.040&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.032&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.021&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.007&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.008&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.023&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.038&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.051&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.061&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.068&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.069&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.065&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.056&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.041&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.022&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.000&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;0.023&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see our &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt; coordinate increasing, then turning around and decreasing, swinging the other way past equilibrium, and then turning around and heading back!&lt;a href=&quot;#fn7&quot; class=&quot;footnoteRef&quot; id=&quot;fnref7&quot;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We &lt;em&gt;automatically generated equations of motion for a pendulum&lt;/em&gt;. Sweet!&lt;/p&gt;
&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap-Up&lt;/h2&gt;
&lt;p&gt;We traveled through the world of physics, math, Haskell, and back again to achieve something that would have initially seemed like a crazy thought experiment. But, utilizing Hamiltonian mechanics, we have a system that can automatically generate equations of motion given your coordinate system and a potential energy function. We also learned how to leverage typed vectors for more correct code and a smoother development process.&lt;/p&gt;
&lt;p&gt;See my &lt;a href=&quot;https://blog.jle.im/entry/introducing-the-hamilton-library.html&quot;&gt;previous post&lt;/a&gt; for even crazier examples – involving multiple objects, double pendulums, and more. And check out my &lt;a href=&quot;http://hackage.haskell.org/package/hamilton&quot;&gt;hamilton&lt;/a&gt; library on hackage, which includes demos for exotic interesting systems, rendered graphically on your terminal.&lt;/p&gt;
&lt;p&gt;I realize that this was a lot, so if you have any questions or suggestions for clarifications, feel free to leave a comment, drop me a &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;tweet&lt;/a&gt;, or find me on the freenode &lt;em&gt;#haskell&lt;/em&gt; channel (where I usually idle as &lt;em&gt;jle`&lt;/em&gt;!)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;The picture with a time-dependent Hamiltonian is different, but only slightly. In the time-dependent case, the system still &lt;em&gt;tries&lt;/em&gt; to move along contour lines at every point in time, but the mountain is constantly changing underneath it and the contour lines keep on shifting underneath it. Sounds like life!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;There’s also another perpendicular vector, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20-y%2C%20x%20%5Crangle&quot; alt=&quot;\langle -y, x \rangle&quot; title=&quot;\langle -y, x \rangle&quot; /&gt;, which actually gives motion &lt;em&gt;backwards&lt;/em&gt; in time.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Disclaimer: I am not a surfer.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BJ_f%7D&quot; alt=&quot;\hat{J_f}&quot; title=&quot;\hat{J_f}&quot; /&gt; is full-rank (meaning &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Chat%7BK%7D&quot; alt=&quot;\hat{K}&quot; title=&quot;\hat{K}&quot; /&gt; is invertible) if its rows are linearly independent. This should be the case as you don’t have any redundant or duplicate coordinates in your general coordinate system.&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;Thanks to Edward Kmett for &lt;a href=&quot;http://disq.us/p/1o4oyqh&quot;&gt;pointing this out&lt;/a&gt;!&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn6&quot;&gt;&lt;p&gt;&lt;code&gt;hessian&lt;/code&gt; computes the Hessian Matrix for scalar-valued function, but here, we have a vector-valued function, so we need &lt;code&gt;hessianF&lt;/code&gt;, the Hessian &lt;em&gt;Tensor&lt;/em&gt;.&lt;a href=&quot;#fnref6&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn7&quot;&gt;&lt;p&gt;Clearly our system is gaining some sort of phantom energy, since it rises up to 0.045 on the left, and then all the way up to -0.69 on the right. Rest assured that this is simply from the inaccuracies in Euler’s Method.&lt;a href=&quot;#fnref7&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.html</guid><pubDate>Mon, 27 Nov 2017 19:46:18 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell</dc:subject><dc:date>2017-11-27</dc:date></item><item><title>Fixed-Length Vector Types in Haskell (an Update for 2017)</title><link>https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html</link><description>&lt;p&gt;This post is a follow-up to my &lt;a href=&quot;https://blog.jle.im/entry/fixed-length-vector-types-in-haskell-2015.html&quot;&gt;fixed-length vectors in haskell in 2015&lt;/a&gt; post! When I was writing the post originally, I was new to the whole type-level game in Haskell; I didn’t know what I was talking about, and that post was a way for me to push myself to learn more. Immediately after it was posted, of course, people taught me where I went wrong in the idioms I explained, and better and more idiomatic ways to do things. And that’s great! Learning is awesome!&lt;/p&gt;
&lt;p&gt;Unfortunately, however, to my horror, I began noticing people referring to the post in a canonical/authoritative way…so the post became an immediate source of guilt to me. I tried correcting things with my &lt;a href=&quot;https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html&quot;&gt;practical dependent types in haskell&lt;/a&gt; series the next year. But I still saw my 2015 post being used as a reference even after that post, so I figured that writing a direct replacement/follow-up as the only way I would ever fix this!&lt;/p&gt;
&lt;p&gt;So here we are in 2017. GHC 8.2 is here, and &lt;em&gt;base&lt;/em&gt; is in version &lt;em&gt;4.10&lt;/em&gt;. What’s the “right” way to do fixed-length vectors in Haskell?&lt;/p&gt;
&lt;p&gt;This post doesn’t attempt to present anything groundbreaking or new, but is meant to be a sort of &lt;em&gt;reference/introduction&lt;/em&gt; to fixed-length vectors in Haskell, as of GHC 8.2 and the 2017 Haskell ecosystem.&lt;/p&gt;
&lt;p&gt;We’ll be looking at two methods here: The first one we will be looking at is a &lt;em&gt;performant&lt;/em&gt; fixed-length vector that you will probably be using for any code that requires a fixed-length container — especially for tight numeric code and situations where performance matters. We’ll see how to implement them using the universal native &lt;code&gt;KnownNat&lt;/code&gt; mechanisms, and also how we can implement them using &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; to help us make things a bit smoother and more well-integrated. For most people, this is all they actually need. (I claim the canonical haskell ecosystem source to be the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector-sized&quot;&gt;vector-sized&lt;/a&gt;&lt;/em&gt; library)&lt;/p&gt;
&lt;p&gt;The second method is a &lt;em&gt;structural&lt;/em&gt; fixed-length inductive vector. It’s…actually more like a fixed-length (lazily linked) &lt;em&gt;list&lt;/em&gt; than a vector. The length of the list is enforced by the very structure of the data type. This type is more useful as a streaming data type, and also in situations where you want take advantage of the structural characteristics of lengths in the context of a dependently typed program. (I claim the canonical haskell ecosystem source to be the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/type-combinators&quot;&gt;type-combinators&lt;/a&gt;&lt;/em&gt; library)&lt;/p&gt;
&lt;h2 id=&quot;the-non-structural-way&quot;&gt;The Non-Structural Way&lt;/h2&gt;
&lt;p&gt;(Code for this section (as well as exercise solutions) are &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs&quot;&gt;available here&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;In most situations, if you use vectors, you want some sort of constant-time indexed data structure. The best way to do this in Haskell is to wrap the heavily optimized &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector&quot;&gt;vector&lt;/a&gt;&lt;/em&gt; library with a newtype wrapper that contains its length as a phantom type parameter.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import qualified&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Data.Vector&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import           &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;GHC.TypeNats&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L19-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; getVector ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a }
    &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Vec n a&lt;/code&gt; will represent an &lt;code&gt;n&lt;/code&gt;-element vector of &lt;code&gt;a&lt;/code&gt;s. So, a &lt;code&gt;Vec 5 Int&lt;/code&gt; will be a vector of five &lt;code&gt;Int&lt;/code&gt;s, a &lt;code&gt;Vec 10 String&lt;/code&gt; is a vector of 10 &lt;code&gt;String&lt;/code&gt;s, etc.&lt;/p&gt;
&lt;p&gt;For our numeric types, we’re using the fancy “type literals” that GHC offers us with the &lt;code&gt;DataKinds&lt;/code&gt; extension. Basically, alongside the normal kinds &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;* -&amp;gt; *&lt;/code&gt;, etc., we also have the &lt;code&gt;Nat&lt;/code&gt; kind; type literals &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;100&lt;/code&gt;, etc. are all &lt;em&gt;types&lt;/em&gt; with the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt;, from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeNats.html&quot;&gt;GHC.TypeNats&lt;/a&gt;&lt;/em&gt; module&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can “reflect” the type-level numeral as a value using the &lt;code&gt;KnownNat&lt;/code&gt; typeclass, provided by GHC, which lets you gain back the number as a run-time value using &lt;code&gt;natVal&lt;/code&gt;: (This process is called “reflection”)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;natVal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; p n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Where &lt;code&gt;Natural&lt;/code&gt;, from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Numeric-Natural.html&quot;&gt;Numeric.Natural&lt;/a&gt;&lt;/em&gt;, is a non-negative &lt;code&gt;Integer&lt;/code&gt; type.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;-- or, natVal (Proxy :: Proxy 10)&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Super low-level utility functions for the &lt;code&gt;Nat&lt;/code&gt; kind (like &lt;code&gt;natVal&lt;/code&gt;) are found in the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeNats.html&quot;&gt;GHC.TypeNats&lt;/a&gt;&lt;/em&gt; module (and also in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html&quot;&gt;GHC.TypeLits&lt;/a&gt;&lt;/em&gt; for a slightly different API)&lt;/p&gt;
&lt;h3 id=&quot;the-smart-constructor&quot;&gt;The Smart Constructor&lt;/h3&gt;
&lt;p&gt;We can use &lt;code&gt;natVal&lt;/code&gt; with the &lt;code&gt;KnownNat&lt;/code&gt; typeclass to write a “smart constructor” for our type – make a &lt;code&gt;Vec&lt;/code&gt; from a &lt;code&gt;Vector&lt;/code&gt;, but only if the length is the correct type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L22-26&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mkVec ::&lt;/span&gt; forall n a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
mkVec v &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; V.length v &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; v)
        &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;n))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we use &lt;code&gt;ScopedTypeVariables&lt;/code&gt; so we can refer to the &lt;code&gt;n&lt;/code&gt; in the type signature in the function body (for &lt;code&gt;natVal (Proxy @n)&lt;/code&gt;), and we need to use an explicit forall, then, to bring the &lt;code&gt;n&lt;/code&gt; into scope.&lt;/p&gt;
&lt;p&gt;We also use &lt;code&gt;TypeApplications&lt;/code&gt; syntax (&lt;code&gt;Proxy @n&lt;/code&gt;) so we can say “We want a &lt;code&gt;Proxy :: Proxy n&lt;/code&gt;” and tell &lt;code&gt;natVal&lt;/code&gt; that we want the &lt;code&gt;Natural&lt;/code&gt; for &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;utilizing-type-level-guarantees&quot;&gt;Utilizing type-level guarantees&lt;/h3&gt;
&lt;p&gt;Another operation we might want to do with vectors is do things with them that might change their length in a predetermined way. We might want the type of our vectors to describe the nature of the operations they are undergoing. For example, if you saw a function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;someFunc ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can see that it takes a function and a vector of length &lt;code&gt;n&lt;/code&gt;, and returns another vector of length &lt;code&gt;n&lt;/code&gt;. Clearly, this function might be a “map” function, which applies the function to all of the values in the &lt;code&gt;Vec&lt;/code&gt;! We know that it must have the same length, so it can’t drop or add items. (However, it could still be shuffling or duplicating or permuting the items, as long as the resulting length is the same)&lt;/p&gt;
&lt;p&gt;In this situation, we can write such a mapping function in an “unsafe” way, and then give it our type signature as a form of documentation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L28-29&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mapVec ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n b
mapVec f v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.map f (getVector v)

&lt;span class=&quot;co&quot;&gt;-- just for fun&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L31-32&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fmap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mapVec&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The compiler didn’t help us write this function, and we have to be pretty careful that the guarantees we specify in our types are reflected in the actual unsafe operations. This is because our types don’t &lt;em&gt;structurally&lt;/em&gt; enforce their type-level lengths.&lt;/p&gt;
&lt;p&gt;So, why bother? For us, here, our fixed-length vector types basically act as “active documentation”, in a way. Compare:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- | Maps the function over the items in the vector, returning a vector of the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- same length&lt;/span&gt;
V.map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is the type signature we’d have to write for a map of an “unsized” vector (like from the &lt;em&gt;Data.Vector&lt;/em&gt; module)&lt;/p&gt;
&lt;p&gt;We have to rely on the documentation to &lt;em&gt;tell&lt;/em&gt; us what the length of the final resulting vector is, even though it can be known statically if you know the length of the input vectors. The vectors have a &lt;em&gt;static relationship&lt;/em&gt; in their length, but this isn’t specified in a way that the compiler can take advantage of.&lt;/p&gt;
&lt;p&gt;By having our &lt;code&gt;mapVec :: (a -&amp;gt; b) -&amp;gt; Vec n a -&amp;gt; Vec n b&lt;/code&gt;, the relationship between the input lengths and output length is right there in the types, when you &lt;em&gt;use&lt;/em&gt; &lt;code&gt;mapVec&lt;/code&gt;, GHC is aware of the relationships and can give you help in the form of typed hole suggestions and informative type errors. You can even catch errors in logic at compile-time instead of runtime!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- the resulting vector&amp;#39;s length is the sum of the input vectors&amp;#39; lengths&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L34-35&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(++) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; xs &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; (xs &lt;span class=&quot;fu&quot;&gt;V.++&lt;/span&gt; ys)

&lt;span class=&quot;co&quot;&gt;-- you must zip two vectors of the same length&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L37-38&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;zipVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n (a, b)
zipVec (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; xs) (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; ys) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; (V.zip xs ys)

&lt;span class=&quot;co&quot;&gt;-- type-level arithmetic to let us &amp;#39;take&amp;#39;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L40-43&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;takeVec ::&lt;/span&gt; forall n m a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
takeVec (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; (V.take l xs)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;n))

&lt;span class=&quot;co&quot;&gt;-- splitAt, as well&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L45-49&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;splitVec ::&lt;/span&gt; forall n m a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a, &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
splitVec (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; ys, &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; zs)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;n))
    (ys, zs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; V.splitAt l xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code&gt;(+)&lt;/code&gt; comes from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeNats.html&quot;&gt;GHC.TypeNats&lt;/a&gt;&lt;/em&gt;, which provides it as a type family (type-level function) we can use, with proper meaning and semantics.&lt;/p&gt;
&lt;p&gt;Note the usage of &lt;code&gt;(+)&lt;/code&gt; for &lt;code&gt;takeVec&lt;/code&gt; and &lt;code&gt;splitVec&lt;/code&gt; to let the function ensure that the input vector has “enough” (at least &lt;code&gt;n&lt;/code&gt;) elements to do the taking.&lt;/p&gt;
&lt;h4 id=&quot;notes-on-the-typechecker&quot;&gt;Notes on the typechecker&lt;/h4&gt;
&lt;p&gt;GHC’s typechecker works very well with concrete, monomorphic &lt;code&gt;Nat&lt;/code&gt;s. For example, &lt;code&gt;5 + 3&lt;/code&gt; will always typecheck as &lt;code&gt;8&lt;/code&gt;, so you don’t have to worry at all about &lt;code&gt;takeVec&lt;/code&gt;, &lt;code&gt;(++)&lt;/code&gt;, and &lt;code&gt;splitVec&lt;/code&gt;’s usage of &lt;code&gt;(+)&lt;/code&gt; if you work with monomorphic, specific &lt;code&gt;Nat&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;However, GHC treats &lt;code&gt;(+)&lt;/code&gt; “opaquely” when using using it with polymorphic type variables. That means that &lt;code&gt;n + (m + o)&lt;/code&gt; is seen as a completely different type to GHC than &lt;code&gt;(n + m) + o&lt;/code&gt; – GHC doesn’t reduce &lt;code&gt;+&lt;/code&gt;, and to it, they both just look like different trees. Remember that one is &lt;code&gt;(+) n ((+) m o)&lt;/code&gt;, and the other is &lt;code&gt;(+) ((+) n m) o&lt;/code&gt;. Completely different structure!&lt;/p&gt;
&lt;p&gt;This comes up as an issue when you start doing non-trivial things, so it sometimes helps to augment GHC’s typechecker.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/ghc-typelits-natnormalise&quot;&gt;ghc-typelits-natnormalise&lt;/a&gt;&lt;/em&gt; package provides such a plugin. If we pass it as a flag to GHC (as &lt;code&gt;-fplugin GHC.TypeLits.NatNormalise&lt;/code&gt;) or as a pragma:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then GHC will be able to recognize the fact that &lt;code&gt;n + (m + o)&lt;/code&gt; and &lt;code&gt;(n + m) + o&lt;/code&gt; are the same, and will unify them during typechecking. It also provides normalization/unification for many other situations that we “expect” to work when using &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; on type variables.&lt;/p&gt;
&lt;h3 id=&quot;indexing&quot;&gt;Indexing&lt;/h3&gt;
&lt;p&gt;We need an appropriate type for indexing our vectors, but we’d like a type where indexing is “safe” – that is, that you can’t compile a program that will result in an index error.&lt;/p&gt;
&lt;p&gt;For this, we can use the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/finite-typelits&quot;&gt;finite-typelits&lt;/a&gt;&lt;/em&gt; package, which provides the &lt;code&gt;Finite n&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Finite n&lt;/code&gt; type is a type with exactly &lt;code&gt;n&lt;/code&gt; distinct inhabitants/values. For example, &lt;code&gt;Finite 4&lt;/code&gt; contains four “anonymous” inhabitants. For convenience, sometimes we like to name them 0, 1, 2, and 3. In general, we sometimes refer to the values of type &lt;code&gt;Finite n&lt;/code&gt; as 0 … (n - 1).&lt;/p&gt;
&lt;p&gt;So, we can imagine that &lt;code&gt;Finite 6&lt;/code&gt; has inhabitants corresponding to 0, 1, 2, 3, 4, and 5. We can convert back and forth between a &lt;code&gt;Finite n&lt;/code&gt; and its &lt;code&gt;Integer&lt;/code&gt; representation using &lt;code&gt;packFinite&lt;/code&gt; and &lt;code&gt;getFinite&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;packFinite ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n)
&lt;span class=&quot;ot&quot;&gt;getFinite  ::&lt;/span&gt;               &lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; map packFinite [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)]
[&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (finite &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (finite &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (finite &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;]
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; getFinite (finite &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use a &lt;code&gt;Finite n&lt;/code&gt; to “index” a &lt;code&gt;Vector n a&lt;/code&gt;. A &lt;code&gt;Vector n a&lt;/code&gt; has exactly &lt;code&gt;n&lt;/code&gt; slots, and a &lt;code&gt;Finite n&lt;/code&gt; has &lt;code&gt;n&lt;/code&gt; possible values. Clearly, &lt;code&gt;Finite n&lt;/code&gt; only contains valid indices into our vector!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L51-52&lt;/span&gt;
index&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
index v i &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getVector v &lt;span class=&quot;fu&quot;&gt;V.!&lt;/span&gt; fromIntegral (getFinite i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;index&lt;/code&gt; will never fail at runtime due to a bad index — do you see why? Valid indices of a &lt;code&gt;Vector 5 a&lt;/code&gt; are the integers 0 to 4, and that is precisely the exact things that &lt;code&gt;Finite 5&lt;/code&gt; can store!&lt;/p&gt;
&lt;h3 id=&quot;generating&quot;&gt;Generating&lt;/h3&gt;
&lt;p&gt;We can directly generate these vectors in interesting ways. Using return-type polymorphism, we can have the user &lt;em&gt;directly&lt;/em&gt; request a vector length, &lt;em&gt;just&lt;/em&gt; by using type inference or a type annotation. (kind of like with &lt;code&gt;read&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;For example, we can write a version of &lt;code&gt;replicate&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L54-57&lt;/span&gt;
replicate&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; forall n a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
replicate x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.replicate l x
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;n))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; replicate &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; (V.fromList [&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that normally, &lt;code&gt;replicate&lt;/code&gt; takes an &lt;code&gt;Int&lt;/code&gt; argument so that the user can give how long the resulting vector needs to be. However, with our new &lt;code&gt;replicate&lt;/code&gt;, we don’t need that &lt;code&gt;Int&lt;/code&gt; argument — the size of the vector we want can more often than not be inferred auto-magically using type inference!&lt;/p&gt;
&lt;p&gt;With this new cleaner type signature, we can actually see that &lt;code&gt;replicate&lt;/code&gt;’s type is something very familiar. Look at it carefully:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;replicate&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might recognize it as very similar to haskellism &lt;code&gt;pure&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;pure&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Applicative&lt;/span&gt; f &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;replicate&lt;/code&gt; is actually &lt;code&gt;pure&lt;/code&gt; for the Applicative instance of &lt;code&gt;Vec n&lt;/code&gt;! As an extra challenge, what would &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; be? See &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L59-61&quot;&gt;the solution&lt;/a&gt; if you want to check your answer!&lt;/p&gt;
&lt;h4 id=&quot;generating-with-indices&quot;&gt;Generating with indices&lt;/h4&gt;
&lt;p&gt;We can be a little more fancy with &lt;code&gt;replicate&lt;/code&gt;, to get what we normally call &lt;code&gt;generate&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L63-66&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;generate ::&lt;/span&gt; forall n a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
generate f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.generate l (f &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromIntegral)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;n))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;type-safety-and-positives-and-negatives&quot;&gt;Type-Safety and positives and negatives&lt;/h4&gt;
&lt;p&gt;I think it’s an interesting point that we’re using &lt;code&gt;Finite n&lt;/code&gt; in a different sense here than in &lt;code&gt;index&lt;/code&gt;, and for different reasons. In &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;Finite&lt;/code&gt; is in the “negative” position — it’s something that the function “takes”. In &lt;code&gt;generate&lt;/code&gt;, &lt;code&gt;Finite&lt;/code&gt; is in the “positive” position — it’s something that the function “gives” (to the &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;generate f&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;In the negative position, &lt;code&gt;Finite n&lt;/code&gt; and type-safety is useful because:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;It tells the user what sort of values that the function expects. The user &lt;em&gt;knows&lt;/em&gt;, just from the type, that indexing a &lt;code&gt;Vec 5 a&lt;/code&gt; requires a &lt;code&gt;Finite 5&lt;/code&gt;, or a number between 0 and 4.&lt;/li&gt;
&lt;li&gt;It guarantees that whatever &lt;code&gt;Finite n&lt;/code&gt; index you give to &lt;code&gt;index&lt;/code&gt; is a &lt;em&gt;valid one&lt;/em&gt;. It’s impossible to give &lt;code&gt;index&lt;/code&gt; an “invalid index”, so &lt;code&gt;index&lt;/code&gt; is allowed to use “unsafe indexing” in its implementation, knowing that nothing bad can be given.&lt;/li&gt;
&lt;li&gt;It lets you develop code in “typed-hole” style: if a function requires a &lt;code&gt;Finite 4&lt;/code&gt;, put an underscore there, and GHC will tell you about all the &lt;code&gt;Finite 4&lt;/code&gt;s you have in scope. It can help you write your code for you!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the positive position, &lt;code&gt;Finite n&lt;/code&gt; and the type-safety have different uses and advantages: it tells the user what sort of values the function can return, and also also the type of values that the user has to be expected to handle. For example, in &lt;code&gt;generate&lt;/code&gt;, the fact that the user has to provide a &lt;code&gt;Finite n -&amp;gt; a&lt;/code&gt; tells the user that they have to handle every number between 0 and n-1, and nothing else.&lt;/p&gt;
&lt;h3 id=&quot;moving-between-sized-and-unsized&quot;&gt;Moving between Sized and Unsized&lt;/h3&gt;
&lt;p&gt;One key part of our API is missing: how to convert between “sized” and “unsized” vectors.&lt;/p&gt;
&lt;p&gt;Converting from sized to unsized is easy, and we already have it:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;getVector ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Converting from unsized to sized is harder. We already saw a “shoe-horning” method, if we know the size we want at compile-time:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;mkVec ::&lt;/span&gt; forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But what if we don’t know what size &lt;code&gt;n&lt;/code&gt; we want? What if we want &lt;code&gt;n&lt;/code&gt; to be whatever the actual size of the input vector is?&lt;/p&gt;
&lt;p&gt;In general we can’t predict the size of our input vector at compile-time, so we can’t just directly put in a size we want. What we want is a method to return a &lt;code&gt;Vec n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the input vector, determined at runtime.&lt;/p&gt;
&lt;p&gt;I’m going to try to convince you that a plausible API is:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;withVec
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note: this does require &lt;code&gt;RankNTypes&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;People familiar with dependent types might recognize that &lt;code&gt;withVec&lt;/code&gt; is a function that takes an unsized vector and returns an &lt;em&gt;existentially quantified&lt;/em&gt; sized vector, in CPS-style. Basically, give the function a vector, and a way to “handle” a &lt;code&gt;Vec n&lt;/code&gt; of &lt;em&gt;any possible size&lt;/em&gt;. The function will then give your handler a &lt;code&gt;Vec n&lt;/code&gt; of the proper type/size. The &lt;em&gt;function&lt;/em&gt; gets to chose the &lt;code&gt;n&lt;/code&gt; that you must handle.&lt;/p&gt;
&lt;p&gt;Within your continuation/handler, you can take advantage of the size type, and do take advantage of all of the type-level guarantees and benefits of a length-indexed vector. In a way, it is its own “world” where your vector has a fixed size. However, the caveat is that you have to treat the size &lt;em&gt;universally&lt;/em&gt; — you have to be able to handle any possible size given to you, in a parametrically polymorphic way.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; myVector &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; V.fromList [&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; withVec myVector &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;v ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;co&quot;&gt;-- in this function body, `v :: Vec 3 Int`, and `n ~ 3`&lt;/span&gt;
          &lt;span class=&quot;co&quot;&gt;-- whatever I return here will be the return value of the entire line&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; packFinite &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- Finite 3&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; i  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; v &lt;span class=&quot;ot&quot;&gt;`index`&lt;/span&gt; i
&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could write, say, a function to always safely get the third item:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L68-69&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getThird ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a
getThird v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withVec v &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \v&amp;#39; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; fmap (v&amp;#39; &lt;span class=&quot;ot&quot;&gt;`index`&lt;/span&gt;) (packFinite &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can run it:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; getThird &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.fromList [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; getThird &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.fromList [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can even do something silly like convert an unsized vector to a sized vector and then back again:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L71-72&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;vectorToVector ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a
vectorToVector v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withVec v getVector&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that I’ve (hopefully) convinced you that this function really does convert an unsized vector into a sized vector that you can use, let’s see how we can implement it!&lt;/p&gt;
&lt;p&gt;To do this, we can take advantage of the &lt;code&gt;someNatVal&lt;/code&gt; function (from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeNats.html&quot;&gt;GHC.TypeNats&lt;/a&gt;&lt;/em&gt;):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n)

&lt;span class=&quot;ot&quot;&gt;someNatVal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SomeNat&lt;/code&gt; contains what we call an existentially quantified type, &lt;code&gt;n&lt;/code&gt;. Basically, a value of &lt;code&gt;SomeNat&lt;/code&gt; contains a &lt;code&gt;Proxy n&lt;/code&gt; with &lt;em&gt;some specific &lt;code&gt;n&lt;/code&gt;&lt;/em&gt;, that is hidden “inside” the constructor. The only way to figure it out is to pattern match on the constructor and use it in a generic and parametrically polymorphic way. Sound familiar?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;someNatVal&lt;/code&gt; converts &lt;code&gt;Natural&lt;/code&gt; (a non-negative Integer type) into a &lt;code&gt;SomeNat&lt;/code&gt; — it “picks” the right &lt;code&gt;n&lt;/code&gt; (the one that corresponds to that &lt;code&gt;Natural&lt;/code&gt;) and stuffs/hides it into &lt;code&gt;SomeNat&lt;/code&gt;. We can leverage this to write our &lt;code&gt;withVec&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L74-76&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withVec v f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; someNatVal (fromIntegral (V.length v)) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;m v)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The &lt;code&gt;TypeApplications&lt;/code&gt; syntax &lt;code&gt;@m&lt;/code&gt; is used with &lt;code&gt;UnsafeMkVec&lt;/code&gt; to specify that we want a &lt;code&gt;Vec m a&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;This process is actually called “reification” – we take a value-level runtime property (the length) and “reify” it, bringing it up to the type-level.&lt;/p&gt;
&lt;p&gt;And now, we have both of our conversion functions! We can convert from sized to unsized using &lt;code&gt;getVector&lt;/code&gt;, and from unsized to sized using &lt;code&gt;withVec&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;verifying-properties&quot;&gt;Verifying Properties&lt;/h3&gt;
&lt;p&gt;The final useful API aspect we will be looking at is how to verify properties of our vector lengths at the type level, and let us use those properties.&lt;/p&gt;
&lt;p&gt;One common thing we might want to do is ensure that two vectors have the same length. This might happen when we use &lt;code&gt;withVec&lt;/code&gt; from two different vectors, and we get a &lt;code&gt;Vec n a&lt;/code&gt; and &lt;code&gt;Vec m a&lt;/code&gt; of two (potentially) different lengths.&lt;/p&gt;
&lt;p&gt;We can do this using &lt;code&gt;sameNat&lt;/code&gt; from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeNats.html&quot;&gt;GHC.TypeNats&lt;/a&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- `Type` is just a synonym for * from Data.Kind&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- from the module Data.Type.Equality&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; (:~:) ::&lt;/span&gt; k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; k &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; x

sameNat
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; m
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; m)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only way we can have a non-bottom value of type &lt;code&gt;n :~: m&lt;/code&gt; is with the &lt;code&gt;Refl&lt;/code&gt; constructor, which can only be used in the case that &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are equal. &lt;code&gt;sameNat&lt;/code&gt; gives us that &lt;code&gt;Refl&lt;/code&gt;, if possible — that is, if &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are equal. If not, it gives us &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, we can write:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L78-81&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;exactLength ::&lt;/span&gt; forall n m a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLength v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sameNat (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;n) (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;m) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v     &lt;span class=&quot;co&quot;&gt;-- here, n ~ m, so a `Vec n a` is a `Vec m a`, too&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We could also write this by using &lt;code&gt;getVector&lt;/code&gt; and &lt;code&gt;mkVec&lt;/code&gt;, which wraps and unwraps, but let’s pretend it is expensive to construct and re-construct).&lt;/p&gt;
&lt;p&gt;Now we can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L37-37&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;zipVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n (a, b)

&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrapped.hs#L83-89&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;zipSame ::&lt;/span&gt; forall a b&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; (a, b))
zipSame v1 v2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withVec v1 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;v1&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                withVec v2 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;v2&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; exactLength v1&amp;#39; &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v1Same &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; getVector
                          (zipVec v1Same v2&amp;#39;)     &lt;span class=&quot;co&quot;&gt;-- v1&amp;#39; has the same length as v2&amp;#39;&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which will zip two unsized vectors, but only if their lengths are the same.&lt;/p&gt;
&lt;p&gt;Now, “checking that the length is a certain length” is literally the least interesting property we can test about our vectors. There are definitely more interesting properties we can test, like whether or not our lengths are even or odd, if they are greater than a certain number, etc.; for these, the process is essentially the same: find some way, &lt;em&gt;at runtime&lt;/em&gt;, to get some sort of witness for the property you want. In our case, our witness was &lt;code&gt;n :~: m&lt;/code&gt;, which witnessed the fact that &lt;code&gt;n ~ m&lt;/code&gt;. Different libraries might provide different witnesses that might be useful. But the general process is&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Find a way to get your witness, using some runtime function (that will probably return &lt;code&gt;Maybe&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Pattern match on your witness, and see that property realized and usable by GHC/the type checker!&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;help-from-singletons&quot;&gt;Help from singletons&lt;/h3&gt;
&lt;p&gt;You have probably heard that &lt;code&gt;TypeNats&lt;/code&gt; provides a very bare-bones and primitive interface. This is true. Its interface also sometimes doesn’t play well with other type-level mechanisms you might want to try. To prepare you for the real world, let’s re-implement these things using the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library, which provides a unified interface for type-level programming in general.&lt;/p&gt;
&lt;p&gt;Instead of &lt;code&gt;KnownNat&lt;/code&gt;, &lt;code&gt;Proxy&lt;/code&gt;, &lt;code&gt;natVal&lt;/code&gt;, &lt;code&gt;SomeNat&lt;/code&gt;, and &lt;code&gt;someNatVal&lt;/code&gt;, we can use the singletons equivalents, &lt;code&gt;Sing&lt;/code&gt;, &lt;code&gt;fromSing&lt;/code&gt;, &lt;code&gt;SomeSing&lt;/code&gt;, and &lt;code&gt;toSing&lt;/code&gt;:&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- TypeNats style&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;natVal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; p n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- Singletons style&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;sing     ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n
&lt;span class=&quot;ot&quot;&gt;fromSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- (for n :: Nat)&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- TypeNats style&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n)
&lt;span class=&quot;ot&quot;&gt;someNatVal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNat&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- Singletons style&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n)
&lt;span class=&quot;ot&quot;&gt;toSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;withSomeSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Natural&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r

&lt;span class=&quot;co&quot;&gt;-- TypeNats style&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;sameNat ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; m)

&lt;span class=&quot;co&quot;&gt;-- Singletons style&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- from Data.Singletons.Decide&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- for our purposes, Decision is basically a fancy Maybe&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Decision&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Void&lt;/span&gt;)
&lt;span class=&quot;ot&quot;&gt;(%~) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Decision&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; m)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hopefully the above should give you a nice “key” for translating between the two styles. But here are some practical translations:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- &amp;quot;explicit Sing&amp;quot; style&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L20-24&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mkVec_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
mkVec_ s v &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; V.length v &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; v)
           &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (fromSing s)

&lt;span class=&quot;co&quot;&gt;-- &amp;quot;implicit&amp;quot; style&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L26-30&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mkVec ::&lt;/span&gt; forall n a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
mkVec v &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; V.length v &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; v)
        &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (fromSing (&lt;span class=&quot;ot&quot;&gt;sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n))

&lt;span class=&quot;co&quot;&gt;-- alternatively, re-using `mkVec_`&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mkVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
mkVec &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkVec_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, in singletons, we have the luxury of defining our functions in “explicit” style (where the user passes in a &lt;code&gt;Sing&lt;/code&gt; token which reveals what length they want) or “implicit” style (where the length is inferred from the return type, requiring a &lt;code&gt;KnownNat n =&amp;gt;&lt;/code&gt; constraint), like we have been writing up to this point. &lt;code&gt;Sing n -&amp;gt;&lt;/code&gt; and &lt;code&gt;KnownNat n =&amp;gt;&lt;/code&gt; really have the same power. You can think of &lt;code&gt;Sing n&lt;/code&gt; as a token that carries around &lt;code&gt;KnownNat n =&amp;gt;&lt;/code&gt;, in a way.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L32-42&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;replicate_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
replicate_ s x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.replicate l x
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (fromSing s)

replicate&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
replicate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; replicate_ sing

&lt;span class=&quot;ot&quot;&gt;withVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withVec v f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing (fromIntegral (V.length v)) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f s (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; v)

&lt;span class=&quot;co&quot;&gt;-- alternatively, skipping `SomeSing` altogether:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L44-54&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withVec&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withVec&amp;#39; v0 f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing (fromIntegral (V.length v0)) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \s &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
    f s (&lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; v0)

&lt;span class=&quot;ot&quot;&gt;exactLength_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLength_ sM sN v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sM &lt;span class=&quot;fu&quot;&gt;%~&lt;/span&gt; sN &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v
    &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; _  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;exactLength ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLength &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exactLength_ sing sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that you &lt;em&gt;aren’t&lt;/em&gt; required to implement both a &lt;code&gt;replicate_&lt;/code&gt; and &lt;code&gt;replicate&lt;/code&gt; — I’m just including them here to show that both API’s (implicit and explicit) are possible. (You can always just directly use &lt;code&gt;sing&lt;/code&gt; right away before getting started to get the &lt;code&gt;Sing n&lt;/code&gt; that those functions use, and so skip &lt;code&gt;replicate_&lt;/code&gt; and other explicit variants)&lt;/p&gt;
&lt;p&gt;One slight bit of friction comes when using libraries that work with &lt;code&gt;KnownNat&lt;/code&gt;, like &lt;em&gt;finite-typelits&lt;/em&gt; and the &lt;code&gt;Finite&lt;/code&gt; type. But we can convert between the two using &lt;code&gt;SNat&lt;/code&gt; or &lt;code&gt;withKnownNat&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- SNat can be used to construct a `Sing` if we have a `KnownNat` constraint&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- It can also be pattern matched on to reveal a `KnownNat constraint`&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n

&lt;span class=&quot;co&quot;&gt;-- we can give a `Sing n` and be able to execute something in the context where&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- that `n` has a `KnownNat` constraint&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withKnownNat ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L56-60&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;generate_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
generate_ s f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withKnownNat s &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.generate l (f &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromIntegral)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (fromSing s)

&lt;span class=&quot;co&quot;&gt;-- alternatively, via pattern matching:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L63-66&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;generate&amp;#39;_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
generate&amp;#39;_ s&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnsafeMkVec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; V.generate l (f &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromIntegral)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromIntegral (fromSing s)

&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs#L68-69&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;generate ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Finite&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
generate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; generate_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can see most of our original code (with pure &lt;code&gt;KnownNat&lt;/code&gt;) rewritten to work with singletons in &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecWrappedSingletons.hs&quot;&gt;this file&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;why-singletons&quot;&gt;Why Singletons?&lt;/h4&gt;
&lt;p&gt;As you can see, singletons-style programming completely subsumes programming with &lt;code&gt;TypeNats&lt;/code&gt; and &lt;code&gt;KnownNat&lt;/code&gt;. What we don’t see here is that singletons style integrates very well with the rest of the singletons ecosystem…so you might just have to take my word for it :)&lt;/p&gt;
&lt;p&gt;What we have just witnessed is the bridge between the singletons ecosystem and the rest of the Haskell ecosystem’s usage of &lt;code&gt;GHC.TypeNats&lt;/code&gt;. &lt;code&gt;KnownNat&lt;/code&gt;, because it is provided by GHC itself, is universal. However, I recommend any new projects or libraries you write that do &lt;em&gt;anything&lt;/em&gt; more than the most trivial of usages of &lt;code&gt;KnownNat&lt;/code&gt; should take a look at doing things singletons-style.&lt;/p&gt;
&lt;p&gt;Working with just &lt;code&gt;GHC.TypeNats&lt;/code&gt; and &lt;code&gt;KnownNat&lt;/code&gt;, you run into limitations very quickly unless you stick to very basic things. And, if you ever work with any other type-level stuff, &lt;em&gt;singletons&lt;/em&gt; integrates very well and very smoothly with everything else type-level you do. If you plan on doing other type-level things besides just the most basic, you will not regret starting singletons-style from the beginning.&lt;/p&gt;
&lt;h3 id=&quot;real-world-examples&quot;&gt;Real-World Examples&lt;/h3&gt;
&lt;p&gt;This exact pattern is used in many real-world libraries. The canonical fixed-length vector library implemented in this style is &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector-sized&quot;&gt;vector-sized&lt;/a&gt;&lt;/em&gt;, which more or less re-exports the entire &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/vector&quot;&gt;vector&lt;/a&gt;&lt;/em&gt; library, but with a statically-sized interface. This is the library I use for all my my modern sized-vector needs.&lt;/p&gt;
&lt;p&gt;It’s also used to great benefit by the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library, which I take advantage of in my &lt;a href=&quot;https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html&quot;&gt;dependently typed neural networks&lt;/a&gt; tutorial series.&lt;/p&gt;
&lt;p&gt;It’s also provided in the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.20.7/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; library, which was one of the first major libraries to adopt this style. However, it offers an incomplete API, and requires lens — its main purpose is for integration with the rest of the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/linear-1.20.7/docs/Linear-V.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; library, which it does very well.&lt;/p&gt;
&lt;p&gt;Anyway, if all you really wanted was performant fixed-size containers, feel free to stop reading now (or jump to the conclusion). But if you want to explore a bit deeper into the world of inductive dependent types … continue on :)&lt;/p&gt;
&lt;h2 id=&quot;the-structural-way&quot;&gt;The Structural Way&lt;/h2&gt;
&lt;p&gt;So, the (a?) problem with &lt;code&gt;TypeNats&lt;/code&gt; from GHC is that it has no internal structure. It’s basically the same as the &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;Natural&lt;/code&gt; type — every single value (constructor) is completely structurally unrelated to the next.&lt;/p&gt;
&lt;p&gt;Just like we can imagine&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can also think of &lt;code&gt;Nat&lt;/code&gt; as just &lt;code&gt;0 | 1 | 2 | 3 | 4 ...&lt;/code&gt;. Each constructor is completely distinct.&lt;/p&gt;
&lt;p&gt;This is useful for most practical applications. However, when we want to use our fixed-length types in a more subtle and nuanced way, it might help to work with a length type that is more…structurally aware.&lt;/p&gt;
&lt;p&gt;We’ve also noticed that the structure of our &lt;code&gt;Vec&lt;/code&gt; and the structure of our &lt;code&gt;Nat&lt;/code&gt; have nothing in common, so we can’t take advantage of any shared structure to help us with type-safety in our implementation…everything we wrote was pretty much implemented using “unsafe” functions.&lt;/p&gt;
&lt;p&gt;So, enough of this non-structural blasphemy. We are proper dependent type programmers, dangit! We want structural verification! Compiler verification from the very bottom!&lt;/p&gt;
&lt;p&gt;For this, we’ll dig into &lt;em&gt;inductive&lt;/em&gt; type-level nats.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re using the &lt;code&gt;DataKinds&lt;/code&gt; extension, so not only does that define the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt; with the &lt;em&gt;values&lt;/em&gt; &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;S :: Nat -&amp;gt; Nat&lt;/code&gt;, it also defines the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Nat&lt;/code&gt; with the &lt;em&gt;types&lt;/em&gt; &lt;code&gt;&#39;Z&lt;/code&gt; and &lt;code&gt;&#39;S :: Nat -&amp;gt; Nat&lt;/code&gt;! (note the backticks)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;ch&quot;&gt;&amp;#39;S &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;&#39;Z&lt;/code&gt; represents 0, and &lt;code&gt;&#39;S&lt;/code&gt; represents the “successor” function: one plus whatever number it contains. &lt;code&gt;&#39;S &#39;Z&lt;/code&gt; represents 1, &lt;code&gt;&#39;S (&#39;S &#39;Z)&lt;/code&gt; represents 2, etc.&lt;/p&gt;
&lt;p&gt;And now we can define a fixed-length &lt;em&gt;list&lt;/em&gt;, which is basically a normal haskell list “zipped” with &lt;code&gt;S&lt;/code&gt;s.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L26-30&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z a&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:+) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S n) a&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we’re using &lt;code&gt;GADT&lt;/code&gt; syntax to define our type using its constructors: the &lt;code&gt;VNil&lt;/code&gt; constructor (which creates a &lt;code&gt;Vec &#39;Z a&lt;/code&gt;, or the empty vector, like &lt;code&gt;[]&lt;/code&gt;) and the &lt;code&gt;(:+)&lt;/code&gt; constructor (like cons, or &lt;code&gt;(:)&lt;/code&gt;), which conses an item to a &lt;code&gt;Vec n a&lt;/code&gt; to get a &lt;code&gt;Vec (&#39;S n) a&lt;/code&gt;, or a vector with one more element.&lt;/p&gt;
&lt;p&gt;Basically, all usage of nil and cons (&lt;code&gt;VNil&lt;/code&gt; and &lt;code&gt;:+&lt;/code&gt;) keeps track of the current “length” of the vectors in its type. Observe that the only way to construct a &lt;code&gt;Vec (&#39;S (&#39;S &#39;Z)) a&lt;/code&gt; is by using two &lt;code&gt;:+&lt;/code&gt;s and a &lt;code&gt;VNil&lt;/code&gt;!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z a&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S (&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z)) Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;type-level-guarantees-are-structurally-free&quot;&gt;Type-level Guarantees are Structurally Free&lt;/h3&gt;
&lt;p&gt;One nice thing about this is that there is no “unsafe” way to construct a &lt;code&gt;Vec&lt;/code&gt;. Any &lt;code&gt;Vec&lt;/code&gt; is &lt;em&gt;inherently of the correct size&lt;/em&gt;. The very act of constructing it enforces its length.&lt;/p&gt;
&lt;p&gt;Remember our “unsafe” &lt;code&gt;mapVec&lt;/code&gt;? We had to implement it unsafely, and trust that our implementation is correct. Even worse — our &lt;em&gt;users&lt;/em&gt; have to trust that our implementation is correct!&lt;/p&gt;
&lt;p&gt;But writing such a &lt;code&gt;mapVec&lt;/code&gt; function using &lt;code&gt;Vec&lt;/code&gt; is guaranteed to preserve the lengths:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L32-35&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;mapVec ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n b
mapVec f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
    x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; mapVec f xs

&lt;span class=&quot;co&quot;&gt;-- compare to&lt;/span&gt;
map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [b]
map f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    [] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; []
    x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; map f xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our implementation is guaranteed to have the correct length. Neat! We get all of the documentation benefits described in our previous discussion of &lt;code&gt;mapVec&lt;/code&gt;, plus more.&lt;/p&gt;
&lt;p&gt;We can write &lt;code&gt;zip&lt;/code&gt; too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L37-42&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;zipVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n (a, b)
zipVec &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
    x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      y &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x,y) &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; zipVec xs ys&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Isn’t it neat how the code reads exactly like the code for map/zip for &lt;em&gt;lists&lt;/em&gt;? Because their structure is identical, their only real difference is the type-level tag. All of the functions we write are the same.&lt;/p&gt;
&lt;h4 id=&quot;type-level-arithmentic&quot;&gt;Type-Level Arithmentic&lt;/h4&gt;
&lt;p&gt;GHC provided our &lt;code&gt;+&lt;/code&gt; before, so we have to write it ourselves if we want to be able to use it for our &lt;code&gt;Nat&lt;/code&gt;s. We can write it as a type family:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L54-61&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; family (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;m ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;)&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z   + m = m&lt;/span&gt;
    &lt;span class=&quot;ch&quot;&gt;&amp;#39;S n + m = &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m)

&lt;span class=&quot;ot&quot;&gt;(++) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; (n &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; m) a
(&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ys
    x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; (xs &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; ys)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This works! However, we have to be careful that GHC can verify that the final vector &lt;em&gt;really does&lt;/em&gt; have the length &lt;code&gt;n + m&lt;/code&gt;. GHC can do this automatically only in very simple situations. In our situation, it is possible because &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;++&lt;/code&gt; have the &lt;em&gt;exact same structure&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Take a moment to stare at the definition of &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;++&lt;/code&gt; very closely, and then squint really hard. You can see that &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;++&lt;/code&gt; really describe the “same function”, using the exact same structure. First, if the first item is a Z-y thing, return the second item as-is. If the first item is a consy thing, return the second item consed with the rest of the first item. Roughly speaking, of course.&lt;/p&gt;
&lt;p&gt;This is a part of what we mean when we say that we can take advantage of the &lt;em&gt;structure&lt;/em&gt; of the length type. Here, the structure of &lt;code&gt;Nat&lt;/code&gt; aligns so well with the structure of &lt;code&gt;Vec&lt;/code&gt; what we can prove structural properties about &lt;code&gt;Nat&lt;/code&gt; and the &lt;code&gt;Vec&lt;/code&gt; together by exploiting their shared inductive structure.&lt;/p&gt;
&lt;p&gt;Unfortunately, for examples where the function we write doesn’t exactly match the structure as the type family we write, this won’t work. And sometimes, the structural properties might get in the way of what we are trying to prove/produce. An example here would be a &lt;code&gt;snoc&lt;/code&gt; function (cons to the end of a list). If you try writing it, you’ll see that the structure of &lt;code&gt;Nat&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt; fight back against you pretty hard. So, exploiting structure isn’t universally useful, but it definitely helps in many situations! Handling tricky cases like this is a subject for a whole other blog post.&lt;/p&gt;
&lt;h3 id=&quot;indexing-1&quot;&gt;Indexing&lt;/h3&gt;
&lt;p&gt;To index our previous type, we used some abstract &lt;code&gt;Finite&lt;/code&gt; type, where &lt;code&gt;Finite n&lt;/code&gt; conveniently represented the type of all possible indices to a &lt;code&gt;Vec n a&lt;/code&gt;. We can do something similar, inductively, as well:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L63-67&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S n)&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S n)&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; n)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I always thought of this inductive definition of &lt;code&gt;Fin&lt;/code&gt; as a cute trick, because I don’t think there was any way I could have thought of it on my own. But if you play around it enough, you might be able to convince yourself that there are exactly &lt;code&gt;n&lt;/code&gt; inhabitants of &lt;code&gt;Fin n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, for &lt;code&gt;Fin (&#39;S &#39;Z)&lt;/code&gt; (indices for a one-item vector), there should be only one inhabitant. And there is! It’s &lt;code&gt;FZ&lt;/code&gt;. &lt;code&gt;FS FZ&lt;/code&gt; is not a valid inhabitant, because it has type &lt;code&gt;Fin (&#39;S (&#39;S m))&lt;/code&gt; for some &lt;code&gt;m&lt;/code&gt;, so cannot possibly have the type &lt;code&gt;Fin (&#39;S &#39;Z)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s see the inhabitants of &lt;code&gt;Fin (&#39;S (&#39;S (&#39;S &#39;Z)))&lt;/code&gt; (indices for three-item vectors):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;              ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S (&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))
&lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;           ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S (&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))
&lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;)&lt;span class=&quot;ot&quot;&gt;      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S (&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))
&lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;)
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt;))&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S (&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))
&lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;TYPE&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As GHC informs us, &lt;code&gt;FS (FS (FS FZ))&lt;/code&gt; is not an inhabitant of &lt;code&gt;Fin (&#39;S (&#39;S (&#39;S &#39;Z)))&lt;/code&gt;, which is exactly the behavior we wanted. This is because &lt;code&gt;FS (FS (FS FZ))&lt;/code&gt; has type &lt;code&gt;Fin (&#39;S (&#39;S (&#39;S (&#39;S m))))&lt;/code&gt; for some &lt;code&gt;m&lt;/code&gt;, and this can’t fit &lt;code&gt;Fin (&#39;S (&#39;S (&#39;S &#39;Z)))&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also, note that there are no inhabitants of &lt;code&gt;Fin &#39;Z&lt;/code&gt;. There is no constructor or combination of constructors that can yield a value of that type.&lt;/p&gt;
&lt;p&gt;Armed with this handy &lt;code&gt;Fin&lt;/code&gt; type, we can do structural type-safe indexing:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L69-74&lt;/span&gt;
index&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
index &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;FZ&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x
    &lt;span class=&quot;dt&quot;&gt;FS&lt;/span&gt; i &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      _ &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; index i xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that our &lt;code&gt;Fin&lt;/code&gt; type structurally precludes us from being able to index into a &lt;code&gt;Vec &#39;Z a&lt;/code&gt; (an empty vector), because to do that, we would have to pass in a &lt;code&gt;Fin &#39;Z&lt;/code&gt;…but there is no such value with that type!&lt;/p&gt;
&lt;h3 id=&quot;generating-1&quot;&gt;Generating&lt;/h3&gt;
&lt;p&gt;Now, generating these requires some more thought. Naively writing a &lt;code&gt;replicate :: a -&amp;gt; Vec n a&lt;/code&gt; is not possible; ideally, we’d want to “pattern match” on our length &lt;code&gt;n&lt;/code&gt;, and use &lt;code&gt;VNil&lt;/code&gt; if it’s &lt;code&gt;&#39;Z&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;However, we can’t pattern match on types in Haskell, because types are &lt;em&gt;erased&lt;/em&gt; at runtime. They’re just used by the compiler to verify your code, but they don’t exist at runtime. So, you can’t just say “do this if &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&#39;Z&lt;/code&gt;, otherwise do this”.&lt;/p&gt;
&lt;p&gt;Recall that, in our previous vector type, we needed to use a &lt;code&gt;KnownNat n&lt;/code&gt; constraint to be able to &lt;em&gt;reflect&lt;/em&gt; a &lt;code&gt;n&lt;/code&gt; type down to the value level. We can do something similar using the &lt;em&gt;singletons&lt;/em&gt; machinery!&lt;/p&gt;
&lt;p&gt;First, we need to get singletons for our &lt;code&gt;Nat&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L21-24&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  data Nat = Z | S Nat
    deriving Eq
  |])

&lt;span class=&quot;co&quot;&gt;-- this creates:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S n)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Sing n&lt;/code&gt; is a singleton for our &lt;code&gt;Nat&lt;/code&gt;, in that there is only one &lt;code&gt;Sing n&lt;/code&gt; for every &lt;code&gt;n&lt;/code&gt;. So, if we receive a value of type &lt;code&gt;Sing n&lt;/code&gt;, we can pattern match on it to figure out what &lt;code&gt;n&lt;/code&gt; is. Essentially, we can &lt;em&gt;pattern match&lt;/em&gt; on &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L76-83&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;singSize ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
singSize &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- here, n is &amp;#39;Z&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Size of zero!&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- here, n is (&amp;#39;S &amp;#39;Z)&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Size of one!&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- here, n is (&amp;#39;S (&amp;#39;S n))&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Wow, so big!&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now branch depending on what &lt;code&gt;n&lt;/code&gt; is!&lt;/p&gt;
&lt;p&gt;Basically, &lt;em&gt;we can use a singleton&lt;/em&gt; if we ever want to “pattern match” or branch our program’s output based on the type. This is a general rule you will observe as we continue on this article.&lt;/p&gt;
&lt;p&gt;Note that because of the inductive nature of our original &lt;code&gt;Nat&lt;/code&gt; type, the singletons are also inductive, as well. This is handy, because then our whole ecosystem remains inductive.&lt;/p&gt;
&lt;p&gt;Now, to write &lt;code&gt;replicate&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L90-93&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;replicate_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
replicate_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; replicate_ l x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we can recover our original “implicit” style, with type-inference-driven lengths, using &lt;code&gt;SingI&lt;/code&gt; and &lt;code&gt;sing :: SingI n =&amp;gt; Sing n&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L95-96&lt;/span&gt;
replicate&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
replicate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; replicate_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can think of &lt;code&gt;SingI&lt;/code&gt; as the “generic singletons” equivalent of &lt;code&gt;KnownNat&lt;/code&gt;. &lt;code&gt;KnownNat&lt;/code&gt; lets us reflect out a &lt;code&gt;GHC.TypeNats.Nat&lt;/code&gt; to a &lt;code&gt;Sing&lt;/code&gt;…&lt;code&gt;SingI&lt;/code&gt; lets us reflect any type that has singletons defined to its corresponding &lt;code&gt;Sing&lt;/code&gt;. Since our new &lt;code&gt;Nat&lt;/code&gt; type has singletons, we basically get a free “&lt;code&gt;KnownNat&lt;/code&gt; equivalent”!&lt;/p&gt;
&lt;p&gt;See how useful the whole singletons ecosystem is? :)&lt;/p&gt;
&lt;h4 id=&quot;generating-with-indices-1&quot;&gt;Generating with indices&lt;/h4&gt;
&lt;p&gt;Writing &lt;code&gt;generate&lt;/code&gt; using the inductive &lt;code&gt;Fin&lt;/code&gt; and &lt;code&gt;Nat&lt;/code&gt; is an interesting challenge. It’s actually a fairly standard pattern that comes up when working with inductive types like these. I’m going to leave it as an exercise to the reader – click the link at the top corner of the text box to see the solution, and see how it compares to your own :)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L98-104&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;generate_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a

&lt;span class=&quot;ot&quot;&gt;generate ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Fin&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
generate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; generate_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The one thing I will point out is that it is very useful that GHC verifies our code for us, and that we have typed holes to help us develop our code. If we ever don’t know something, we can just use a typed hole &lt;code&gt;_&lt;/code&gt;, and GHC will tell us what type it expects, and what values in scope have that type. It is infinitely useful for situations like this, especially when you are new to this sort of dependently typed inductive programming!&lt;/p&gt;
&lt;p&gt;If you ever get stuck, try throwing in a &lt;code&gt;_&lt;/code&gt; and seeing what types GHC expects…these clues will help you get your bearings!&lt;/p&gt;
&lt;h3 id=&quot;between-sized-and-unsized&quot;&gt;Between Sized and Unsized&lt;/h3&gt;
&lt;p&gt;Converting from sized to unsized vectors (to lists) is something that is pretty straightforward, and can be done by just pattern matching on the vector and recursing on the tail. I’ve &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L85-88&quot;&gt;left it as an excercise&lt;/a&gt; to write &lt;code&gt;Vec n a -&amp;gt; [a]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;More interesting is the other way around; our the API of converting unsized to sized vectors will be the same:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L106-106&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withVec ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But implementing it inductively is also an interesting challenge. See my tip above about typed holes (&lt;code&gt;_&lt;/code&gt;). I recommend taking a break here to try to solve it yourself.&lt;/p&gt;
&lt;p&gt;Ready?&lt;/p&gt;
&lt;p&gt;Welcome back! Hope you had a fun time :) Here’s the solution!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L106-110&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withVec ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall n&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r
withVec &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    []   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \f &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
    x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \f &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; withVec xs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \l ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        f (&lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; l) (x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; ys)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To handle the empty list, we just return immediately, giving &lt;code&gt;f&lt;/code&gt; the proper singleton and vector (&lt;code&gt;SZ&lt;/code&gt; and &lt;code&gt;VNil&lt;/code&gt;). For the non-empty list, first we convert the tail &lt;code&gt;xs&lt;/code&gt; into a vector (&lt;code&gt;ys&lt;/code&gt;) and its corresponding length-singleton (&lt;code&gt;l&lt;/code&gt;), and then we give &lt;code&gt;f&lt;/code&gt; the “correct” length singleton of our complete vector (&lt;code&gt;SS l&lt;/code&gt;) and the correct complete vector (&lt;code&gt;x :+ ys&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;One nice property where (in contrast with our previous non-structural &lt;code&gt;withVec&lt;/code&gt;) is that GHC ensures that the length of the vector we give to &lt;code&gt;f&lt;/code&gt; is actually what we claim it is.&lt;/p&gt;
&lt;h3 id=&quot;verifying-properties-1&quot;&gt;Verifying properties&lt;/h3&gt;
&lt;p&gt;We can create some corresponding example of &lt;code&gt;exactLength&lt;/code&gt; using the exact same process we did before&lt;/p&gt;
&lt;p&gt;First, it’d be nice to get a witness for the length of a given vector just from the vector itself:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L112-115&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;vecLength ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n
vecLength &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;
    _ &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; (vecLength xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type of &lt;code&gt;vecLength :: Vec n a -&amp;gt; Sing n&lt;/code&gt; says that it is possible, from the structure of the vector given alone, to get a witness to its length. And, because the structure of the vector and the structure of the length type are so similar, this is possible! (Note that this is not possible for our non-structural “wrapped” &lt;code&gt;Vec&lt;/code&gt;, without some unsafe operations)&lt;/p&gt;
&lt;p&gt;Now, our code will be identical to the code for our wrapped/non-structural vectors, using &lt;code&gt;%~&lt;/code&gt; and &lt;code&gt;Decision&lt;/code&gt; and &lt;code&gt;Refl&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L117-123&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;exactLength_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLength_ sM v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sM &lt;span class=&quot;fu&quot;&gt;%~&lt;/span&gt; vecLength v &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; v
    &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;exactLength ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLength &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exactLength_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s nice that this is exactly the same as before, and that’s a testament to how useful the singletons library is at unifying all of these distinct type-level stuffs.&lt;/p&gt;
&lt;p&gt;We could also write &lt;code&gt;exactLength&lt;/code&gt; in a cute way by inducting on the length we want and the vector, so it might be fun to look at this version instead –&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L125-135&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;exactLengthInductive_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLengthInductive_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
      _ &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
      x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; exactLengthInductive_ l xs

&lt;span class=&quot;ot&quot;&gt;exactLengthInductive ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
exactLengthInductive &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exactLengthInductive_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is another way you can take advantage of the &lt;em&gt;structure&lt;/em&gt; of the length type. Here, we explicitly take advantage of the inductive structure of the &lt;code&gt;Nat&lt;/code&gt; type and how it matches with the structure of the &lt;code&gt;Vec&lt;/code&gt; type, and do bold things with it!&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But I digress. Like in the last section, checking for a given length is literally the least interesting property you can check for. But, again, the same process is usable here: find a way to get your witness, and then pattern match on that witness.&lt;/p&gt;
&lt;p&gt;For example, we can make a witness that &lt;code&gt;n&lt;/code&gt; is less than or equal to &lt;code&gt;m&lt;/code&gt;, as well as a way to construct such a witness:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L137-149&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;LEZ&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;Z n&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;LES&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; n m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;S n) (&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; m)

&lt;span class=&quot;ot&quot;&gt;isLTE ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Decision&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; n m)
isLTE &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LEZ&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- EmptyCase&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; isLTE n m &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; l    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LES&lt;/span&gt; l
        &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; p &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;LES&lt;/span&gt; l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; p l&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, it is impossible to construct an &lt;code&gt;LTE n m&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; less than or equal to &lt;code&gt;m&lt;/code&gt;. I dare you to try!&lt;/p&gt;
&lt;p&gt;We can write code to check for this property in our vectors:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L151-157&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;atLeast_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; n m, &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
atLeast_ sN v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; isLTE sN (vecLength v) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Proved&lt;/span&gt; l    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (l, v)
    &lt;span class=&quot;dt&quot;&gt;Disproved&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;atLeast ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; n m, &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a)
atLeast &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; atLeast_ sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;atLeast_ sN&lt;/code&gt; will only return our vector if its length is &lt;em&gt;at least&lt;/em&gt; the length of the length indicated by &lt;code&gt;sN&lt;/code&gt;. Basically, we check if our vector is “at least” a certain length.&lt;/p&gt;
&lt;p&gt;We can write a function that can “take” an arbitrary amount from a vector, given (via proof) that the vector has at least that many elements:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L159-163&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;takeVec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LTE&lt;/span&gt; n m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a
takeVec &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;LEZ&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;VNil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;LES&lt;/span&gt; l &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:+&lt;/span&gt; takeVec l xs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, we can combine that with our &lt;code&gt;atLeast&lt;/code&gt; function, to be able to take (maybe)&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; from any vector:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/fixvec-2/VecInductive.hs#L165-169&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;takeVecMaybe_ ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
takeVecMaybe_ sN v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uncurry takeVec &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; atLeast_ sN v

&lt;span class=&quot;ot&quot;&gt;takeVecMaybe ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; m a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Vec&lt;/span&gt; n a)
takeVecMaybe v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uncurry takeVec &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; atLeast v&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;in-the-real-world&quot;&gt;In the Real World&lt;/h3&gt;
&lt;p&gt;This type is more like a list than a vector, so it’s in a bit of an awkward position, utility-wise. You usually chose a list over a vector in Haskell when you want some sort of lazy streaming, but the cases where you want to lazily stream something &lt;em&gt;and&lt;/em&gt; you know exactly how many items you want to stream are admittedly a bit rare. GHC can’t handle infinite &lt;code&gt;Vec&lt;/code&gt;s, so there’s that, too. For “containers”, &lt;em&gt;vector&lt;/em&gt; is great, so the non-structural &lt;code&gt;Vec&lt;/code&gt; is seen a lot more.&lt;/p&gt;
&lt;p&gt;However, if you are working with a lot of other inductive types, &lt;code&gt;Vec&lt;/code&gt; works very naturally alongside them. It makes sense, then, that a “canonical” package offering &lt;code&gt;Vec&lt;/code&gt; is &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/type-combinators&quot;&gt;type-combinators&lt;/a&gt;&lt;/em&gt;, an actively maintained library with loads of useful inductive types for type-level programming, exporting its own &lt;code&gt;Nat&lt;/code&gt; and &lt;code&gt;Sing&lt;/code&gt;-equivalents. If I am doing the sort of type-level programming that &lt;code&gt;Vec&lt;/code&gt; is useful for, chances are I already have &lt;em&gt;type-combinators&lt;/em&gt; imported. This is the library that I personally suggest if you want to use this &lt;code&gt;Vec&lt;/code&gt; in the real world.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;There’s obviously more to look at, and much more we can do with fixed-length vectors and inductive types. And, there will definitely be more issues that come up when you start working with these in the real world, with real applications.&lt;/p&gt;
&lt;p&gt;If you plan on moving into learning about dependent types, I hope that guide would be a good launching point. But if all you wanted to do was learn how to use fixed-length vectors effectively in Haskell…hopefully after reading this, you have confidence to work with these things directly, and to know what to google if anything else comes up :)&lt;/p&gt;
&lt;p&gt;Feel free as always to leave a comment or a &lt;a href=&quot;https://twitter.com/mstk&quot;&gt;tweet&lt;/a&gt;, or find me the freenode &lt;code&gt;#haskell&lt;/code&gt; channel, as &lt;em&gt;jle`&lt;/em&gt;. I always welcome feedback, suggestions, or questions!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Users who are used to GHC 8.0 and below might remember &lt;code&gt;Nat&lt;/code&gt; coming from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html&quot;&gt;GHC.TypeLits&lt;/a&gt;&lt;/em&gt;. Well, GHC 8.2 is here, &lt;code&gt;TypeLits&lt;/code&gt; is out, &lt;code&gt;TypeNats&lt;/code&gt; is in. The difference is that, in &lt;code&gt;TypeLits&lt;/code&gt;, the &lt;code&gt;Nat&lt;/code&gt; kind reifies/reflects with &lt;code&gt;Integer&lt;/code&gt;. In &lt;code&gt;TypeNats&lt;/code&gt;, the &lt;code&gt;Nat&lt;/code&gt; kind reifies/reflects with &lt;code&gt;Natural&lt;/code&gt; from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Numeric-Natural.html&quot;&gt;Numeric.Natural&lt;/a&gt;&lt;/em&gt;.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;For singletons &amp;gt; 2.3 &lt;code&gt;fromSing&lt;/code&gt; and &lt;code&gt;toSing&lt;/code&gt; give and take &lt;code&gt;Natural&lt;/code&gt; when going to &lt;code&gt;Nat&lt;/code&gt;. However, for 2.3.1 and below, they give/take &lt;code&gt;Integer&lt;/code&gt; instead.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Note, however, that if you unroll the definition of &lt;code&gt;%~&lt;/code&gt; for &lt;code&gt;Nat&lt;/code&gt;, you pretty much get the exact same thing.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;Remember the whole point of this exercise — that the &lt;code&gt;Maybe&lt;/code&gt; is required only in the completely polymorphic case, where we get our lengths at runtime and don’t know them at compile-time. If we &lt;em&gt;knew&lt;/em&gt; &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; at compile-time, and knew that &lt;code&gt;n&lt;/code&gt; was less than or equal to &lt;code&gt;m&lt;/code&gt;, we could construct an &lt;code&gt;LTE n m&lt;/code&gt; and call &lt;code&gt;takeVec&lt;/code&gt; directly, and not return a &lt;code&gt;Maybe&lt;/code&gt;.&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><category>Reference</category><guid isPermaLink="true">https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html</guid><pubDate>Fri, 25 Aug 2017 20:37:10 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials, Reference</dc:subject><dc:date>2017-08-25</dc:date></item><item><title>Verify your Typeclass Instances in Haskell Today!</title><link>https://blog.jle.im/entry/verified-instances-in-haskell.html</link><description>&lt;p&gt;One of the most common gripes people have when learning Haskell is the fact that typeclass “laws” are only laws by convention, and aren’t enforced by the language and compiler. When asked why, the typical response is “Haskell can’t do that”, followed by a well-intentioned redirection to quickcheck or some other fuzzing library.&lt;/p&gt;
&lt;p&gt;But, to any experienced Haskeller, “Haskell’s type system can’t express X” is always interpreted as a (personal) challenge.&lt;/p&gt;
&lt;p&gt;GHC Haskell’s type system has been advanced enough to provide verified typeclasses for a long time, since the introduction of data kinds and associated types. And with the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library, it’s now as easy as ever.&lt;/p&gt;
&lt;p&gt;(The code for this post is available &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs&quot;&gt;here&lt;/a&gt; if you want to follow along! Some of the examples here involving &lt;code&gt;Demote&lt;/code&gt; and relying on its injectivity will only work with &lt;a href=&quot;https://github.com/goldfirere/singletons&quot;&gt;singletons HEAD&lt;/a&gt;, even though the necessary patches were made seven months ago&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;semigroups&quot;&gt;Semigroups&lt;/h2&gt;
&lt;p&gt;Let’s start simple – everyone’s favorite structural addition to magmas, &lt;a href=&quot;http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html&quot;&gt;semigroups&lt;/a&gt;. A semigroup is a type with an associative binary operation, &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (&amp;lt;&amp;gt;) ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Its one law is associativity:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;(x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (y &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; z)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, this class stinks, because it’s super easy to write bad instances:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; a (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a)
    &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
    &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x (ys &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This instance isn’t associative:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ((&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;))
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But if you try to compile it, GHC doesn’t complain at all. Is this an error on the part of Haskell? Not quite; it’s an error on the part of the &lt;code&gt;Semigroup&lt;/code&gt; typeclass not requiring proofs that the instance is indeed associative.&lt;/p&gt;
&lt;p&gt;Let’s try again.&lt;/p&gt;
&lt;h3 id=&quot;verify-me-captain&quot;&gt;Verify me, Captain&lt;/h3&gt;
&lt;p&gt;We will now define &lt;code&gt;Semigroup&lt;/code&gt; on the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;List&lt;/code&gt;, using &lt;code&gt;-XDataKinds&lt;/code&gt;, instead of the type.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;y ::&lt;/span&gt; a)&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; a

&lt;span class=&quot;ot&quot;&gt;    (%&amp;lt;&amp;gt;) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;y ::&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y)

    appendAssoc
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;y ::&lt;/span&gt; a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;z ::&lt;/span&gt; a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; ((x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; z) &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (y &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; z))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; exists not as a function on &lt;em&gt;values&lt;/em&gt;, but as a function on &lt;em&gt;types&lt;/em&gt;. &lt;code&gt;%&amp;lt;&amp;gt;&lt;/code&gt; is a function that performs &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; at the value level, written to work with singletons representing the input types, so that GHC can verify that it is identical to the type family &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. (it’s 100% boilerplate and should pretty much exactly match the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; type family).&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; Finally, &lt;code&gt;appendAssoc&lt;/code&gt; is a proof that the type family &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is associative, using &lt;code&gt;:~:&lt;/code&gt; (type equality witness) from &lt;code&gt;Data.Type.Equality&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This means that, if a type is an instance of &lt;code&gt;Semigroup&lt;/code&gt;, it not only has to provide &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;/&lt;code&gt;%&amp;lt;&amp;gt;&lt;/code&gt;, but also a &lt;em&gt;proof that they are associative&lt;/em&gt;. You can’t write the full instance without it!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Semigroup&lt;/code&gt; is a “kind-class”, because it is a bunch of methods and types associated with a certain kind. Which &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is dispatched when you do something like &lt;code&gt;x &amp;lt;&amp;gt; y&lt;/code&gt; depends on the &lt;em&gt;kind&lt;/em&gt; of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. GHC does “kind inference” and uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; corresponding to the kinds of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using the &lt;code&gt;SingKind&lt;/code&gt; typeclass from the singletons library, we can move back and forth from &lt;code&gt;Sing x&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, and get our original (value-level) &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; back:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;(&lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;)
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; m
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; m
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; m
x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing x &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sX &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
           withSomeSing y &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sY &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
             fromSing (sX &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; sY)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This works best with singletons HEAD at the moment, because &lt;code&gt;Demote&lt;/code&gt; is injective. On 2.2 or lower, using this would require an explicit type application or annotation at any place you use &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; or &lt;code&gt;%&amp;lt;&amp;gt;&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Now, let’s write the instance for &lt;code&gt;List&lt;/code&gt;. First, we need to define the singletons:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;xs ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x xs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, we can define the instance, using the traditional &lt;code&gt;(++)&lt;/code&gt; appending that lists famously have:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x (xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys)

    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
    &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; x xs &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; x (xs &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; ys)

    appendAssoc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; x xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \ys zs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; appendAssoc xs ys zs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like I promised, &lt;code&gt;%&amp;lt;&amp;gt;&lt;/code&gt; is a boilerplate re-implementation of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, to manipulate value-level witnesses. &lt;code&gt;appendAssoc&lt;/code&gt; is the interesting bit: It’s our proof. It reads like this:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;If the first list is &lt;code&gt;Nil&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- left hand side&lt;/span&gt;
(&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs
  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs        &lt;span class=&quot;co&quot;&gt;-- definition of `(Nil &amp;lt;&amp;gt;)`&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- right hand side&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (ys &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs)
  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs        &lt;span class=&quot;co&quot;&gt;-- definition of `(Nil &amp;lt;&amp;gt;)`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, no work needed. QED! (Or, as we say in Haskell, &lt;code&gt;Refl&lt;/code&gt;!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the first list is &lt;code&gt;Cons x xs&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- left hand side&lt;/span&gt;
(&lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs
  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x (xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys)) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs   &lt;span class=&quot;co&quot;&gt;-- definition of `(Cons x xs &amp;lt;&amp;gt;)`&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x ((xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs)   &lt;span class=&quot;co&quot;&gt;-- definition of `(Cons x xs &amp;lt;&amp;gt;)`&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- right hand side&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (ys &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs)
  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cons&lt;/span&gt; x (xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (ys &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; zs))   &lt;span class=&quot;co&quot;&gt;-- definition of `(Cons x xs &amp;lt;&amp;gt;)`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, the problem reduces to proving that &lt;code&gt;(xs &amp;lt;&amp;gt; ys) &amp;lt;&amp;gt; zs&lt;/code&gt; is equal to &lt;code&gt;xs &amp;lt;&amp;gt; (ys &amp;lt;&amp;gt; zs)&lt;/code&gt;. If we can do that, then we can prove that the whole things are equal. We generate that proof using &lt;code&gt;appendAssoc xs ys zs&lt;/code&gt;, and, wit that proof in scope…QED!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And, we’re done!&lt;/p&gt;
&lt;p&gt;Note that if you had tried any &lt;em&gt;non-associative&lt;/em&gt; implementation of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (and &lt;code&gt;%&amp;lt;&amp;gt;&lt;/code&gt;), GHC would reject it because you wouldn’t have been able to write the proof!&lt;/p&gt;
&lt;h4 id=&quot;automatic-singletons&quot;&gt;Automatic Singletons&lt;/h4&gt;
&lt;p&gt;Deriving &lt;code&gt;Sing&lt;/code&gt; and &lt;code&gt;SingKind&lt;/code&gt; and both versions of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is kind of tedious, so it’s useful to use template haskell to do it all for us:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  data List a = Nil | Cons a (List a)
      deriving (Show)

  infixr 5 `Cons`

  appendList :: List a -&amp;gt; List a -&amp;gt; List a
  appendList Nil         ys = ys
  appendList (Cons x xs) ys = Cons x (appendList xs ys)
  |])

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AppendList&lt;/span&gt; xs ys
    (&lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sAppendList

    appendAssoc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \ys zs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; appendAssoc xs ys zs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The boilerplate of re-defining &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as &lt;code&gt;%&amp;lt;&amp;gt;&lt;/code&gt; goes away!&lt;/p&gt;
&lt;p&gt;And now, we we can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; ((&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;)
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`Cons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ta dah!&lt;/p&gt;
&lt;h3 id=&quot;naturally-maybe&quot;&gt;Naturally, Maybe&lt;/h3&gt;
&lt;p&gt;Now that we have our basic infrastructure, let’s implement some other famous semigroups:&lt;/p&gt;
&lt;p&gt;First, the inductive nats, &lt;code&gt;data N = Z | S N:&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  data N = Z | S N
    deriving (Show)

  plus :: N -&amp;gt; N -&amp;gt; N
  plus Z     y = y
  plus (S x) y = S (plus x y)
  |])

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plus&lt;/span&gt; xs ys
    (&lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sPlus

    appendAssoc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \y z &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; appendAssoc x y z &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And the standard instance for &lt;code&gt;Maybe&lt;/code&gt;, which lifts the underlying semigroup:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  data Option a = None | Some a
      deriving (Show)
  |])

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Option&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;None&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; y
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; x      &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;None&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y)

    &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; y       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; y
    x       &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
    &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;%&amp;lt;&amp;gt;&lt;/span&gt; y)

    appendAssoc &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; y &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; z &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; appendAssoc x y z &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))
&lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;))))
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; print &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;None&lt;/span&gt;       &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))
&lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;)))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;going-monoidal&quot;&gt;Going Monoidal&lt;/h2&gt;
&lt;p&gt;Of course, we can now introduce the &lt;code&gt;Monoid&lt;/code&gt; typeclass, which introduces a new element &lt;code&gt;empty&lt;/code&gt;, along with the laws that appending with empty leaves things unchanged:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; a ::&lt;/span&gt; a

&lt;span class=&quot;ot&quot;&gt;    sEmpty ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt; a)

    emptyIdentLeft
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; x
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; x

    emptyIdentRight
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; x
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; x

empty
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; m)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; m
empty &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fromSing sEmpty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because working implicitly return-type polymorphism at the type level can be annoying sometimes, we have &lt;code&gt;Empty&lt;/code&gt; take the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; as a parameter, instead of having it be inferred through kind inference like we did for &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. That is, &lt;code&gt;Empty (List a)&lt;/code&gt; is &lt;code&gt;Empty&lt;/code&gt; for the &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;List a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As usual in Haskell, the instances write themselves!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nil&lt;/span&gt;

    sEmpty &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;
    emptyIdentLeft _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
    emptyIdentRight  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; emptyIdentRight xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Z&lt;/span&gt;

    sEmpty &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt;
    emptyIdentLeft _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
    emptyIdentRight  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SZ&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SS&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; emptyIdentRight x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Semigroup&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Option&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Empty&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Option&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;None&lt;/span&gt;

    sEmpty &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;
    emptyIdentLeft  _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
    emptyIdentRight _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;play-that-funcy-music&quot;&gt;Play that Funcy Music&lt;/h2&gt;
&lt;p&gt;How about some higher-kinded typeclasses?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; f &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a b (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; b) (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; f a)&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; f b

    sFmap
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;g            ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; b)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x            ::&lt;/span&gt; f a   )
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a b g&lt;span class=&quot;ot&quot;&gt; x ::&lt;/span&gt; f b   )

    &lt;span class=&quot;co&quot;&gt;-- | fmap id x == x&lt;/span&gt;
    fmapId
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; f a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a a &lt;span class=&quot;dt&quot;&gt;IdSym0&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; x

    &lt;span class=&quot;co&quot;&gt;-- | fmap f (fmap g x) = fmap (f . g) x&lt;/span&gt;
    fmapCompose
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; b &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; c)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;h ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; b)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; f a   )
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; b c g (&lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a b h x) &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a c (((&lt;span class=&quot;fu&quot;&gt;:.$&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;@@&lt;/span&gt; g) &lt;span class=&quot;fu&quot;&gt;@@&lt;/span&gt; h) x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Fmap a b g x&lt;/code&gt; maps the &lt;em&gt;type-level function&lt;/em&gt; &lt;code&gt;g :: a ~&amp;gt; b&lt;/code&gt; over &lt;code&gt;x :: f a&lt;/code&gt;, and returns a type of kind &lt;code&gt;f b&lt;/code&gt;. Like with &lt;code&gt;Empty&lt;/code&gt;, to help with kind inference, we have &lt;code&gt;Fmap&lt;/code&gt; explicitly requre the &lt;em&gt;kinds&lt;/em&gt; of the input and results of &lt;code&gt;g&lt;/code&gt; (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) so GHC doesn’t have to struggle to infer it implicitly.&lt;/p&gt;
&lt;p&gt;And, of course, along with &lt;code&gt;sFmap&lt;/code&gt; (the singleton mirror of &lt;code&gt;Fmap&lt;/code&gt;), we have our laws: &lt;code&gt;fmap id x = x&lt;/code&gt;, and &lt;code&gt;fmap g (fmap h) x = fmap (g . h) x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But, what are &lt;code&gt;a ~&amp;gt; b&lt;/code&gt;, &lt;code&gt;IdSym0&lt;/code&gt;, &lt;code&gt;:.$&lt;/code&gt;, and &lt;code&gt;@@&lt;/code&gt;? They’re a part of the &lt;em&gt;defunctionalization&lt;/em&gt; system that the singletons library uses. A &lt;code&gt;g :: a ~&amp;gt; b&lt;/code&gt; means that &lt;code&gt;g&lt;/code&gt; represents a type-level function taking a type of kind &lt;code&gt;a&lt;/code&gt; to a type of kind &lt;code&gt;b&lt;/code&gt;, but, importantly, encodes it in a way that makes Haskell happy. This hack is required because you can’t partially apply type families in Haskell. If &lt;code&gt;g&lt;/code&gt; was a regular old &lt;code&gt;a -&amp;gt; b&lt;/code&gt; type family, you wouldn’t be able to pass just &lt;code&gt;g&lt;/code&gt; into &lt;code&gt;Fmap a b g&lt;/code&gt; (because it’d be partially applied, and type families always have to appear fully saturated).&lt;/p&gt;
&lt;p&gt;You can convert a &lt;code&gt;g :: a ~&amp;gt; b&lt;/code&gt; back into a regular old &lt;code&gt;g :: a -&amp;gt; b&lt;/code&gt; using &lt;code&gt;Apply&lt;/code&gt;, or its convenient infix synonym &lt;code&gt;@@&lt;/code&gt;, like &lt;code&gt;g @@ (x :: a) :: b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The singletons library provides &lt;code&gt;type family Id a where Id a = a&lt;/code&gt;, but we can’t pass in &lt;code&gt;Id&lt;/code&gt; directly into &lt;code&gt;Fmap&lt;/code&gt;. We have to pass in its “defunctionalized” encoding, &lt;code&gt;IdSym0 :: a ~&amp;gt; a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For the composition law, we use &lt;code&gt;(:.$)&lt;/code&gt; (which is a defunctionalized type-level &lt;code&gt;.&lt;/code&gt;) and apply it to &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; to get, essentially, &lt;code&gt;g :. h&lt;/code&gt;, where &lt;code&gt;:.&lt;/code&gt; is type-level function composition.&lt;/p&gt;
&lt;p&gt;Now we Haskell.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  mapOption :: (a -&amp;gt; b) -&amp;gt; Option a -&amp;gt; Option b
  mapOption _ None     = None
  mapOption f (Some x) = Some (f x)

  mapList :: (a -&amp;gt; b) -&amp;gt; List a -&amp;gt; List b
  mapList _ Nil         = Nil
  mapList f (Cons x xs) = Cons (f x) (mapList f xs)
  |])

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Option&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a b g x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MapOption&lt;/span&gt; g x

    sFmap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sMapOption
    fmapId &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

    fmapCompose _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fmap&lt;/span&gt; a b g x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MapList&lt;/span&gt; g x

    sFmap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sMapList
    fmapId &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fmapId xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

    fmapCompose g h &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; fmapCompose g h xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And there you have it. A verified &lt;code&gt;Functor&lt;/code&gt; typeclass, ensuring that all instances are lawful. Never tell me that Haskell’s type system can’t do anything ever again!&lt;/p&gt;
&lt;p&gt;Note that any mistakes in implementation (like, for example, having &lt;code&gt;mapOption _ _ = None&lt;/code&gt;) will cause a compile-time error now, because the proofs are impossible to provide.&lt;/p&gt;
&lt;p&gt;As a side note, I’m not quite sure how to implement the value-level &lt;code&gt;fmap&lt;/code&gt; from this, since I can’t figure out how to promote functions nicely. Using &lt;code&gt;sFmap&lt;/code&gt; is the only way to work with this at the value level that I can see, but it’s probably because of my own lack of understanding. If anyone knows how to do this, please let me know!&lt;/p&gt;
&lt;p&gt;Anyway, what an exciting journey and a wonderful conclusion. I hope you enjoyed this and will begin using this in your normal day-to-day Haskell. Goodbye, until next time!&lt;/p&gt;
&lt;h2 id=&quot;just-one-more&quot;&gt;Just one more&lt;/h2&gt;
&lt;p&gt;Hah! Of course we aren’t done. I wouldn’t let you down like that. I know that you probably saw that the entire last section’s only purpose was to build up to the pièce de résistance: the crown jewel of every Haskell article, the Monad.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; f &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; f &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Return&lt;/span&gt; a   (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a)&lt;span class=&quot;ot&quot;&gt;                   ::&lt;/span&gt; f a
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt;   a b (&lt;span class=&quot;ot&quot;&gt;m ::&lt;/span&gt; f a) (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f b)&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; f b

    sReturn
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Return&lt;/span&gt; a&lt;span class=&quot;ot&quot;&gt; x ::&lt;/span&gt; f a)

    sBind
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;m ::&lt;/span&gt; f a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f b)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; a b m g)

    &lt;span class=&quot;co&quot;&gt;-- | (return x &amp;gt;&amp;gt;= f) == f x&lt;/span&gt;
    returnIdentLeft
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f b)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; a b (&lt;span class=&quot;dt&quot;&gt;Return&lt;/span&gt; a x) g &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; (g &lt;span class=&quot;fu&quot;&gt;@@&lt;/span&gt; x)

    &lt;span class=&quot;co&quot;&gt;-- | (m &amp;gt;&amp;gt;= return) == m&lt;/span&gt;
    returnIdentRight
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;m ::&lt;/span&gt; f a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; a a m &lt;span class=&quot;dt&quot;&gt;ReturnSym0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; m

    &lt;span class=&quot;co&quot;&gt;-- | m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= h) == (m &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= h&lt;/span&gt;
    bindCompose
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;m ::&lt;/span&gt; f a)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f b)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;h ::&lt;/span&gt; b &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f c)
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; a c m (&lt;span class=&quot;dt&quot;&gt;KCompSym2&lt;/span&gt; a b c g h) &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; b c (&lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; a b m g) h

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ReturnSym0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f a
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Apply&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;ReturnSym0&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f a) (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Return&lt;/span&gt; a x

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KComp&lt;/span&gt; a b c (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f b) (&lt;span class=&quot;ot&quot;&gt;h ::&lt;/span&gt; b &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f c) (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt; b c (g &lt;span class=&quot;fu&quot;&gt;@@&lt;/span&gt; x) h
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KCompSym2&lt;/span&gt; a b c g&lt;span class=&quot;ot&quot;&gt; h ::&lt;/span&gt; (a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f c)
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Apply&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KCompSym2&lt;/span&gt; a b c g&lt;span class=&quot;ot&quot;&gt; h ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; f c) (&lt;span class=&quot;ot&quot;&gt;x ::&lt;/span&gt; a) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KComp&lt;/span&gt; a b c g h x

return
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; a, &lt;span class=&quot;dt&quot;&gt;SingKind&lt;/span&gt; (f a), &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; f)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; a
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Demote&lt;/span&gt; (f a)
return x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing x &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sX &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
             fromSing (sReturn sX)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To help with kind inference, again, we provide explicit kind arguments for &lt;code&gt;Return&lt;/code&gt; (the kind of the thing that is being lifted) and &lt;code&gt;Bind&lt;/code&gt; (the original &lt;code&gt;a&lt;/code&gt; and the resulting &lt;code&gt;b&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Some boilerplate exists there at the bottom — it’s the plumbing for the defunctionalization system. &lt;code&gt;returnIdentRight&lt;/code&gt; requires a defunctionalized version of &lt;code&gt;Return&lt;/code&gt;, so we can provide that by defining &lt;code&gt;ReturnSym0&lt;/code&gt;, and writing an &lt;code&gt;Apply&lt;/code&gt; instance for it (which “applies” it the parameter &lt;code&gt;x&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We introduce &lt;code&gt;KComp&lt;/code&gt; (kleisli composition) and its defunctionalized version in order to express the third law, because we don’t yet have type-level lambdas in Haskell. The actual function it is expressing is &lt;code&gt;\x -&amp;gt; f x &amp;gt;&amp;gt;= g&lt;/code&gt;, and that definition is given on the &lt;code&gt;type KComp a b c ... = Bind ...&lt;/code&gt; line. &lt;code&gt;KCompSym2&lt;/code&gt; is the defunctioanlized version, which is not a &lt;code&gt;a -&amp;gt; f c&lt;/code&gt; but rather an &lt;code&gt;a ~&amp;gt; f c&lt;/code&gt;, which allows it to be partially applied (like we do for &lt;code&gt;composeBind&lt;/code&gt;). And, finally, to hook all of this up into the defunctionalization system, we write an &lt;code&gt;Apply&lt;/code&gt; instance yet again.&lt;/p&gt;
&lt;p&gt;And, again, if anyone knows how I can write a value-level &lt;code&gt;Bind&lt;/code&gt;, I’d definitely appreciate hearing!&lt;/p&gt;
&lt;p&gt;Let’s see some sample implementations.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(singletons [d|
  bindOption :: Option a -&amp;gt; (a -&amp;gt; Option b) -&amp;gt; Option b
  bindOption None     _ = None
  bindOption (Some x) f = f x

  concatMapList :: (a -&amp;gt; List b) -&amp;gt; List a -&amp;gt; List b
  concatMapList _ Nil         = Nil
  concatMapList f (Cons x xs) = f x `appendList` concatMapList f xs
  |])

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Option&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Return&lt;/span&gt; a   x   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Some&lt;/span&gt; x
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt;   a b m g &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;BindOption&lt;/span&gt; m g

    sReturn &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt;
    sBind   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sBindOption

    returnIdentLeft _ _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
    returnIdentRight &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sReturn x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
    bindCompose &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNone&lt;/span&gt;   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SSome&lt;/span&gt; _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Return&lt;/span&gt; a   x   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;PureList&lt;/span&gt; x
    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bind&lt;/span&gt;   a b m g &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ConcatMapList&lt;/span&gt; g m

    sReturn   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sPureList
    sBind x f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sConcatMapList f x

    returnIdentLeft x g &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; sReturn x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; y &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; emptyIdentRight (unSingFun1 &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; g y) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

    returnIdentRight &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; returnIdentRight xs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

    bindCompose &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; x xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \g h &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; bindCompose xs g h &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; unSingFun1 &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; g x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; y ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; gxs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sConcatMapList g xs
                hgxs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sConcatMapList h gxs
                hy   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unSingFun1 &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; h y
                hys  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sConcatMapList h ys
            &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; distribConcatMap h ys gxs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                  &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; appendAssoc hy hys hgxs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- | Proving that concatMap distributes over &amp;lt;&amp;gt;&lt;/span&gt;
distribConcatMap
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;g ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; b)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;xs ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;ys ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;List&lt;/span&gt; a)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ConcatMapList&lt;/span&gt; g (xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; ys) &lt;span class=&quot;fu&quot;&gt;:~:&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;ConcatMapList&lt;/span&gt; g xs &lt;span class=&quot;fu&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ConcatMapList&lt;/span&gt; g ys)
distribConcatMap g &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \_ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; x xs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \ys &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; distribConcatMap g xs ys &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; gx    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; unSingFun1 &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; g x
              cmgxs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sConcatMapList g xs
              cmgys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sConcatMapList g ys
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; appendAssoc gx cmgxs cmgys &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Refl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use &lt;code&gt;unSingFun1&lt;/code&gt;, which converts a singleton of a type-level function into a value-level function on singletons:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;unSingFun1
&lt;span class=&quot;ot&quot;&gt;    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;f      ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; b)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;  (&lt;span class=&quot;ot&quot;&gt;f      ::&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;~&amp;gt;&lt;/span&gt; b)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;  (&lt;span class=&quot;ot&quot;&gt;x      ::&lt;/span&gt; a)
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt;  (f &lt;span class=&quot;fu&quot;&gt;@@&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; x ::&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Proxy&lt;/code&gt; argument only exists for historical reasons, I believe. But, the crux is that, given a &lt;code&gt;Sing (f :: a ~&amp;gt; b)&lt;/code&gt; and a &lt;code&gt;Sing (x :: a)&lt;/code&gt;, we can “apply” them to get &lt;code&gt;Sing (f @@ x :: b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The proofs for the list instance is admittedly ugly to write, due to the fact that &lt;code&gt;List&lt;/code&gt; is a recursive type. It’s also tricky because Haskell has poor to little support for theorem proving and no real tools to help you write them efficiently. But, the proofs for &lt;code&gt;Option&lt;/code&gt; are really something, aren’t they? It’s kind of amazing how much GHC can do on its own without requiring any manual proving on the part of the user.&lt;/p&gt;
&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;
&lt;p&gt;Don’t do this in actual code, please (&lt;a href=&quot;https://twitter.com/mstk/status/848677244478279680&quot;&gt;why?&lt;/a&gt;). This post started off as an April Fools joke that accidentally compiled correctly for reasons which I cannot explain.&lt;/p&gt;
&lt;p&gt;While I don’t recommend that you do this in actual code, but definitely do recommend that you do it for fun! The code in this post is available &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs&quot;&gt;here&lt;/a&gt; if you want to play around!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Not sure why it’s not on hackage yet, but I will update when it gets there!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;In full &lt;em&gt;singletons&lt;/em&gt; style, this should actually be expressed in terms of the the &lt;em&gt;partially applied&lt;/em&gt; (defunctionalized) &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. However, I’m giving the non-defunctionalized versions here for clarity.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/verified-instances-in-haskell.html</guid><pubDate>Sat,  1 Apr 2017 20:25:04 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell</dc:subject><dc:date>2017-04-01</dc:date></item><item><title>Introducing the Hamilton library</title><link>https://blog.jle.im/entry/introducing-the-hamilton-library.html</link><description>&lt;p&gt;&lt;a href=&quot;http://i.imgur.com/Vaaa2EC.gifv&quot;&gt;&lt;img src=&quot;/img/entries/hamilton/double-pendulum.gif&quot; title=&quot;My name is William Rowan Hamilton&quot; alt=&quot;My name is William Rowan Hamilton&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hamilton&lt;/strong&gt;: &lt;a href=&quot;https://github.com/mstksg/hamilton#readme&quot;&gt;README&lt;/a&gt; / &lt;a href=&quot;http://hackage.haskell.org/package/hamilton&quot;&gt;hackage&lt;/a&gt; / &lt;a href=&quot;https://github.com/mstksg/hamilton&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hamilton&quot;&gt;hamilton&lt;/a&gt;&lt;/em&gt; library is on hackage! It was mostly a proof-of-concept toy experiment to simulate motion on bezier curves, but it became usable enough and accurate enough (to my surprise, admittedly) that I finished up some final touches to make it complete and put it on hackage as a general-purpose physics simulator.&lt;/p&gt;
&lt;p&gt;The library is, in short, a way to simulate a physical system by stating nothing more than an arbitrary parameterization of a system (a “generalized coordinate”) and a potential energy function.&lt;/p&gt;
&lt;p&gt;I was going to write a Haskell post on the implementation, which was what interested me at first. I wanted to go over –&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Using &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;automatic differentiation&lt;/a&gt; to automatically compute momentum and the hamilton equations, which are solutions of differential equations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Using type-indexed vectors and dependent types in a seamless way to encode the dimensionality of the generalized coordinate systems and to encode invariants the types of functions.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And fun stuff like that. But that post might be a bit of a while away, so I’m just going to write a post about the usage of the library. (Fair warning, most of this information is also found in the &lt;a href=&quot;https://github.com/mstksg/hamilton#readme&quot;&gt;readme&lt;/a&gt;.)&lt;/p&gt;
&lt;h3 id=&quot;hamiltonian-mechanics&quot;&gt;Hamiltonian Mechanics&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;(This section goes briefly over some relevant part of the physics behind Hamiltonian dynamics, but feel free to skip it if you want to go straight to the Haskell)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hamiltonian_mechanics&quot;&gt;Hamiltonian mechanics&lt;/a&gt; is a brilliant, radical, and beautiful re-imagination of the physics of mechanics and dynamics by &lt;a href=&quot;https://www.youtube.com/watch?v=SZXHoWwBcDc&quot;&gt;William Rowan Hamilton&lt;/a&gt;. It was adapted for statistical mechanics and thermodynamics, and it was through the lens of Hamiltonian mechanics that Schroedinger and Heisenberg independently found insight that unlocked the secrets of quantum mechanics. While Newton’s interpretation of mechanics (in terms of forces and accelerations) was cute, it simply didn’t generalize to quantum mechanics. Hamiltonian’s interpretation of mechanics &lt;em&gt;did&lt;/em&gt;, and we have a century of physics revolutions to thank for it. Hamiltonian mechanics also generalize without any extra work to relativity – another case where newtonian mechanics tends to fall apart.&lt;/p&gt;
&lt;p&gt;Hamiltonian mechanics, in a classical sense, imagines that the state of the system exists as a point in &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Phase_space&quot;&gt;phase space&lt;/a&gt;&lt;/em&gt;, and that the system evolves based on geometric properties of the system’s &lt;em&gt;Hamiltonian&lt;/em&gt; over that phase space.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/hamilton/phase-space.gif&quot; alt=&quot;Animation of particles traveling in phase space (top) over time, from Wikipedia&quot; /&gt;&lt;figcaption&gt;Animation of particles traveling in phase space (top) over time, from Wikipedia&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In other words, define the Hamiltonian of the system, and you see the step-by-step evolution and dynamics of the system. You can imagine mechanics as a series of streams of flow over phase space…and the state of the system just goes along for the ride.&lt;/p&gt;
&lt;p&gt;One nice thing about phase space is that it can be stated in terms of any arbitrary parameterization/coordinate system of your system. For example, for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_pendulum&quot;&gt;double pendulum&lt;/a&gt; system, you can imagine the system as traveling about in the phase space of the angles of the bobs (instead of their actual positions in cartesian space). If you can find &lt;em&gt;any&lt;/em&gt; way to parameterize your system, in any sort of type of coordinates, then Hamiltonian mechanics will describe how it evolves in those coordinates.&lt;/p&gt;
&lt;p&gt;State some fundamental geometric properties about your coordinate system, and the Hamiltonian figures out the rest. It’s the key to unlocking the dynamical properties of the system.&lt;/p&gt;
&lt;p&gt;I could go into more details, but this isn’t a post about Hamiltonian mechanics! Armed with this, let’s look into modeling an actual double pendulum system in terms of the angles of the bobs.&lt;/p&gt;
&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;h4 id=&quot;the-double-pendulum&quot;&gt;The Double Pendulum&lt;/h4&gt;
&lt;p&gt;So, if we’re going to be simulating a double pendulum system using &lt;em&gt;hamilton&lt;/em&gt;, we need three things:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;A statement of our parameterized coordinates and how they relate to the underlying cartesian coordinates of our system&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The inertias (in our case, masses) of each of those underlying coordinates.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A potential energy function (in our case, just the potential energy induced by gravity)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have two coordinates here (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta_1&quot; alt=&quot;\theta_1&quot; title=&quot;\theta_1&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta_2&quot; alt=&quot;\theta_2&quot; title=&quot;\theta_2&quot; /&gt;), which will be encoding the positions of the two pendulums:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Clangle%20x_1%2C%20y_1%20%5Crangle%20%3D%0A%20%20%5Cleft%5Clangle%20%5Csin%20%28%5Ctheta_1%29%2C%20-%20%5Ccos%20%28%5Ctheta_1%29%20%5Cright%5Crangle%0A&quot; alt=&quot;
\langle x_1, y_1 \rangle =
  \left\langle \sin (\theta_1), - \cos (\theta_1) \right\rangle
&quot; title=&quot;
\langle x_1, y_1 \rangle =
  \left\langle \sin (\theta_1), - \cos (\theta_1) \right\rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Clangle%20x_2%2C%20y_2%20%5Crangle%20%3D%0A%20%20%5Cleft%5Clangle%20%5Csin%20%28%5Ctheta_1%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%20%5Csin%20%28%5Ctheta_2%29%2C%0A%20%20%20%20-%20%5Ccos%20%28%5Ctheta_1%29%20-%20%5Cfrac%7B1%7D%7B2%7D%20%5Ccos%20%28%5Ctheta_2%29%20%5Cright%5Crangle%0A&quot; alt=&quot;
\langle x_2, y_2 \rangle =
  \left\langle \sin (\theta_1) + \frac{1}{2} \sin (\theta_2),
    - \cos (\theta_1) - \frac{1}{2} \cos (\theta_2) \right\rangle
&quot; title=&quot;
\langle x_2, y_2 \rangle =
  \left\langle \sin (\theta_1) + \frac{1}{2} \sin (\theta_2),
    - \cos (\theta_1) - \frac{1}{2} \cos (\theta_2) \right\rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;(Assuming that the first pendulum has length 1 and the second pendulum has length &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%7D&quot; alt=&quot;\frac{1}{2}&quot; title=&quot;\frac{1}{2}&quot; /&gt;)&lt;/p&gt;
&lt;p&gt;The inertias of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x_1&quot; alt=&quot;x_1&quot; title=&quot;x_1&quot; /&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?y_1&quot; alt=&quot;y_1&quot; title=&quot;y_1&quot; /&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x_2&quot; alt=&quot;x_2&quot; title=&quot;x_2&quot; /&gt;, and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?y_2&quot; alt=&quot;y_2&quot; title=&quot;y_2&quot; /&gt; are the “masses” attached to them. Let’s pick that the first bob has mass &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?1&quot; alt=&quot;1&quot; title=&quot;1&quot; /&gt; and the second bob has mass &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?2&quot; alt=&quot;2&quot; title=&quot;2&quot; /&gt;, so then our masses are &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%201%2C%201%2C%202%2C%202%20%5Crangle&quot; alt=&quot;\langle 1, 1, 2, 2 \rangle&quot; title=&quot;\langle 1, 1, 2, 2 \rangle&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the potential energy of our system is just the potential energy of gravity, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m%20%5Ctimes%20g%20%5Ctimes%20y&quot; alt=&quot;m \times g \times y&quot; title=&quot;m \times g \times y&quot; /&gt; for each of our points:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0AU%28x_1%2C%20y_1%2C%20x_2%2C%20y_2%29%20%3D%20%28%20y_1%20%2B%202%20y_2%20%29%20g%0A&quot; alt=&quot;
U(x_1, y_1, x_2, y_2) = ( y_1 + 2 y_2 ) g
&quot; title=&quot;
U(x_1, y_1, x_2, y_2) = ( y_1 + 2 y_2 ) g
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Turns out that this is a complete enough description of our system to let &lt;em&gt;hamilton&lt;/em&gt; do the rest!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L10-25&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;doublePendulum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
doublePendulum &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSystem&amp;#39; masses coordinates potential
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    masses ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
    masses &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec4 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    coordinates
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; a
    coordinates (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; θ1 θ2) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V4&lt;/span&gt; (sin θ1)            (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;cos θ1)
                                (sin θ1 &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; sin θ2&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;cos θ1 &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; cos θ2&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    potential
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
    potential (&lt;span class=&quot;dt&quot;&gt;V4&lt;/span&gt; _ y1 _ y2) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (y1 &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y2) &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- assuming g = 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(with some &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L27-35&quot;&gt;helper patterns&lt;/a&gt; defined here – &lt;code&gt;V2&lt;/code&gt; and &lt;code&gt;V4&lt;/code&gt; – that lets us pattern match on and construct sized &lt;code&gt;Vector&lt;/code&gt;s and their 2 (or 4) elements)&lt;/p&gt;
&lt;p&gt;Ta dah. That’s literally all we need.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;System m n&lt;/code&gt; represents a description of a physical system (without its state) described with &lt;code&gt;n&lt;/code&gt; parameters/generalized coordinates. The &lt;code&gt;m&lt;/code&gt; represents the dimension of its underlying cartesian coordinate system (&lt;code&gt;4&lt;/code&gt; for us, with &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%20x_1%2C%20y_1%2C%20x_2%2C%20y_2%20%5Crangle&quot; alt=&quot;\langle x_1, y_1, x_2, y_2 \rangle&quot; title=&quot;\langle x_1, y_1, x_2, y_2 \rangle&quot; /&gt;). The &lt;code&gt;m&lt;/code&gt; should be more or less irrelevant to the actual &lt;em&gt;usage&lt;/em&gt; of &lt;code&gt;System m n&lt;/code&gt; and the &lt;em&gt;hamilton&lt;/em&gt; api…but it’s mostly useful only if we eventually want to plot the system in normal cartesian space.&lt;/p&gt;
&lt;p&gt;Now, let’s run the simulation. First we have to pick a starting configuration:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L37-39&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;config0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
config0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cfg&lt;/span&gt; (vec2 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  )  &lt;span class=&quot;co&quot;&gt;-- initial positions&lt;/span&gt;
              (vec2 &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- initial velocities&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Config n&lt;/code&gt; represents the state of the system, represented in configuration-space. But, remember, Hamiltonian dynamics is about simulating the path of the particle through &lt;em&gt;phase space&lt;/em&gt;. So we can convert our configuration-space state into a phase-space state:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L41-42&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;phase0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
phase0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toPhase doublePendulum config0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can ask for the state of our system at any amount of points in time:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L44-45&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;evolution ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
evolution &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; evolveHam&amp;#39; doublePendulum phase0 [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The result there will be the state of the system at times 0, 0.01, 0.02, 0.03 … etc.&lt;/p&gt;
&lt;p&gt;Or, if you want to run the system step-by-step:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L47-48&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;evolution&amp;#39; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
evolution&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterate (stepHam &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; doublePendulum) phase0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And you can get the position of the coordinates as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L50-51&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;positions ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
positions &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; phsPositions &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; evolution&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;phsPositions :: Phase n -&amp;gt; R n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And the position in the underlying cartesian space as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L53-54&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;positions&amp;#39; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]
positions&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; underlyingPos doublePendulum &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; positions&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code&gt;underlyingPos :: System m n -&amp;gt; Phase n -&amp;gt; R m&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s ignore the underlying position for now, and print out now the full progression of the system’s positions:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/DoublePendulum.hs#L56-57&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withRows (take &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt; positions) (disp &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;withRows&lt;/code&gt; is from &lt;em&gt;hmatrix&lt;/em&gt;, which treats a list of vectors as a matrix with each vector as a row, and &lt;code&gt;disp 5&lt;/code&gt; from &lt;em&gt;hmatrix&lt;/em&gt; pretty-prints our matrix with 5 decimal places of precision)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L 25 2
 1.0000   0.0000
 0.9727   0.0800
 0.8848   0.2345
 0.7164   0.5129
 0.4849   0.8725
 0.2878   1.0648
 0.1223   1.0801
-0.0165   0.9388
-0.1099   0.6400
-0.1161   0.1447
-0.0539  -0.4882
-0.0795  -0.9212
-0.1689  -1.1797
-0.2860  -1.2970
-0.4146  -1.2803
-0.5562  -1.1238
-0.7249  -0.8079
-0.8762  -0.4505
-0.9442  -0.2075
-0.9416  -0.0516
-0.8793   0.0312
-0.7596   0.0265
-0.5728  -0.1086
-0.3001  -0.4237
-0.0381  -0.6640&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neat! We see that the first coordinate (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta_1&quot; alt=&quot;\theta_1&quot; title=&quot;\theta_1&quot; /&gt;) starts at 1 like we asked, and then begins decreasing and falling… And then we see the second coordinate (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta_2&quot; alt=&quot;\theta_2&quot; title=&quot;\theta_2&quot; /&gt;) starting at 0 and then “swinging” to the right. The &lt;a href=&quot;http://i.imgur.com/Vaaa2EC.gifv&quot;&gt;image the top of this post&lt;/a&gt; is an animation of such a system (albeit with &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m_2%20%3D%201&quot; alt=&quot;m_2 = 1&quot; title=&quot;m_2 = 1&quot; /&gt;).&lt;/p&gt;
&lt;h4 id=&quot;two-body-system&quot;&gt;Two-body system&lt;/h4&gt;
&lt;p&gt;Here’s one more situation where generalized coordinates describe things in a lot nicer way than cartesian coordinates: the classic two-body problem.&lt;/p&gt;
&lt;p&gt;Really, you can describe the state of a two-body system with only two parameters: the distance between the two bodies, and their current angle of rotation.&lt;/p&gt;
&lt;p&gt;In this framework, Kepler tells us that for bodies in orbit, the distance will grow smaller and larger again over time, and that the angle of rotation will constantly increase…and increase at a faster rate when the distance is smaller (which is &lt;a href=&quot;https://en.wikipedia.org/wiki/Kepler&amp;#39;s_laws_of_planetary_motion#Second_law&quot;&gt;Kepler’s second law&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;If we assume that the center of mass of the system is at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%200%2C%200%20%5Crangle&quot; alt=&quot;\langle 0, 0 \rangle&quot; title=&quot;\langle 0, 0 \rangle&quot; /&gt;, then we can state these coordinates as&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Clangle%20x_1%2C%20y_1%20%5Crangle%20%3D%20%5Clangle%20r_1%20%5Ccos%20%28%5Ctheta%29%2C%20r_1%20%5Csin%20%28%5Ctheta%29%20%5Crangle%0A&quot; alt=&quot;
\langle x_1, y_1 \rangle = \langle r_1 \cos (\theta), r_1 \sin (\theta) \rangle
&quot; title=&quot;
\langle x_1, y_1 \rangle = \langle r_1 \cos (\theta), r_1 \sin (\theta) \rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Clangle%20x_2%2C%20y_2%20%5Crangle%20%3D%20%5Clangle%20r_2%20%5Ccos%20%28%5Ctheta%29%2C%20r_2%20%5Csin%20%28%5Ctheta%29%20%5Crangle%0A&quot; alt=&quot;
\langle x_2, y_2 \rangle = \langle r_2 \cos (\theta), r_2 \sin (\theta) \rangle
&quot; title=&quot;
\langle x_2, y_2 \rangle = \langle r_2 \cos (\theta), r_2 \sin (\theta) \rangle
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r_1%20%3D%20%5Cfrac%7Bm_2%7D%7Bm_1%20%2B%20m_2%7D&quot; alt=&quot;r_1 = \frac{m_2}{m_1 + m_2}&quot; title=&quot;r_1 = \frac{m_2}{m_1 + m_2}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r_2%20%3D%20-%20%5Cfrac%7Bm_1%7D%7Bm_1%20%2B%20m_2%7D&quot; alt=&quot;r_2 = - \frac{m_1}{m_1 + m_2}&quot; title=&quot;r_2 = - \frac{m_1}{m_1 + m_2}&quot; /&gt; (solving from the center of mass).&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Our potential energy function is Newton’s famous &lt;a href=&quot;https://en.wikipedia.org/wiki/Newton&amp;#39;s_law_of_universal_gravitation&quot;&gt;law of universal gravitation&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0AU%28r%2C%20%5Ctheta%29%20%3D%20-%20%5Cfrac%7BG%20m_1%20m_2%7D%7Br%7D%0A&quot; alt=&quot;
U(r, \theta) = - \frac{G m_1 m_2}{r}
&quot; title=&quot;
U(r, \theta) = - \frac{G m_1 m_2}{r}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And, this should be enough to go for &lt;em&gt;hamilton&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;“But wait,” I hear you say. “If we’re doing a change-of-coordinate-system into polar coordinates, don’t we have to account for artifacts like centrifugal acceleration from the fact that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?d%20%5Ctheta&quot; alt=&quot;d \theta&quot; title=&quot;d \theta&quot; /&gt; is non-uniform and depends on &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt;?”&lt;/p&gt;
&lt;p&gt;Well, I’m glad you asked! And the answer is, nope. We don’t have to account for any weird interplay from non-uniform coordinate systems because &lt;em&gt;hamilton&lt;/em&gt; arrives at the proper solution simply from the geometry of the generalized coordinates. (And it does this using &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt;, but more on that for a later post!)&lt;/p&gt;
&lt;p&gt;Anyway, here we go:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/TwoBody.hs#L10-42&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;twoBody ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;System&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
twoBody &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mkSystem masses coordinates potential
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    masses ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
    masses &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; vec4 &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    coordinates
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; a
    coordinates (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; r θ) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V4&lt;/span&gt; (r1 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; cos θ) (r1 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; sin θ)
                              (r2 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; cos θ) (r2 &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; sin θ)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        r1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;   r &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;
        r2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; r &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;
    potential
&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;V.Vector&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; a
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
    potential (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; r _) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; r       &lt;span class=&quot;co&quot;&gt;-- G = 1&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;config0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
config0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cfg&lt;/span&gt; (vec2 &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- initial positions&lt;/span&gt;
              (vec2 &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- initial velocities&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(we use &lt;code&gt;mkSystem&lt;/code&gt; instead of &lt;code&gt;mkSystem&#39;&lt;/code&gt; because we want to state the potential energy in terms of our generalized coordinates &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt;)&lt;/p&gt;
&lt;p&gt;Let’s take a peek:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton/TwoBody.hs#L44-60&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;phase0 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
phase0 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toPhase twoBody config0

&lt;span class=&quot;ot&quot;&gt;evolution&amp;#39; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Phase&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
evolution&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterate (stepHam &lt;span class=&quot;fl&quot;&gt;0.1&lt;/span&gt; twoBody) phase0

&lt;span class=&quot;ot&quot;&gt;positions ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
positions &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; phsPositions &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; evolution&amp;#39;

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withRows (take &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt; positions) (disp &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;L 25 2
2.0000  0.0000
1.9887  0.0502
1.9547  0.1015
1.8972  0.1554
1.8149  0.2133
1.7058  0.2777
1.5669  0.3523
1.3933  0.4435
1.1774  0.5647
0.9057  0.7503
0.5516  1.1413
0.2057  3.4946
0.6092  5.2275
0.9490  5.5664
1.2115  5.7386
1.4207  5.8542
1.5889  5.9424
1.7233  6.0152
1.8283  6.0785
1.9069  6.1358
1.9610  6.1892
1.9917  6.2403
1.9998  6.2904
1.9852  6.3407
1.9479  6.3923&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neat! We see that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; starts big and gets smaller, and then gets big again. And it’s clear that when &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?r&quot; alt=&quot;r&quot; title=&quot;r&quot; /&gt; is smallest, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Ctheta&quot; alt=&quot;\theta&quot; title=&quot;\theta&quot; /&gt; changes the fastest. Look at it go!&lt;/p&gt;
&lt;p&gt;Here’s an animation of the same situation with some different masses:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://i.imgur.com/TDEHTcb.gifv&quot;&gt;&lt;img src=&quot;/img/entries/hamilton/two-body.gif&quot; alt=&quot;The two-body solution&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;just-you-wait&quot;&gt;Just you wait&lt;/h3&gt;
&lt;p&gt;Now, this isn’t all just useful for physics. You can state a lot of animation/dynamics problems as motion along coordinates that aren’t always trivial. This project started, after all, as a way to simulate constant-velocity motion along a bezier curve. (In that case, the single coordinate is the non-uniform time parameter to the bezier curve.)&lt;/p&gt;
&lt;p&gt;I’ve included more examples in the &lt;a href=&quot;https://github.com/mstksg/hamilton#example-app-runner&quot;&gt;example app launcher&lt;/a&gt; included in the library (which generated those animations you see above), including:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;A spring hanging from a block sliding along a horizontal rail (a favorite of many physics students, of course)&lt;/li&gt;
&lt;li&gt;A ball bouncing around a room, showing that you can represent bouncy walls as potential energy functions&lt;/li&gt;
&lt;li&gt;The bezier curve example.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let me know in the comments if you think of any interesting systems to apply this to, or if you have any interesting applications in physical or non-physical ways! I’d love to hear :D&lt;/p&gt;
&lt;p&gt;And if you’re interested in the implementation using some of those Haskell tricks I mentioned above, stay tuned :)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Alternatively, we could assume that the halfway point (or even the first body) is always at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Clangle%200%2C%200%20%5Crangle&quot; alt=&quot;\langle 0, 0 \rangle&quot; title=&quot;\langle 0, 0 \rangle&quot; /&gt;, but this doesn’t give us as pretty of plots. The center of mass is a nice reference point because newton’s third law implies that it remains stationary forever.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Projects</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-hamilton-library.html</guid><pubDate>Mon, 28 Nov 2016 17:28:32 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Projects</dc:subject><dc:date>2016-11-28</dc:date></item><item><title>Practical Dependent Types in Haskell 2: Existential Neural Networks and Types at
Runtime</title><link>https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html</link><description>&lt;p&gt;We’re back to continue on &lt;a href=&quot;https://blog.jle.im/entries/series/+practical-dependent-types-in-haskell.html&quot;&gt;our journey&lt;/a&gt; in using dependent types to write type-safe neural networks! In &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html&quot;&gt;Part 1&lt;/a&gt;, we wrote things out in normal, untyped Haskell, and looked at red flags and general design principles that nudged us in the direction of adding dependent types to our program. We learned to appreciate what dependent types offered in terms of guiding us in writing our code, helping the compiler check our correctness, providing a better interface for users, and more.&lt;/p&gt;
&lt;p&gt;We also learned how to use singletons to work around some of Haskell’s fundamental limitations to let us “pattern match” on the structure of types, and how to use typeclasses to generate singletons reflecting the structure of types we are dealing with.&lt;/p&gt;
&lt;p&gt;(If you read &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html&quot;&gt;Part 1&lt;/a&gt; &lt;em&gt;before&lt;/em&gt; the singletons section was re-written to use the &lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt; library, &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#singletons-and-induction&quot;&gt;here’s a link to the section&lt;/a&gt; in specific. This tutorial will assume familiarity with what is discussed there!)&lt;/p&gt;
&lt;p&gt;All of what we’ve dealt with so far has essentially been with types that are fixed at compile-time. All the networks we’ve made have had “static” types, with their sizes in their types indicated directly in the source code. In this post, we’re going to dive into the world of types that &lt;em&gt;depend&lt;/em&gt; on factors unknown until runtime, and see how dependent types in a strongly typed language like Haskell helps us write safer, more correct, and more maintainable code.&lt;/p&gt;
&lt;p&gt;This post was written for GHC 8 on stackage snapshot &lt;a href=&quot;https://www.stackage.org/nightly-2016-06-28&quot;&gt;nightly-2016-06-28&lt;/a&gt;, but should work with GHC 7.10 for the most part. All of the set-up instructions and caveats (like the &lt;em&gt;singletons-2.0.1&lt;/em&gt; bug affecting GHC 7.10 users and the unreleased &lt;em&gt;hmatrix&lt;/em&gt; version) are the same as for &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#setup&quot;&gt;part 1’s setup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All of the code in this post is &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs&quot;&gt;downloadable as a standalone source file&lt;/a&gt; so you can follow along!&lt;/p&gt;
&lt;p&gt;A fair disclosure: a lot of this post doesn’t actually directly deal with machine learning or neural networks. Most of it will be learning general principles for working with dependent types through implementing things you’d want to do with neural networks. More stuff with ML will come in the next posts!&lt;/p&gt;
&lt;h2 id=&quot;types-at-runtime&quot;&gt;Types at Runtime&lt;/h2&gt;
&lt;p&gt;Recall the type we had for our neural networks:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;k &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They’re of the form &lt;code&gt;Network i hs o&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the size of the input vector it expects, &lt;code&gt;hs&lt;/code&gt; is the list of hidden layer sizes, and &lt;code&gt;o&lt;/code&gt; is the size of the output vector it produces. Something of type &lt;code&gt;Network 10 &#39;[6, 4] 3&lt;/code&gt; is a network with 10 input nodes, two input layers of size 6 and 4, and 3 output nodes.&lt;/p&gt;
&lt;p&gt;This is great and all, but there’s an severe limitation to this: Haskell is a statically typed language, right? So doesn’t this mean that using a network requires that you know the entire structure of the network at compile-time?&lt;/p&gt;
&lt;p&gt;It’s conceivable that you might be able to have the input and output sizes known at compile-time, but it’s possible that you don’t care or know your hidden layer structure. You might load it from a configuration file, or have it depend on user input. You might even want to receive one over a network channel without knowing what the internal structure is. But can a type really depend on things that you can’t know until runtime?&lt;/p&gt;
&lt;p&gt;To illustrate more clearly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;What hidden layer structure do you want?&amp;quot;&lt;/span&gt;
    hs  &lt;span class=&quot;ot&quot;&gt;&amp;lt;- readLn    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
    net &lt;span class=&quot;ot&quot;&gt;&amp;lt;- randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;???&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;-- what is ???&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- ...?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We &lt;em&gt;want&lt;/em&gt; to put &lt;code&gt;hs&lt;/code&gt; there where &lt;code&gt;???&lt;/code&gt; is, but…&lt;code&gt;???&lt;/code&gt; has to be a type (of kind &lt;code&gt;[Nat]&lt;/code&gt;). &lt;code&gt;hs&lt;/code&gt; is a value (of type &lt;code&gt;[Integer]&lt;/code&gt;). It’s clear here that the &lt;em&gt;type&lt;/em&gt; of our network depends on something we can’t write down or decide until runtime.&lt;/p&gt;
&lt;h3 id=&quot;an-existential-crisis&quot;&gt;An Existential Crisis&lt;/h3&gt;
&lt;p&gt;There are two main ways to go about solving this issue in Haskell. We’ll look at both, and then see that they are really actually just two styles of doing the same thing.&lt;/p&gt;
&lt;h4 id=&quot;types-hiding-behind-constructors&quot;&gt;Types hiding behind constructors&lt;/h4&gt;
&lt;p&gt;Now, having the entire structure of your neural network in the type is nice and all for cool tricks like &lt;code&gt;randomNet&lt;/code&gt;…but do you &lt;em&gt;really&lt;/em&gt; want to work with this directly? After all, from the user’s perspective, the user really only ever needs to know &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt;: What vectors the network &lt;em&gt;expects&lt;/em&gt; and what vectors the network &lt;em&gt;outputs&lt;/em&gt;. In the end, a (feed-forward) Neural Network is really just a fancy &lt;code&gt;R i -&amp;gt; R o&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember, the main benefits of having the entire structure in the type was to help us &lt;em&gt;implement&lt;/em&gt; our functions more safely, with the compiler’s help, and also for cute return type polymorphism tricks like &lt;code&gt;randomNet&lt;/code&gt; and &lt;code&gt;getNet&lt;/code&gt; and some stronger documentation. The &lt;em&gt;user&lt;/em&gt; of the network really only benefits from the second two types of benefits.&lt;/p&gt;
&lt;p&gt;One practical downside of having the structure in the type is that you can’t store them in the same list or data structure. A &lt;code&gt;Network 10 &#39;[5,3] 1&lt;/code&gt; won’t share a list with a &lt;code&gt;Network 10 &#39;[5,2] 1&lt;/code&gt;, despite having the same inputs/outputs (and API).&lt;/p&gt;
&lt;p&gt;Imagine that we had written a &lt;code&gt;Network&lt;/code&gt; type that &lt;em&gt;didn’t&lt;/em&gt; have the internal structure in the type —&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall that our issue earlier was that we had to write &lt;code&gt;Network i ??? o&lt;/code&gt;, but we had no idea what to put in for &lt;code&gt;???&lt;/code&gt;. But, if we worked with an &lt;code&gt;OpaqueNet i o&lt;/code&gt;, we wouldn’t even care! We wouldn’t have to tell GHC what the internal structure is.&lt;/p&gt;
&lt;p&gt;I’d actually argue that &lt;code&gt;OpaqueNet&lt;/code&gt; might often be the more useful type to offer to your users (or to use yourself), because it only exposes the types that are &lt;em&gt;relevant&lt;/em&gt; to its usage/API. You can store them in a list or MVar — &lt;code&gt;[OpaqueNet 10 3]&lt;/code&gt; and &lt;code&gt;MVar (OpaqueNet 10 3)&lt;/code&gt;, serialize/deserialize them without knowing their internal structure in advance (&lt;code&gt;loadNet :: FilePath -&amp;gt; IO (OpaqueNet 10 3)&lt;/code&gt;), etc. (if you wanted to load a &lt;code&gt;Network&lt;/code&gt;, you would need to know exactly what internal structure was stored, in advance). Though &lt;code&gt;Network&lt;/code&gt; is a much easier type to &lt;em&gt;implement&lt;/em&gt;, &lt;code&gt;OpaqueNet&lt;/code&gt; is a often a more ideal type to &lt;em&gt;use&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We can implement our vision for &lt;code&gt;OpaqueNet&lt;/code&gt; as an “existential” wrapper over &lt;code&gt;Network&lt;/code&gt;, actually:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L110-111&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, if you have &lt;code&gt;net :: Network 6 &#39;[10,6,3] 2&lt;/code&gt;, you can create &lt;code&gt;ONet net :: OpaqueNet 6 2&lt;/code&gt;. When you use the &lt;code&gt;ONet&lt;/code&gt; constructor, the structure of the hidden layers disappears from the type!&lt;/p&gt;
&lt;p&gt;We can use the network inside by &lt;em&gt;pattern matching&lt;/em&gt; on &lt;code&gt;ONet&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L113-125&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runOpaqueNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
             &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runOpaqueNet (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runNet n x

&lt;span class=&quot;ot&quot;&gt;numHiddens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
numHiddens (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go n
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; _      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
        _ &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; go n&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the &lt;em&gt;ScopedTypeVariables&lt;/em&gt; extension, we can even bring &lt;code&gt;hs&lt;/code&gt; back into scope, as in:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; oN &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pattern is sometimes called the &lt;strong&gt;dependent pair&lt;/strong&gt;, because pattern matching on &lt;code&gt;ONet&lt;/code&gt; yields the hidden &lt;strong&gt;existentially quantified&lt;/strong&gt; type (&lt;code&gt;hs&lt;/code&gt;) and also a value whose type is based on it (&lt;code&gt;Network i hs o&lt;/code&gt;). It’s like &lt;code&gt;hs&lt;/code&gt; “paired” with &lt;code&gt;Network i hs o&lt;/code&gt;. Pattern match on the results to give both the type (&lt;code&gt;hs&lt;/code&gt;) &lt;em&gt;and&lt;/em&gt; the data structure. (To make this more explicit, we could have implemented it as &lt;code&gt;ONet :: Sing hs -&amp;gt; Network i hs o -&amp;gt; OpaqueNet i o&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;And here’s the key to making this all work: once you pattern match on &lt;code&gt;ONet&lt;/code&gt;, you have to handle the &lt;code&gt;hs&lt;/code&gt; in a &lt;em&gt;completely polymorphic way&lt;/em&gt;. You’re not allowed to assume anything about &lt;code&gt;hs&lt;/code&gt;…you have to provide a completely parametrically polymorphic way of dealing with it!&lt;/p&gt;
&lt;p&gt;For example, this function is completely &lt;em&gt;not&lt;/em&gt; ok:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;bad ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
bad (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; n            &lt;span class=&quot;co&quot;&gt;-- nope, not ok at all.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Why not? Well, a type signature like &lt;code&gt;OpaqueNet i o -&amp;gt; Network i hs o&lt;/code&gt; means that the &lt;em&gt;caller&lt;/em&gt; can decide what &lt;code&gt;hs&lt;/code&gt; can be — just like &lt;code&gt;read :: Read a =&amp;gt; String -&amp;gt; a&lt;/code&gt;, where the caller decides what &lt;code&gt;a&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;Of course, this isn’t the case in the way we’ve written the function…the function can only return a &lt;em&gt;specific&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt; (namely, the &lt;code&gt;hs&lt;/code&gt; of the network that &lt;code&gt;ONet&lt;/code&gt; hides). The &lt;em&gt;caller&lt;/em&gt; has to accommodate whatever is inside &lt;code&gt;ONet&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;the-universal-and-the-existential&quot;&gt;The Universal and the Existential&lt;/h4&gt;
&lt;p&gt;We just brushed here on something at the heart of using existential types in Haskell: the issue of who has the power to decide what the types will be instantiated as. Most polymorphic functions you work with in Haskell are “universally qualified”. For example, for a function like&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are universally quantified, which means that the person who &lt;em&gt;uses&lt;/em&gt; &lt;code&gt;map&lt;/code&gt; gets to decide what &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are. To be more explicit, that type signature can be written as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; forall a b&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;map&lt;/code&gt; is defined in a way that will work for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that the &lt;em&gt;caller&lt;/em&gt; wants. As a caller, you can request:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;]
map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Void&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Void&lt;/span&gt;]
map&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or anything else!&lt;/p&gt;
&lt;p&gt;Consequentially, the function has to be implemented in a way that will work for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. The function’s implementation has the burden of being flexible enough to handle whatever the caller asks for.&lt;/p&gt;
&lt;p&gt;But, for a function like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the caller can choose what &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; are, the &lt;em&gt;function&lt;/em&gt; gets to choose what &lt;code&gt;hs&lt;/code&gt; (in the hidden &lt;code&gt;Network i hs o&lt;/code&gt;) is. If I want to &lt;em&gt;use&lt;/em&gt; the thing that &lt;code&gt;foo&lt;/code&gt; returns…then &lt;em&gt;I&lt;/em&gt; have to be flexible. &lt;em&gt;I&lt;/em&gt; have the burden of being flexible enough to handle whatever &lt;code&gt;hs&lt;/code&gt; the &lt;em&gt;function&lt;/em&gt; returns.&lt;/p&gt;
&lt;p&gt;In summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For universally quantified types, the &lt;em&gt;caller&lt;/em&gt; chooses the type being instanced, and the &lt;em&gt;function’s implementation&lt;/em&gt; has to accommodate any choice.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For existentially quantified types, the &lt;em&gt;function’s implementation&lt;/em&gt; chooses the type being instanced, and the &lt;em&gt;caller&lt;/em&gt; has to accommodate any choice.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Indeed, we saw earlier that if we ever wanted to &lt;em&gt;use&lt;/em&gt; the &lt;code&gt;Network i hs o&lt;/code&gt; inside the &lt;code&gt;OpaqueNet i o&lt;/code&gt;, we were forced to deal with it in a parametrically polymorphic way. We had to be able to handle &lt;em&gt;any&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt; that the &lt;code&gt;ONet&lt;/code&gt; could throw at us!&lt;/p&gt;
&lt;h4 id=&quot;a-familiar-friend&quot;&gt;A familiar friend&lt;/h4&gt;
&lt;p&gt;I called &lt;code&gt;OpaqueNet i o&lt;/code&gt; a “dependent pair” earlier, pairing &lt;code&gt;hs&lt;/code&gt; with &lt;code&gt;Network i hs o&lt;/code&gt;. But there’s another common term for it: a &lt;strong&gt;dependent sum&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;People familiar with Haskell might recognize that “sum types” are &lt;code&gt;Either&lt;/code&gt;-like types that can be one thing or another. Sum types are one of the first things you learn about in Haskell — heck, even &lt;code&gt;Maybe a&lt;/code&gt; is the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt;. Dependent pairs/existential types actually are very similar to &lt;code&gt;Either&lt;/code&gt;/sum types, in spirit, and it might help to see the parallel so that you can see that they’re nothing scary, and that the fundamentals/intuition of working with existential types in Haskell is no different than working with &lt;code&gt;Either&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;If I had:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I have to handle the result for both the case where I get an &lt;code&gt;Int&lt;/code&gt; and the case where I get a &lt;code&gt;Bool&lt;/code&gt;. The &lt;em&gt;function&lt;/em&gt; gets to pick what type I have to handle (&lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt;), and &lt;em&gt;I&lt;/em&gt; have to adapt to whatever it returns. Sound familiar? In fact, you can even imagine that &lt;code&gt;OpaqueNet i o&lt;/code&gt; as being just a infinite &lt;em&gt;Either&lt;/em&gt; over &lt;code&gt;&#39;[]&lt;/code&gt;, &lt;code&gt;&#39;[1]&lt;/code&gt;, &lt;code&gt;&#39;[1,2]&lt;/code&gt;, etc.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Remember that the basic way of handling an &lt;code&gt;Either&lt;/code&gt; and figuring out what the type of the value is inside is through &lt;em&gt;pattern matching&lt;/em&gt; on it. You can’t know if an &lt;code&gt;Either Int Bool&lt;/code&gt; contains an &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt; until you pattern match. But, once you do, all is revealed, and GHC lets you take advantage of knowing the type.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;OpaqueNet i o&lt;/code&gt;, it’s the same! You don’t know the actual type of the &lt;code&gt;Network i hs o&lt;/code&gt; it contains until you &lt;em&gt;pattern match&lt;/em&gt; on the network (This time, it’s a “dependent pattern match”). Once you pattern match on it, all is revealed…and GHC lets you take advantage of knowing the type!&lt;/p&gt;
&lt;h3 id=&quot;reification&quot;&gt;Reification&lt;/h3&gt;
&lt;p&gt;For simplicity, let’s re-write &lt;code&gt;randomNet&lt;/code&gt; the more sensible way — with the explicit singleton input style:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L79-87&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomNet&amp;#39; ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights
    &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; randomNet&amp;#39; ss

&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomNet&amp;#39; sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use &lt;code&gt;sing :: SingI hs =&amp;gt; Sing hs&lt;/code&gt; to go call the &lt;code&gt;Sing hs -&amp;gt;&lt;/code&gt;-style function from the &lt;code&gt;SingI hs =&amp;gt;&lt;/code&gt; one.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now, we still need to somehow get our list of integers to the type level so that we can create a &lt;code&gt;Network i hs o&lt;/code&gt; to stuff into our &lt;code&gt;ONet&lt;/code&gt;. For that, the &lt;em&gt;singletons&lt;/em&gt; library offers the necessary tooling. It gives us &lt;code&gt;SomeSing&lt;/code&gt;, which is a lot like our &lt;code&gt;OpaqueNet&lt;/code&gt; above, wrapping the &lt;code&gt;Sing a&lt;/code&gt; inside an existential data constructor. &lt;code&gt;toSing&lt;/code&gt; takes the term-level value (for us, an &lt;code&gt;[Integer]&lt;/code&gt;) and returns a &lt;code&gt;SomeSing&lt;/code&gt; wrapping the type-level value (for us, a &lt;code&gt;[Nat]&lt;/code&gt;). When we pattern match on the &lt;code&gt;SomeSing&lt;/code&gt; constructor, we get &lt;code&gt;a&lt;/code&gt; in scope!&lt;/p&gt;
&lt;p&gt;As of &lt;em&gt;singletons-2.2&lt;/em&gt; and GHC 8&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;, &lt;code&gt;SomeSing&lt;/code&gt; is implemented as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;a ::&lt;/span&gt; k) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And you have:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;bar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;
bar &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pattern matching looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;How many cats do you own?&amp;quot;&lt;/span&gt;
    c &lt;span class=&quot;ot&quot;&gt;&amp;lt;- readLn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing c &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, inside the case statement branch (the &lt;code&gt;...&lt;/code&gt;), we have &lt;em&gt;type&lt;/em&gt; &lt;code&gt;n :: Nat&lt;/code&gt; in scope! And by pattern matching on the &lt;code&gt;SNat&lt;/code&gt; constructor, we also have a &lt;code&gt;KnownNat n&lt;/code&gt; instance (As discussed in &lt;a href=&quot;https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html#on-typeclasses-and-dictionaries&quot;&gt;previous part&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toSing&lt;/code&gt; works using a simple typeclass mechanism with an associated type whose job is to connect the types of values with the kinds of their singletons. It associates &lt;code&gt;Bool&lt;/code&gt; (the type) with &lt;code&gt;Bool&lt;/code&gt; (the kind), &lt;code&gt;Integer&lt;/code&gt; (the type) with &lt;code&gt;Nat&lt;/code&gt; (the kind), &lt;code&gt;[Integer]&lt;/code&gt; (the type) with &lt;code&gt;[Nat]&lt;/code&gt; (the kind), etc., and it does it with simple applications of type families (here’s a &lt;a href=&quot;https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html&quot;&gt;nice tutorial on type families&lt;/a&gt; courtesy of Oliver Charles, as a refresher). With it, we can convert any normal value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt; to a singleton representing type &lt;code&gt;x&lt;/code&gt; with kind &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We now have enough to write our &lt;code&gt;randomONet&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L127-131&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomONet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o)
randomONet hs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing hs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                  &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomNet&amp;#39; ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This process of bringing a term-level value into the type level is known in Haskell as &lt;strong&gt;reification&lt;/strong&gt;. With this, our original goal is (finally) within reach:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L205-213&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;What hidden layer structure do you want?&amp;quot;&lt;/span&gt;
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
    n  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet hs
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; n &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;net ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        print net
        &lt;span class=&quot;co&quot;&gt;-- blah blah stuff with our dynamically generated net&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;the-boundary&quot;&gt;The Boundary&lt;/h4&gt;
&lt;p&gt;With the power of existentially quantified types (like in &lt;code&gt;SomeSing&lt;/code&gt;), we essentially gained the ability to work with types that depend on runtime results.&lt;/p&gt;
&lt;p&gt;In a way, you can consider the &lt;code&gt;toSing&lt;/code&gt; and the &lt;code&gt;SomeSing&lt;/code&gt; as our “boundary” between the “untyped world” and the “typed world”. This layer (and the process of reification) cleanly separates the two.&lt;/p&gt;
&lt;p&gt;This boundary can be thought of as a lot like the boundary we talk about between “pure” functions and values and “impure” (IO, etc.) ones. People say to always write as much of your program as possible in the “pure” world — to separate and pull out as much logic as you can to be pure logic. That’s one of the first things you learn about as a Haskell programmer: how to separate logic that &lt;em&gt;can&lt;/em&gt; be pure from logic that is “impure” (IO, etc.), and then finally combine them at the very end, as late as possible.&lt;/p&gt;
&lt;p&gt;It’s easy to think that just because the final program is going to “be in IO in the end anyway”, there isn’t any point in separating out pure and impure parts of your program logic. But we know that we gain separation of concerns, the increased ability to reason with your code and analyze what it does, the compiler’s ability to check what you write, the limitation of implementations, etc.&lt;/p&gt;
&lt;p&gt;You can think of the general philosophy of working with typed/untyped worlds as being the same thing. You try to write as much of your program as possible in the “typed” world, like we did in Part 1. Take advantage of the increased ability to reason with your code, parametric polymorphism helping you &lt;em&gt;write&lt;/em&gt; your code, limit your implementations, nab you compiler help, etc. All of those are benefits of working in the typed world.&lt;/p&gt;
&lt;p&gt;Then, write what you absolutely must in your “untyped” world, such as dealing with values that pop up at runtime like the &lt;code&gt;[Integer]&lt;/code&gt; above.&lt;/p&gt;
&lt;p&gt;Finally, at the very end, &lt;em&gt;unite&lt;/em&gt; them at the boundary. Pass the control football from the untyped world to the typed world!&lt;/p&gt;
&lt;p&gt;The great part about this all is that GHC and the type system is there at every step holding your hand, guiding you as you implement your programs and making sure everything is type-safe and fits together! (This, after all, is why dependently typed programming with dynamically generated types is &lt;em&gt;not&lt;/em&gt; the same thing as “&lt;em&gt;dynamically&lt;/em&gt; typed programming”!)&lt;/p&gt;
&lt;h3 id=&quot;continuation-based-existentials&quot;&gt;Continuation-Based Existentials&lt;/h3&gt;
&lt;p&gt;There’s another way in Haskell that we work with existential types that can be more natural to use in a lot of cases. Remember that when we pattern match on an existential data type, we have to work with the values in the constructor in a parametrically polymorphic way. For example, if we had:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;oNetToFoo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Foo&lt;/span&gt;
oNetToFoo (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt; has to take a &lt;code&gt;Network i hs o&lt;/code&gt; but deal with it in a way that works &lt;em&gt;for all&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt;. It can’t be written for &lt;em&gt;only&lt;/em&gt; &lt;code&gt;&#39;[5]&lt;/code&gt; or &lt;em&gt;only&lt;/em&gt; &lt;code&gt;&#39;[6,3]&lt;/code&gt;…it has to work for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;hs&lt;/code&gt;. That’s the whole “existential vs. universal quantification” thing we just talked about.&lt;/p&gt;
&lt;p&gt;Well, we could really also just skip the constructor altogether and represent an existential type as something &lt;em&gt;taking&lt;/em&gt; the continuation &lt;code&gt;f&lt;/code&gt; and giving it what it needs.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L154-154&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o r &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“Tell me how you would make an &lt;code&gt;r&lt;/code&gt; if you had a &lt;code&gt;Network i hs o&lt;/code&gt; (that works for any &lt;code&gt;hs&lt;/code&gt;) and I’ll make it for you!”&lt;/p&gt;
&lt;p&gt;(This takes advantage of Rank-N types. If you’re unfamiliar with them, Gregor Riegler has a &lt;a href=&quot;http://sleepomeno.github.io/blog/2014/02/12/Explaining-Haskell-RankNTypes-for-all/&quot;&gt;nice tutorial&lt;/a&gt; on the subject.)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Using&lt;/em&gt; these types is very similar to using the constructor-style ones:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L159-176&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runOpaqueNet&amp;#39; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o (&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runOpaqueNet&amp;#39; oN x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; oN (\n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; runNet n x)
&lt;span class=&quot;co&quot;&gt;--            :: ((forall hs. Network i hs o -&amp;gt; R o) -&amp;gt; R o)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--            -&amp;gt; R i&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--            -&amp;gt; R o&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;numHiddens&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
numHiddens&amp;#39; oN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; oN go
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; _      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
        _ &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; go n&amp;#39;
&lt;span class=&quot;co&quot;&gt;--          :: ((forall hs. Network i hs o -&amp;gt; Int) -&amp;gt; Int)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--          -&amp;gt; Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This “continuation transformation” is formally known as &lt;strong&gt;skolemization&lt;/strong&gt;.&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can “wrap” a &lt;code&gt;Network i hs o&lt;/code&gt; into an &lt;code&gt;OpaqueNet&#39; i o r&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L156-157&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;oNet&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o r
oNet&amp;#39; n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \f &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s write a version of &lt;code&gt;randomONet&lt;/code&gt; that returns a continuation-style existential:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;withRandomONet&amp;#39; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
                &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r)
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r
&lt;span class=&quot;co&quot;&gt;--         aka, =&amp;gt; [Integer]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--              -&amp;gt; OpaqueNet&amp;#39; i o (m r)&lt;/span&gt;
withRandomONet&amp;#39; hs f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing hs &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                         &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                           net &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomNet&amp;#39; ss
                           f net&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, hey, because we’re skolemizing everything, let’s do it with the skolemized version of &lt;code&gt;toSing&lt;/code&gt;/&lt;code&gt;SomeSing&lt;/code&gt;, &lt;code&gt;withSomeSing&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- a version of `toSing` that returns a skolemized `SomeSing`&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withSomeSing ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall (&lt;span class=&quot;ot&quot;&gt;hs ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;])&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r)
             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because why not? Skolemize all the things!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L178-186&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withRandomONet&amp;#39; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
                &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r)
                &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m r
&lt;span class=&quot;co&quot;&gt;--         aka, =&amp;gt; [Integer]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--              -&amp;gt; OpaqueNet&amp;#39; i o (m r)&lt;/span&gt;
withRandomONet&amp;#39; hs f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
                         net &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomNet&amp;#39; ss
                         f net&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use it to do the same things we used the constructor-based existential for, as well…and, in a way, it actually seems (oddly) more natural.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L215-221&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    putStrLn &lt;span class=&quot;st&quot;&gt;&amp;quot;What hidden layer structure do you want?&amp;quot;&lt;/span&gt;
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
    withRandomONet&amp;#39; hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;net ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      print net
      &lt;span class=&quot;co&quot;&gt;-- blah blah stuff with our dynamically generated net&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the case statement pattern match represented the lexical “wall”/“boundary” between the untyped and typed world when using constructor-style existentials, the &lt;code&gt;... $ \net -&amp;gt; ...&lt;/code&gt; can be thought of the “wall” for the continuation-style existentials.&lt;/p&gt;
&lt;h2 id=&quot;a-tale-of-two-styles&quot;&gt;A Tale of Two Styles&lt;/h2&gt;
&lt;p&gt;We’ve just discussed two ways of doing the same thing. Two styles of representing/working with existential types. The two are equivalent, in that you can always “convert” between one or the other, but the choice of which one you use/reach for/offer can make a difference in code clarity. After working with both styles a lot (sometimes, libraries only offer one style), you start to get a feel for which one you like more in which situations. In the end, I don’t think there are any hard or fast rules. Just use whichever one you feel is more readable!&lt;/p&gt;
&lt;p&gt;That being said, here are some general Pros and Cons that I’ve noticed over the years:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Most obviously, continuation-style doesn’t require you to define a throwaway data type/constructor. While new types are cheap in Haskell, they force your users to learn a new set of types and constructors for every single existential type you return. If you or the library you’re writing uses/returns a &lt;em&gt;lot&lt;/em&gt; of different existentially qualified types, all those extra dumb wrappers are a huge hassle.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Continuation-style existentials are in general smoother to use than constructor-style ones when functions &lt;em&gt;return&lt;/em&gt; existentials. Especially if you intend to immediately use them, continuation-style basically saves you an extraneous pattern match.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When you have to use several existentials at once, continuation-style is much better because each nested existential doesn’t force another level of indentation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withSomeSing x &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      withSomeSing y &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sy &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      withSomeSing z &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \sz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vs.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing x &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sx &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing y &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sy &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; toSing z &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sz &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
                  &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Every time you nest a case statement, you actually waste &lt;em&gt;two&lt;/em&gt; levels of indentation, which can be annoying even at 2-space indentation. But you don’t need &lt;em&gt;any&lt;/em&gt; to nest in the continuation style!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you’re working monadically, though, you can take advantage of do notation and &lt;em&gt;ScopedTypeVariables&lt;/em&gt; for a nicer style that doesn’t require any nesting at all:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n1 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet [&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n2 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; n3 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
    &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n4 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; randomONet hs
    &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is arguably nicer than&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; withRandomONet&amp;#39; [&lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \n1 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
       withRandomONet&amp;#39; [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \n2 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
       withRandomONet&amp;#39; [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \n3 &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
         hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; readLn
         withRandomONet&amp;#39; hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \(&lt;span class=&quot;ot&quot;&gt;n4 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; hs &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
           &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A lot of libraries return existentials in &lt;code&gt;Maybe&lt;/code&gt;’s (&lt;a href=&quot;http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#v:someNatVal&quot;&gt;base is guilty&lt;/a&gt;), so this trick can be useful for those, too!&lt;/p&gt;
&lt;p&gt;This trick is less useful for functions like &lt;code&gt;toSing&lt;/code&gt; where things are &lt;em&gt;not&lt;/em&gt; returned in a monad. You could wrap it in Identity, but that’s kind of silly:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runIdentity &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sx &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toSing x
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sy &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toSing y
        &lt;span class=&quot;dt&quot;&gt;SomeSing&lt;/span&gt; sz &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Identity&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toSing z
        return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Constructor-style is necessary for writing typeclass instances. You can’t write a &lt;code&gt;Show&lt;/code&gt; instance for &lt;code&gt;(forall hs. Network i hs o -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, but you can write one for &lt;code&gt;OpaqueNet i o&lt;/code&gt;. We’ll also be writing &lt;code&gt;Binary&lt;/code&gt; instances later for serialization/deserialization, and it all only works in constructor-style.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Haskell doesn’t allow you to use Rank-N types as arguments to type constructors, so you can have &lt;code&gt;[OpaqueNet i o]&lt;/code&gt;, but &lt;em&gt;not&lt;/em&gt; &lt;code&gt;[OpaqueNet&#39; i o r]&lt;/code&gt; or &lt;code&gt;[(forall hs. Network i hs o -&amp;gt; r) -&amp;gt; r]&lt;/code&gt;. You can have &lt;code&gt;MVar (OpaqueNet i o)&lt;/code&gt;, but not &lt;code&gt;MVar ((forall hs. Network i hs o -&amp;gt; r) -&amp;gt; r)&lt;/code&gt;. The latter are known as &lt;em&gt;impredicative&lt;/em&gt; types, which are a big no-no in GHC Haskell. Don’t even go there! The constructor style is necessary in these situations.&lt;/p&gt;
&lt;p&gt;If the type constructor is a Monad, you can get away with a ContT-style skolemization, like &lt;code&gt;(forall hs. Network i hs o -&amp;gt; [r]) -&amp;gt; [r]&lt;/code&gt; and &lt;code&gt;(forall hs. Network i hs o -&amp;gt; IO r) -&amp;gt; IO r&lt;/code&gt;. But this doesn’t work for &lt;code&gt;MVar&lt;/code&gt; and other useful type constructors you might want to put &lt;code&gt;OpaqueNet&lt;/code&gt; in.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When writing functions that &lt;em&gt;take&lt;/em&gt; existentials as inputs, the constructor-style is arguably more natural. But barely.&lt;/p&gt;
&lt;p&gt;For example, we wrote a function to find the number of hidden layers in a network earlier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;numHiddens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But the continuation-style version has a slightly messier type:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;numHiddens&amp;#39; ::&lt;/span&gt; ((forall hs&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even with with the type synonym, it’s still a little awkward:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;numHiddens&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&amp;#39;&lt;/span&gt; i o &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is why you’ll encounter many more functions &lt;em&gt;returning&lt;/em&gt; continuation-style existentials in libraries than &lt;em&gt;taking&lt;/em&gt; them, for the most part.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These are just general principles, not hard fast rules. This list is nowhere near exhaustive and reflects my current progress in my journey towards a dependently typed lifestyle. If you come back in a month, you might see more things listed here!&lt;/p&gt;
&lt;p&gt;All said, I do find myself very happy when I see that a library I’m using offers &lt;em&gt;both&lt;/em&gt; styles for me to use. And I’ve been known to submit PR’s to a library to have it offer one style or another, if it’s lacking.&lt;/p&gt;
&lt;p&gt;Be judicious. If you’re writing a library, don’t spam it with too many throwaway constructors. After a while, you’ll begin to intuitively see which style shines in which situations! (And, in some case, there might not even be a definitive “better” style to use.)&lt;/p&gt;
&lt;h2 id=&quot;serializing-networks&quot;&gt;Serializing Networks&lt;/h2&gt;
&lt;p&gt;To drive things home, let’s apply what we learned about existential types and reification to another simple application: serialization.&lt;/p&gt;
&lt;h3 id=&quot;recap-on-the-binary-library&quot;&gt;Recap on the Binary Library&lt;/h3&gt;
&lt;p&gt;Serializing networks of &lt;em&gt;known&lt;/em&gt; size — whose sizes are statically in their types — is pretty straightforward, and its ease is one of the often-quoted advantages of having sizes in your types.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; I’m going to be using the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/binary&quot;&gt;binary&lt;/a&gt;&lt;/em&gt; library, which offers a very standard typeclass-based approach for serializing and deserializing data. There are a lot of tutorials online (and I even &lt;a href=&quot;https://blog.jle.im/entry/streaming-huffman-compression-in-haskell-part-2-binary.html&quot;&gt;wrote a small one&lt;/a&gt; myself a few years ago), but a very high-level view is that the library offers monads (&lt;code&gt;Get&lt;/code&gt;, &lt;code&gt;Put&lt;/code&gt;) for describing serialization schemes and also a typeclass used to provide serialization instructions for different types.&lt;/p&gt;
&lt;p&gt;In practice, we usually don’t write our own instances from scratch. Instead, we use GHC’s generics features to give us instances for free:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L25-30&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
                     ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; o i)
                     }
  &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Generic&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Binary&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For simple types like &lt;code&gt;Weights&lt;/code&gt;, which simply contain serializable things, the &lt;em&gt;binary&lt;/em&gt; library is smart enough to write your instances automatically for you! This gives us &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;get ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Get&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)

&lt;span class=&quot;ot&quot;&gt;put ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Put&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, for GADTs like &lt;code&gt;Network&lt;/code&gt;, we have to things manually.&lt;/p&gt;
&lt;h4 id=&quot;serializing-network&quot;&gt;Serializing &lt;code&gt;Network&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Taking advantage of having the entire structure in the type, &lt;code&gt;put&lt;/code&gt; is simple:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L89-94&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;putNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Put&lt;/span&gt;
putNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w     &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; put w
    w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; put w &lt;span class=&quot;fu&quot;&gt;*&amp;gt;&lt;/span&gt; putNet n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If it’s an &lt;code&gt;O w&lt;/code&gt;, just serialize the &lt;code&gt;w&lt;/code&gt;. If it’s a &lt;code&gt;w :&amp;amp;~ net&lt;/code&gt;, serialize the &lt;code&gt;w&lt;/code&gt; then the rest of the &lt;code&gt;net&lt;/code&gt;. Normally, we might have to put a “flag” to tell what constructor we serializing, so that the deserializer can know what constructor to deserialize at every step. But for &lt;code&gt;Network&lt;/code&gt;, we don’t have to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L96-101&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getNet ::&lt;/span&gt; forall i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Get&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
getNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get
    &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; getNet ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;getNet&lt;/code&gt; doesn’t need flags because we already &lt;em&gt;know&lt;/em&gt; how many &lt;code&gt;:&amp;amp;~&lt;/code&gt; layers to expect &lt;em&gt;just from the type&lt;/em&gt;. If we want to deserialize a &lt;code&gt;Network 5 &#39;[10,6,3] 2&lt;/code&gt;, we &lt;em&gt;know&lt;/em&gt; we want three &lt;code&gt;(:&amp;amp;~)&lt;/code&gt;’s and one &lt;code&gt;O&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getNet&lt;/code&gt; is written similarly to how we wrote &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L79-83&quot;&gt;&lt;code&gt;randomNet&#39;&lt;/code&gt;&lt;/a&gt;. We “pattern match” on &lt;code&gt;hs&lt;/code&gt; (using singletons) to get the constructors we are expecting to deserialize and just follow what the singleton’s structure tells us.&lt;/p&gt;
&lt;p&gt;To write a &lt;code&gt;Binary&lt;/code&gt; instance for &lt;code&gt;Network&lt;/code&gt;, we can’t have &lt;code&gt;get&lt;/code&gt; take a &lt;code&gt;Sing hs&lt;/code&gt; input — that’d change the arity/type of the function. We have to switch to &lt;code&gt;SingI&lt;/code&gt;-style had have their &lt;code&gt;Binary&lt;/code&gt; instances require a &lt;code&gt;SingI hs&lt;/code&gt; constraint.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L103-105&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Binary&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; putNet
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getNet sing&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;serializating-opaquenet&quot;&gt;Serializating &lt;code&gt;OpaqueNet&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;It’s arguably much more useful to serialize/deserialize &lt;code&gt;OpaqueNet&lt;/code&gt;s. Between different iterations of your program, you might have the same inputs/outputs, but want to try out different internal structures. You’d want to store them and access them uniformly, or send them over a network without requiring the receiver to know the internal structure beforehand. Remember, you can’t even &lt;em&gt;load&lt;/em&gt; a &lt;code&gt;Network i hs o&lt;/code&gt; without knowing its complete structure!&lt;/p&gt;
&lt;p&gt;Because the complete structure of the network is not in the type, we need to encode it as a flag in the binary serialization so that the deserializer will know what constructors to expect and deserialize. We can write a simple function to get the &lt;code&gt;[Integer]&lt;/code&gt; of a network’s structure:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L72-77&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hiddenStruct ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;]
hiddenStruct &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; _    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; []
    _ &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; (&lt;span class=&quot;ot&quot;&gt;n&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs&amp;#39; o)
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; natVal (&lt;span class=&quot;dt&quot;&gt;Proxy&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;h)
            &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; hiddenStruct n&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recall that &lt;code&gt;natVal :: KnownNat n =&amp;gt; Proxy n -&amp;gt; Integer&lt;/code&gt; returns the value-level &lt;code&gt;Integer&lt;/code&gt; corresponding to the type-level &lt;code&gt;n :: Nat&lt;/code&gt;. (I’m also using GHC 8’s fancy &lt;em&gt;TypeApplications&lt;/em&gt; syntax, and &lt;code&gt;Proxy @h&lt;/code&gt; is the same as &lt;code&gt;Proxy :: Proxy h&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;natVal&lt;/code&gt; and &lt;code&gt;hiddenStruct&lt;/code&gt; are kind of interesting — they take type-level information (&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;hs&lt;/code&gt;) and turns them into term-level values (&lt;code&gt;Integer&lt;/code&gt;s, &lt;code&gt;[Integer]&lt;/code&gt;s). They are the opposites of our reification functions (like &lt;code&gt;toSing&lt;/code&gt;). Going from the “type level” to the “value level” is known in Haskell as &lt;strong&gt;reflection&lt;/strong&gt;, and is the dual concept of reification. (The &lt;em&gt;singletons&lt;/em&gt; library offers reflectors for all of its singletons, as &lt;code&gt;fromSing&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;That’s all we need!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L133-138&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;putONet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Put&lt;/span&gt;
putONet (&lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; net) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    put (hiddenStruct net)
    putNet net&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“Put the structure (as a binary flag), and then put the network itself.”&lt;/p&gt;
&lt;p&gt;Now, to deserialize, we want to &lt;em&gt;load&lt;/em&gt; the list of &lt;code&gt;Integer&lt;/code&gt;s and reify it back to the type level to know what type of network we’re expecting to load:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L140-145&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getONet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Get&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o)
getONet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    hs &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; get
    withSomeSing hs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;ONet&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getNet ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We load our flag, reify it, and once we’re back in the typed land again, we can do our normal business. Isn’t it nice that GHC is also there at every step to make sure we make the transition safely?&lt;/p&gt;
&lt;p&gt;Our final instance:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L147-149&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Binary&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;OpaqueNet&lt;/span&gt; i o) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; putONet
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getONet&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, of course, we used the constructor-style existential this whole time instead of the continuation-style one because we can’t directly write typeclass instances for the latter.&lt;/p&gt;
&lt;h2 id=&quot;an-existence-for-all&quot;&gt;An Existence For All&lt;/h2&gt;
&lt;p&gt;We’ve learned about how to “cross” from the untyped world to the typed world and bring about contexts involving types that can depend on runtime factors. To me, this is really the point where dependently typed programming starts — when you start having to work with types that depend on run-time factors.&lt;/p&gt;
&lt;p&gt;We’ve already been able to reap a lot of benefits. All of the type safety we discovered in the last part is now available to us in a fully dynamic world, as well. We also learned the advantages of &lt;em&gt;separating&lt;/em&gt; the typed world from the untyped world and how the compiler helps us make the transition safely.&lt;/p&gt;
&lt;p&gt;But really, this is all just the &lt;em&gt;start&lt;/em&gt; of dependently typed programming. This is where things &lt;em&gt;really&lt;/em&gt; start to get fun.&lt;/p&gt;
&lt;p&gt;Stepping into this new world can be disorienting at first. There’s a lot of unexpected things that come up when we start working more with these fancy new types. We have to deal with types coming from different sources, convince the type system about their properties and relationships between them, and deal with a whole bunch of other concerns that just don’t happen when you program only at the value level. But don’t worry! Like all things, it will more naturally with practice.&lt;/p&gt;
&lt;p&gt;Now that we have existential types and run-time types out of the way, come back for the next post in the series, where we start to have the &lt;em&gt;real&lt;/em&gt; fun! :D&lt;/p&gt;
&lt;h4 id=&quot;exercises&quot;&gt;Exercises&lt;/h4&gt;
&lt;p&gt;Here are some fun exercises you can try, if you want to test your understanding! Links are to the solutions.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Implement &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L188-193&quot;&gt;&lt;code&gt;putONet&#39;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L195-203&quot;&gt;&lt;code&gt;getONet&#39;&lt;/code&gt;&lt;/a&gt; using the continuation-style existentials, instead.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Work with an existential wrapper over the &lt;em&gt;entire&lt;/em&gt; network structure (inputs and outputs, too):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNet&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;SNet&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeNet&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We need the &lt;code&gt;KnownNat&lt;/code&gt; constraints because of type erasure, to recover the original input/output dimensions back once we pattern match)&lt;/p&gt;
&lt;p&gt;And write:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function to &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L231-234&quot;&gt;convert &lt;code&gt;SomeNet&lt;/code&gt;s to &lt;code&gt;OpaqueNet&lt;/code&gt;s&lt;/a&gt;. Return the &lt;code&gt;OpaqueNet&lt;/code&gt; with existentially quantified &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;o&lt;/code&gt; in continuation-style. (You can write a data type to return it in constructor-style, too, for funsies.)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L236-245&quot;&gt;&lt;code&gt;randomSNet&lt;/code&gt;&lt;/a&gt;, returning &lt;code&gt;m SomeNet&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;While you’re at it, write it to return &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L247-258&quot;&gt;a random continuation-style &lt;code&gt;SomeNet&lt;/code&gt;, too&lt;/a&gt;! (See the type of &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L178-186&quot;&gt;&lt;code&gt;withRandomONet&#39;&lt;/code&gt;&lt;/a&gt; for reference on how to write the type)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped2.hs#L260-274&quot;&gt;binary instance&lt;/a&gt; for &lt;code&gt;SomeNet&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hint: Remember &lt;code&gt;natVal :: KnownNat n =&amp;gt; Proxy n -&amp;gt; Integer&lt;/code&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hint: Remember that &lt;code&gt;toSomeSing&lt;/code&gt; also works for &lt;code&gt;Integer&lt;/code&gt;s, to get &lt;code&gt;Sing&lt;/code&gt;s for &lt;code&gt;Nat&lt;/code&gt;s, too!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;A bit of a stretch, because the set of all &lt;code&gt;[Nat]&lt;/code&gt;s is non-enumerable and uncountable, but hopefully you get the picture!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Recall that I recommend (personally, and subjectively) a style where your external API functions and typeclass instances are implemented in &lt;code&gt;SingI a =&amp;gt;&lt;/code&gt; style, and your internal ones in &lt;code&gt;Sing a -&amp;gt;&lt;/code&gt; style. This lets all of your internal functions fit together more nicely (&lt;code&gt;Sing a -&amp;gt;&lt;/code&gt; style tends to be easier to write in, especially if you stay in it the entire time, because &lt;code&gt;Sing&lt;/code&gt;s are normal first-class values, unlike those global and magical typeclasses) while at the same time removing the burden of calling with explicit singletons from people using the functionality externally.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;In older versions of singletons, before GHC 8 and &lt;em&gt;TypeInType&lt;/em&gt;, we had to implement it using “kind proxies”. Don’t worry if you’re following along in 7.10; the basic usage of &lt;code&gt;SomeSing&lt;/code&gt; is essentially identical either way.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;Skolemization is probably one of the coolest words you’ll encounter when learning/using Haskell, and sometimes just knowing that you’re “skolemizing” something makes you feel cooler. Thank you &lt;a href=&quot;https://en.wikipedia.org/wiki/Thoralf_Skolem&quot;&gt;Thoralf Skolem&lt;/a&gt;. If you ever see a “rigid, skolem” error in GHC, you can thank him for that too! He is also the inspiration behind my decision to name my first-born son Thoralf. (My second son’s name will be Curry)&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;It even lets you write &lt;code&gt;Storable&lt;/code&gt; instances!&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html</guid><pubDate>Thu, 30 Jun 2016 18:59:23 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2016-06-30</dc:date></item><item><title>Practical Dependent Types in Haskell: Type-Safe Neural Networks (Part 1)</title><link>https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html</link><description>&lt;p&gt;It seems these days like programming with dependent types in Haskell (and its advantages) is moving slowly but steadily to the mainstream of Haskell programming. In the current state of Haskell education, dependent types are often considered topics for “advanced” Haskell users. However, I can foresee a day where the ease of use of modern Haskell libraries relying on dependent types forces programming with dependent types to be an integral part of normal intermediate (or even beginner) Haskell education.&lt;/p&gt;
&lt;p&gt;There are &lt;a href=&quot;https://www.youtube.com/watch?v=rhWMhTjQzsU&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety&quot;&gt;more&lt;/a&gt; and &lt;a href=&quot;http://jozefg.bitbucket.org/posts/2014-08-25-dep-types-part-1.html&quot;&gt;more&lt;/a&gt; great resources and tutorials and introductions to integrating dependent types into your Haskell every day. The point of this series is to show more some practical examples of using dependent types in guiding your programming, and to also walk through the “why” and high-level philosophy of the way you structure your Haskell programs. It’ll also hopefully instill an intuition of a dependently typed work flow of “exploring” how dependent types can help your current programs. The intended audience of this post is for intermediate Haskell programmers in general, with no required knowledge of dependently typed programming. I should also point out that I’m no expert — I’m still in the process of learning this all, myself :)&lt;/p&gt;
&lt;p&gt;The first project in this series will build up to a type-safe &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot;&gt;artificial neural network&lt;/a&gt;&lt;/strong&gt; implementation with back-propagation training.&lt;/p&gt;
&lt;h4 id=&quot;setup&quot;&gt;Setup&lt;/h4&gt;
&lt;p&gt;This post is written on &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; snapshot &lt;em&gt;&lt;a href=&quot;https://www.stackage.org/nightly-2016-06-28&quot;&gt;nightly-2016-06-28&lt;/a&gt;&lt;/em&gt;, with &lt;em&gt;singletons-2.2&lt;/em&gt;, but uses an unreleased version of &lt;em&gt;hmatrix&lt;/em&gt;, &lt;em&gt;&lt;a href=&quot;https://github.com/albertoruiz/hmatrix/tree/42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1&quot;&gt;hmatrix-0.18 (commit 42a88fb)&lt;/a&gt;&lt;/em&gt;. I &lt;a href=&quot;http://mstksg.github.io/hmatrix/&quot;&gt;maintain my own documentation&lt;/a&gt; for reference.&lt;/p&gt;
&lt;p&gt;If you’re forced to use GHC 7.10 for some reason, there’s also a bug in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons-2.0.1&quot;&gt;singletons-2.0.1&lt;/a&gt;&lt;/em&gt; package that’s fixed in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/singletons-2.1&quot;&gt;singletons-2.1&lt;/a&gt;&lt;/em&gt;, but &lt;em&gt;2.1&lt;/em&gt; is not available with GHC 7.10 – I have a &lt;a href=&quot;https://github.com/mstksg/singletons/releases/tag/v2.0.2&quot;&gt;github fork&lt;/a&gt; that fixes the bug if you want to stay on GHC 7.10.&lt;/p&gt;
&lt;p&gt;You can add this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode yaml&quot;&gt;&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;packages:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;location:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;git:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; git@github.com:albertoruiz/hmatrix.git&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;commit:&lt;/span&gt;&lt;span class=&quot;at&quot;&gt; 42a88fbcb6bd1d2c4dc18fae5e962bd34fb316a1&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;subdirs:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; packages/base
&lt;span class=&quot;co&quot;&gt;# # If stuck on GHC 7.10:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# - location:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#     git: git@github.com:mstksg/singletons.git&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#     commit: v2.0.2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to the &lt;code&gt;packages&lt;/code&gt; field of your directory or global &lt;em&gt;stack.yaml&lt;/em&gt; and &lt;em&gt;stack&lt;/em&gt; will know what version of &lt;em&gt;hmatrix&lt;/em&gt; and &lt;em&gt;singletons&lt;/em&gt; to use when you use &lt;code&gt;stack runghc&lt;/code&gt; or &lt;code&gt;stack ghc&lt;/code&gt;, etc. to build your files.&lt;/p&gt;
&lt;h2 id=&quot;neural-networks&quot;&gt;Neural Networks&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_neural_network&quot;&gt;Artificial neural networks&lt;/a&gt; have been somewhat of a hot topic in computing recently. Implementations of training algorithms (like back-propagation) are tricky to implement correctly — despite being simple, there are many locations where accidental bugs might pop up when multiplying the wrong matrices, for example.&lt;/p&gt;
&lt;p&gt;Though some might recognize that complicated matrix and vector arithmetic is a common application of phantom type-based dependent types, it’s not necessarily always easy to gauge before-the-fact what would or would not be a good candidate for adding dependent types to. Often times, it can even be considered premature to start off with “as powerful types as you can”. So let’s walk through programming things with as “dumb” types as possible, and see where types can help.&lt;/p&gt;
&lt;p&gt;We’ll be following a process called “type-driven development” — start with general and non-descriptive types, write the implementation and recognize partial functions and red flags, and slowly refine and add more and more powerful types to fix the problems.&lt;/p&gt;
&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/dependent-haskell-1/ffneural.png&quot; title=&quot;Feed-forward ANN architecture&quot; alt=&quot;Feed-forward ANN architecture&quot; /&gt;&lt;figcaption&gt;Feed-forward ANN architecture&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Here’s a quick run through on background for ANN’s — but remember, this isn’t an article on ANN’s, so we are going to be glossing over some of the details.&lt;/p&gt;
&lt;p&gt;We’re going to be implementing a &lt;em&gt;feed-forward neural network&lt;/em&gt; with back-propagation training. These networks are layers of “nodes”, each connected to the each of the nodes of the previous layer. Input goes to the first layer, which feeds information to the next layer, which feeds it to the next, etc., until the final layer, where we read it off as the “answer” that the network is giving us. Layers between the input and output layers are called &lt;em&gt;hidden&lt;/em&gt; layers. Every node “outputs” a weighted sum of all of the outputs of the &lt;em&gt;previous&lt;/em&gt; layer, plus an always-on “bias” term (so that its result can be non-zero even when all of its inputs are zero). Symbolically, it looks like:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0Ay_j%20%3D%20b_j%20%2B%20%5Csum_i%5Em%20w_%7Bij%7D%20x_i%0A&quot; alt=&quot;
y_j = b_j + \sum_i^m w_{ij} x_i
&quot; title=&quot;
y_j = b_j + \sum_i^m w_{ij} x_i
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Or, if we treat the output of a layer and the list of list of weights as a matrix, we can write it a little cleaner:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7By%7D%20%3D%20%5Cmathbf%7Bb%7D%20%2B%20W%20%5Cmathbf%7Bx%7D%0A&quot; alt=&quot;
\mathbf{y} = \mathbf{b} + W \mathbf{x}
&quot; title=&quot;
\mathbf{y} = \mathbf{b} + W \mathbf{x}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;The result, the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;-vector of nodes &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7By%7D&quot; alt=&quot;\mathbf{y}&quot; title=&quot;\mathbf{y}&quot; /&gt;, is computed from the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n&quot; alt=&quot;n&quot; title=&quot;n&quot; /&gt;-vector of biases &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bb%7D&quot; alt=&quot;\mathbf{b}&quot; title=&quot;\mathbf{b}&quot; /&gt; and the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?n%20%5Ctimes%20m&quot; alt=&quot;n \times m&quot; title=&quot;n \times m&quot; /&gt; weight matrix &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?W&quot; alt=&quot;W&quot; title=&quot;W&quot; /&gt; multiplied with the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?m&quot; alt=&quot;m&quot; title=&quot;m&quot; /&gt;-vector input, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D&quot; alt=&quot;\mathbf{x}&quot; title=&quot;\mathbf{x}&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;To “scale” the result (and to give the system the magical powers of nonlinearity), we actually apply an “activation function” to the output before passing it down to the next step. We’ll be using the popular &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_function&quot;&gt;logistic function&lt;/a&gt;, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%28x%29%20%3D%201%20%2F%20%281%20%2B%20e%5E%7B-x%7D%29&quot; alt=&quot;f(x) = 1 / (1 + e^{-x})&quot; title=&quot;f(x) = 1 / (1 + e^{-x})&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Training&lt;/em&gt; a network involves picking the right set of weights to get the network to answer the question you want.&lt;/p&gt;
&lt;h2 id=&quot;vanilla-types&quot;&gt;Vanilla Types&lt;/h2&gt;
&lt;p&gt;We can store a network by storing the matrix of of weights and biases between each layer:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L18-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- n&lt;/span&gt;
                 ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Matrix&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- n x m&lt;/span&gt;
                 }                              &lt;span class=&quot;co&quot;&gt;-- &amp;quot;m to n&amp;quot; layer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, a &lt;code&gt;Weights&lt;/code&gt; linking an &lt;em&gt;m&lt;/em&gt;-node layer to an &lt;em&gt;n&lt;/em&gt;-node layer has an &lt;em&gt;n&lt;/em&gt;-dimensional bias vector (one component for each output) and an &lt;em&gt;n&lt;/em&gt;-by-&lt;em&gt;m&lt;/em&gt; node weight matrix (one column for each output, one row for each input).&lt;/p&gt;
&lt;p&gt;(We’re using the &lt;code&gt;Matrix&lt;/code&gt; type from the awesome &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library for performant linear algebra, implemented using blas/lapack under the hood)&lt;/p&gt;
&lt;p&gt;A feed-forward neural network is then just a linked list of these weights:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L22-28&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;     ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:&amp;amp;~) ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we’re using &lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/GADT&quot;&gt;GADT&lt;/a&gt; syntax here, which just lets us define &lt;code&gt;Network&lt;/code&gt; (with a kind signature, &lt;code&gt;*&lt;/code&gt;) by providing the type of its &lt;em&gt;constructors&lt;/em&gt;, &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;(:&amp;amp;~)&lt;/code&gt;. It’d be equivalent to the following normal data declaration:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A network with one input layer, two inner layers, and one output layer would look like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ih &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; ho&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first component is the weights from the input to first inner layer, the second is the weights between the two hidden layers, and the last is the weights between the last hidden layer and the output layer.&lt;/p&gt;
&lt;!-- TODO: graphs using diagrams? --&gt;
&lt;p&gt;We can write simple procedures, like generating random networks:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L46-56&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
randomWeights i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    seed1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
&lt;span class=&quot;ot&quot;&gt;    seed2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomVector  seed1 &lt;span class=&quot;dt&quot;&gt;Uniform&lt;/span&gt; o &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        wN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uniformSample seed2 o (replicate i (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN

&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
randomNet i []     o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights i o
randomNet i (h&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;hs) o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights i h &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; randomNet h hs o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(We’re using the &lt;code&gt;MonadRandom&lt;/code&gt; typeclass from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/MonadRandom&quot;&gt;MonadRandom&lt;/a&gt;&lt;/em&gt; library, which uses the mechanisms in &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/random-1.1/docs/System-Random.html&quot;&gt;System.Random&lt;/a&gt;&lt;/em&gt; and gives us a generic way of working with monads where we can get random values with &lt;code&gt;getRandom&lt;/code&gt;, etc.)&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:randomVector&quot;&gt;&lt;code&gt;randomVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#v:uniformSample&quot;&gt;&lt;code&gt;uniformSample&lt;/code&gt;&lt;/a&gt; are from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt; library, generating random vectors and matrices from a random &lt;code&gt;Int&lt;/code&gt; seed. We manipulate them here to generate them with numbers between -1 and 1)&lt;/p&gt;
&lt;p&gt;And now we can write a function to “run” our network on a given input vector, following the matrix equation we wrote earlier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L30-44&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;logistic ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
logistic x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; exp (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;x))

&lt;span class=&quot;ot&quot;&gt;runLayer ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
runLayer (&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v

&lt;span class=&quot;ot&quot;&gt;runNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;
runNet (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w)      &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
runNet (w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;) &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
                       &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  runNet n&amp;#39; v&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;#&amp;gt;&lt;/code&gt; is matrix-vector multiplication)&lt;/p&gt;
&lt;!-- TODO: examples of running --&gt;
&lt;p&gt;If you’re a non-Haskell programmer, this might all seem perfectly fine and normal, and you probably have only a slightly elevated heart rate. If you are a Haskell programmer, you are most likely already having heart attacks. Let’s imagine all of the bad things that could happen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;How do we know that we didn’t accidentally mix up the dimensions for our implementation of &lt;code&gt;randomWeights&lt;/code&gt;? We could have switched parameters and be none the wiser.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we even know that each subsequent matrix in the network is “compatible”? We want the outputs of one matrix to line up with the inputs of the next, but there’s no way to know. It’s possible to build a bad network, and things will just explode at runtime.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we know the size of vector the network expects? What stops you from sending in a bad vector at run-time? We might do runtime-checks, but the compiler won’t help us.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How do we verify that we have implemented &lt;code&gt;runLayer&lt;/code&gt; and &lt;code&gt;runNet&lt;/code&gt; in a way that they won’t suddenly fail at runtime? We write &lt;code&gt;l #&amp;gt; v&lt;/code&gt;, but how do we know that it’s even correct…what if we forgot to multiply something, or used something in the wrong places? We can it prove ourselves, but the compiler won’t help us.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;back-propagation&quot;&gt;Back-propagation&lt;/h3&gt;
&lt;p&gt;Now, let’s try implementing back-propagation! It’s a textbook gradient descent algorithm. There are &lt;a href=&quot;https://en.wikipedia.org/wiki/Backpropagation&quot;&gt;many explanations&lt;/a&gt; on the internet; the basic idea is that you try to minimize the squared error of what the neural network outputs for a given input vs. the actual expected output. You find the direction of change that minimizes the error (by finding the derivative), and move that direction. The implementation of backpropagation is found in many sources online and in literature, so let’s see the implementation in Haskell:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L58-96&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;train ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ learning rate&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ target vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;
train rate x0 target &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; go x0
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;-- handle the output layer&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN))
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;--   (logistic&amp;#39; is the derivative of logistic)&lt;/span&gt;
              dEdy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (o &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; target)
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&amp;#39;, dWs)
    &lt;span class=&quot;co&quot;&gt;-- handle the inner layers&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n)
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- get dWs&amp;#39;, bundle of derivatives from rest of the net&lt;/span&gt;
              (n&amp;#39;, dWs&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go o n
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              dEdy       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dWs&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; scale rate (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (w&amp;#39; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;, dWs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The algorithm computes the &lt;em&gt;updated&lt;/em&gt; network by recursively updating the layers, backwards up from the output layer. At every step, it returns the updated layer/network, as well as a bundle of derivatives (&lt;code&gt;dWs&lt;/code&gt;) for the next layer up to use to calculate its descent direction.&lt;/p&gt;
&lt;p&gt;At the output layer, all it needs to calculate the direction of descent is just &lt;code&gt;o - targ&lt;/code&gt;, the target. At the inner layers, it has to use the &lt;code&gt;dWs&lt;/code&gt; bundle it receives from the lower layers to figure it out. &lt;code&gt;dWs&lt;/code&gt; essentially “bubbles up” from the output layer up to the input layer calculations.&lt;/p&gt;
&lt;p&gt;Writing this is a bit of a struggle. I actually implemented this incorrectly several times before writing it as you see here. The type system doesn’t help you like it normally does in Haskell, and you can’t really use parametricity to help you write your code like normal Haskell. Everything is monomorphic, and everything multiplies with everything else. You don’t have any hints about what to multiply with what at any point in time. It’s like all of the bad things mentioned before, but amplified.&lt;/p&gt;
&lt;p&gt;In short, you’re leaving yourself open to many potential bugs…and the compiler doesn’t help you write your code at all! This is the nightmare of every Haskell programmer. There must be a better way!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;putting-it-to-the-test&quot;&gt;Putting it to the test&lt;/h4&gt;
&lt;p&gt;Pretty much the only way you can verify this code is to test it out on example cases. In the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs&quot;&gt;source file&lt;/a&gt;, I have &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkUntyped.hs#L128-136&quot;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; test out the backprop, training a network on a 2D function that was “on” for two small circles and “off” everywhere else (A nice cute non-linearly-separable function to test our network on). We basically train the network to be able to recognize the two-circle pattern. I implemented a simple printing function and tested the trained network on a grid:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; install hmatrix MonadRandom
$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; ghc -- -O2 ./NetworkUntyped.hs
$ &lt;span class=&quot;ex&quot;&gt;./NetworkUntyped&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Training network...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .=########=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          .##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          .##############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .###########&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                 ...             ...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                             -##########.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           -##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           ################&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            =############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                              .#######=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not too bad! The network learned to recognize the circles. But, I was basically forced to resort to unit testing to ensure my code was correct. Let’s see if we can do better.&lt;/p&gt;
&lt;h3 id=&quot;the-call-of-types&quot;&gt;The Call of Types&lt;/h3&gt;
&lt;p&gt;Before we go on to the “typed” version of our program, let’s take a step back and look at some big checks you might want to ask yourself after you write code in Haskell.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Are any of my functions either partial or implemented using partial functions?&lt;/li&gt;
&lt;li&gt;How could I have written things that are &lt;em&gt;incorrect&lt;/em&gt;, and yet still type check? Where does the compiler &lt;em&gt;not&lt;/em&gt; help me by restricting my choices?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both of these questions usually yield some truth about the code you write and the things you should worry about. As a Haskeller, they should always be at the back of your mind!&lt;/p&gt;
&lt;p&gt;Looking back at our untyped implementation, we notice some things:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Literally every single function we wrote is partial. Like, actually.&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; If we had passed in the incorrectly sized matrix/vector, or stored mismatched vectors in our network, everything would fall apart.&lt;/li&gt;
&lt;li&gt;There are billions of ways we could have implemented our functions where they would still typechecked. We could multiply mismatched matrices, or forget to multiply a matrix, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;with-static-size-indexed-types&quot;&gt;With Static Size-Indexed Types&lt;/h2&gt;
&lt;h3 id=&quot;networks&quot;&gt;Networks&lt;/h3&gt;
&lt;p&gt;Gauging our potential problems, it seems like the first major class of bugs we can address is improperly sized and incompatible matrices. If the compiler always made sure we used compatible matrices, we can avoid bugs at compile-time, and we also can get a friendly helper when we write programs (by knowing what works with what, and what we need were, and helping us organize our logic)&lt;/p&gt;
&lt;p&gt;Let’s write a &lt;code&gt;Weights&lt;/code&gt; type that tells you the size of its output and the input it expects. Let’s have, say, a &lt;code&gt;Weights 10 5&lt;/code&gt; be a set of weights that takes you from a layer of 10 nodes to a layer of 5 nodes. &lt;code&gt;w :: Weights 4 6&lt;/code&gt; would take you from a layer of 4 nodes to a layer of 6 nodes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L21-23&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; wBiases ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o)
                     ,&lt;span class=&quot;ot&quot;&gt; wNodes  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; o i)
                     }                      &lt;span class=&quot;co&quot;&gt;-- an &amp;quot;o x i&amp;quot; layer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type constructor &lt;code&gt;Weights&lt;/code&gt; has the kind &lt;code&gt;Weights :: Nat -&amp;gt; Nat -&amp;gt; *&lt;/code&gt; — it takes two types of kind &lt;code&gt;Nat&lt;/code&gt; (from the &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html&quot;&gt;GHC.TypeLits&lt;/a&gt;&lt;/em&gt; module, which the integer type literals give us with &lt;em&gt;&lt;a href=&quot;https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell#type-level-naturals&quot;&gt;DataKinds&lt;/a&gt;&lt;/em&gt; enabled) and returns a &lt;code&gt;*&lt;/code&gt; — a “normal type”.&lt;/p&gt;
&lt;p&gt;We’re using the &lt;em&gt;&lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html&quot;&gt;Numeric.LinearAlgebra.Static&lt;/a&gt;&lt;/em&gt; module from &lt;em&gt;&lt;a href=&quot;http://hackage.haskell.org/package/hmatrix&quot;&gt;hmatrix&lt;/a&gt;&lt;/em&gt;, which offers matrix and vector types with their size in their types: an &lt;code&gt;R 5&lt;/code&gt; is a vector of Doubles with 5 elements, and a &lt;code&gt;L 3 6&lt;/code&gt; is a 3x6 vector of Doubles.&lt;/p&gt;
&lt;p&gt;These types are called “dependent” types because the type itself &lt;em&gt;depends&lt;/em&gt; on its value. If an &lt;code&gt;R n&lt;/code&gt; contains a 5-element vector, its type is &lt;code&gt;R 5&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Static&lt;/em&gt; module in &lt;em&gt;hmatrix&lt;/em&gt; relies on the &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html#t:KnownNat&quot;&gt;&lt;code&gt;KnownNat&lt;/code&gt;&lt;/a&gt; mechanism that GHC offers. Almost all operations in the library require a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the type-level Nats — for example, you can take the dot product of two vectors with &lt;code&gt;dot :: KnownNat n =&amp;gt; R n -&amp;gt; R n -&amp;gt; Double&lt;/code&gt;. It lets the library use the information in the &lt;code&gt;n&lt;/code&gt; at runtime as an &lt;code&gt;Integer&lt;/code&gt;. (More on this later!)&lt;/p&gt;
&lt;p&gt;Moving on, our network type for this post will be something like &lt;code&gt;Network 10 &#39;[7,5,3] 2&lt;/code&gt;: Take 10 inputs, return 2 outputs — and internally, have hidden layers of size 7, 5, and 3. (The &lt;code&gt;&#39;[7,5,3]&lt;/code&gt; is a type-level list of Nats; the optional &lt;code&gt;&#39;&lt;/code&gt; apostrophe is just for our own benefit to distinguish it from a value-level list of integers.)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L25-32&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;     ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i &lt;span class=&quot;ch&quot;&gt;&amp;#39;[] o&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (:&amp;amp;~) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; h
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i h)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs o)
          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i (h &lt;span class=&quot;ch&quot;&gt;&amp;#39;: hs) o&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;infixr&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We use GADT syntax here again. The &lt;em&gt;kind signature&lt;/em&gt; of the type constructor means that the &lt;code&gt;Network&lt;/code&gt; type constructor takes three inputs: a &lt;code&gt;Nat&lt;/code&gt; (type-level numeral, like &lt;code&gt;10&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt;), list of &lt;code&gt;Nat&lt;/code&gt;s, and another &lt;code&gt;Nat&lt;/code&gt; (the input, hidden layers, and output sizes). Let’s go over the two constructors.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;O&lt;/code&gt; constructor takes a &lt;code&gt;Weights i o&lt;/code&gt; and returns a &lt;code&gt;Network i &#39;[] o&lt;/code&gt;. That is, if your network is just weights from &lt;code&gt;i&lt;/code&gt; inputs to &lt;code&gt;o&lt;/code&gt; outputs, your network itself just takes &lt;code&gt;i&lt;/code&gt; inputs and returns &lt;code&gt;o&lt;/code&gt; outputs, with no hidden layers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;(:&amp;amp;~)&lt;/code&gt; constructor takes a &lt;code&gt;Network h hs o&lt;/code&gt; – a network with &lt;code&gt;h&lt;/code&gt; inputs and &lt;code&gt;o&lt;/code&gt; outputs – and “conses” an extra input layer in front. If you give it a &lt;code&gt;Weights i h&lt;/code&gt;, its outputs fit perfectly into the inputs of the subnetwork, and you get a &lt;code&gt;Network i (h &#39;: hs) o&lt;/code&gt;. (&lt;code&gt;(&#39;:)&lt;/code&gt;, or &lt;code&gt;(:)&lt;/code&gt;, is the same as normal &lt;code&gt;(:)&lt;/code&gt;, but is for type-level lists. The apostrophe is optional here too, but it’s just nice to be able to visually distinguish the two)&lt;/p&gt;
&lt;p&gt;We add a &lt;code&gt;KnownNat&lt;/code&gt; constraint on the &lt;code&gt;h&lt;/code&gt;, so that whenever you pattern match on &lt;code&gt;w :&amp;amp;~ net&lt;/code&gt;, you automatically get a &lt;code&gt;KnownNat&lt;/code&gt; constraint for the input size of &lt;code&gt;net&lt;/code&gt; (and the output of &lt;code&gt;w&lt;/code&gt;) that the &lt;em&gt;hmatrix&lt;/em&gt; library can use.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can still construct them the same way:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- given:&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ih ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hh ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- we have:&lt;/span&gt;
              &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[] 2&lt;/span&gt;
       hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[4] 2&lt;/span&gt;
ih &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; hh &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ho ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[7,4] 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the shape of the constructors requires all of the weight vectors to “fit together”. &lt;code&gt;ih :&amp;amp;~ O ho&lt;/code&gt; would be a type error (feeding a 7-output layer to a 4-input layer). Also, if we ever pattern match on &lt;code&gt;:&amp;amp;~&lt;/code&gt;, we know that the resulting matrices and vectors are compatible!&lt;/p&gt;
&lt;p&gt;One neat thing is that this approach is also self-documenting. I don’t need to specify what the dimensions are in the docs and trust the users to read it and obey it. The types tell them! And if they don’t listen, they get a compiler error! (You should, of course, still provide reasonable documentation. But, in this case, the compiler actually enforces your documentation’s statements!)&lt;/p&gt;
&lt;p&gt;Generating random weights and networks is even nicer now:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L57-64&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
              &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)
randomWeights &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    s1 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
&lt;span class=&quot;ot&quot;&gt;    s2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getRandom
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; randomVector  s1 &lt;span class=&quot;dt&quot;&gt;Uniform&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
        wN &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; uniformSample s2 (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that the &lt;em&gt;Static&lt;/em&gt; versions of &lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:randomVector&quot;&gt;&lt;code&gt;randomVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://mstksg.github.io/hmatrix/Numeric-LinearAlgebra-Static.html#v:uniformSample&quot;&gt;&lt;code&gt;uniformSample&lt;/code&gt;&lt;/a&gt; don’t actually require the size of the vector/matrix you want as an input – they just use &lt;em&gt;type inference&lt;/em&gt; to figure out what size you want! This is the same process that &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; uses to figure out what type of thing you want to return. You would use &lt;code&gt;randomVector s Uniform :: R 10&lt;/code&gt;, and type inference would give you a 10-element vector the same way &lt;code&gt;read &amp;quot;hello&amp;quot; :: Int&lt;/code&gt; would give you an &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It’s important to note that it’s much harder to implement this incorrectly. Before, you could give the matrix the wrong dimensions (maybe you flipped the parameters?), or gave the wrong parameter to the vector generator.&lt;/p&gt;
&lt;p&gt;But here, you are guaranteed/forced to return the correctly sized vectors and matrices. In fact, you &lt;em&gt;don’t even have to worry&lt;/em&gt; about it — it’s handled automatically by the magic of type inference&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;! I consider this a very big victory. One of the whole points of types is to give you less to “worry about”, as a programmer. Here, we completely eliminate an &lt;em&gt;entire dimension&lt;/em&gt; of programmer concern.&lt;/p&gt;
&lt;h4 id=&quot;benefits-to-the-user&quot;&gt;Benefits to the user&lt;/h4&gt;
&lt;p&gt;Not only is this style nicer for you as the implementer, it’s also very beneficial for the &lt;em&gt;user&lt;/em&gt; of the function. Consider looking at the two competing type signatures side-by-side:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomWeights ::&lt;/span&gt;               m (&lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you want to &lt;em&gt;use&lt;/em&gt; this function, you have to look up some things from the documentation:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;What do the two arguments represent?&lt;/li&gt;
&lt;li&gt;What &lt;em&gt;order&lt;/em&gt; is the function expecting these two arguments?&lt;/li&gt;
&lt;li&gt;What will be the dimension of the result?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These are three things you &lt;em&gt;need&lt;/em&gt; to look up in the documentation. There’s simply no way around it.&lt;/p&gt;
&lt;p&gt;But, here, all of these questions are answered &lt;em&gt;immediately&lt;/em&gt;, just from the type (which you can get from GHC, or from ghci). You don’t need to worry about arguments. You don’t need to worry about what order the function is expecting the arguments to be in. And you already know &lt;em&gt;exactly&lt;/em&gt; what the dimensions of the result is, right in the type.&lt;/p&gt;
&lt;p&gt;I often implement many of my functions in this style, even if the rest of my program isn’t intended to be dependently typed (I can just convert the type to a “dumb” type as soon as I get the result). All of these benefits come even when the caller doesn’t &lt;em&gt;care&lt;/em&gt; at all about dependently typed programming — it’s just a better style of defining functions/offering an API!&lt;/p&gt;
&lt;h3 id=&quot;singletons-and-induction&quot;&gt;Singletons and Induction&lt;/h3&gt;
&lt;p&gt;The code for the updated &lt;code&gt;randomNet&lt;/code&gt; takes a bit of background to understand, so let’s take a quick detour through the concepts of singletons, dependent pattern matching, and induction on dependent data types.&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let’s say we want to implement an algorithm that can create any &lt;code&gt;Network i hs o&lt;/code&gt;, so that we can construct a &lt;code&gt;Network 4 &#39;[3,2] 1&lt;/code&gt; or something. In true Haskell fashion, we want do this recursively (“inductively”). After all, we know how to make a &lt;code&gt;Network i &#39;[] o&lt;/code&gt; (just &lt;code&gt;O &amp;lt;$&amp;gt; randomWeights&lt;/code&gt;), and we know how to create a &lt;code&gt;Network i (h &#39;: hs) o&lt;/code&gt; if we had a &lt;code&gt;Network h hs o&lt;/code&gt; (just use &lt;code&gt;(:&amp;amp;~)&lt;/code&gt; with &lt;code&gt;randomWeights&lt;/code&gt;). Now all we have to do is just “pattern match” on the type-level list, and…&lt;/p&gt;
&lt;p&gt;Oh wait. We can’t pattern match on types like that in Haskell. This is a consequence of one of Haskell’s fundamental design decisions: types are &lt;strong&gt;erased&lt;/strong&gt; at runtime. We need to have a way to “access” the type (at run-time) as a &lt;em&gt;value&lt;/em&gt; so we can pattern match on it and do things with it.&lt;/p&gt;
&lt;p&gt;In Haskell, the popular way to deal with this is by using &lt;em&gt;singletons&lt;/em&gt; — (parameterized) types which only have valid constructor. The canonical method of working with singletons in Haskell is with the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt;&lt;/em&gt; library, which provides a uniform interface for all sorts of singletons of types you’ll encounter in everyday use.&lt;/p&gt;
&lt;p&gt;We want to “pattern match” on a type-level list, so we want a singleton for lists. The &lt;em&gt;singletons&lt;/em&gt; library provides them:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[]&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; as &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; (a &lt;span class=&quot;ch&quot;&gt;&amp;#39;: as)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that if we ever get value of type &lt;code&gt;Sing as&lt;/code&gt; (and &lt;code&gt;as&lt;/code&gt; is a type-level list), we can pattern match on it. If we match on the &lt;code&gt;SNil&lt;/code&gt; constructor, we &lt;em&gt;know&lt;/em&gt; it’s a &lt;code&gt;Sing &#39;[]&lt;/code&gt; in that branch, and if we match on the &lt;code&gt;SCons&lt;/code&gt; constructor, we &lt;em&gt;know&lt;/em&gt; it’s a &lt;code&gt;Sing (a &#39;: as)&lt;/code&gt; – a non-empty list. This is called &lt;em&gt;dependent pattern matching&lt;/em&gt;. Every “branch” of your case statement has a different inferred type of the arguments, depending on the constructor you match on.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; foo &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- here, GHC knows `foo :: Sing &amp;#39;[]`&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SCons&lt;/span&gt; _ _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- here, GHC knows `foo :: Sing (a &amp;#39;: as)`&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;singletons&lt;/em&gt; actually provides a whole bunch of singleton constructors for different types and kinds, like for &lt;code&gt;Bool&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(That’s the &lt;em&gt;type&lt;/em&gt; &lt;code&gt;&#39;True&lt;/code&gt;, of &lt;em&gt;kind&lt;/em&gt; &lt;code&gt;Bool&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;So, if we ever are given a &lt;code&gt;Sing b&lt;/code&gt; with some type-level &lt;code&gt;Bool&lt;/code&gt; we don’t know, we can pattern match on it. And in the branch that &lt;code&gt;STrue&lt;/code&gt; matches on, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;&#39;True&lt;/code&gt;, and in the branch that &lt;code&gt;SFalse&lt;/code&gt; matches on, &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Singletons give us a way to pattern match on types by having an actual term-level value we can pattern match on. So, we &lt;em&gt;could&lt;/em&gt; implement:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;randomNet&lt;/code&gt; gets to directly pattern match and deconstruct on &lt;code&gt;Sing hs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, for actual API’s, it’s often more convenient to &lt;em&gt;not&lt;/em&gt; require the extra parameter, and have it be “inferred” in the way we’ve been doing it before. That way the &lt;em&gt;user&lt;/em&gt; doesn’t have the burden of supplying it. The &lt;em&gt;singletons&lt;/em&gt; library offers a typeclass we can use to implicitly conjure up values of a singleton type – &lt;code&gt;SingI&lt;/code&gt;. We can use &lt;code&gt;sing :: SingI s =&amp;gt; Sing s&lt;/code&gt; to generate the “inferred” singleton:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[]&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; sing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;ch&quot;&gt;&amp;#39;False, &amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SFalse&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;STrue&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So if you have a function &lt;code&gt;SingI hs =&amp;gt; ...&lt;/code&gt;, it’s really no different than &lt;code&gt;Sing hs -&amp;gt; ...&lt;/code&gt;. The function itself gets to use a &lt;code&gt;Sing hs&lt;/code&gt; either way … but for the first, the argument is implicit.&lt;/p&gt;
&lt;p&gt;The final piece of the puzzle is the singleton for a type-level &lt;code&gt;Nat&lt;/code&gt;. It’s a little different because when you pattern match on it, instead of directly learning about the type, you “receive” a &lt;code&gt;KnownNat&lt;/code&gt; instance you can use.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- `foo :: Sing n`, but we don&amp;#39;t know what `n` it is&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; foo &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;-- in this branch, we have a `KnownNat n` instance&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essentially, the data constructor comes “packaged” with a &lt;code&gt;KnownNat n&lt;/code&gt; instance. The &lt;em&gt;creation&lt;/em&gt; of &lt;code&gt;SNat :: Sing n&lt;/code&gt; requires the presence of &lt;code&gt;KnownNat n&lt;/code&gt;. So if you ever pattern match on a validly created &lt;code&gt;SNat&lt;/code&gt;, the fact that that &lt;code&gt;SNat&lt;/code&gt; constructor even exists (instead of, say, being &lt;code&gt;undefined&lt;/code&gt;) is a &lt;em&gt;witness&lt;/em&gt; to that very &lt;code&gt;KnownNat&lt;/code&gt; instance, and the type system lets us use this. It’s as if you “pattern match” out the instance itself, like any other value the constructor might have.&lt;/p&gt;
&lt;p&gt;Now we have enough pieces of the puzzle:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L66-75&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;randomNet ::&lt;/span&gt; forall m i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;MonadRandom&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;SingI&lt;/span&gt; hs, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
          &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o)
randomNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go sing
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; forall h hs&amp;#39;&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; h
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs&amp;#39;
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; h hs&amp;#39; o)
    go &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;            &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights
        &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; ss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; randomWeights &lt;span class=&quot;fu&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; go ss&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The real heavy lifting is done by &lt;code&gt;go&lt;/code&gt; (written with &lt;a href=&quot;https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase&quot;&gt;LambdaCase&lt;/a&gt;), which takes the singleton structure it needs and recursively calls it until it reaches the base case (&lt;code&gt;SNil&lt;/code&gt;, an output layer). We just call &lt;code&gt;go sing&lt;/code&gt; to give it the initial structure it needs. Note there, &lt;code&gt;sing :: Sing hs&lt;/code&gt;, but this is inferred, because &lt;code&gt;go&lt;/code&gt; is &lt;code&gt;Sing hs -&amp;gt; Network i hs o&lt;/code&gt;, and it’s being asked to return a &lt;code&gt;Network i hs o&lt;/code&gt;, so it’s safely inferable that we want &lt;code&gt;Sing hs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Remember that we can write &lt;code&gt;O &amp;lt;$&amp;gt; randomWeights&lt;/code&gt; because &lt;code&gt;randomWeights&lt;/code&gt;, like &lt;code&gt;read&lt;/code&gt;, adapts to whatever type we want from it — in this case, we ask for a &lt;code&gt;Weights h o&lt;/code&gt;, and type inference is the real hero.&lt;/p&gt;
&lt;p&gt;When possible, we like to write functions like &lt;code&gt;go&lt;/code&gt; that take &lt;em&gt;explicit&lt;/em&gt; singletons. In a lot of situations, we’ll actually write our internal &lt;em&gt;logic&lt;/em&gt; itself using explicit singletons, and only use &lt;code&gt;SingI&lt;/code&gt; and implicit singletons at the &lt;em&gt;external&lt;/em&gt; boundaries of our API (like &lt;code&gt;randomNet&lt;/code&gt;) for convenience to the user.&lt;/p&gt;
&lt;p&gt;We’ve stumbled upon common pattern in dependent Haskell: “building up” a value-level singleton &lt;em&gt;structure&lt;/em&gt; from a type that we want (either explicitly given as an argument, or provided through a typeclass like &lt;code&gt;SingI&lt;/code&gt;) and then inductively piggybacking on that structure’s constructors to build the thing you &lt;em&gt;really&lt;/em&gt; want (called “elimination”). Here, we use &lt;code&gt;SingI hs&lt;/code&gt; and “eliminate” that structure to create our &lt;code&gt;Network i hs o&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;on-typeclasses-and-dictionaries&quot;&gt;On Typeclasses and Dictionaries&lt;/h4&gt;
&lt;p&gt;One of the more bizarre things here, to me, is that &lt;code&gt;SNat&lt;/code&gt; somehow gave us a &lt;code&gt;KnownNat n&lt;/code&gt; instance that we can use and pass off to &lt;code&gt;randomWeights&lt;/code&gt;. However, once you realize that typeclasses in Haskell really aren’t any more than a way to pass in implicit arguments, it starts to make sense.&lt;/p&gt;
&lt;p&gt;The only thing you can really do from a &lt;code&gt;KnownNat&lt;/code&gt; is to get an &lt;code&gt;Integer&lt;/code&gt; from it with &lt;code&gt;natVal&lt;/code&gt;. So really, &lt;code&gt;KnownNat n =&amp;gt; ...&lt;/code&gt; is more or less the same as &lt;code&gt;Integer -&amp;gt; ...&lt;/code&gt;. That’s right — at runtime, a &lt;code&gt;KnownNat n&lt;/code&gt; constraint is more or less just an &lt;code&gt;Integer&lt;/code&gt; that GHC passes around automatically for you, to save you the hassle of manually passing it in yourself. (We say that the “dictionary” of &lt;code&gt;KnownNat&lt;/code&gt; is &lt;code&gt;Integer&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;So, the constructor:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is really &lt;em&gt;kind&lt;/em&gt; of like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; n
&lt;span class=&quot;co&quot;&gt;-- or, in normal data type notation&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- kinda!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The GADT constructor for &lt;code&gt;SNat&lt;/code&gt; requires a &lt;code&gt;KnownNat n&lt;/code&gt; instance in scope to produce. That instance is essentially stored inside the constructor (as if it were just an &lt;code&gt;Integer&lt;/code&gt;). Then, later, when you pattern match on it, you pattern match out the instance that was originally put in there, and you can use it!&lt;/p&gt;
&lt;p&gt;So what’s the big deal, why not just ditch &lt;code&gt;KnownNat&lt;/code&gt; and just pass around integers? The difference is that GHC and the compiler can now &lt;em&gt;track&lt;/em&gt; these at compile-time to give you &lt;em&gt;checks&lt;/em&gt; on how your Nat’s act together on the type level, allowing it to catch mismatches with compile-time checks instead of run-time checks.&lt;/p&gt;
&lt;h3 id=&quot;running-with-it&quot;&gt;Running with it&lt;/h3&gt;
&lt;p&gt;So now, you can use &lt;code&gt;randomNet :: IO (Network 5 &#39;[4,3] 2)&lt;/code&gt; to get a random network of the desired dimensions! (&lt;code&gt;IO&lt;/code&gt; is an instance of &lt;code&gt;MonadRandom&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;Can we just pause right here to just appreciate how awesome it is that we can generate random networks of whatever size we want by &lt;em&gt;just requesting something by its type&lt;/em&gt;? Our implementation is also &lt;em&gt;guaranteed&lt;/em&gt; to have the right sized matrices — no worrying about using the right size parameters for the right matrix in the right order. GHC does it for you automatically! And, for the person who &lt;em&gt;uses&lt;/em&gt; &lt;code&gt;randomNet&lt;/code&gt;, they don’t have to bungle around with figuring out what function argument indicates what, and in what order, and they don’t have to play a guessing game about the shape of the returned matrix.&lt;/p&gt;
&lt;p&gt;The code for &lt;em&gt;running&lt;/em&gt; the nets is actually literally identical from before:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L42-55&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runLayer ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Weights&lt;/span&gt; i o
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
         &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runLayer (&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; v

&lt;span class=&quot;ot&quot;&gt;runNet ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o
runNet &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
   &lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \(&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; logistic (runLayer w v)
   (w &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; \(&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;v) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; v&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic (runLayer w v)
                          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; runNet n&amp;#39; v&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now, we get the assurance that the matrices and vectors all fit each-other, at compile-time. GHC basically writes our code for us. The operations all demand vectors and matrices that “fit together”, so you can only ever multiply a matrix by a properly sized vector.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(+)  ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n
     &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n
&lt;span class=&quot;ot&quot;&gt;(#&amp;gt;) ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; m)
     &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;L&lt;/span&gt; n m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n

&lt;span class=&quot;ot&quot;&gt;logistic ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; n
         &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The source code is the same from before, so there isn’t any extra overhead in annotation. The correctness proofs and guarantees basically come without any extra work — they’re free!&lt;/p&gt;
&lt;p&gt;Our back-prop algorithm is ported pretty nicely too:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L77-116&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;train ::&lt;/span&gt; forall i hs o&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; i, &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; o)
      &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Double&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- ^ learning rate&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; i              &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; o              &lt;span class=&quot;co&quot;&gt;-- ^ target vector&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o   &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o
train rate x0 target &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; go x0
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go  ::&lt;/span&gt; forall j js&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;KnownNat&lt;/span&gt; j
        &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; j              &lt;span class=&quot;co&quot;&gt;-- ^ input vector&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; j js o   &lt;span class=&quot;co&quot;&gt;-- ^ network to train&lt;/span&gt;
        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; j js o, &lt;span class=&quot;dt&quot;&gt;R&lt;/span&gt; j)
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN))
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;--   (logistic&amp;#39; is the derivative of logistic)&lt;/span&gt;
              dEdy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (o &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; target)
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (&lt;span class=&quot;dt&quot;&gt;O&lt;/span&gt; w&amp;#39;, dWs)
    &lt;span class=&quot;co&quot;&gt;-- handle the inner layers&lt;/span&gt;
    go &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x (w&lt;span class=&quot;fu&quot;&gt;@&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB wN) &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n)
        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; runLayer w x
              o          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic y
              &lt;span class=&quot;co&quot;&gt;-- get dWs&amp;#39;, bundle of derivatives from rest of the net&lt;/span&gt;
              (n&amp;#39;, dWs&amp;#39;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go o n
              &lt;span class=&quot;co&quot;&gt;-- the gradient (how much y affects the error)&lt;/span&gt;
              dEdy       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; logistic&amp;#39; y &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dWs&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- new bias weights and node weights&lt;/span&gt;
              wB&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wB &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; dEdy
              wN&amp;#39;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wN &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; konst rate &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; (dEdy &lt;span class=&quot;ot&quot;&gt;`outer`&lt;/span&gt; x)
              w&amp;#39;   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt; wB&amp;#39; wN&amp;#39;
              &lt;span class=&quot;co&quot;&gt;-- bundle of derivatives for next step&lt;/span&gt;
              dWs  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; tr wN &lt;span class=&quot;fu&quot;&gt;#&amp;gt;&lt;/span&gt; dEdy
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  (w&amp;#39; &lt;span class=&quot;fu&quot;&gt;:&amp;amp;~&lt;/span&gt; n&amp;#39;, dWs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s pretty much again almost an exact copy-and-paste, but now with GHC checking to make sure everything fits together in our implementation.&lt;/p&gt;
&lt;p&gt;One thing that’s hard for me to convey here without walking through the implementation step-by-step is how much the types &lt;em&gt;help you&lt;/em&gt; in writing this code.&lt;/p&gt;
&lt;p&gt;Before starting writing a back-prop implementation without the help of types, I’d probably be a bit concerned. I mentioned earlier that writing the untyped version was no fun at all. But, with the types, writing the implementation became a &lt;em&gt;joy&lt;/em&gt; again. And, you have the help of &lt;em&gt;hole driven development&lt;/em&gt;, too.&lt;/p&gt;
&lt;p&gt;If you need, say, an &lt;code&gt;R n&lt;/code&gt;, there might be only one way get it! And if you have something that you need to combine with something you don’t know about, you can use typed holes (&lt;code&gt;_&lt;/code&gt;) and GHC will give you a list of all the values you have in scope that can fit there. Your programs basically write themselves!&lt;/p&gt;
&lt;p&gt;The more you can restrict the implementations of your functions with your types, the more of a joy programming in Haskell is. Things fit together and fall together before your eyes…and the best part is that if they’re wrong, the compiler will nudge you gently into the correct direction.&lt;/p&gt;
&lt;p&gt;The most stressful part of programming happens when you have to tenuously hold a complex and fragile network of ideas and constraints in your brain, and any slight distraction or break in focus causes everything to crash down in your mind. Over time, people have begun to believe that this is “normal” in programming. Don’t believe this lie — it’s &lt;em&gt;not&lt;/em&gt;! A good programming experience involves maintaining as &lt;em&gt;little&lt;/em&gt; in your head as possible, and letting the compiler handle remembering/checking the rest.&lt;/p&gt;
&lt;h4 id=&quot;the-final-test&quot;&gt;The final test&lt;/h4&gt;
&lt;p&gt;You can download the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs&quot;&gt;typed network&lt;/a&gt; source code and run it yourself. Again, the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L151-159&quot;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt; method is written identically to that of the other file and tests the identical function.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; install hmatrix MonadRandom singletons
$ &lt;span class=&quot;ex&quot;&gt;stack&lt;/span&gt; ghc -- -O2 ./NetworkTyped.hs
$ &lt;span class=&quot;ex&quot;&gt;./NetworkTyped&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Training network...&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#             -#########-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#           -#############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          -###############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#          =###############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#           ##############=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#            .##########=.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                               .==#=-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            -###########-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           =##############.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                          .###############=&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                           =##############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                            =############-&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#                              -######=-.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;finding-something-to-depend-on&quot;&gt;Finding Something to Depend on&lt;/h2&gt;
&lt;p&gt;We wrote out an initial “non-typed” implementation and recognized a lot red flags that you might already be trained to recognize if you have been programming Haskell for a while: &lt;em&gt;partial functions&lt;/em&gt; and &lt;em&gt;multiple potential implementations&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We followed our well-tuned Haskell guts, listened to our hearts, and introduced extra power in our types to remove all partial functions and eliminate &lt;em&gt;most&lt;/em&gt; potential implementations (though not all, yet — there are more gains to be made from pulling in more parametric polymorphism).&lt;/p&gt;
&lt;p&gt;Though we might have been able to find the bugs we avoided “eventually”, we were able to remove entire &lt;em&gt;dimensions&lt;/em&gt; of programmer concern and also leverage parametric polymorphism to help write our programs for us. We found joy again in programming.&lt;/p&gt;
&lt;p&gt;In the process, however, we encountered some unexpected resistance from Haskell (the language). We couldn’t directly pattern match on our types, so we ended up playing games with singletons and GADT constructors to pass instances.&lt;/p&gt;
&lt;p&gt;In practice, using types as powerful and descriptive as these begin to require a whole new set of tools once you get past the simplest use cases here. For example, our &lt;code&gt;Network&lt;/code&gt; types so far required you to specify their size in the program itself (&lt;code&gt;Network 2 &#39;[16, 8] 1&lt;/code&gt; in the example source code, for instance). But what if we wanted to generate a network that has runtime-determined size (For example, getting the size from user input)? What if we wanted to load a pre-trained network whose size we don’t know? How can we manipulate our networks in a “dynamic” and generic way that still gives us all of the benefits of type-safe programming? We’ll found out next post!&lt;/p&gt;
&lt;p&gt;What we’re looking at here is a world where &lt;em&gt;types&lt;/em&gt; can depend on run-time values … and values can depend on types. A world where types can be returned from functions and where types become as much of a manipulatable citizen of as values are.&lt;/p&gt;
&lt;p&gt;The art of working with types like this is &lt;em&gt;dependently typed programming&lt;/em&gt;. We’re going to feel a bit of push back from Haskell at first, but after we hit our stride and tame the tools we need, we’re going to open up a whole new world of potential!&lt;/p&gt;
&lt;h3 id=&quot;exercises&quot;&gt;Exercises&lt;/h3&gt;
&lt;p&gt;Here are some exercises you can do for fun to test your understanding and apply some of the concepts! The links are to the solutions in the source file.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Write a function that &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L167-168&quot;&gt;“pops” the input layer&lt;/a&gt; off of a &lt;code&gt;Network&lt;/code&gt;, returning both the input layer’s weights and the rest of the network, &lt;code&gt;(Weights i h, Network h hs o)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Think about what its type would have to be. Could it possibly be called with a network that cannot be popped? (that is, that has only one layer?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L170-187&quot;&gt;function that takes two networks of the same dimensions and adds together their weights&lt;/a&gt;. Remember that &lt;code&gt;L m n&lt;/code&gt; has a &lt;code&gt;Num&lt;/code&gt; instance that adds the matrices together element-by-element.&lt;/p&gt;
&lt;p&gt;Could this function ever be accidentally called on two networks that have different internal structures?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Write a function that takes a &lt;code&gt;Network i hs o&lt;/code&gt; and &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/dependent-haskell/NetworkTyped.hs#L189-192&quot;&gt;returns the singleton representing its hidden layer structure&lt;/a&gt; — &lt;code&gt;Sing hs&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;hiddenSing ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; i hs o &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; hs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;&amp;lt;- randomNet ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Network&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[5,3] 1)&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; s &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; hiddenSing n
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t s
&lt;span class=&quot;ot&quot;&gt;s ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Sing&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;[5,3]&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; s
&lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNat&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;`SCons`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SNil&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;This sentence is the story of my Haskell life.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Okay, maybe not &lt;em&gt;literally&lt;/em&gt; every one. But, pretty much every one.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Thank you based Hindley-Milner.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;This entire section was previously written to use the &lt;a href=&quot;http://hackage.haskell.org/package/typelits-witnesses&quot;&gt;typelits-witnesses&lt;/a&gt; library, but has now been re-written to use the canonical &lt;a href=&quot;https://hackage.haskell.org/package/singletons&quot;&gt;singletons&lt;/a&gt; library after a &lt;a href=&quot;https://www.reddit.com/r/haskell/comments/4l199z/practical_dependent_types_in_haskell_type_safe/d3jkslv&quot;&gt;conversation&lt;/a&gt; with Andras Kovacs. The &lt;a href=&quot;https://github.com/mstksg/inCode/blob/697c1f726b9ab9c3f9830ed5521bfeee6ec10727/entry/practical-dependent-types-in-haskell-1.md#singletons-and-induction&quot;&gt;old version&lt;/a&gt; is still online at github, if you want to look at it or compare!&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html</guid><pubDate>Wed, 25 May 2016 19:46:21 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2016-05-25</dc:date></item><item><title>Automatic Propagation of Uncertainty with AD</title><link>https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html</link><description>&lt;blockquote&gt;
&lt;p&gt;This post and &lt;a href=&quot;https://blog.jle.im/entries/series/+uncertain.html&quot;&gt;series&lt;/a&gt; is a walk-through of the implementation of my &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; library, now on hackage!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some of my favorite Haskell “tricks” involve working with exotic numeric types with custom “overloaded” numeric functions and literals that let us work with data in surprisingly elegant and expressive ways.&lt;/p&gt;
&lt;p&gt;Here is one example — from my work in experimental physics and statistics, we often deal with experimental/sampled values with inherent uncertainty. If you ever measure something to be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?12.3%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.3\,\mathrm{cm}&quot; title=&quot;12.3\,\mathrm{cm}&quot; /&gt;, that doesn’t mean it’s &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?12.300000%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.300000\,\mathrm{cm}&quot; title=&quot;12.300000\,\mathrm{cm}&quot; /&gt; — it means that it’s somewhere between &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?12.2%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.2\,\mathrm{cm}&quot; title=&quot;12.2\,\mathrm{cm}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?12.4%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.4\,\mathrm{cm}&quot; title=&quot;12.4\,\mathrm{cm}&quot; /&gt;…and we don’t know exactly. We can write it as &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?12.3%20%5Cpm%200.1%5C%2C%5Cmathrm%7Bcm%7D&quot; alt=&quot;12.3 \pm 0.1\,\mathrm{cm}&quot; title=&quot;12.3 \pm 0.1\,\mathrm{cm}&quot; /&gt;. The interesting thing happens when we try to add, multiply, divide numbers with uncertainty. What happens when you “add” &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?12%20%5Cpm%203&quot; alt=&quot;12 \pm 3&quot; title=&quot;12 \pm 3&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?19%20%5Cpm%206&quot; alt=&quot;19 \pm 6&quot; title=&quot;19 \pm 6&quot; /&gt;?&lt;/p&gt;
&lt;p&gt;The initial guess might be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?31%20%5Cpm%209&quot; alt=&quot;31 \pm 9&quot; title=&quot;31 \pm 9&quot; /&gt;, because one is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%203&quot; alt=&quot;\pm 3&quot; title=&quot;\pm 3&quot; /&gt; and the other is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%206&quot; alt=&quot;\pm 6&quot; title=&quot;\pm 6&quot; /&gt;. But! If you actually do experiments like this several times, you’ll see that this isn’t the case. If you tried this out experimentally and simulate several hundred trials, you’ll see that the answer is actually something like &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?31%20%5Cpm%207&quot; alt=&quot;31 \pm 7&quot; title=&quot;31 \pm 7&quot; /&gt;. (We’ll explain why later, but feel free to stop reading this article now and try this out yourself!&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Let’s write ourselves a Haskell data type that lets us work with “numbers with inherent uncertainty”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;   &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;450&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sqrt (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)
&lt;span class=&quot;fl&quot;&gt;6.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; logBase y x
&lt;span class=&quot;fl&quot;&gt;0.78&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; log (x&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;y)
&lt;span class=&quot;fl&quot;&gt;85.9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Along the way, we’ll also learn how to harness the power of awesome &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; library, a library used in implementing back-propagation and other optimization algorithms, to analyze numerical functions in a mathematical way and break down their derivatives and gradients.&lt;/p&gt;
&lt;p&gt;You can follow along with &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs&quot;&gt;the source code&lt;/a&gt;, which is actually a &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; executable! If you download the source and you have &lt;em&gt;&lt;a href=&quot;http://www.haskellstack.org&quot;&gt;stack&lt;/a&gt;&lt;/em&gt; installed, you can run it (and run the tests above) as an executable:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;ex&quot;&gt;./Uncertain.hs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Otherwise, you can run it directly with stack (using &lt;code&gt;runhaskell&lt;/code&gt;) and the &lt;a href=&quot;shttp://hackage.haskell.org/package/linear/docs/Linear-V2.html&quot;&gt;linear&lt;/a&gt; and &lt;a href=&quot;https://hackage.haskell.org/package/ad&quot;&gt;ad&lt;/a&gt; packages installed…or load it up with &lt;code&gt;stack ghci&lt;/code&gt; to play with it. If you want to be sure to reproduce the behavior, this article was written under &lt;a href=&quot;https://www.stackage.org/&quot;&gt;stackage&lt;/a&gt; snapshot &lt;a href=&quot;https://www.stackage.org/lts-5.15&quot;&gt;lts-5.15&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;dealing-with-uncertainty-precisely&quot;&gt;Dealing with Uncertainty Precisely&lt;/h2&gt;
&lt;p&gt;First of all, let’s think about why adding two “uncertain” values doesn’t involve simply adding the uncertainties linearly. (If you don’t care about the math and just want to get on to the Haskell, feel free to skip this section!)&lt;/p&gt;
&lt;p&gt;If I have a value &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?16%20%5Cpm%203&quot; alt=&quot;16 \pm 3&quot; title=&quot;16 \pm 3&quot; /&gt; (maybe I have a ruler whose ticks are 3 units apart, or an instrument that produces measurements with 3 units of noise), it either means that it’s a little below 16 or a little above 16. If I have an independently sampled value &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?25%20%5Cpm%204&quot; alt=&quot;25 \pm 4&quot; title=&quot;25 \pm 4&quot; /&gt;, it means that it’s a little below 25 or a little above 25.&lt;/p&gt;
&lt;p&gt;What happens if I want to think about their sum? Well, it’s going to be somewhere around 41. But, the uncertainty won’t be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. It would only be &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt; if the errors in the two values are &lt;em&gt;always aligned&lt;/em&gt;. Only if or when every “little bit above” 16 error lines up perfectly with a “little bit above” 25 error, and when every single “little bit below” 16 error lines up perfectly with a “little bit above” 25 error, would you really get something that is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. But, because the two values are sampled independently, you shouldn’t expect such alignment. So, you’ll get an uncertainty that’s &lt;em&gt;less than&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%207&quot; alt=&quot;\pm 7&quot; title=&quot;\pm 7&quot; /&gt;. In fact, it’ll actually be around &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cpm%205&quot; alt=&quot;\pm 5&quot; title=&quot;\pm 5&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;In general, we find that for &lt;em&gt;independent&lt;/em&gt; &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7BVar%7D%5BaX%20%2B%20bY%20%2B%20c%5D%20%3D%20a%5E2%20%5Csigma_X%5E2%20%2B%20b%5E2%20%5Csigma_Y%5E2%0A&quot; alt=&quot;
\operatorname{Var}[aX + bY + c] = a^2 \sigma_X^2 + b^2 \sigma_Y^2
&quot; title=&quot;
\operatorname{Var}[aX + bY + c] = a^2 \sigma_X^2 + b^2 \sigma_Y^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Csigma_X%5E2&quot; alt=&quot;\sigma_X^2&quot; title=&quot;\sigma_X^2&quot; /&gt; is the variance in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt;. We consider &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Csigma_X&quot; alt=&quot;\sigma_X&quot; title=&quot;\sigma_X&quot; /&gt; to be the standard deviation of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt;, or the “plus or minus” part of our numbers. In the simple case of addition, we have &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Coperatorname%7BVar%7D%5BX%20%2B%20Y%5D%20%3D%20%5Csigma_X%5E2%20%2B%20%5Csigma_Y%5E2&quot; alt=&quot;\operatorname{Var}[X + Y] = \sigma_X^2 + \sigma_Y^2&quot; title=&quot;\operatorname{Var}[X + Y] = \sigma_X^2 + \sigma_Y^2&quot; /&gt;, so our new uncertainty&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Csqrt%7B%5Csigma_X%5E2%20%2B%20%5Csigma_Y%5E2%7D&quot; alt=&quot;\sqrt{\sigma_X^2 + \sigma_Y^2}&quot; title=&quot;\sqrt{\sigma_X^2 + \sigma_Y^2}&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;However, not all functions that combine &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt; can be expressed as simple linear combinations &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?aX%20%2B%20bY%20%2B%20c&quot; alt=&quot;aX + bY + c&quot; title=&quot;aX + bY + c&quot; /&gt;. But! If you dig back to your days of high school calculus, you might remember a method for expressing any arbitrary function as a linear approximation – the &lt;a href=&quot;https://en.wikipedia.org/wiki/Taylor_series&quot;&gt;Taylor Expansion&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;In general, we can attempt to approximate any well-behaving function around a point as its tangent hyperplane:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0Af%28x_0%20%2B%20x%2C%20y_0%20%2B%20y%29%20%5Capprox%20f_x%28x_0%2C%20y_0%29%20x%20%2B%20f_y%28x_0%2C%20y_0%29%20y%20%2B%20f%28x_0%2C%20y_0%29%0A&quot; alt=&quot;
f(x_0 + x, y_0 + y) \approx f_x(x_0, y_0) x + f_y(x_0, y_0) y + f(x_0, y_0)
&quot; title=&quot;
f(x_0 + x, y_0 + y) \approx f_x(x_0, y_0) x + f_y(x_0, y_0) y + f(x_0, y_0)
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f_x%28x_0%2Cy_0%29&quot; alt=&quot;f_x(x_0,y_0)&quot; title=&quot;f_x(x_0,y_0)&quot; /&gt; is the first (partial) derivative with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%29&quot; alt=&quot;(x_0, y_0)&quot; title=&quot;(x_0, y_0)&quot; /&gt;. This gives us an approximation of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f&quot; alt=&quot;f&quot; title=&quot;f&quot; /&gt; at locations close to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%28x_0%2C%20y_0%29&quot; alt=&quot;(x_0, y_0)&quot; title=&quot;(x_0, y_0)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;Look familiar? This is exactly the form that we used earlier to calculate “combined” variance! If we approximate the functions around &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;(\mu_X, \mu_Y)&quot; title=&quot;(\mu_X, \mu_Y)&quot; /&gt;, the center/expected value of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?X&quot; alt=&quot;X&quot; title=&quot;X&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?Y&quot; alt=&quot;Y&quot; title=&quot;Y&quot; /&gt;, we see:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7BVar%7D%5Bf%28X%2CY%29%5D%20%5Capprox%20f_x%28%5Cmu_X%2C%20%5Cmu_Y%29%5E2%20%5Csigma_X%5E2%20%2B%20f_y%28%5Cmu_X%2C%5Cmu_Y%29%5E2%20%5Csigma_Y%5E2%0A&quot; alt=&quot;
\operatorname{Var}[f(X,Y)] \approx f_x(\mu_X, \mu_Y)^2 \sigma_X^2 + f_y(\mu_X,\mu_Y)^2 \sigma_Y^2
&quot; title=&quot;
\operatorname{Var}[f(X,Y)] \approx f_x(\mu_X, \mu_Y)^2 \sigma_X^2 + f_y(\mu_X,\mu_Y)^2 \sigma_Y^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;A similar analysis can be used to figure out how the expected value changes by taking the taylor expansion to the &lt;em&gt;second&lt;/em&gt; degree:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7BE%7D%5Bf%28X%2CY%29%5D%20%5Capprox%0Af%28%5Cmu_X%2C%20%5Cmu_Y%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%0A%5Cleft%5B%20f_%7Bxx%7D%28%5Cmu_X%2C%20%5Cmu_Y%29%20%5Csigma_X%5E2%20%2B%20f_%7Byy%7D%28%5Cmu_X%2C%20%5Cmu_Y%29%20%5Csigma_Y%5E2%20%5Cright%5D%0A&quot; alt=&quot;
\operatorname{E}[f(X,Y)] \approx
f(\mu_X, \mu_Y) + \frac{1}{2}
\left[ f_{xx}(\mu_X, \mu_Y) \sigma_X^2 + f_{yy}(\mu_X, \mu_Y) \sigma_Y^2 \right]
&quot; title=&quot;
\operatorname{E}[f(X,Y)] \approx
f(\mu_X, \mu_Y) + \frac{1}{2}
\left[ f_{xx}(\mu_X, \mu_Y) \sigma_X^2 + f_{yy}(\mu_X, \mu_Y) \sigma_Y^2 \right]
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f_%7Bxx%7D%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;f_{xx}(\mu_X, \mu_Y)&quot; title=&quot;f_{xx}(\mu_X, \mu_Y)&quot; /&gt; is the second (partial) derivative with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; twice at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%28%5Cmu_X%2C%20%5Cmu_Y%29&quot; alt=&quot;(\mu_X, \mu_Y)&quot; title=&quot;(\mu_X, \mu_Y)&quot; /&gt;&lt;/p&gt;
&lt;p&gt;For our case of simple addition, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Coperatorname%7BE%7D%5BX%20%2B%20Y%5D%20%3D%20%5Cmu_X%20%2B%20%5Cmu_Y&quot; alt=&quot;\operatorname{E}[X + Y] = \mu_X + \mu_Y&quot; title=&quot;\operatorname{E}[X + Y] = \mu_X + \mu_Y&quot; /&gt;, because the second-order partials of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%28x%2Cy%29%20%3D%20x%20%2B%20y&quot; alt=&quot;f(x,y) = x + y&quot; title=&quot;f(x,y) = x + y&quot; /&gt; are 0.&lt;/p&gt;
&lt;h2 id=&quot;uncertain-values-in-haskell&quot;&gt;Uncertain Values in Haskell&lt;/h2&gt;
&lt;p&gt;So, how are we going to model our uncertain values in Haskell … ? With an Algebraic Data Type, of course!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L18-20&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; uMean ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;a
                   ,&lt;span class=&quot;ot&quot;&gt; uVar  ::&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;a
                   }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’ll keep track of the mean (the central point) and the &lt;em&gt;variance&lt;/em&gt;, which is the standard deviation &lt;em&gt;squared&lt;/em&gt;. We keep track of the variance and not the standard deviation (the “plus or minus”) because the mathematics is a bit more straightforward.&lt;/p&gt;
&lt;p&gt;We can write a function to turn a “plus or minus” statement into an &lt;code&gt;Uncert&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L22-23&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;(+/-) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
x &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (dx&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;dx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Give the &lt;code&gt;dx&lt;/code&gt; (the standard deviation) and store &lt;code&gt;dx^2&lt;/code&gt;, the variance.&lt;/p&gt;
&lt;p&gt;Let’s also throw in a handy helper function for “exact” values:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L25-26&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;exact ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
exact x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, we can do better (if just for fun). We can use pattern synonyms to basically “abstract” away the data type itself, and let people pattern match on a mean and standard deviation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L29-34&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- pattern (:+/-) :: () =&amp;gt; Floating a =&amp;gt; a -&amp;gt; a -&amp;gt; Uncert a&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- [GHC 8.0:]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- pattern (:+/-) :: Floating a =&amp;gt; a -&amp;gt; a -&amp;gt; Uncert a&lt;/span&gt;
pattern x &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (sqrt&lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;dx)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    x &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x (dx&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;dx)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that the type signature you need for this is different depending on if you’re in GHC 8.0 and GHC 7.10; they’re mutually incompatible. How unfortunate!)&lt;/p&gt;
&lt;p&gt;Now, people can pattern match on &lt;code&gt;x :+/- dx&lt;/code&gt; and receive the mean and uncertainty directly. Neat!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L36-37&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;uStdev ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Floating&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
uStdev (_ &lt;span class=&quot;fu&quot;&gt;:+/-&lt;/span&gt; dx) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;making-it-numeric&quot;&gt;Making it Numeric&lt;/h3&gt;
&lt;p&gt;Now, time for the magic! Let’s write a &lt;code&gt;Num&lt;/code&gt; instance!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fromIntegral      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exact &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromIntegral
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)    (vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy)
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; y)    (vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy)
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y)    (y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vy)
    negate (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (negate x) vx
    &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it! Do the same thing for every numeric typeclass, and you get automatic propagation of uncertainty.&lt;/p&gt;
&lt;h3 id=&quot;the-problem&quot;&gt;The Problem&lt;/h3&gt;
&lt;p&gt;But, wait — this method is definitely not ideal. It’s pretty repetitive, and involves a but of copy-and-pasting code that is slightly different in ways the typechecker can’t verify. What if we didn’t change something we were supposed to? And, if you look at the &lt;code&gt;Fractional&lt;/code&gt; instance…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a) &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fromRational      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; exact &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; fromRational
    &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (x&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;vy)   (x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;vx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vy&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
    recip (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx)   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; (recip x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; vx&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) (vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yikes. All that ugly and complicated numerical code that the typechecker can’t help us with (and, honestly, I’m not very confident in the results myself!). Those are runtime bugs just waiting to happen. How do we even &lt;em&gt;know&lt;/em&gt; that we calculated the right derivatives, and implemented the formula correctly?&lt;/p&gt;
&lt;p&gt;What if we could reduce this boilerplate? What if we could somehow analytically compute derivatives for functions instead of computing them manually?&lt;/p&gt;
&lt;h2 id=&quot;automatic-differentiation&quot;&gt;Automatic Differentiation&lt;/h2&gt;
&lt;p&gt;Automatic differentiation is honestly one of the coolest Haskell tricks you can show that any beginner can immediately understand. Like our trick with &lt;code&gt;Uncert&lt;/code&gt;, it’s nice to use because of its overloaded &lt;code&gt;Num&lt;/code&gt;/numeric typeclasses.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- 2*x&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; sin x) &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- cos x&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diff (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- 3*x^2 - 6*x + 2&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A very rough explanation about how forward-mode automatic differentiation works is that it uses a wrapper type (like ours) that defines &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;negate&lt;/code&gt;, etc. so that they also compute the &lt;em&gt;derivative(s)&lt;/em&gt; of the function, instead of just the &lt;em&gt;result&lt;/em&gt;, like normal. There are a lot of nice tutorials online, like &lt;a href=&quot;http://www.danielbrice.net/blog/10/&quot;&gt;this one&lt;/a&gt; by Daniel Brice, if you want to follow up on this fun little subject.&lt;/p&gt;
&lt;h3 id=&quot;single-variable-functions&quot;&gt;Single-variable functions&lt;/h3&gt;
&lt;p&gt;And, now that we can automatically differentiate functions, we can use this knowledge directly in our implementations. Let’s define a universal “lifter” of single-variable functions.&lt;/p&gt;
&lt;p&gt;We use the function &lt;code&gt;diffs0&lt;/code&gt; to get a “tower” of derivatives:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; diffs0 (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; x&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
[&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;112&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;88&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first value is actually &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?4%5E2%20-%202%20%5Ctimes%204%5E3&quot; alt=&quot;4^2 - 2 \times 4^3&quot; title=&quot;4^2 - 2 \times 4^3&quot; /&gt;. The second is the derivative (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?2%20x%20-%206x%5E2&quot; alt=&quot;2 x - 6x^2&quot; title=&quot;2 x - 6x^2&quot; /&gt;) at 4, the third is the second derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?2%20-%2012%20x&quot; alt=&quot;2 - 12 x&quot; title=&quot;2 - 12 x&quot; /&gt; at 4, then the third derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?-12&quot; alt=&quot;-12&quot; title=&quot;-12&quot; /&gt;, then the fourth derivative &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?0&quot; alt=&quot;0&quot; title=&quot;0&quot; /&gt;, etc.&lt;/p&gt;
&lt;p&gt;We only need the actual value and the first two derivatives, so we can pattern match them as &lt;code&gt;fx:dfx:ddfx:_ = diffs0 f x&lt;/code&gt;, the derivatives and values of the function we lift, &lt;code&gt;f&lt;/code&gt;, around the mean &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At that point, the equations we have from before just translate nicely:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7BE%7D%5Bf%28X%29%5D%20%3D%20f%28%5Cmu_X%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%20f_%7Bxx%7D%28%5Cmu_X%29%20%5Csigma_X%5E2%0A&quot; alt=&quot;
\operatorname{E}[f(X)] = f(\mu_X) + \frac{1}{2} f_{xx}(\mu_X) \sigma_X^2
&quot; title=&quot;
\operatorname{E}[f(X)] = f(\mu_X) + \frac{1}{2} f_{xx}(\mu_X) \sigma_X^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Coperatorname%7BVar%7D%5Bf%28X%29%5D%20%3D%20f_x%28%5Cmu_X%29%5E2%20%5Csigma_X%5E2%0A&quot; alt=&quot;
\operatorname{Var}[f(X)] = f_x(\mu_X)^2 \sigma_X^2
&quot; title=&quot;
\operatorname{Var}[f(X)] = f_x(\mu_X)^2 \sigma_X^2
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And we call &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Cmu_X&quot; alt=&quot;\mu_X&quot; title=&quot;\mu_X&quot; /&gt; &lt;code&gt;x&lt;/code&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Csigma_X%5E2&quot; alt=&quot;\sigma_X^2&quot; title=&quot;\sigma_X^2&quot; /&gt; &lt;code&gt;vx&lt;/code&gt;, and this becomes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;y  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; ddfx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
vy &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dfx&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Putting it all together:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L39-47&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftU ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
      &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Tower&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Tower&lt;/span&gt; a))
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
      &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU f (&lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; x vx) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    fx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;dfx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ddfx&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; diffs0 f x
    y             &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; ddfx &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    vy            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dfx&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; vx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type &lt;code&gt;forall s. AD s (Tower a) -&amp;gt; AD s (Tower a)&lt;/code&gt; looks a little scary, but you can think of it as representing a function on &lt;code&gt;a&lt;/code&gt; (like &lt;code&gt;negate&lt;/code&gt;, &lt;code&gt;(*2)&lt;/code&gt;, etc.) that the &lt;em&gt;ad&lt;/em&gt; library can differentiate several times — something you could use with &lt;code&gt;diff0&lt;/code&gt; to get a “tower” of derivatives.&lt;/p&gt;
&lt;p&gt;And … that’s it! We can already define things like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;negate &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU negate
recip  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU recip
sqrt   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU sqrt
sin    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU sin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;multivariable-functions&quot;&gt;Multivariable functions&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;ad&lt;/em&gt; also lets you work multivariable functions, too. To model multivariable functions, it takes a function from a &lt;code&gt;Traversable&lt;/code&gt; of vales to a single value. We can use the &lt;code&gt;V2&lt;/code&gt; type from the &lt;em&gt;&lt;a href=&quot;shttp://hackage.haskell.org/package/linear/docs/Linear-V2.html&quot;&gt;linear&lt;/a&gt;&lt;/em&gt; package to pass in a two-variable function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; grad (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The gradient of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%28x%2C%20y%29%20%3D%20x%20y%5E2%20%2B%203x&quot; alt=&quot;f(x, y) = x y^2 + 3x&quot; title=&quot;f(x, y) = x y^2 + 3x&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%28y%5E2%20%2B%203%2C%202xy%29&quot; alt=&quot;(y^2 + 3, 2xy)&quot; title=&quot;(y^2 + 3, 2xy)&quot; /&gt;, which, at &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%283%2C%201%29&quot; alt=&quot;(3, 1)&quot; title=&quot;(3, 1)&quot; /&gt;, is indeed &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%284%2C%206%29&quot; alt=&quot;(4, 6)&quot; title=&quot;(4, 6)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;The gradient gives us the first order partials, but we need the second order partials to calculate the new mean, so for that, we can use &lt;code&gt;hessian&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hessian (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
   (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix&quot;&gt;hessian&lt;/a&gt; of a function &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f%28x%2Cy%29&quot; alt=&quot;f(x,y)&quot; title=&quot;f(x,y)&quot; /&gt; is basically a matrix of second-order partial derivatives:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Bbmatrix%7D%0Af_%7Bxx%7D%28x%2C%20y%29%20%26%20f_%7Byx%7D%28x%2C%20y%29%20%5C%5C%0Af_%7Byx%7D%28x%2C%20y%29%20%26%20f_%7Byy%7D%28x%2C%20y%29%0A%5Cend%7Bbmatrix%7D%0A&quot; alt=&quot;
\begin{bmatrix}
f_{xx}(x, y) &amp;amp; f_{yx}(x, y) \\
f_{yx}(x, y) &amp;amp; f_{yy}(x, y)
\end{bmatrix}
&quot; title=&quot;
\begin{bmatrix}
f_{xx}(x, y) &amp;amp; f_{yx}(x, y) \\
f_{yx}(x, y) &amp;amp; f_{yy}(x, y)
\end{bmatrix}
&quot; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;In our case, we only care about the diagonal – the repeated double-derivatives, &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f_%7Bxx%7D&quot; alt=&quot;f_{xx}&quot; title=&quot;f_{xx}&quot; /&gt; and &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?f_%7Byy%7D&quot; alt=&quot;f_{yy}&quot; title=&quot;f_{yy}&quot; /&gt;. Indeed, the double-partial of our function respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?x&quot; alt=&quot;x&quot; title=&quot;x&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?0&quot; alt=&quot;0&quot; title=&quot;0&quot; /&gt;, and the double-partial with respect to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?y&quot; alt=&quot;y&quot; title=&quot;y&quot; /&gt; is &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?2x&quot; alt=&quot;2x&quot; title=&quot;2x&quot; /&gt;, which gives us a hessian with a diagonal &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%280%2C%206%29&quot; alt=&quot;(0, 6)&quot; title=&quot;(0, 6)&quot; /&gt; for the input &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%283%2C%201%29&quot; alt=&quot;(3, 1)&quot; title=&quot;(3, 1)&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;ad&lt;/em&gt; package generously gives us a function that lets us calculate the function’s result, its gradient, and its hessian all in one pass:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; hessian&amp;#39; (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
     &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can access the gradient by using &lt;code&gt;fmap fst&lt;/code&gt; on the second component of the tuple and access the hessian by using &lt;code&gt;fmap snd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We need a couple of helpers, first — one to get the “diagonal” of our hessian, because we only care about the repeated partials:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L49-53&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;diag ::&lt;/span&gt; [[a]] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
diag &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt;
    []        &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; []
    []   &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;yss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; diag (drop &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; yss)
    (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_)&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;yss &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; diag (drop &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; yss)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then a “dot product”, utility function, which just multiplies two lists together component-by-component and sums the results:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L55-56&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;dot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Num&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
dot xs ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; sum (zipWith (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;) xs ys)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can write our multi-variate function lifter:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L58-75&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftUF ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Traversable&lt;/span&gt; f, &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a)
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a)) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a)
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftUF f us &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Un&lt;/span&gt; y vy
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    xs          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;         uMean &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; us
    vxs         &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; toList (uVar  &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; us)
    (fx, hgrad) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; hessian&amp;#39; f xs
    dfxs        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fst &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; hgrad
    hess        &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; snd &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; hgrad
    y           &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fx &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; partials &lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        partials &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dot vxs
                 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; diag
                 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toList (fmap toList hess) &lt;span class=&quot;co&quot;&gt;-- from f (f a) to [[a]]&lt;/span&gt;
    vy          &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; dot vxs
                &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; toList ((&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; dfxs)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Again, don’t mind the scary type &lt;code&gt;forall s. f (AD s (Sparse a)) -&amp;gt; AD s (Sparse a)&lt;/code&gt;, it’s just &lt;em&gt;ad&lt;/em&gt;’s type for things you can use &lt;code&gt;hessian&#39;&lt;/code&gt; on)&lt;/p&gt;
&lt;p&gt;And we can write some nice helper functions so we can use them more naturally:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs#L77-90&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftU2 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU2 f x y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftUF (\(&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x&amp;#39; y&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x&amp;#39; y&amp;#39;) (&lt;span class=&quot;dt&quot;&gt;V2&lt;/span&gt; x y)

&lt;span class=&quot;ot&quot;&gt;liftU3 ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fractional&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall s&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;AD&lt;/span&gt; s (&lt;span class=&quot;dt&quot;&gt;Sparse&lt;/span&gt; a))
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Uncert&lt;/span&gt; a
liftU3 f x y z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftUF (\(&lt;span class=&quot;dt&quot;&gt;V3&lt;/span&gt; x&amp;#39; y&amp;#39; z&amp;#39;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; f x&amp;#39; y&amp;#39; z&amp;#39;) (&lt;span class=&quot;dt&quot;&gt;V3&lt;/span&gt; x y z)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, our code is pretty much complete. We can fill in the other two-argument functions from the numeric typeclasses:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;(&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;)     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;/&lt;/span&gt;)
(&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;)    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 (&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;)
logBase &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftU2 logBase&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Admittedly, there’s still some slight boilerplate (that you can get rid of with some Template Haskell, maybe), but you have a &lt;em&gt;lot&lt;/em&gt; less room for error, and a lot simpler to check over and read to make sure you didn’t miss any bugs.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-it-up&quot;&gt;Wrapping it up&lt;/h2&gt;
&lt;p&gt;The full code (with all of the numeric instances fully implemented) is up &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/uncertain/Uncertain.hs&quot;&gt;on github&lt;/a&gt;, which you can run and explore and test by executing it or loading it with &lt;code&gt;stack ghci&lt;/code&gt;. I’ve added a special &lt;em&gt;Show&lt;/em&gt; instance that “rounds” your values to as many digits that your uncertainty suggests, to give more meaningful &lt;code&gt;show&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;All of what’s in this post is actually up on my &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; package on hackage, if you want to use it in your own projects, or see how I take this and make it more robust for real-world applications. The project also has more features on top of the basic things shown here.&lt;/p&gt;
&lt;h3 id=&quot;verification-and-accuracy&quot;&gt;Verification and Accuracy&lt;/h3&gt;
&lt;p&gt;My &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;uncertain&lt;/a&gt;&lt;/em&gt; package has a Monte Carlo module to propagate uncertainty through Monte Carlo simulations. Let’s see how the values compare!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y         &lt;span class=&quot;co&quot;&gt;-- Monte Carlo Results:&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;46&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- actually 46 +/- 2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; y
&lt;span class=&quot;dv&quot;&gt;450&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;40&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- actually 450 +/- 40&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; sqrt (x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; y)
&lt;span class=&quot;fl&quot;&gt;6.8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.2&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- actually 6.8 +/- 0.2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; logBase y x
&lt;span class=&quot;fl&quot;&gt;0.78&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- actually 0.78 +/- 0.02&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; log (x&lt;span class=&quot;fu&quot;&gt;**&lt;/span&gt;y)
&lt;span class=&quot;fl&quot;&gt;85.9&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.3&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- actually 83 +/- 6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, it looks like the mathematical model of uncertainty propagation matched up well with the “actual” results we gain from Monte Carlo simulations! The only one of our examples that was significantly wrong was the &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/png.latex?%5Coperatorname%7Blog%7D%28x%5Ey%29&quot; alt=&quot;\operatorname{log}(x^y)&quot; title=&quot;\operatorname{log}(x^y)&quot; /&gt; example, which heavily underestimated the uncertainty by about a factor of 20. But, remember, the model was derived after dropping the 2nd, 3rd, 4th, etc. terms of the taylor expansion for the calculation of the new uncertainty, and the 4th, 6th, etc. terms of the taylor expansion for the calculation of the new mean. For functions that have high second, third, fourth derivatives relative to the mean and the uncertainty, it’s going to be a bit off.&lt;/p&gt;
&lt;h3 id=&quot;what-next&quot;&gt;What next?&lt;/h3&gt;
&lt;p&gt;For an extension on the mathematics behind this method, Dan Piponi has a &lt;a href=&quot;http://blog.sigfpe.com/2011/08/computing-errors-with-square-roots-of.html&quot;&gt;great article&lt;/a&gt; with a lot of good references for further reading on the formal method.&lt;/p&gt;
&lt;p&gt;Going off of what we’ve done here, a simple extension of this would be to implement the Monte Carlo simulator I mentioned above, which is pretty straightforward to implement with the &lt;em&gt;&lt;a href=&quot;https://hackage.haskell.org/package/mwc-random&quot;&gt;mwc-random&lt;/a&gt;&lt;/em&gt; package.&lt;/p&gt;
&lt;p&gt;However, the most unsettling thing here that we never deal with is what happens correlated terms that are combined. All of our math assumed uncorrelated samples. But what happens if we have expressions that involve additions of correlated values?&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; x
&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;14.6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.8&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;x
&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+/-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;x + x&lt;/code&gt; is different than &lt;code&gt;2*x&lt;/code&gt;. This is because &lt;code&gt;x&lt;/code&gt; acts like an &lt;em&gt;independent generator&lt;/em&gt;, so when you say &lt;code&gt;x + x&lt;/code&gt;, it expands to &lt;code&gt;(14.6 +/- 0.8) + (14.6 +/- 0.8)&lt;/code&gt;, which represents the addition of two independent samples.&lt;/p&gt;
&lt;p&gt;When you say &lt;code&gt;2*x&lt;/code&gt;, that represents sampling &lt;code&gt;x&lt;/code&gt; &lt;em&gt;once&lt;/em&gt; and &lt;em&gt;doubling&lt;/em&gt; it. If you sample &lt;code&gt;x&lt;/code&gt; and double it, any error in &lt;code&gt;x&lt;/code&gt; will also be doubled. That’s why the uncertainty is greater in the &lt;code&gt;2*x&lt;/code&gt; version.&lt;/p&gt;
&lt;p&gt;How can we account for correlated values that are combined in complex ways? Stay tuned for the next part of the &lt;a href=&quot;https://blog.jle.im/entries/series/+uncertain.html&quot;&gt;series&lt;/a&gt;!&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;You can simulate noisy data by using uniform noise distributions, Gaussian distributions, or however manner you like that has a given expected value (mean) and “spread”. Verify by checking the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; of the sums!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;This law actually comes from the mathematical &lt;em&gt;definition&lt;/em&gt; of variance, so does not assume anything about the underlying distribution of the sampling — just that they are independent, and that they have defined variances.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;Or just look at my &lt;a href=&quot;https://hackage.haskell.org/package/uncertain&quot;&gt;package&lt;/a&gt; :)&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/automatic-propagation-of-uncertainty-with-ad.html</guid><pubDate>Mon,  9 May 2016 19:38:24 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Tutorials</dc:subject><dc:date>2016-05-09</dc:date></item><language>en</language><copyright>Copyright 2016 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Tue,  9 Jan 2018 22:50:54 UTC</lastBuildDate><generator>feed-0.3.11.1 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><dc:creator>Justin Le</dc:creator><dc:language>en</dc:language><dc:rights>Copyright 2016 Justin Le</dc:rights><dc:date>2018-01-09</dc:date><dc:description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</dc:description></channel></rss>